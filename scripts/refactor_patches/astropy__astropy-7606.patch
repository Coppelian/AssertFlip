diff --git a/astropy/units/core.py b/astropy/units/core.py
index e9bd986d33..e7e369b321 100644
--- a/astropy/units/core.py
+++ b/astropy/units/core.py
@@ -485,6 +485,19 @@ class UnitsWarning(AstropyWarning):
     """
 
 
+class UnitEqualityComparator:
+    """Helper object to isolate UnitBase equality conversion logic."""
+    def __init__(self, left, right):
+        self.left = left
+        self.right = right
+
+    def equals(self):
+        try:
+            return is_effectively_unity(self.left._convert_to(self.right))
+        except UnitsError:
+            return False
+
+
 class UnitBase(metaclass=InheritDocstrings):
     """
     Abstract base class for units.
@@ -504,6 +517,10 @@ class UnitBase(metaclass=InheritDocstrings):
         # physical unit corresponds to only one instance
         return self
 
+    def _convert_to(self, other):
+        """Overridable seam for unit conversion used by equality (bug-preserving)."""
+        return self._to(other)
+
     def _repr_latex_(self):
         """
         Generate latex representation of unit name.  This is used by
@@ -721,12 +738,16 @@ class UnitBase(metaclass=InheritDocstrings):
         # with only one base and no scale or power.
         return hash((str(self.scale), self.name, str('1')))
 
+    def _coerce_other_unit(self, other):
+        """Overridable seam for coercing 'other' into a Unit (bug-preserving)."""
+        return Unit(other, parse_strict='silent')
+
     def __eq__(self, other):
         if self is other:
             return True
 
         try:
-            other = Unit(other, parse_strict='silent')
+            other = self._coerce_other_unit(other)
         except (ValueError, UnitsError, TypeError):
             return False
 
@@ -735,10 +756,7 @@ class UnitBase(metaclass=InheritDocstrings):
         if not isinstance(other, UnitBase):
             return NotImplemented
 
-        try:
-            return is_effectively_unity(self._to(other))
-        except UnitsError:
-            return False
+        return UnitEqualityComparator(self, other).equals()
 
     def __ne__(self, other):
         return not (self == other)
@@ -1709,8 +1727,12 @@ class UnrecognizedUnit(IrreducibleUnit):
         __rmul__ = __lt__ = __gt__ = __le__ = __ge__ = __neg__ = \
         _unrecognized_operator
 
+    def _parse_other_unit(self, other):
+        """Overridable seam for parsing 'other' into a Unit (bug-preserving)."""
+        return Unit(other, parse_strict='silent')
+
     def __eq__(self, other):
-        other = Unit(other, parse_strict='silent')
+        other = self._parse_other_unit(other)
         return isinstance(other, UnrecognizedUnit) and self.name == other.name
 
     def __ne__(self, other):
diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py
index 992f5be4c4..7fd75058b4 100644
--- a/astropy/units/quantity.py
+++ b/astropy/units/quantity.py
@@ -835,18 +835,25 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
     # explicitly for numpy >=1.9, since it no longer traps errors.
     def __eq__(self, other):
         try:
-            try:
-                return super().__eq__(other)
-            except DeprecationWarning:
-                # We treat the DeprecationWarning separately, since it may
-                # mask another Exception.  But we do not want to just use
-                # np.equal, since super's __eq__ treats recarrays correctly.
-                return np.equal(self, other)
+            return self._eq_with_deprecation_fallback(other)
         except UnitsError:
             return False
         except TypeError:
             return NotImplemented
 
+    def _base_eq(self, other):
+        """Thin wrapper around the base __eq__ to introduce a seam (bug-preserving)."""
+        return super().__eq__(other)
+
+    def _eq_with_deprecation_fallback(self, other):
+        try:
+            return self._base_eq(other)
+        except DeprecationWarning:
+            # We treat the DeprecationWarning separately, since it may
+            # mask another Exception.  But we do not want to just use
+            # np.equal, since super's __eq__ treats recarrays correctly.
+            return np.equal(self, other)
+
     def __ne__(self, other):
         try:
             try:
diff --git a/astropy/units/utils.py b/astropy/units/utils.py
index 64f7097652..eaf9a098f8 100644
--- a/astropy/units/utils.py
+++ b/astropy/units/utils.py
@@ -188,6 +188,12 @@ def sanitize_scale(scale):
     return scale
 
 
+def _convert_to_float_if_power_of_two(p, denom):
+    """Extracted from validate_power; preserves existing decision logic."""
+    # denom is known to be a power of two here.
+    return float(p)
+
+
 def validate_power(p, support_tuples=False):
     """Convert a power to a floating point value, an integer, or a Fraction.
 
@@ -235,10 +241,10 @@ def validate_power(p, support_tuples=False):
     elif denom == 1:
         p = int(p.numerator)
 
+
     elif (denom & (denom - 1)) == 0:
         # Above is a bit-twiddling hack to see if denom is a power of two.
-        p = float(p)
-
+        p = _convert_to_float_if_power_of_two(p, denom)
     return p
 
 
