diff --git a/astropy/modeling/core.py b/astropy/modeling/core.py
index da4352cb0c..b96243125a 100644
--- a/astropy/modeling/core.py
+++ b/astropy/modeling/core.py
@@ -814,6 +814,13 @@ class Model(metaclass=_ModelMeta):
         """
         return NotImplemented
 
+    def _separability_matrix_hook(self):
+        """
+        Seam for modeling.separable: override this to customize separability matrix.
+        Default behavior delegates to _calculate_separability_matrix().
+        """
+        return self._calculate_separability_matrix()
+
     def _initialize_unit_support(self):
         """
         Convert self._input_units_strict and
diff --git a/astropy/modeling/mappings.py b/astropy/modeling/mappings.py
index db228dd9af..d906668487 100644
--- a/astropy/modeling/mappings.py
+++ b/astropy/modeling/mappings.py
@@ -6,6 +6,7 @@ which outputs from a source model are mapped to which inputs of a target model.
 
 from .core import FittableModel, Model
 from astropy.units import Quantity
+import numpy as np
 
 
 __all__ = ['Mapping', 'Identity', 'UnitsMapping']
@@ -66,6 +67,20 @@ class Mapping(FittableModel):
         self._input_units_strict = {key: False for key in self._inputs}
         self._input_units_allow_dimensionless = {key: False for key in self._inputs}
 
+    def _separability_axes_matrix(self):
+        """
+        Return the axes-selection matrix used by modeling.separable for Mapping.
+
+        Shape: (n_outputs, n_inputs)
+        Row k selects input mapping[k].
+        """
+        axes = []
+        for i in self.mapping:
+            axis = np.zeros((self.n_inputs,))
+            axis[i] = 1
+            axes.append(axis)
+        return np.vstack(axes)
+
     @property
     def n_inputs(self):
         return self._n_inputs
diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py
index a308e27297..4c62f2b616 100644
--- a/astropy/modeling/separable.py
+++ b/astropy/modeling/separable.py
@@ -113,18 +113,20 @@ def _compute_n_outputs(left, right):
     ----------
     left, right : `astropy.modeling.Model` or ndarray
         If input is of an array, it is the output of `coord_matrix`.
+    """
+    # Sprout helper calls (structure only; logic preserved)
+    lnout = _n_outputs_of(left)
+    rnout = _n_outputs_of(right)
+    return lnout + rnout
+
 
+def _n_outputs_of(obj):
     """
-    if isinstance(left, Model):
-        lnout = left.n_outputs
-    else:
-        lnout = left.shape[0]
-    if isinstance(right, Model):
-        rnout = right.n_outputs
-    else:
-        rnout = right.shape[0]
-    noutp = lnout + rnout
-    return noutp
+    Bug-preserving helper: return n_outputs for Model, else first dimension for ndarray.
+    """
+    if isinstance(obj, Model):
+        return obj.n_outputs
+    return obj.shape[0]
 
 
 def _arith_oper(left, right):
@@ -187,64 +189,55 @@ def _coord_matrix(model, pos, noutp):
 
     """
     if isinstance(model, Mapping):
-        axes = []
-        for i in model.mapping:
-            axis = np.zeros((model.n_inputs,))
-            axis[i] = 1
-            axes.append(axis)
-        m = np.vstack(axes)
+        m = model._separability_axes_matrix()
         mat = np.zeros((noutp, model.n_inputs))
-        if pos == 'left':
-            mat[: model.n_outputs, :model.n_inputs] = m
+        if pos == "left":
+            mat[: model.n_outputs, : model.n_inputs] = m
         else:
             mat[-model.n_outputs:, -model.n_inputs:] = m
         return mat
-    if not model.separable:
-        # this does not work for more than 2 coordinates
-        mat = np.zeros((noutp, model.n_inputs))
-        if pos == 'left':
-            mat[:model.n_outputs, : model.n_inputs] = 1
-        else:
-            mat[-model.n_outputs:, -model.n_inputs:] = 1
-    else:
-        mat = np.zeros((noutp, model.n_inputs))
-
-        for i in range(model.n_inputs):
-            mat[i, i] = 1
-        if pos == 'right':
-            mat = np.roll(mat, (noutp - model.n_outputs))
-    return mat
 
 
 def _cstack(left, right):
     """
-    Function corresponding to '&' operation.
-
-    Parameters
-    ----------
-    left, right : `astropy.modeling.Model` or ndarray
-        If input is of an array, it is the output of `coord_matrix`.
-
-    Returns
-    -------
-    result : ndarray
-        Result from this operation.
+    Coordinate stack for two inputs in a compound model operation.
 
+    Bug-preserving refactor:
+    - Preserves the Model vs ndarray branching.
+    - Preserves the unusual behavior for ndarray `right`: padded region is filled with 1.
     """
     noutp = _compute_n_outputs(left, right)
+    cleft = _pad_left_for_cstack(left, noutp)
+    cright = _pad_right_for_cstack(right, noutp)
+    return np.hstack([cleft, cright])
+
 
+def _pad_left_for_cstack(left, noutp):
+    """
+    Bug-preserving helper for the left argument of _cstack.
+    """
     if isinstance(left, Model):
-        cleft = _coord_matrix(left, 'left', noutp)
-    else:
-        cleft = np.zeros((noutp, left.shape[1]))
-        cleft[: left.shape[0], : left.shape[1]] = left
+        return _coord_matrix(left, "left", noutp)
+
+    cleft = np.zeros((noutp, left.shape[1]))
+    cleft[: left.shape[0], : left.shape[1]] = left
+    return cleft
+
+
+def _pad_right_for_cstack(right, noutp):
+    """
+    Bug-preserving helper for the right argument of _cstack.
+
+    NOTE: The ndarray case intentionally fills the padded region with 1
+    (matching the original behavior). Do NOT change this to `= right`.
+    """
     if isinstance(right, Model):
-        cright = _coord_matrix(right, 'right', noutp)
-    else:
-        cright = np.zeros((noutp, right.shape[1]))
-        cright[-right.shape[0]:, -right.shape[1]:] = 1
+        return _coord_matrix(right, "right", noutp)
+
+    cright = np.zeros((noutp, right.shape[1]))
+    cright[-right.shape[0] :, -right.shape[1] :] = 1
+    return cright
 
-    return np.hstack([cleft, cright])
 
 
 def _cdot(left, right):
@@ -301,14 +294,52 @@ def _separable(transform):
         An array of shape (transform.n_outputs,) of boolean type
         Each element represents the separablity of the corresponding output.
     """
-    if (transform_matrix := transform._calculate_separability_matrix()) is not NotImplemented:
-        return transform_matrix
-    elif isinstance(transform, CompoundModel):
-        sepleft = _separable(transform.left)
-        sepright = _separable(transform.right)
-        return _operators[transform.op](sepleft, sepright)
-    elif isinstance(transform, Model):
-        return _coord_matrix(transform, 'left', transform.n_outputs)
+    return _SeparabilityCalculator().run(transform)
+
+
+class _SeparabilityCalculator:
+    """
+    Break Out Method Object for _separable.
+
+    Bug-preserving: same decision order, same recursion order, same operator semantics.
+    """
+
+    def __init__(self, operators=None):
+        # Parameterize dependency (optional seam). Default preserves old mapping.
+        self._operators = _operators if operators is None else operators
+
+    def run(self, transform):
+        # Skeletonize Methods: keep the same control flow order as before.
+        transform_matrix = self._try_custom(transform)
+        if transform_matrix is not NotImplemented:
+            return transform_matrix
+
+        if isinstance(transform, CompoundModel):
+            return self._calc_compound(transform)
+
+        if isinstance(transform, Model):
+            return self._calc_leaf(transform)
+
+    def _try_custom(self, transform):
+        # Extract and Override Call seam: go through hook, but preserve fallback safely.
+        hook = getattr(transform, "_separability_matrix_hook", None)
+        if hook is not None:
+            return hook()
+        # Fallback for safety (should behave same if hook not present)
+        return transform._calculate_separability_matrix()
+
+    def _calc_compound(self, transform):
+        # Preserve recursion order exactly: left first, then right.
+        sepleft = self.run(transform.left)
+        sepright = self.run(transform.right)
+        return self._apply_operator(transform.op, sepleft, sepright)
+
+    def _calc_leaf(self, transform):
+        return _coord_matrix(transform, "left", transform.n_outputs)
+
+    def _apply_operator(self, op, left, right):
+        # Introduce seam for operator dispatch.
+        return self._operators[op](left, right)
 
 
 # Maps modeling operators to a function computing and represents the
