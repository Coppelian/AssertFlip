diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py
index 8c1ac5d738..56c8d56847 100644
--- a/astropy/io/fits/card.py
+++ b/astropy/io/fits/card.py
@@ -323,14 +323,8 @@ class Card(_Verify):
         if isinstance(value, float) and (np.isnan(value) or np.isinf(value)):
             raise ValueError("Floating point {!r} values are not allowed "
                              "in FITS headers.".format(value))
-
         elif isinstance(value, str):
-            m = self._ascii_text_re.match(value)
-            if not m:
-                raise ValueError(
-                    'FITS header values must contain standard printable ASCII '
-                    'characters; {!r} contains characters not representable in '
-                    'ASCII or non-printable characters.'.format(value))
+            value = self._normalize_string_value(value)
         elif isinstance(value, bytes):
             # Allow str, but only if they can be decoded to ASCII text; note
             # this is not even allowed on Python 3 since the `bytes` type is
@@ -378,6 +372,20 @@ class Card(_Verify):
                     raise ValueError('value {} is not a float'.format(
                             self._value))
 
+    def _normalize_string_value(self, value):
+        """Validate and normalize a string header value.
+
+        Extracted from the value setter to create a tiny seam for tests that
+        need to isolate ASCII validation behavior without altering semantics.
+        """
+        m = self._ascii_text_re.match(value)
+        if not m:
+            raise ValueError(
+                'FITS header values must contain standard printable ASCII '
+                'characters; {!r} contains characters not representable in '
+                'ASCII or non-printable characters.'.format(value))
+        return value
+
     @value.deleter
     def value(self):
         if self._invalid:
@@ -1065,6 +1073,14 @@ class Card(_Verify):
             idx += maxlen
         return ''.join(output)
 
+    def _match_value_regex(self, valuecomment):
+        """Seam for matching a value/comment field against the FSC regex.
+
+        Extracted from `_verify` so tests/APR harnesses can override or probe
+        matching behavior without changing verification control flow.
+        """
+        return self._value_FSC_RE.match(valuecomment)
+
     def _verify(self, option='warn'):
         self._verified = True
 
@@ -1131,7 +1147,7 @@ class Card(_Verify):
                              valuecomment),
                     fixable=False))
         else:
-            m = self._value_FSC_RE.match(valuecomment)
+            m = self._match_value_regex(valuecomment)
             if not m:
                 errs.append(self.run_option(
                     option,
diff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py
index ad07e6d52d..49fdaa4852 100644
--- a/astropy/io/fits/header.py
+++ b/astropy/io/fits/header.py
@@ -356,6 +356,18 @@ class Header:
         # contains non-valid characters (namely \n) the cards may be split
         # immediately at the separator
         require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)
+        cards = cls._build_cards_from_data(data, sep, require_full_cardlength)
+        return cls._fromcards(cards)
+
+    @classmethod
+    def _build_cards_from_data(cls, data, sep, require_full_cardlength):
+        """Build a list of `Card` objects from raw header data.
+
+        Extracted from `fromstring` to isolate the parsing loop and create a
+        seam for tests. IMPORTANT: this preserves original behavior (including
+        any bytes/str mismatch behavior) by not altering types or decoding.
+        """
+        cards = []
 
         # Split the header into individual cards
         idx = 0
@@ -394,7 +406,7 @@ class Header:
         if image:
             cards.append(Card.fromstring(''.join(image)))
 
-        return cls._fromcards(cards)
+        return cards
 
     @classmethod
     def fromfile(cls, fileobj, sep='', endcard=True, padding=True):
@@ -1560,6 +1572,17 @@ class Header:
 
         self._add_commentary('', value, before=before, after=after)
 
+    def _normalize_update_keyword(self, keyword):
+        """Normalize keyword for update lookups.
+
+        Extracted from `_update` to create a seam for tests and make keyword
+        normalization observable without changing update control flow.
+        """
+        keyword = keyword.upper()
+        if keyword.startswith('HIERARCH '):
+            keyword = keyword[9:]
+        return keyword
+
     def _update(self, card):
         """
         The real update code.  If keyword already exists, its value and/or
@@ -1573,9 +1596,7 @@ class Header:
         keyword, value, comment = card
 
         # Lookups for existing/known keywords are case-insensitive
-        keyword = keyword.upper()
-        if keyword.startswith('HIERARCH '):
-            keyword = keyword[9:]
+        keyword = self._normalize_update_keyword(keyword)
 
         if (keyword not in Card._commentary_keywords and
                 keyword in self._keyword_indices):
@@ -1603,35 +1624,50 @@ class Header:
             # A new keyword! self.append() will handle updating _modified
             self.append(card)
 
-    def _cardindex(self, key):
-        """Returns an index into the ._cards list given a valid lookup key."""
+    def _parse_cardindex_key(self, key):
+        """Parse a header key for `_cardindex`.
 
-        # This used to just set key = (key, 0) and then go on to act as if the
-        # user passed in a tuple, but it's much more common to just be given a
-        # string as the key, so optimize more for that case
+        Extracted to create a seam for tests and to isolate key interpretation.
+        Returns either:
+          - int (direct index)
+          - slice
+          - (keyword: str, n: int)
+        """
         if isinstance(key, str):
-            keyword = key
-            n = 0
-        elif isinstance(key, int):
-            # If < 0, determine the actual index
+            return (key, 0)
+
+        if isinstance(key, int):
             if key < 0:
                 key += len(self._cards)
             if key < 0 or key >= len(self._cards):
                 raise IndexError('Header index out of range.')
             return key
-        elif isinstance(key, slice):
+
+        if isinstance(key, slice):
             return key
-        elif isinstance(key, tuple):
+
+        if isinstance(key, tuple):
             if (len(key) != 2 or not isinstance(key[0], str) or
                     not isinstance(key[1], int)):
                 raise ValueError(
                     'Tuple indices must be 2-tuples consisting of a '
                     'keyword string and an integer index.')
-            keyword, n = key
-        else:
-            raise ValueError(
-                'Header indices must be either a string, a 2-tuple, or '
-                'an integer.')
+            return key
+
+        raise ValueError(
+            'Header indices must be either a string, a 2-tuple, or '
+            'an integer.')
+
+    def _cardindex(self, key):
+        """Returns an index into the ._cards list given a valid lookup key."""
+
+        # This used to just set key = (key, 0) and then go on to act as if the
+        # user passed in a tuple, but it's much more common to just be given a
+        # string as the key, so optimize more for that case
+        parsed = self._parse_cardindex_key(key)
+        if isinstance(parsed, (int, slice)):
+            return parsed
+        keyword, n = parsed
 
         keyword = Card.normalize_keyword(keyword)
         # Returns the index into _cards for the n-th card with the given
