diff --git a/django/core/exceptions.py b/django/core/exceptions.py
index 0e85397b9c..d6644b4a8c 100644
--- a/django/core/exceptions.py
+++ b/django/core/exceptions.py
@@ -150,12 +150,18 @@ class ValidationError(Exception):
             return sum(dict(self).values(), [])
         return list(self)
 
+    def _extend_error_dict(self, error_dict, field, error_list):
+        """Extend *error_dict* in-place.
+        Sprout method: isolates mutation for easier testing.
+        """
+        error_dict.setdefault(field, []).extend(error_list)
+
     def update_error_dict(self, error_dict):
         if hasattr(self, 'error_dict'):
             for field, error_list in self.error_dict.items():
-                error_dict.setdefault(field, []).extend(error_list)
+                self._extend_error_dict(error_dict, field, error_list)
         else:
-            error_dict.setdefault(NON_FIELD_ERRORS, []).extend(self.error_list)
+            self._extend_error_dict(error_dict, NON_FIELD_ERRORS, self.error_list)
         return error_dict
 
     def __iter__(self):
@@ -164,10 +170,13 @@ class ValidationError(Exception):
                 yield field, list(ValidationError(errors))
         else:
             for error in self.error_list:
-                message = error.message
-                if error.params:
-                    message %= error.params
-                yield str(message)
+                yield self._format_error_message(error)
+
+    def _format_error_message(self, error):
+        message = error.message
+        if error.params:
+            message %= error.params
+        return str(message)
 
     def __str__(self):
         if hasattr(self, 'error_dict'):
diff --git a/django/core/validators.py b/django/core/validators.py
index 92394a7eae..c49d3adc32 100644
--- a/django/core/validators.py
+++ b/django/core/validators.py
@@ -49,12 +49,18 @@ class RegexValidator:
 
         self.regex = _lazy_re_compile(self.regex, self.flags)
 
+    def _perform_regex_match(self, value):
+        """Return a match object for *value*.
+        Separated into a method to allow overriding in tests.
+        """
+        return self.regex.search(str(value))
+
     def __call__(self, value):
         """
         Validate that the input contains (or does *not* contain, if
         inverse_match is True) a match for the regular expression.
         """
-        regex_matches = self.regex.search(str(value))
+        regex_matches = self._perform_regex_match(value)
         invalid_input = regex_matches if self.inverse_match else not regex_matches
         if invalid_input:
             raise ValidationError(self.message, code=self.code)
@@ -70,6 +76,85 @@ class RegexValidator:
         )
 
 
+class _URLPartsValidator:
+    """Method object for URL validation.
+
+    Break Out Method Object: URLValidator.__call__ remains the public entry
+    point, but the step-by-step algorithm lives here.
+    """
+
+    def __init__(self, validator, value):
+        self.validator = validator
+        self.value = value
+
+    def validate(self):
+        # Preserve original URLValidator.__call__ control decisions:
+        # - Always validate scheme first
+        # - Run IPv6 netloc validation ONLY if the initial (“trivial”) regex validation succeeded
+        #   (originally: inside the `else:` branch of `try: super().__call__(value)`).
+        self._validate_scheme()
+
+        trivial_ok = self._validate_full_url_with_idn_fallback()
+        if trivial_ok:
+            self._validate_ipv6_netloc_when_present()
+
+        self._validate_netloc_length()
+
+    def _raise(self):
+        raise ValidationError(self.validator.message, code=self.validator.code)
+
+    def _validate_scheme(self):
+        scheme = self.value.split('://')[0].lower()
+        if scheme not in self.validator.schemes:
+            self._raise()
+
+    def _validate_full_url_with_idn_fallback(self):
+        """
+        Returns:
+            True  -> trivial (direct) regex validation succeeded
+            False -> trivial failed, IDN fallback validation succeeded
+
+        This boolean preserves the original URLValidator.__call__ control decision:
+        IPv6 validation runs only when the trivial path succeeds.
+        """
+        try:
+            RegexValidator.__call__(self.validator, self.value)
+            return True
+        except ValidationError as e:
+            # Trivial case failed. Try for possible IDN domain.
+            if not self.value:
+                raise
+            try:
+                scheme, netloc, path, query, fragment = urlsplit(self.value)
+            except ValueError:  # for example, "Invalid IPv6 URL"
+                self._raise()
+            try:
+                netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE
+            except UnicodeError:  # invalid domain part
+                raise e
+            url = urlunsplit((scheme, netloc, path, query, fragment))
+            RegexValidator.__call__(self.validator, url)
+            return False
+
+    def _validate_ipv6_netloc_when_present(self):
+        host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(self.value).netloc)
+        if not host_match:
+            return
+        potential_ip = host_match.groups()[0]
+        try:
+            validate_ipv6_address(potential_ip)
+        except ValidationError:
+            self._raise()
+
+    def _validate_netloc_length(self):
+        # The maximum length of a full host name is 253 characters per RFC 1034
+        # section 3.1. It's defined to be 255 bytes or less, but this includes
+        # one byte for the length of the name and one byte for the trailing dot
+        # that's used to indicate absolute names in DNS.
+        if len(urlsplit(self.value).netloc) > 253:
+            self._raise()
+
+
 @deconstructible
 class URLValidator(RegexValidator):
     ul = '\u00a1-\uffff'  # unicode letters range (must not be a raw string)
@@ -109,44 +194,7 @@ class URLValidator(RegexValidator):
 
     def __call__(self, value):
         # Check first if the scheme is valid
-        scheme = value.split('://')[0].lower()
-        if scheme not in self.schemes:
-            raise ValidationError(self.message, code=self.code)
-
-        # Then check full URL
-        try:
-            super().__call__(value)
-        except ValidationError as e:
-            # Trivial case failed. Try for possible IDN domain
-            if value:
-                try:
-                    scheme, netloc, path, query, fragment = urlsplit(value)
-                except ValueError:  # for example, "Invalid IPv6 URL"
-                    raise ValidationError(self.message, code=self.code)
-                try:
-                    netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE
-                except UnicodeError:  # invalid domain part
-                    raise e
-                url = urlunsplit((scheme, netloc, path, query, fragment))
-                super().__call__(url)
-            else:
-                raise
-        else:
-            # Now verify IPv6 in the netloc part
-            host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)
-            if host_match:
-                potential_ip = host_match.groups()[0]
-                try:
-                    validate_ipv6_address(potential_ip)
-                except ValidationError:
-                    raise ValidationError(self.message, code=self.code)
-
-        # The maximum length of a full host name is 253 characters per RFC 1034
-        # section 3.1. It's defined to be 255 bytes or less, but this includes
-        # one byte for the length of the name and one byte for the trailing dot
-        # that's used to indicate absolute names in DNS.
-        if len(urlsplit(value).netloc) > 253:
-            raise ValidationError(self.message, code=self.code)
+        _URLPartsValidator(self, value).validate()
 
 
 integer_validator = RegexValidator(
@@ -198,15 +246,21 @@ class EmailValidator:
         if (domain_part not in self.domain_whitelist and
                 not self.validate_domain_part(domain_part)):
             # Try for possible IDN domain-part
-            try:
-                domain_part = domain_part.encode('idna').decode('ascii')
-            except UnicodeError:
-                pass
-            else:
-                if self.validate_domain_part(domain_part):
-                    return
+            if self._validate_idn_domain_part(domain_part):
+                return
             raise ValidationError(self.message, code=self.code)
 
+    def _validate_idn_domain_part(self, domain_part):
+        """Try IDN -> ACE conversion and validate the converted domain part.
+
+        Returns True if validation succeeds after IDN conversion, else False.
+        """
+        try:
+            ace = domain_part.encode('idna').decode('ascii')
+        except UnicodeError:
+            return False
+        return self.validate_domain_part(ace)
+
     def validate_domain_part(self, domain_part):
         if self.domain_regex.match(domain_part):
             return True
