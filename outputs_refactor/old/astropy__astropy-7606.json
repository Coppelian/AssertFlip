{
  "repo": "astropy/astropy",
  "instance_id": "astropy__astropy-7606",
  "base_commit": "3cedd79e6c121910220f8e6df77c54a0b344ea94",
  "patch": "diff --git a/astropy/units/core.py b/astropy/units/core.py\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -728,7 +728,7 @@ def __eq__(self, other):\n         try:\n             other = Unit(other, parse_strict='silent')\n         except (ValueError, UnitsError, TypeError):\n-            return False\n+            return NotImplemented\n \n         # Other is Unit-like, but the test below requires it is a UnitBase\n         # instance; if it is not, give up (so that other can try).\n@@ -1710,8 +1710,12 @@ def _unrecognized_operator(self, *args, **kwargs):\n         _unrecognized_operator\n \n     def __eq__(self, other):\n-        other = Unit(other, parse_strict='silent')\n-        return isinstance(other, UnrecognizedUnit) and self.name == other.name\n+        try:\n+            other = Unit(other, parse_strict='silent')\n+        except (ValueError, UnitsError, TypeError):\n+            return NotImplemented\n+\n+        return isinstance(other, type(self)) and self.name == other.name\n \n     def __ne__(self, other):\n         return not (self == other)\n",
  "test_patch": "diff --git a/astropy/units/tests/test_units.py b/astropy/units/tests/test_units.py\n--- a/astropy/units/tests/test_units.py\n+++ b/astropy/units/tests/test_units.py\n@@ -185,6 +185,13 @@ def test_unknown_unit3():\n     assert unit != unit3\n     assert not unit.is_equivalent(unit3)\n \n+    # Also test basic (in)equalities.\n+    assert unit == \"FOO\"\n+    assert unit != u.m\n+    # next two from gh-7603.\n+    assert unit != None  # noqa\n+    assert unit not in (None, u.m)\n+\n     with pytest.raises(ValueError):\n         unit._get_converter(unit3)\n \n",
  "problem_statement": "Unit equality comparison with None raises TypeError for UnrecognizedUnit\n```\r\nIn [12]: x = u.Unit('asdf', parse_strict='silent')\r\n\r\nIn [13]: x == None  # Should be False\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-13-2486f2ccf928> in <module>()\r\n----> 1 x == None  # Should be False\r\n\r\n/Users/aldcroft/anaconda3/lib/python3.5/site-packages/astropy/units/core.py in __eq__(self, other)\r\n   1699 \r\n   1700     def __eq__(self, other):\r\n-> 1701         other = Unit(other, parse_strict='silent')\r\n   1702         return isinstance(other, UnrecognizedUnit) and self.name == other.name\r\n   1703 \r\n\r\n/Users/aldcroft/anaconda3/lib/python3.5/site-packages/astropy/units/core.py in __call__(self, s, represents, format, namespace, doc, parse_strict)\r\n   1808 \r\n   1809         elif s is None:\r\n-> 1810             raise TypeError(\"None is not a valid Unit\")\r\n   1811 \r\n   1812         else:\r\n\r\nTypeError: None is not a valid Unit\r\n```\n",
  "hints_text": "`x is None` works fine. Is there a reason why `==` is needed here?\n`x is None` would indeed be preferred, but `==` should never fail, so this is still a bug.",
  "created_at": "2018-06-29T16:27:46Z",
  "version": "1.3",
  "FAIL_TO_PASS": "[\"astropy/units/tests/test_units.py::test_unknown_unit3\"]",
  "PASS_TO_PASS": "[\"astropy/units/tests/test_units.py::test_getting_started\", \"astropy/units/tests/test_units.py::test_initialisation\", \"astropy/units/tests/test_units.py::test_invalid_power\", \"astropy/units/tests/test_units.py::test_invalid_compare\", \"astropy/units/tests/test_units.py::test_convert\", \"astropy/units/tests/test_units.py::test_convert_fail\", \"astropy/units/tests/test_units.py::test_composite\", \"astropy/units/tests/test_units.py::test_str\", \"astropy/units/tests/test_units.py::test_repr\", \"astropy/units/tests/test_units.py::test_represents\", \"astropy/units/tests/test_units.py::test_units_conversion\", \"astropy/units/tests/test_units.py::test_units_manipulation\", \"astropy/units/tests/test_units.py::test_decompose\", \"astropy/units/tests/test_units.py::test_dimensionless_to_si\", \"astropy/units/tests/test_units.py::test_dimensionless_to_cgs\", \"astropy/units/tests/test_units.py::test_unknown_unit\", \"astropy/units/tests/test_units.py::test_multiple_solidus\", \"astropy/units/tests/test_units.py::test_invalid_scale\", \"astropy/units/tests/test_units.py::test_cds_power\", \"astropy/units/tests/test_units.py::test_register\", \"astropy/units/tests/test_units.py::test_in_units\", \"astropy/units/tests/test_units.py::test_null_unit\", \"astropy/units/tests/test_units.py::test_unrecognized_equivalency\", \"astropy/units/tests/test_units.py::test_unit_noarg\", \"astropy/units/tests/test_units.py::test_convertible_exception\", \"astropy/units/tests/test_units.py::test_convertible_exception2\", \"astropy/units/tests/test_units.py::test_invalid_type\", \"astropy/units/tests/test_units.py::test_steradian\", \"astropy/units/tests/test_units.py::test_decompose_bases\", \"astropy/units/tests/test_units.py::test_complex_compose\", \"astropy/units/tests/test_units.py::test_equiv_compose\", \"astropy/units/tests/test_units.py::test_empty_compose\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[%]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[A]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[AU]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Angstrom]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Ba]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Bi]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Bq]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[C]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Ci]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[D]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[F]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Fr]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[G]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Gal]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[H]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Hz]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[J]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Jy]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[K]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[M_e]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[M_p]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[N]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Ohm]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[P]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Pa]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[R]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Ry]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[S]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[St]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Sun]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[T]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[V]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[W]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[Wb]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[a]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[abC]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[adu]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[arcmin]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[arcsec]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[bar]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[barn]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[beam]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[bin]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[bit]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[byte]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[cd]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[chan]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[cm]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[ct]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[cycle]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[d]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[dB]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[deg]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[deg_C]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[dex]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[dyn]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[eV]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[earthMass]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[earthRad]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[electron]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[erg]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[fortnight]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[g]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[h]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[hourangle]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[jupiterMass]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[jupiterRad]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[k]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[kg]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[l]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[lm]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[lx]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[lyr]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[m]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[mag]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[mas]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[micron]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[min]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[mol]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[pc]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[ph]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[pix]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[rad]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[s]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[sday]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[solLum]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[solMass]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[solRad]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[sr]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[statA]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[t]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[u]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[uas]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[vox]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[wk]\", \"astropy/units/tests/test_units.py::test_compose_roundtrip[yr]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[Ba]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[Bi]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[C]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[D]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[Fr]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[G]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[Gal]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[K]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[P]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[St]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[abC]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[cd]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[cm]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[dyn]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[erg]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[g]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[k]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[mol]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[rad]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[s]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[sr]\", \"astropy/units/tests/test_units.py::test_compose_cgs_to_si[statA]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[%]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[A]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Angstrom]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Bq]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[C]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Ci]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[F]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[H]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Hz]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[J]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[K]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[N]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Ohm]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Pa]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[S]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[T]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[V]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[W]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[Wb]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[a]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[arcmin]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[arcsec]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[bar]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[cd]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[d]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[deg]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[eV]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[fortnight]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[g]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[h]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[hourangle]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[kg]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[l]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[lm]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[lx]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[m]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[mas]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[micron]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[min]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[mol]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[rad]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[s]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[sday]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[sr]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[t]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[uas]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[wk]\", \"astropy/units/tests/test_units.py::test_compose_si_to_cgs[yr]\", \"astropy/units/tests/test_units.py::test_to_cgs\", \"astropy/units/tests/test_units.py::test_decompose_to_cgs\", \"astropy/units/tests/test_units.py::test_compose_issue_579\", \"astropy/units/tests/test_units.py::test_compose_prefix_unit\", \"astropy/units/tests/test_units.py::test_self_compose\", \"astropy/units/tests/test_units.py::test_compose_failed\", \"astropy/units/tests/test_units.py::test_compose_fractional_powers\", \"astropy/units/tests/test_units.py::test_compose_best_unit_first\", \"astropy/units/tests/test_units.py::test_compose_no_duplicates\", \"astropy/units/tests/test_units.py::test_long_int\", \"astropy/units/tests/test_units.py::test_endian_independence\", \"astropy/units/tests/test_units.py::test_radian_base\", \"astropy/units/tests/test_units.py::test_no_as\", \"astropy/units/tests/test_units.py::test_no_duplicates_in_names\", \"astropy/units/tests/test_units.py::test_pickling\", \"astropy/units/tests/test_units.py::test_pickle_unrecognized_unit\", \"astropy/units/tests/test_units.py::test_duplicate_define\", \"astropy/units/tests/test_units.py::test_all_units\", \"astropy/units/tests/test_units.py::test_repr_latex\", \"astropy/units/tests/test_units.py::test_operations_with_strings\", \"astropy/units/tests/test_units.py::test_comparison\", \"astropy/units/tests/test_units.py::test_compose_into_arbitrary_units\", \"astropy/units/tests/test_units.py::test_unit_multiplication_with_string\", \"astropy/units/tests/test_units.py::test_unit_division_by_string\", \"astropy/units/tests/test_units.py::test_sorted_bases\", \"astropy/units/tests/test_units.py::test_megabit\", \"astropy/units/tests/test_units.py::test_composite_unit_get_format_name\", \"astropy/units/tests/test_units.py::test_unicode_policy\", \"astropy/units/tests/test_units.py::test_suggestions\", \"astropy/units/tests/test_units.py::test_fits_hst_unit\", \"astropy/units/tests/test_units.py::test_barn_prefixes\", \"astropy/units/tests/test_units.py::test_fractional_powers\", \"astropy/units/tests/test_units.py::test_inherit_docstrings\", \"astropy/units/tests/test_units.py::test_sqrt_mag\", \"astropy/units/tests/test_units.py::test_composite_compose\", \"astropy/units/tests/test_units.py::test_data_quantities\", \"astropy/units/tests/test_units.py::test_compare_with_none\", \"astropy/units/tests/test_units.py::test_validate_power_detect_fraction\", \"astropy/units/tests/test_units.py::test_complex_fractional_rounding_errors\", \"astropy/units/tests/test_units.py::test_fractional_rounding_errors_simple\", \"astropy/units/tests/test_units.py::test_enable_unit_groupings\", \"astropy/units/tests/test_units.py::test_unit_summary_prefixes\"]",
  "environment_setup_commit": "848c8fa21332abd66b44efe3cb48b72377fb32cc",
  "difficulty": "15 min - 1 hour",
  "test_context": null,
  "localized_code": "[start of astropy/units/__init__.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \n3| \"\"\"\n4| This subpackage contains classes and functions for defining and converting\n5| between different physical units.\n6| \n7| This code is adapted from the `pynbody\n8| <https://github.com/pynbody/pynbody>`_ units module written by Andrew\n9| Pontzen, who has granted the Astropy project permission to use the\n10| code under a BSD license.\n11| \"\"\"\n12| \n13| from .core import *\n14| from .quantity import *\n15| from .decorators import *\n16| \n17| from . import si\n18| from . import cgs\n19| from . import astrophys\n20| from .function import units as function_units\n21| \n22| from .si import *\n23| from .astrophys import *\n24| from .cgs import *\n25| from .physical import *\n26| from .function.units import *\n27| \n28| from .equivalencies import *\n29| \n30| from .function.core import *\n31| from .function.logarithmic import *\n32| from .function import magnitude_zero_points\n33| \n34| del bases\n35| \n36| # Enable the set of default units.  This notably does *not* include\n37| # Imperial units.\n38| \n39| set_enabled_units([si, cgs, astrophys, function_units])\n... Code Truncated ...\n\n[start of astropy/units/core.py]\n1701|     st : str\n1702|         The name of the unit.\n1703|     \"\"\"\n1704|     # For UnrecognizedUnits, we want to use \"standard\" Python\n1705|     # pickling, not the special case that is used for\n1706|     # IrreducibleUnits.\n1707|     __reduce__ = object.__reduce__\n1708| \n1709|     def __repr__(self):\n1710|         return \"UnrecognizedUnit({0})\".format(str(self))\n1711| \n1712|     def __bytes__(self):\n1713|         return self.name.encode('ascii', 'replace')\n1714| \n1715|     def __str__(self):\n1716|         return self.name\n1717| \n1718|     def to_string(self, format=None):\n1719|         return self.name\n1720| \n1721|     def _unrecognized_operator(self, *args, **kwargs):\n1722|         raise ValueError(\n1723|             \"The unit {0!r} is unrecognized, so all arithmetic operations \"\n1724|             \"with it are invalid.\".format(self.name))\n1725| \n1726|     __pow__ = __div__ = __rdiv__ = __truediv__ = __rtruediv__ = __mul__ = \\\n1727|         __rmul__ = __lt__ = __gt__ = __le__ = __ge__ = __neg__ = \\\n1728|         _unrecognized_operator\n1729| \n1730|     def _parse_other_unit(self, other):\n1731|         \"\"\"Overridable seam for parsing 'other' into a Unit (bug-preserving).\"\"\"\n1732|         return Unit(other, parse_strict='silent')\n1733| \n1734|     def __eq__(self, other):\n1735|         other = self._parse_other_unit(other)\n1736|         return isinstance(other, UnrecognizedUnit) and self.name == other.name\n1737| \n1738|     def __ne__(self, other):\n1739|         return not (self == other)\n1740| \n1741|     def is_equivalent(self, other, equivalencies=None):\n1742|         self._normalize_equivalencies(equivalencies)\n1743|         return self == other\n1744| \n1745|     def _get_converter(self, other, equivalencies=None):\n1746|         self._normalize_equivalencies(equivalencies)\n1747|         raise ValueError(\n1748|             \"The unit {0!r} is unrecognized.  It can not be converted \"\n1749|             \"to other units.\".format(self.name))\n1750| \n1751|     def get_format_name(self, format):\n1752|         return self.name\n1753| \n1754|     def is_unity(self):\n1755|         return False\n1756| \n1757| \n1758| class _UnitMetaClass(InheritDocstrings):\n1759|     \"\"\"\n1760|     This metaclass exists because the Unit constructor should\n1761|     sometimes return instances that already exist.  This \"overrides\"\n1762|     the constructor before the new instance is actually created, so we\n1763|     can return an existing one.\n1764|     \"\"\"\n1765| \n1766|     def __call__(self, s, represents=None, format=None, namespace=None,\n1767|                  doc=None, parse_strict='raise'):\n1768| \n1769|         # Short-circuit if we're already a unit\n1770|         if hasattr(s, '_get_physical_type_id'):\n1771|             return s\n1772| \n1773|         # turn possible Quantity input for s or represents into a Unit\n1774|         from .quantity import Quantity\n1775| \n1776|         if isinstance(represents, Quantity):\n1777|             if is_effectively_unity(represents.value):\n1778|                 represents = represents.unit\n1779|             else:\n1780|                 # cannot use _error_check=False: scale may be effectively unity\n1781|                 represents = CompositeUnit(represents.value *\n1782|                                            represents.unit.scale,\n1783|                                            bases=represents.unit.bases,\n1784|                                            powers=represents.unit.powers)\n1785| \n1786|         if isinstance(s, Quantity):\n1787|             if is_effectively_unity(s.value):\n1788|                 s = s.unit\n1789|             else:\n1790|                 s = CompositeUnit(s.value * s.unit.scale,\n1791|                                   bases=s.unit.bases,\n1792|                                   powers=s.unit.powers)\n1793| \n1794|         # now decide what we really need to do; define derived Unit?\n1795|         if isinstance(represents, UnitBase):\n1796|             # This has the effect of calling the real __new__ and\n1797|             # __init__ on the Unit class.\n1798|             return super().__call__(\n1799|                 s, represents, format=format, namespace=namespace, doc=doc)\n1800| \n1801|         # or interpret a Quantity (now became unit), string or number?\n1802|         if isinstance(s, UnitBase):\n1803|             return s\n1804| \n1805|         elif isinstance(s, (bytes, str)):\n1806|             if len(s.strip()) == 0:\n1807|                 # Return the NULL unit\n1808|                 return dimensionless_unscaled\n1809| \n1810|             if format is None:\n1811|                 format = unit_format.Generic\n1812| \n1813|             f = unit_format.get_format(format)\n1814|             if isinstance(s, bytes):\n1815|                 s = s.decode('ascii')\n1816| \n1817|             try:\n1818|                 return f.parse(s)\n1819|             except Exception as e:\n1820|                 if parse_strict == 'silent':\n1821|                     pass\n1822|                 else:\n1823|                     # Deliberately not issubclass here. Subclasses\n1824|                     # should use their name.\n1825|                     if f is not unit_format.Generic:\n1826|                         format_clause = f.name + ' '\n1827|                     else:\n1828|                         format_clause = ''\n1829|                     msg = (\"'{0}' did not parse as {1}unit: {2}\"\n1830|                            .format(s, format_clause, str(e)))\n1831|                     if parse_strict == 'raise':\n1832|                         raise ValueError(msg)\n1833|                     elif parse_strict == 'warn':\n1834|                         warnings.warn(msg, UnitsWarning)\n1835|                     else:\n1836|                         raise ValueError(\"'parse_strict' must be 'warn', \"\n1837|                                          \"'raise' or 'silent'\")\n1838|                 return UnrecognizedUnit(s)\n1839| \n1840|         elif isinstance(s, (int, float, np.floating, np.integer)):\n1841|             return CompositeUnit(s, [], [])\n1842| \n1843|         elif s is None:\n1844|             raise TypeError(\"None is not a valid Unit\")\n1845| \n1846|         else:\n1847|             raise TypeError(\"{0} can not be converted to a Unit\".format(s))\n1848| \n1849| \n1850| class Unit(NamedUnit, metaclass=_UnitMetaClass):\n1851|     \"\"\"\n1852|     The main unit class.\n1853| \n1854|     There are a number of different ways to construct a Unit, but\n1855|     always returns a `UnitBase` instance.  If the arguments refer to\n1856|     an already-existing unit, that existing unit instance is returned,\n1857|     rather than a new one.\n1858| \n1859|     - From a string::\n1860| \n1861|         Unit(s, format=None, parse_strict='silent')\n1862| \n1863|       Construct from a string representing a (possibly compound) unit.\n1864| \n1865|       The optional `format` keyword argument specifies the format the\n1866|       string is in, by default ``\"generic\"``.  For a description of\n1867|       the available formats, see `astropy.units.format`.\n1868| \n1869|       The optional ``parse_strict`` keyword controls what happens when an\n1870|       unrecognized unit string is passed in.  It may be one of the following:\n1871| \n1872|          - ``'raise'``: (default) raise a ValueError exception.\n1873| \n1874|          - ``'warn'``: emit a Warning, and return an\n1875|            `UnrecognizedUnit` instance.\n1876| \n1877|          - ``'silent'``: return an `UnrecognizedUnit` instance.\n1878| \n1879|     - From a number::\n1880| \n1881|         Unit(number)\n1882| \n1883|       Creates a dimensionless unit.\n1884| \n1885|     - From a `UnitBase` instance::\n1886| \n1887|         Unit(unit)\n1888| \n1889|       Returns the given unit unchanged.\n1890| \n1891|     - From `None`::\n1892| \n1893|         Unit()\n1894| \n1895|       Returns the null unit.\n1896| \n1897|     - The last form, which creates a new `Unit` is described in detail\n1898|       below.\n1899| \n1900|     Parameters\n1901|     ----------\n1902|     st : str or list of str\n1903|         The name of the unit.  If a list, the first element is the\n1904|         canonical (short) name, and the rest of the elements are\n1905|         aliases.\n1906| \n1907|     represents : UnitBase instance\n1908|         The unit that this named unit represents.\n1909| \n1910|     doc : str, optional\n1911|         A docstring describing the unit.\n1912| \n1913|     format : dict, optional\n1914|         A mapping to format-specific representations of this unit.\n1915|         For example, for the ``Ohm`` unit, it might be nice to have it\n1916|         displayed as ``\\\\Omega`` by the ``latex`` formatter.  In that\n1917|         case, `format` argument should be set to::\n1918| \n1919|             {'latex': r'\\\\Omega'}\n1920| \n1921|     namespace : dictionary, optional\n... Code Truncated ...\n\n[start of astropy/units/utils.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \n3| \"\"\"\n4| Miscellaneous utilities for `astropy.units`.\n5| \n6| None of the functions in the module are meant for use outside of the\n7| package.\n8| \"\"\"\n9| \n10| \n11| import numbers\n12| import io\n13| import re\n14| from fractions import Fraction\n15| \n16| import numpy as np\n17| from numpy import finfo\n18| \n19| \n20| _float_finfo = finfo(float)\n21| # take float here to ensure comparison with another float is fast\n22| # give a little margin since often multiple calculations happened\n23| _JUST_BELOW_UNITY = float(1.-4.*_float_finfo.epsneg)\n24| _JUST_ABOVE_UNITY = float(1.+4.*_float_finfo.eps)\n25| \n26| \n27| def _get_first_sentence(s):\n28|     \"\"\"\n29|     Get the first sentence from a string and remove any carriage\n30|     returns.\n31|     \"\"\"\n32| \n33|     x = re.match(r\".*?\\S\\.\\s\", s)\n34|     if x is not None:\n35|         s = x.group(0)\n36|     return s.replace('\\n', ' ')\n37| \n38| \n39| def _iter_unit_summary(namespace):\n40|     \"\"\"\n41|     Generates the ``(unit, doc, represents, aliases, prefixes)``\n42|     tuple used to format the unit summary docs in `generate_unit_summary`.\n43|     \"\"\"\n44| \n45|     from . import core\n46| \n47|     # Get all of the units, and keep track of which ones have SI\n48|     # prefixes\n49|     units = []\n50|     has_prefixes = set()\n51|     for key, val in namespace.items():\n52|         # Skip non-unit items\n53|         if not isinstance(val, core.UnitBase):\n54|             continue\n55| \n56|         # Skip aliases\n57|         if key != val.name:\n58|             continue\n59| \n60|         if isinstance(val, core.PrefixUnit):\n61|             # This will return the root unit that is scaled by the prefix\n62|             # attached to it\n63|             has_prefixes.add(val._represents.bases[0].name)\n64|         else:\n65|             units.append(val)\n66| \n67|     # Sort alphabetically, case insensitive\n68|     units.sort(key=lambda x: x.name.lower())\n69| \n70|     for unit in units:\n71|         doc = _get_first_sentence(unit.__doc__).strip()\n72|         represents = ''\n73|         if isinstance(unit, core.Unit):\n74|             represents = \":math:`{0}`\".format(\n75|                 unit._represents.to_string('latex')[1:-1])\n76|         aliases = ', '.join('``{0}``'.format(x) for x in unit.aliases)\n77| \n78|         yield (unit, doc, represents, aliases, 'Yes' if unit.name in has_prefixes else 'No')\n79| \n80| \n81| def generate_unit_summary(namespace):\n82|     \"\"\"\n83|     Generates a summary of units from a given namespace.  This is used\n84|     to generate the docstring for the modules that define the actual\n85|     units.\n86| \n87|     Parameters\n88|     ----------\n89|     namespace : dict\n90|         A namespace containing units.\n91| \n92|     Returns\n93|     -------\n94|     docstring : str\n95|         A docstring containing a summary table of the units.\n96|     \"\"\"\n97| \n98|     docstring = io.StringIO()\n99| \n100|     docstring.write(\"\"\"\n101| .. list-table:: Available Units\n102|    :header-rows: 1\n103|    :widths: 10 20 20 20 1\n104| \n105|    * - Unit\n106|      - Description\n107|      - Represents\n108|      - Aliases\n109|      - SI Prefixes\n110| \"\"\")\n111| \n112|     for unit_summary in _iter_unit_summary(namespace):\n113|         docstring.write(\"\"\"\n114|    * - ``{0}``\n115|      - {1}\n116|      - {2}\n117|      - {3}\n118|      - {4}\n119| \"\"\".format(*unit_summary))\n120| \n121|     return docstring.getvalue()\n122| \n123| \n124| def generate_prefixonly_unit_summary(namespace):\n125|     \"\"\"\n126|     Generates table entries for units in a namespace that are just prefixes\n127|     without the base unit.  Note that this is intended to be used *after*\n128|     `generate_unit_summary` and therefore does not include the table header.\n129| \n130|     Parameters\n131|     ----------\n132|     namespace : dict\n133|         A namespace containing units that are prefixes but do *not* have the\n134|         base unit in their namespace.\n135| \n136|     Returns\n137|     -------\n138|     docstring : str\n139|         A docstring containing a summary table of the units.\n140|     \"\"\"\n141|     from . import PrefixUnit\n142| \n143|     faux_namespace = {}\n144|     for nm, unit in namespace.items():\n145|         if isinstance(unit, PrefixUnit):\n146|             base_unit = unit.represents.bases[0]\n147|             faux_namespace[base_unit.name] = base_unit\n148| \n149|     docstring = io.StringIO()\n150| \n151|     for unit_summary in _iter_unit_summary(faux_namespace):\n152|         docstring.write(\"\"\"\n153|    * - Prefixes for ``{0}``\n154|      - {1} prefixes\n155|      - {2}\n156|      - {3}\n157|      - Only\n158| \"\"\".format(*unit_summary))\n159| \n160|     return docstring.getvalue()\n161| \n162| \n163| def is_effectively_unity(value):\n164|     # value is *almost* always real, except, e.g., for u.mag**0.5, when\n165|     # it will be complex.  Use try/except to ensure normal case is fast\n166|     try:\n167|         return _JUST_BELOW_UNITY <= value <= _JUST_ABOVE_UNITY\n168|     except TypeError:  # value is complex\n169|         return (_JUST_BELOW_UNITY <= value.real <= _JUST_ABOVE_UNITY and\n170|                 _JUST_BELOW_UNITY <= value.imag + 1 <= _JUST_ABOVE_UNITY)\n171| \n172| \n173| def sanitize_scale(scale):\n174|     if is_effectively_unity(scale):\n175|         return 1.0\n176| \n177|     if np.iscomplex(scale):  # scale is complex\n178|         if scale == 0.0:\n179|             return 0.0\n180| \n181|         if abs(scale.real) > abs(scale.imag):\n182|             if is_effectively_unity(scale.imag/scale.real + 1):\n183|                 scale = scale.real\n184|         else:\n185|             if is_effectively_unity(scale.real/scale.imag + 1):\n186|                 scale = complex(0., scale.imag)\n187| \n188|     return scale\n189| \n190| \n191| def _convert_to_float_if_power_of_two(p, denom):\n192|     \"\"\"Extracted from validate_power; preserves existing decision logic.\"\"\"\n193|     # denom is known to be a power of two here.\n194|     return float(p)\n195| \n196| \n197| def validate_power(p, support_tuples=False):\n198|     \"\"\"Convert a power to a floating point value, an integer, or a Fraction.\n199| \n200|     If a fractional power can be represented exactly as a floating point\n201|     number, convert it to a float, to make the math much faster; otherwise,\n202|     retain it as a `fractions.Fraction` object to avoid losing precision.\n203|     Conversely, if the value is indistinguishable from a rational number with a\n204|     low-numbered denominator, convert to a Fraction object.\n205| \n206|     Parameters\n207|     ----------\n208|     p : float, int, Rational, Fraction\n209|         Power to be converted\n210|     \"\"\"\n211|     denom = getattr(p, 'denominator', None)\n212|     if denom is None:\n213|         try:\n214|             p = float(p)\n215|         except Exception:\n216|             if not np.isscalar(p):\n217|                 raise ValueError(\"Quantities and Units may only be raised \"\n218|                                  \"to a scalar power\")\n219|             else:\n220|                 raise\n221| \n222|         if (p % 1.0) == 0.0:\n223|             # Denominators of 1 can just be integers.\n224|             p = int(p)\n225|         elif (p * 8.0) % 1.0 == 0.0:\n226|             # Leave alone if the denominator is exactly 2, 4 or 8, since this\n227|             # can be perfectly represented as a float, which means subsequent\n228|             # operations are much faster.\n229|             pass\n230|         else:\n231|             # Convert floats indistinguishable from a rational to Fraction.\n232|             # Here, we do not need to test values that are divisors of a higher\n233|             # number, such as 3, since it is already addressed by 6.\n234|             for i in (10, 9, 7, 6):\n235|                 scaled = p * float(i)\n236|                 if((scaled + 4. * _float_finfo.eps) % 1.0 <\n237|                    8. * _float_finfo.eps):\n238|                     p = Fraction(int(round(scaled)), i)\n239|                     break\n240| \n241|     elif denom == 1:\n242|         p = int(p.numerator)\n243| \n244| \n245|     elif (denom & (denom - 1)) == 0:\n246|         # Above is a bit-twiddling hack to see if denom is a power of two.\n247|         p = _convert_to_float_if_power_of_two(p, denom)\n248|     return p\n249| \n250| \n251| def resolve_fractions(a, b):\n252|     \"\"\"\n253|     If either input is a Fraction, convert the other to a Fraction.\n254|     This ensures that any operation involving a Fraction will use\n255|     rational arithmetic and preserve precision.\n256|     \"\"\"\n257|     a_is_fraction = isinstance(a, Fraction)\n258|     b_is_fraction = isinstance(b, Fraction)\n259|     if a_is_fraction and not b_is_fraction:\n260|         b = Fraction(b)\n261|     elif not a_is_fraction and b_is_fraction:\n262|         a = Fraction(a)\n263|     return a, b\n264| \n265| \n266| def quantity_asanyarray(a, dtype=None):\n267|     from .quantity import Quantity\n268|     if not isinstance(a, np.ndarray) and not np.isscalar(a) and any(isinstance(x, Quantity) for x in a):\n269|         return Quantity(a, dtype=dtype)\n270|     else:\n271|         return np.asanyarray(a, dtype=dtype)\n... Code Truncated ...\n\n[start of astropy/utils/__init__.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \"\"\"\n3| This subpackage contains developer-oriented utilities used by Astropy.\n4| \n5| Public functions and classes in this subpackage are safe to be used by other\n6| packages, but this subpackage is for utilities that are primarily of use for\n7| developers or to implement python hacks. This subpackage also includes the\n8| `astropy.utils.compat` package, which houses utilities that provide\n9| compatibility and bugfixes across all versions of Python that Astropy supports.\n10| \"\"\"\n11| \n12| \n13| from .codegen import *\n14| from .decorators import *\n15| from .introspection import *\n16| from .misc import *\n... Code Truncated ...\n\n[start of astropy/utils/exceptions.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \"\"\"\n3| This module contains errors/exceptions and warnings of general use for\n4| astropy. Exceptions that are specific to a given subpackage should *not*\n5| be here, but rather in the particular subpackage.\n6| \"\"\"\n7| \n8| \n9| class AstropyWarning(Warning):\n10|     \"\"\"\n11|     The base warning class from which all Astropy warnings should inherit.\n12| \n13|     Any warning inheriting from this class is handled by the Astropy logger.\n14|     \"\"\"\n15| \n16| \n17| class AstropyUserWarning(UserWarning, AstropyWarning):\n18|     \"\"\"\n19|     The primary warning class for Astropy.\n20| \n21|     Use this if you do not need a specific sub-class.\n22|     \"\"\"\n23| \n24| \n25| class AstropyDeprecationWarning(AstropyWarning):\n26|     \"\"\"\n27|     A warning class to indicate a deprecated feature.\n28|     \"\"\"\n29| \n30| \n31| class AstropyPendingDeprecationWarning(PendingDeprecationWarning, AstropyWarning):\n32|     \"\"\"\n33|     A warning class to indicate a soon-to-be deprecated feature.\n34|     \"\"\"\n35| \n36| \n37| class AstropyBackwardsIncompatibleChangeWarning(AstropyWarning):\n38|     \"\"\"\n39|     A warning class indicating a change in astropy that is incompatible\n40|     with previous versions.\n41| \n42|     The suggested procedure is to issue this warning for the version in\n43|     which the change occurs, and remove it for all following versions.\n44|     \"\"\"\n45| \n46| class _NoValue:\n47|     \"\"\"Special keyword value.\n48| \n49|     This class may be used as the default value assigned to a\n50|     deprecated keyword in order to check if it has been given a user\n51|     defined value.\n52|     \"\"\"\n53|     def __repr__(self):\n54|         return 'astropy.utils.exceptions.NoValue'\n55| \n56| \n57| NoValue = _NoValue()\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "astropy/units/__init__.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/units/core.py",
      "suspect_lines": [
        1701,
        1821
      ]
    },
    {
      "filename": "astropy/units/utils.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/utils/__init__.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/utils/exceptions.py",
      "suspect_lines": []
    }
  ]
}