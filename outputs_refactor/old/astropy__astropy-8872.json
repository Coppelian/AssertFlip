{
  "repo": "astropy/astropy",
  "instance_id": "astropy__astropy-8872",
  "base_commit": "b750a0e6ee76fb6b8a099a4d16ec51977be46bf6",
  "patch": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -215,8 +215,8 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):\n     dtype : ~numpy.dtype, optional\n         The dtype of the resulting Numpy array or scalar that will\n         hold the value.  If not provided, it is determined from the input,\n-        except that any input that cannot represent float (integer and bool)\n-        is converted to float.\n+        except that any integer and (non-Quantity) object inputs are converted\n+        to float by default.\n \n     copy : bool, optional\n         If `True` (default), then the value is copied.  Otherwise, a copy will\n@@ -296,8 +296,7 @@ def __new__(cls, value, unit=None, dtype=None, copy=True, order=None,\n                 if not copy:\n                     return value\n \n-                if not (np.can_cast(np.float32, value.dtype) or\n-                        value.dtype.fields):\n+                if value.dtype.kind in 'iu':\n                     dtype = float\n \n             return np.array(value, dtype=dtype, copy=copy, order=order,\n@@ -377,9 +376,7 @@ def __new__(cls, value, unit=None, dtype=None, copy=True, order=None,\n                             \"Numpy numeric type.\")\n \n         # by default, cast any integer, boolean, etc., to float\n-        if dtype is None and (not (np.can_cast(np.float32, value.dtype)\n-                                   or value.dtype.fields)\n-                              or value.dtype.kind == 'O'):\n+        if dtype is None and value.dtype.kind in 'iuO':\n             value = value.astype(float)\n \n         value = value.view(cls)\n",
  "test_patch": "diff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py\n--- a/astropy/units/tests/test_quantity.py\n+++ b/astropy/units/tests/test_quantity.py\n@@ -138,10 +138,13 @@ def test_preserve_dtype(self):\n         assert q2.value == float(q1.value)\n         assert q2.unit == q1.unit\n \n-        # but we should preserve float32\n-        a3 = np.array([1., 2.], dtype=np.float32)\n-        q3 = u.Quantity(a3, u.yr)\n-        assert q3.dtype == a3.dtype\n+        # but we should preserve any float32 or even float16\n+        a3_32 = np.array([1., 2.], dtype=np.float32)\n+        q3_32 = u.Quantity(a3_32, u.yr)\n+        assert q3_32.dtype == a3_32.dtype\n+        a3_16 = np.array([1., 2.], dtype=np.float16)\n+        q3_16 = u.Quantity(a3_16, u.yr)\n+        assert q3_16.dtype == a3_16.dtype\n         # items stored as objects by numpy should be converted to float\n         # by default\n         q4 = u.Quantity(decimal.Decimal('10.25'), u.m)\n",
  "problem_statement": "float16 quantities get upgraded to float64 automatically\nWhen trying to create a `Quantity` from a `np.float16` (not something I actually intended to do, I was experimenting while investigating other issue) it gets upgraded automatically to `np.float64`, which is something that does not happen with other float types:\r\n\r\n```\r\nIn [73]: np.float16(1)\r\nOut[73]: 1.0\r\n\r\nIn [74]: (np.float16(1) * u.km)\r\nOut[74]: <Quantity 1. km>\r\n\r\nIn [75]: (np.float16(1) * u.km).dtype\r\nOut[75]: dtype('float64')\r\n```\r\n\r\nHowever:\r\n\r\n```\r\nIn [76]: (np.float32(1) * u.km).dtype\r\nOut[76]: dtype('float32')\r\n\r\nIn [77]: (np.float64(1) * u.km).dtype\r\nOut[77]: dtype('float64')\r\n\r\nIn [78]: (np.float128(1) * u.km).dtype\r\nOut[78]: dtype('float128')\r\n\r\nIn [79]: (np.float(1) * u.km).dtype\r\nOut[79]: dtype('float64')\r\n\r\nIn [80]: (np.float_(1) * u.km).dtype\r\nOut[80]: dtype('float64')\r\n```\r\n\r\nSomewhat related: #6389\n",
  "hints_text": "Hmm, it was added in gh-1776 (code in [l299](https://github.com/astropy/astropy/blob/master/astropy/units/quantity.py#L299) and [l379](https://github.com/astropy/astropy/blob/master/astropy/units/quantity.py#L379) by checking `np.can_cast(np.float32, value.dtype)`. From the discussion, it seems half floats were never considered (I'm not sure I realized they existed...). It does seem reasonable to allow every inexact type.",
  "created_at": "2019-06-19T20:34:56Z",
  "version": "3.1",
  "FAIL_TO_PASS": "[\"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_preserve_dtype\"]",
  "PASS_TO_PASS": "[\"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_1\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_2\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_3\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_nan_inf\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_unit_property\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_copy\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_subok\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_order\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_ndmin\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_non_quantity_with_unit\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_creation_via_view\", \"astropy/units/tests/test_quantity.py::TestQuantityCreation::test_rshift_warns\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_addition\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_subtraction\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_multiplication\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_division\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_commutativity\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_power\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_matrix_multiplication\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_unary\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_abs\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_incompatible_units\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_non_number_type\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_dimensionless_operations\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_complicated_operation\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_comparison\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_numeric_converters\", \"astropy/units/tests/test_quantity.py::TestQuantityOperations::test_array_converters\", \"astropy/units/tests/test_quantity.py::test_quantity_conversion\", \"astropy/units/tests/test_quantity.py::test_quantity_value_views\", \"astropy/units/tests/test_quantity.py::test_quantity_conversion_with_equiv\", \"astropy/units/tests/test_quantity.py::test_quantity_conversion_equivalency_passed_on\", \"astropy/units/tests/test_quantity.py::test_self_equivalency\", \"astropy/units/tests/test_quantity.py::test_si\", \"astropy/units/tests/test_quantity.py::test_cgs\", \"astropy/units/tests/test_quantity.py::TestQuantityComparison::test_quantity_equality\", \"astropy/units/tests/test_quantity.py::TestQuantityComparison::test_quantity_equality_array\", \"astropy/units/tests/test_quantity.py::TestQuantityComparison::test_quantity_comparison\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_dimensionless_quantity_repr\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_dimensionless_quantity_str\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_dimensionless_quantity_format\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_scalar_quantity_str\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_scalar_quantity_repr\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_array_quantity_str\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_array_quantity_repr\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_scalar_quantity_format\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_uninitialized_unit_format\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_to_string\", \"astropy/units/tests/test_quantity.py::TestQuantityDisplay::test_repr_latex\", \"astropy/units/tests/test_quantity.py::test_decompose\", \"astropy/units/tests/test_quantity.py::test_decompose_regression\", \"astropy/units/tests/test_quantity.py::test_arrays\", \"astropy/units/tests/test_quantity.py::test_array_indexing_slicing\", \"astropy/units/tests/test_quantity.py::test_array_setslice\", \"astropy/units/tests/test_quantity.py::test_inverse_quantity\", \"astropy/units/tests/test_quantity.py::test_quantity_mutability\", \"astropy/units/tests/test_quantity.py::test_quantity_initialized_with_quantity\", \"astropy/units/tests/test_quantity.py::test_quantity_string_unit\", \"astropy/units/tests/test_quantity.py::test_quantity_invalid_unit_string\", \"astropy/units/tests/test_quantity.py::test_implicit_conversion\", \"astropy/units/tests/test_quantity.py::test_implicit_conversion_autocomplete\", \"astropy/units/tests/test_quantity.py::test_quantity_iterability\", \"astropy/units/tests/test_quantity.py::test_copy\", \"astropy/units/tests/test_quantity.py::test_deepcopy\", \"astropy/units/tests/test_quantity.py::test_equality_numpy_scalar\", \"astropy/units/tests/test_quantity.py::test_quantity_pickelability\", \"astropy/units/tests/test_quantity.py::test_quantity_initialisation_from_string\", \"astropy/units/tests/test_quantity.py::test_unsupported\", \"astropy/units/tests/test_quantity.py::test_unit_identity\", \"astropy/units/tests/test_quantity.py::test_quantity_to_view\", \"astropy/units/tests/test_quantity.py::test_quantity_tuple_power\", \"astropy/units/tests/test_quantity.py::test_quantity_fraction_power\", \"astropy/units/tests/test_quantity.py::test_inherit_docstrings\", \"astropy/units/tests/test_quantity.py::test_repr_array_of_quantity\", \"astropy/units/tests/test_quantity.py::TestQuantityMatplotlib::test_plot\", \"astropy/units/tests/test_quantity.py::test_unit_class_override\", \"astropy/units/tests/test_quantity.py::TestQuantityMimics::test_mimic_input[QuantityMimic]\", \"astropy/units/tests/test_quantity.py::TestQuantityMimics::test_mimic_input[QuantityMimic2]\", \"astropy/units/tests/test_quantity.py::TestQuantityMimics::test_mimic_setting[QuantityMimic]\", \"astropy/units/tests/test_quantity.py::TestQuantityMimics::test_mimic_setting[QuantityMimic2]\"]",
  "environment_setup_commit": "2e89d074b3b2abc2da80e437c93b1d5516a0ca57",
  "difficulty": "15 min - 1 hour",
  "test_context": null,
  "localized_code": "[start of astropy/units/core.py]\n952|         raise UnitConversionError(\n953|             \"'{0!r}' is not a scaled version of '{1!r}'\".format(self, other))\n954| \n955|     def to(self, other, value=UNITY, equivalencies=[]):\n956|         \"\"\"\n957|         Return the converted values in the specified unit.\n958| \n959|         Parameters\n960|         ----------\n961|         other : unit object or string\n962|             The unit to convert to.\n963| \n964|         value : scalar int or float, or sequence convertible to array, optional\n965|             Value(s) in the current unit to be converted to the\n966|             specified unit.  If not provided, defaults to 1.0\n967| \n968|         equivalencies : list of equivalence pairs, optional\n969|             A list of equivalence pairs to try if the units are not\n970|             directly convertible.  See :ref:`unit_equivalencies`.\n971|             This list is in addition to possible global defaults set by, e.g.,\n972|             `set_enabled_equivalencies`.\n973|             Use `None` to turn off all equivalencies.\n974| \n975|         Returns\n976|         -------\n977|         values : scalar or array\n978|             Converted value(s). Input value sequences are returned as\n979|             numpy arrays.\n980| \n981|         Raises\n982|         ------\n983|         UnitsError\n984|             If units are inconsistent\n985|         \"\"\"\n986|         if other is self and value is UNITY:\n987|             return UNITY\n988|         else:\n989|             return self._get_converter(other, equivalencies=equivalencies)(value)\n990| \n991|     def in_units(self, other, value=1.0, equivalencies=[]):\n992|         \"\"\"\n993|         Alias for `to` for backward compatibility with pynbody.\n994|         \"\"\"\n995|         return self.to(\n996|             other, value=value, equivalencies=equivalencies)\n997| \n998|     def decompose(self, bases=set()):\n999|         \"\"\"\n1000|         Return a unit object composed of only irreducible units.\n1001| \n1002|         Parameters\n1003|         ----------\n1004|         bases : sequence of UnitBase, optional\n1005|             The bases to decompose into.  When not provided,\n1006|             decomposes down to any irreducible units.  When provided,\n1007|             the decomposed result will only contain the given units.\n1008|             This will raises a `UnitsError` if it's not possible\n1009|             to do so.\n1010| \n1011|         Returns\n1012|         -------\n1013|         unit : CompositeUnit object\n1014|             New object containing only irreducible unit objects.\n1015|         \"\"\"\n1016|         raise NotImplementedError()\n1017| \n1018|     def _compose(self, equivalencies=[], namespace=[], max_depth=2, depth=0,\n1019|                  cached_results=None):\n1020|         def is_final_result(unit):\n1021|             # Returns True if this result contains only the expected\n1022|             # units\n1023|             for base in unit.bases:\n1024|                 if base not in namespace:\n1025|                     return False\n1026|             return True\n1027| \n1028|         unit = self.decompose()\n1029|         key = hash(unit)\n1030| \n1031|         cached = cached_results.get(key)\n1032|         if cached is not None:\n1033|             if isinstance(cached, Exception):\n1034|                 raise cached\n1035|             return cached\n1036| \n1037|         # Prevent too many levels of recursion\n1038|         # And special case for dimensionless unit\n1039|         if depth >= max_depth:\n1040|             cached_results[key] = [unit]\n1041|             return [unit]\n1042| \n1043|         # Make a list including all of the equivalent units\n1044|         units = [unit]\n1045|         for funit, tunit, a, b in equivalencies:\n1046|             if tunit is not None:\n1047|                 if self._is_equivalent(funit):\n1048|                     scale = funit.decompose().scale / unit.scale\n1049|                     units.append(Unit(a(1.0 / scale) * tunit).decompose())\n1050|                 elif self._is_equivalent(tunit):\n1051|                     scale = tunit.decompose().scale / unit.scale\n1052|                     units.append(Unit(b(1.0 / scale) * funit).decompose())\n... Code Truncated ...\n\n[start of astropy/units/quantity.py]\n272|     dtype : ~numpy.dtype, optional\n273|         The dtype of the resulting Numpy array or scalar that will\n274|         hold the value.  If not provided, it is determined from the input,\n275|         except that any input that cannot represent float (integer and bool)\n276|         is converted to float.\n277| \n278|     copy : bool, optional\n279|         If `True` (default), then the value is copied.  Otherwise, a copy will\n280|         only be made if ``__array__`` returns a copy, if value is a nested\n281|         sequence, or if a copy is needed to satisfy an explicitly given\n282|         ``dtype``.  (The `False` option is intended mostly for internal use,\n283|         to speed up initialization where a copy is known to have been made.\n284|         Use with care.)\n285| \n286|     order : {'C', 'F', 'A'}, optional\n287|         Specify the order of the array.  As in `~numpy.array`.  This parameter\n288|         is ignored if the input is a `Quantity` and ``copy=False``.\n289| \n290|     subok : bool, optional\n291|         If `False` (default), the returned array will be forced to be a\n292|         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\n293|         or a subclass appropriate for the unit will be used (such as\n294|         `~astropy.units.Dex` for ``u.dex(u.AA)``).\n295| \n296|     ndmin : int, optional\n297|         Specifies the minimum number of dimensions that the resulting array\n298|         should have.  Ones will be pre-pended to the shape as needed to meet\n299|         this requirement.  This parameter is ignored if the input is a\n300|         `Quantity` and ``copy=False``.\n301| \n302|     Raises\n303|     ------\n304|     TypeError\n305|         If the value provided is not a Python numeric type.\n306|     TypeError\n307|         If the unit provided is not either a :class:`~astropy.units.Unit`\n308|         object or a parseable string unit.\n309| \n310|     Notes\n311|     -----\n312|     Quantities can also be created by multiplying a number or array with a\n313|     :class:`~astropy.units.Unit`. See http://docs.astropy.org/en/latest/units/\n314| \n315|     \"\"\"\n316|     # Need to set a class-level default for _equivalencies, or\n317|     # Constants can not initialize properly\n318|     _equivalencies = []\n319| \n320|     # Default unit for initialization; can be overridden by subclasses,\n321|     # possibly to `None` to indicate there is no default unit.\n322|     _default_unit = dimensionless_unscaled\n323| \n324|     # Ensures views have an undefined unit.\n325|     _unit = None\n326| \n327|     __array_priority__ = 10000\n328| \n329|     def __new__(cls, value, unit=None, dtype=None, copy=True, order=None,\n330|                 subok=False, ndmin=0):\n331| \n332|         if unit is not None:\n333|             # convert unit first, to avoid multiple string->unit conversions\n334|             unit = Unit(unit)\n335|             # if we allow subclasses, allow a class from the unit.\n336|             if subok:\n337|                 qcls = getattr(unit, '_quantity_class', cls)\n338|                 if issubclass(qcls, cls):\n339|                     cls = qcls\n340| \n341|         # optimize speed for Quantity with no dtype given, copy=False\n342|         if isinstance(value, Quantity):\n343|             if unit is not None and unit is not value.unit:\n344|                 value = value.to(unit)\n345|                 # the above already makes a copy (with float dtype)\n346|                 copy = False\n347| \n348|             if type(value) is not cls and not (subok and\n349|                                                isinstance(value, cls)):\n350|                 value = value.view(cls)\n351| \n352|             if dtype is None:\n353|                 if not copy:\n354|                     return value\n355| \n356|                 if not (np.can_cast(np.float32, value.dtype) or\n357|                         value.dtype.fields):\n358|                     dtype = float\n359| \n360|             return np.array(value, dtype=dtype, copy=copy, order=order,\n361|                             subok=True, ndmin=ndmin)\n362| \n363|         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\n364|         # To ensure array remains fast, we short-circuit it.\n365|         value_unit = None\n366|         if not isinstance(value, np.ndarray):\n367|             if isinstance(value, str):\n368|                 # The first part of the regex string matches any integer/float;\n369|                 # the second parts adds possible trailing .+-, which will break\n370|                 # the float function below and ensure things like 1.2.3deg\n371|                 # will not work.\n372|                 pattern = (r'\\s*[+-]?'\n373|                            r'((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|'\n374|                            r'([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))'\n375|                            r'([eE][+-]?\\d+)?'\n376|                            r'[.+-]?')\n377| \n378|                 v = re.match(pattern, value)\n379|                 unit_string = None\n380|                 try:\n381|                     value = float(v.group())\n382| \n383|                 except Exception:\n384|                     raise TypeError('Cannot parse \"{0}\" as a {1}. It does not '\n385|                                     'start with a number.'\n386|                                     .format(value, cls.__name__))\n387| \n388|                 unit_string = v.string[v.end():].strip()\n389|                 if unit_string:\n390|                     value_unit = Unit(unit_string)\n391|                     if unit is None:\n392|                         unit = value_unit  # signal no conversion needed below.\n393| \n394|             elif (isiterable(value) and len(value) > 0 and\n395|                   all(isinstance(v, Quantity) for v in value)):\n396|                 # Convert all quantities to the same unit.\n397|                 if unit is None:\n398|                     unit = value[0].unit\n399|                 value = [q.to_value(unit) for q in value]\n400|                 value_unit = unit  # signal below that conversion has been done\n401| \n402|         if value_unit is None:\n403|             # If the value has a `unit` attribute and if not None\n404|             # (for Columns with uninitialized unit), treat it like a quantity.\n405|             value_unit = getattr(value, 'unit', None)\n406|             if value_unit is None:\n407|                 # Default to dimensionless for no (initialized) unit attribute.\n408|                 if unit is None:\n409|                     unit = cls._default_unit\n410|                 value_unit = unit  # signal below that no conversion is needed\n411|             else:\n412|                 try:\n413|                     value_unit = Unit(value_unit)\n414|                 except Exception as exc:\n415|                     raise TypeError(\"The unit attribute {0!r} of the input could \"\n416|                                     \"not be parsed as an astropy Unit, raising \"\n417|                                     \"the following exception:\\n{1}\"\n418|                                     .format(value.unit, exc))\n419| \n420|                 if unit is None:\n421|                     unit = value_unit\n422|                 elif unit is not value_unit:\n423|                     copy = False  # copy will be made in conversion at end\n424| \n425|         value = np.array(value, dtype=dtype, copy=copy, order=order,\n426|                          subok=False, ndmin=ndmin)\n427| \n428|         # check that array contains numbers or long int objects\n429|         if (value.dtype.kind in 'OSU' and\n430|             not (value.dtype.kind == 'O' and\n431|                  isinstance(value.item(() if value.ndim == 0 else 0),\n432|                             numbers.Number))):\n433|             raise TypeError(\"The value must be a valid Python or \"\n434|                             \"Numpy numeric type.\")\n435| \n436|         # by default, cast any integer, boolean, etc., to float\n437|         if dtype is None and (not (np.can_cast(np.float32, value.dtype)\n438|                                    or value.dtype.fields)\n439|                               or value.dtype.kind == 'O'):\n440|             value = value.astype(float)\n441| \n442|         value = value.view(cls)\n443|         value._set_unit(value_unit)\n444|         if unit is value_unit:\n445|             return value\n446|         else:\n447|             # here we had non-Quantity input that had a \"unit\" attribute\n448|             # with a unit different from the desired one.  So, convert.\n449|             return value.to(unit)\n450| \n451|     def __array_finalize__(self, obj):\n452|         # If we're a new object or viewing an ndarray, nothing has to be done.\n453|         if obj is None or obj.__class__ is np.ndarray:\n454|             return\n455| \n456|         # If our unit is not set and obj has a valid one, use it.\n457|         if self._unit is None:\n458|             unit = getattr(obj, '_unit', None)\n459|             if unit is not None:\n460|                 self._set_unit(unit)\n461| \n462|         # Copy info if the original had `info` defined.  Because of the way the\n463|         # DataInfo works, `'info' in obj.__dict__` is False until the\n464|         # `info` attribute is accessed or set.\n465|         if 'info' in obj.__dict__:\n466|             self.info = obj.info\n467| \n468|     def __array_wrap__(self, obj, context=None):\n469| \n470|         if context is None:\n471|             # Methods like .squeeze() created a new `ndarray` and then call\n472|             # __array_wrap__ to turn the array into self's subclass.\n473|             return self._new_view(obj)\n474| \n475|         raise NotImplementedError('__array_wrap__ should not be used '\n476|                                   'with a context any more, since we require '\n477|                                   'numpy >=1.13.  Please raise an issue on '\n478|                                   'https://github.com/astropy/astropy')\n479| \n480|     # ---- seams for ufunc execution (override in tests/subclasses if needed) ----\n481|     def _get_converters_and_unit(self, function, method, *inputs):\n482|         return converters_and_unit(function, method, *inputs)\n483| \n... Code Truncated ...\n\n[start of astropy/units/quantity_helper/converters.py]\n1| # -*- coding: utf-8 -*-\n2| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n3| \"\"\"Converters for Quantity.\"\"\"\n4| \n5| import numpy as np\n6| \n7| from astropy.units.core import (UnitsError, UnitConversionError, UnitTypeError,\n8|                                 dimensionless_unscaled)\n9| \n10| __all__ = ['can_have_arbitrary_unit', 'converters_and_unit',\n11|            'check_output', 'UFUNC_HELPERS', 'UNSUPPORTED_UFUNCS']\n12| \n13| def _get_unit_converter(unit, to_unit):\n14|     \"\"\"Seam for unit conversion lookup (override/monkeypatch in tests).\"\"\"\n15|     return unit._get_converter(to_unit)\n16| \n17| class UfuncHelpers(dict):\n18|     \"\"\"Registry of unit conversion functions to help ufunc evaluation.\n19| \n20|     Based on dict for quick access, but with a missing method to load\n21|     helpers for additional modules such as scipy.special and erfa.\n22| \n23|     Such modules should be registered using ``register_module``.\n24|     \"\"\"\n25|     UNSUPPORTED = set()\n26| \n27|     def register_module(self, module, names, importer):\n28|         \"\"\"Register (but do not import) a set of ufunc helpers.\n29| \n30|         Parameters\n31|         ----------\n32|         module : str\n33|             Name of the module with the ufuncs (e.g., 'scipy.special').\n34|         names : iterable of str\n35|             Names of the module ufuncs for which helpers are available.\n36|         importer : callable\n37|             Function that imports the ufuncs and returns a dict of helpers\n38|             keyed by those ufuncs.  If the value is `None`, the ufunc is\n39|             explicitly *not* supported.\n40|         \"\"\"\n41|         self.modules[module] = {'names': names,\n42|                                 'importer': importer}\n43| \n44|     @property\n45|     def modules(self):\n46|         \"\"\"Modules for which helpers are available (but not yet loaded).\"\"\"\n47|         if not hasattr(self, '_modules'):\n48|             self._modules = {}\n49|         return self._modules\n50| \n51|     def import_module(self, module):\n52|         \"\"\"Import the helpers from the given module using its helper function.\n53| \n54|         Parameters\n55|         ----------\n56|         module : str\n57|             Name of the module. Has to have been registered beforehand.\n58|         \"\"\"\n59|         module_info = self.modules.pop(module)\n60|         self.update(module_info['importer']())\n61| \n62|     def __missing__(self, ufunc):\n63|         \"\"\"Called if a ufunc is not found.\n64| \n65|         Check if the ufunc is in any of the available modules, and, if so,\n66|         import the helpers for that module.\n67|         \"\"\"\n68|         if ufunc in self.UNSUPPORTED:\n69|             raise TypeError(\"Cannot use ufunc '{0}' with quantities\"\n70|                             .format(ufunc.__name__))\n71| \n72|         for module, module_info in list(self.modules.items()):\n73|             if ufunc.__name__ in module_info['names']:\n74|                 # A ufunc with the same name is supported by this module.\n75|                 # Of course, this doesn't necessarily mean it is the\n76|                 # right module. So, we try let the importer do its work.\n77|                 # If it fails (e.g., for `scipy.special`), then that's\n78|                 # fine, just raise the TypeError.  If it succeeds, but\n79|                 # the ufunc is not found, that is also fine: we will\n80|                 # enter __missing__ again and either find another\n81|                 # module or get the TypeError there.\n82|                 try:\n83|                     self.import_module(module)\n84|                 except ImportError:\n85|                     pass\n86|                 else:\n87|                     return self[ufunc]\n88| \n89|         raise TypeError(\"unknown ufunc {0}.  If you believe this ufunc \"\n90|                         \"should be supported, please raise an issue on \"\n91|                         \"https://github.com/astropy/astropy\"\n92|                         .format(ufunc.__name__))\n93| \n94|     def __setitem__(self, key, value):\n95|         # Implementation note: in principle, we could just let `None`\n96|         # mean that something is not implemented, but this means an\n97|         # extra if clause for the output, slowing down the common\n98|         # path where a ufunc is supported.\n99|         if value is None:\n100|             self.UNSUPPORTED |= {key}\n101|             self.pop(key, None)\n102|         else:\n103|             super().__setitem__(key, value)\n104|             self.UNSUPPORTED -= {key}\n105| \n106| \n107| UFUNC_HELPERS = UfuncHelpers()\n108| UNSUPPORTED_UFUNCS = UFUNC_HELPERS.UNSUPPORTED\n109| \n110| \n111| def can_have_arbitrary_unit(value):\n112|     \"\"\"Test whether the items in value can have arbitrary units\n113| \n114|     Numbers whose value does not change upon a unit change, i.e.,\n115|     zero, infinity, or not-a-number\n116| \n117|     Parameters\n118|     ----------\n119|     value : number or array\n120| \n121|     Returns\n122|     -------\n123|     `True` if each member is either zero or not finite, `False` otherwise\n124|     \"\"\"\n125|     return np.all(np.logical_or(np.equal(value, 0.), ~np.isfinite(value)))\n126| \n127| \n128| def converters_and_unit(function, method, *args, _unit_converter=_get_unit_converter):\n129|     \"\"\"Determine the required converters and the unit of the ufunc result.\n130| \n131|     Converters are functions required to convert to a ufunc's expected unit,\n132|     e.g., radian for np.sin; or to ensure units of two inputs are consistent,\n133|     e.g., for np.add.  In these examples, the unit of the result would be\n134|     dimensionless_unscaled for np.sin, and the same consistent unit for np.add.\n135| \n136|     Parameters\n137|     ----------\n138|     function : `~numpy.ufunc`\n139|         Numpy universal function\n140|     method : str\n141|         Method with which the function is evaluated, e.g.,\n142|         '__call__', 'reduce', etc.\n143|     *args : Quantity or other ndarray subclass\n144|         Input arguments to the function\n145| \n146|     Raises\n147|     ------\n148|     TypeError : when the specified function cannot be used with Quantities\n149|         (e.g., np.logical_or), or when the routine does not know how to handle\n150|         the specified function (in which case an issue should be raised on\n151|         https://github.com/astropy/astropy).\n152|     UnitTypeError : when the conversion to the required (or consistent) units\n153|         is not possible.\n154|     \"\"\"\n155| \n156|     # Check whether we support this ufunc, by getting the helper function\n157|     # (defined in helpers) which returns a list of function(s) that convert the\n158|     # input(s) to the unit required for the ufunc, as well as the unit the\n159|     # result will have (a tuple of units if there are multiple outputs).\n160|     ufunc_helper = UFUNC_HELPERS[function]\n161| \n162|     if method == '__call__' or (method == 'outer' and function.nin == 2):\n163|         # Find out the units of the arguments passed to the ufunc; usually,\n164|         # at least one is a quantity, but for two-argument ufuncs, the second\n165|         # could also be a Numpy array, etc.  These are given unit=None.\n166|         units = [getattr(arg, 'unit', None) for arg in args]\n167| \n168|         # Determine possible conversion functions, and the result unit.\n169|         converters, result_unit = ufunc_helper(function, *units)\n170| \n171|         if any(converter is False for converter in converters):\n172|             # for multi-argument ufuncs with a quantity and a non-quantity,\n173|             # the quantity normally needs to be dimensionless, *except*\n174|             # if the non-quantity can have arbitrary unit, i.e., when it\n175|             # is all zero, infinity or NaN.  In that case, the non-quantity\n176|             # can just have the unit of the quantity\n177|             # (this allows, e.g., `q > 0.` independent of unit)\n178|             try:\n179|                 # Don't fold this loop in the test above: this rare case\n180|                 # should not make the common case slower.\n181|                 for i, converter in enumerate(converters):\n182|                     if converter is not False:\n183|                         continue\n184|                     if can_have_arbitrary_unit(args[i]):\n185|                         converters[i] = None\n186|                     else:\n187|                         raise UnitConversionError(\n188|                             \"Can only apply '{0}' function to \"\n189|                             \"dimensionless quantities when other \"\n190|                             \"argument is not a quantity (unless the \"\n191|                             \"latter is all zero/infinity/nan)\"\n192|                             .format(function.__name__))\n193|             except TypeError:\n194|                 # _can_have_arbitrary_unit failed: arg could not be compared\n195|                 # with zero or checked to be finite. Then, ufunc will fail too.\n196|                 raise TypeError(\"Unsupported operand type(s) for ufunc {0}: \"\n197|                                 \"'{1}'\".format(function.__name__,\n198|                                                ','.join([arg.__class__.__name__\n199|                                                          for arg in args])))\n200| \n201|         # In the case of np.power and np.float_power, the unit itself needs to\n202|         # be modified by an amount that depends on one of the input values,\n203|         # so we need to treat this as a special case.\n204|         # TODO: find a better way to deal with this.\n205|         if result_unit is False:\n206|             if units[0] is None or units[0] == dimensionless_unscaled:\n207|                 result_unit = dimensionless_unscaled\n208|             else:\n209|                 if units[1] is None:\n210|                     p = args[1]\n211|                 else:\n212|                     p = args[1].to(dimensionless_unscaled).value\n213| \n214|                 try:\n215|                     result_unit = units[0] ** p\n216|                 except ValueError as exc:\n217|                     # Changing the unit does not work for, e.g., array-shaped\n218|                     # power, but this is OK if we're (scaled) dimensionless.\n219|                     try:\n220|                         converters[0] = _unit_converter(\n221|                             units[0], dimensionless_unscaled\n222|                         )\n223|                     except UnitConversionError:\n224|                         raise exc\n225|                     else:\n226|                         result_unit = dimensionless_unscaled\n227| \n228|     else:  # methods for which the unit should stay the same\n229|         nin = function.nin\n230|         unit = getattr(args[0], 'unit', None)\n231|         if method == 'at' and nin <= 2:\n232|             if nin == 1:\n233|                 units = [unit]\n234|             else:\n235|                 units = [unit, getattr(args[2], 'unit', None)]\n236| \n237|             converters, result_unit = ufunc_helper(function, *units)\n238| \n239|             # ensure there is no 'converter' for indices (2nd argument)\n240|             converters.insert(1, None)\n241| \n242|         elif method in {'reduce', 'accumulate', 'reduceat'} and nin == 2:\n243|             converters, result_unit = ufunc_helper(function, unit, unit)\n244|             converters = converters[:1]\n245|             if method == 'reduceat':\n246|                 # add 'scale' for indices (2nd argument)\n247|                 converters += [None]\n248| \n249|         else:\n250|             if method in {'reduce', 'accumulate',\n251|                           'reduceat', 'outer'} and nin != 2:\n252|                 raise ValueError(\"{0} only supported for binary functions\"\n253|                                  .format(method))\n254| \n255|             raise TypeError(\"Unexpected ufunc method {0}.  If this should \"\n256|                             \"work, please raise an issue on\"\n257|                             \"https://github.com/astropy/astropy\"\n258|                             .format(method))\n259| \n260|         # for all but __call__ method, scaling is not allowed\n261|         if unit is not None and result_unit is None:\n262|             raise TypeError(\"Cannot use '{1}' method on ufunc {0} with a \"\n263|                             \"Quantity instance as the result is not a \"\n264|                             \"Quantity.\".format(function.__name__, method))\n265| \n266|         if (converters[0] is not None or\n267|             (unit is not None and unit is not result_unit and\n268|              (not result_unit.is_equivalent(unit) or\n269|               result_unit.to(unit) != 1.))):\n270|             # NOTE: this cannot be the more logical UnitTypeError, since\n271|             # then things like np.cumprod will not longer fail (they check\n272|             # for TypeError).\n273|             raise UnitsError(\"Cannot use '{1}' method on ufunc {0} with a \"\n274|                              \"Quantity instance as it would change the unit.\"\n275|                              .format(function.__name__, method))\n276| \n277|     return converters, result_unit\n278| \n279| \n280| def check_output(output, unit, inputs, function=None):\n281|     \"\"\"Check that function output can be stored in the output array given.\n282| \n283|     Parameters\n284|     ----------\n285|     output : array or `~astropy.units.Quantity` or tuple\n286|         Array that should hold the function output (or tuple of such arrays).\n287|     unit : `~astropy.units.Unit` or None, or tuple\n288|         Unit that the output will have, or `None` for pure numbers (should be\n289|         tuple of same if output is a tuple of outputs).\n290|     inputs : tuple\n291|         Any input arguments.  These should be castable to the output.\n292|     function : callable\n293|         The function that will be producing the output.  If given, used to\n294|         give a more informative error message.\n295| \n296|     Returns\n297|     -------\n298|     arrays : `~numpy.ndarray` view of ``output`` (or tuple of such views).\n299| \n300|     Raises\n301|     ------\n302|     UnitTypeError : If ``unit`` is inconsistent with the class of ``output``\n303| \n304|     TypeError : If the ``inputs`` cannot be cast safely to ``output``.\n305|     \"\"\"\n306|     if isinstance(output, tuple):\n307|         return tuple(check_output(output_, unit_, inputs, function)\n308|                      for output_, unit_ in zip(output, unit))\n309| \n310|     # ``None`` indicates no actual array is needed.  This can happen, e.g.,\n311|     # with np.modf(a, out=(None, b)).\n312|     if output is None:\n313|         return None\n314| \n315|     if hasattr(output, '__quantity_subclass__'):\n316|         # Check that we're not trying to store a plain Numpy array or a\n317|         # Quantity with an inconsistent unit (e.g., not angular for Angle).\n318|         if unit is None:\n319|             raise TypeError(\"Cannot store non-quantity output{0} in {1} \"\n320|                             \"instance\".format(\n321|                                 (\" from {0} function\".format(function.__name__)\n322|                                  if function is not None else \"\"),\n323|                                 type(output)))\n324| \n325|         if output.__quantity_subclass__(unit)[0] is not type(output):\n326|             raise UnitTypeError(\n327|                 \"Cannot store output with unit '{0}'{1} \"\n328|                 \"in {2} instance.  Use {3} instance instead.\"\n329|                 .format(unit, (\" from {0} function\".format(function.__name__)\n330|                                if function is not None else \"\"), type(output),\n331|                         output.__quantity_subclass__(unit)[0]))\n332| \n333|         # Turn into ndarray, so we do not loop into array_wrap/array_ufunc\n334|         # if the output is used to store results of a function.\n335|         output = output.view(np.ndarray)\n336|     else:\n337|         # output is not a Quantity, so cannot obtain a unit.\n338|         if not (unit is None or unit is dimensionless_unscaled):\n339|             raise UnitTypeError(\"Cannot store quantity with dimension \"\n340|                                 \"{0}in a non-Quantity instance.\"\n341|                                 .format(\"\" if function is None else\n342|                                         \"resulting from {0} function \"\n343|                                         .format(function.__name__)))\n344| \n345|     # check we can handle the dtype (e.g., that we are not int\n346|     # when float is required).\n347|     if not np.can_cast(np.result_type(*inputs), output.dtype,\n348|                        casting='same_kind'):\n349|         raise TypeError(\"Arguments cannot be cast safely to inplace \"\n350|                         \"output with dtype={0}\".format(output.dtype))\n351|     return output\n... Code Truncated ...\n\n[start of astropy/units/quantity_helper/helpers.py]\n1| # -*- coding: utf-8 -*-\n2| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n3| # The idea for this module (but no code) was borrowed from the\n4| # quantities (http://pythonhosted.org/quantities/) package.\n5| \"\"\"Helper functions for Quantity.\n6| \n7| In particular, this implements the logic that determines scaling and result\n8| units for a given ufunc, given input units.\n9| \"\"\"\n10| \n11| from fractions import Fraction\n12| \n13| import numpy as np\n14| \n15| from . import UFUNC_HELPERS, UNSUPPORTED_UFUNCS\n16| from astropy.units.core import (\n17|     UnitsError, UnitConversionError, UnitTypeError,\n18|     dimensionless_unscaled, get_current_unit_registry)\n19| \n20| \n21| def _d(unit):\n22|     if unit is None:\n23|         return dimensionless_unscaled\n24|     else:\n25|         return unit\n26| \n27| \n28| def get_converter(from_unit, to_unit):\n29|     \"\"\"Like Unit._get_converter, except returns None if no scaling is needed,\n30|     i.e., if the inferred scale is unity.\"\"\"\n31|     try:\n32|         scale = from_unit._to(to_unit)\n33|     except UnitsError:\n34|         return from_unit._apply_equivalencies(\n35|                 from_unit, to_unit, get_current_unit_registry().equivalencies)\n36|     except AttributeError:\n37|         raise UnitTypeError(\"Unit '{0}' cannot be converted to '{1}'\"\n38|                             .format(from_unit, to_unit))\n39|     if scale == 1.:\n40|         return None\n41|     else:\n42|         return lambda val: scale * val\n43| \n44| \n45| def _get_unit_converter(from_unit, to_unit):\n46|     \"\"\"Seam wrapper for get_converter (substitute in tests if needed).\"\"\"\n47|     return get_converter(from_unit, to_unit)\n48| \n49| \n50| def _handle_dimensionless_units_error(converters, changeable, unit2):\n51|     # special case: would be OK if unitless number is zero, inf, nan\n52|     converters[1-changeable] = False\n53|     return converters, unit2\n54| \n55| \n56| def get_converters_and_unit(f, unit1, unit2, _unit_converter=_get_unit_converter):\n57|     converters = [None, None]\n58|     # By default, we try adjusting unit2 to unit1, so that the result will\n59|     # be unit1 as well. But if there is no second unit, we have to try\n60|     # adjusting unit1 (to dimensionless, see below).\n61|     if unit2 is None:\n62|         if unit1 is None:\n63|             # No units for any input -- e.g., np.add(a1, a2, out=q)\n64|             return converters, dimensionless_unscaled\n65|         changeable = 0\n66|         # swap units.\n67|         unit2 = unit1\n68|         unit1 = None\n69|     elif unit2 is unit1:\n70|         # ensure identical units is fast (\"==\" is slow, so avoid that).\n71|         return converters, unit1\n72|     else:\n73|         changeable = 1\n74| \n75|     # Try to get a converter from unit2 to unit1.\n76|     if unit1 is None:\n77|         try:\n78|             converters[changeable] = _unit_converter(unit2, dimensionless_unscaled)\n79| \n80|         except UnitsError:\n81|             return _handle_dimensionless_units_error(converters, changeable, unit2)\n82|         else:\n83|             return converters, dimensionless_unscaled\n84|     else:\n85|         try:\n86|             converters[changeable] = _unit_converter(unit2, unit1)\n87|         except UnitsError:\n88|             raise UnitConversionError(\n89|                 \"Can only apply '{0}' function to quantities \"\n90|                 \"with compatible dimensions\"\n91|                 .format(f.__name__))\n92| \n93|         return converters, unit1\n94| \n95| \n96| # SINGLE ARGUMENT UFUNC HELPERS\n97| #\n98| # The functions below take a single argument, which is the quantity upon which\n99| # the ufunc is being used. The output of the helper function should be two\n100| # values: a list with a single converter to be used to scale the input before\n101| # it is being passed to the ufunc (or None if no conversion is needed), and\n102| # the unit the output will be in.\n103| \n104| def helper_onearg_test(f, unit):\n105|     return ([None], None)\n106| \n107| \n108| def helper_invariant(f, unit):\n109|     return ([None], _d(unit))\n110| \n111| \n112| def helper_square(f, unit):\n113|     return ([None], unit ** 2 if unit is not None else dimensionless_unscaled)\n114| \n115| \n116| def helper_reciprocal(f, unit):\n117|     return ([None], unit ** -1 if unit is not None else dimensionless_unscaled)\n118| \n119| \n120| one_half = 0.5  # faster than Fraction(1, 2)\n121| one_third = Fraction(1, 3)\n122| \n123| \n124| def helper_sqrt(f, unit):\n125|     return ([None], unit ** one_half if unit is not None\n126|             else dimensionless_unscaled)\n127| \n128| \n129| def helper_cbrt(f, unit):\n130|     return ([None], (unit ** one_third if unit is not None\n131|                      else dimensionless_unscaled))\n132| \n133| \n134| def helper_modf(f, unit):\n135|     if unit is None:\n136|         return [None], (dimensionless_unscaled, dimensionless_unscaled)\n137| \n138|     try:\n139|         return ([get_converter(unit, dimensionless_unscaled)],\n140|                 (dimensionless_unscaled, dimensionless_unscaled))\n141|     except UnitsError:\n142|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n143|                             \"dimensionless quantities\"\n144|                             .format(f.__name__))\n145| \n146| \n147| def helper__ones_like(f, unit):\n148|     return [None], dimensionless_unscaled\n149| \n150| \n151| def helper_dimensionless_to_dimensionless(f, unit):\n152|     if unit is None:\n153|         return [None], dimensionless_unscaled\n154| \n155|     try:\n156|         return ([get_converter(unit, dimensionless_unscaled)],\n157|                 dimensionless_unscaled)\n158|     except UnitsError:\n159|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n160|                             \"dimensionless quantities\"\n161|                             .format(f.__name__))\n162| \n163| \n164| def helper_dimensionless_to_radian(f, unit):\n165|     from astropy.units.si import radian\n166|     if unit is None:\n167|         return [None], radian\n168| \n169|     try:\n170|         return [get_converter(unit, dimensionless_unscaled)], radian\n171|     except UnitsError:\n172|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n173|                             \"dimensionless quantities\"\n174|                             .format(f.__name__))\n175| \n176| \n177| def helper_degree_to_radian(f, unit):\n178|     from astropy.units.si import degree, radian\n179|     try:\n180|         return [get_converter(unit, degree)], radian\n181|     except UnitsError:\n182|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n183|                             \"quantities with angle units\"\n184|                             .format(f.__name__))\n185| \n186| \n187| def helper_radian_to_degree(f, unit):\n188|     from astropy.units.si import degree, radian\n189|     try:\n190|         return [get_converter(unit, radian)], degree\n191|     except UnitsError:\n192|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n193|                             \"quantities with angle units\"\n194|                             .format(f.__name__))\n195| \n196| \n197| def helper_radian_to_dimensionless(f, unit):\n198|     from astropy.units.si import radian\n199|     try:\n200|         return [get_converter(unit, radian)], dimensionless_unscaled\n201|     except UnitsError:\n202|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n203|                             \"quantities with angle units\"\n204|                             .format(f.__name__))\n205| \n206| \n207| def helper_frexp(f, unit):\n208|     if not unit.is_unity():\n209|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n210|                             \"unscaled dimensionless quantities\"\n211|                             .format(f.__name__))\n212|     return [None], (None, None)\n213| \n214| \n215| # TWO ARGUMENT UFUNC HELPERS\n216| #\n217| # The functions below take a two arguments. The output of the helper function\n218| # should be two values: a tuple of two converters to be used to scale the\n219| # inputs before being passed to the ufunc (None if no conversion is needed),\n220| # and the unit the output will be in.\n221| \n222| def helper_multiplication(f, unit1, unit2):\n223|     return [None, None], _d(unit1) * _d(unit2)\n224| \n225| \n226| def helper_division(f, unit1, unit2):\n227|     return [None, None], _d(unit1) / _d(unit2)\n228| \n229| \n230| def helper_power(f, unit1, unit2):\n231|     # TODO: find a better way to do this, currently need to signal that one\n232|     # still needs to raise power of unit1 in main code\n233|     if unit2 is None:\n234|         return [None, None], False\n235| \n236|     try:\n237|         return [None, get_converter(unit2, dimensionless_unscaled)], False\n238|     except UnitsError:\n239|         raise UnitTypeError(\"Can only raise something to a \"\n240|                             \"dimensionless quantity\")\n241| \n242| \n243| def helper_ldexp(f, unit1, unit2):\n244|     if unit2 is not None:\n245|         raise TypeError(\"Cannot use ldexp with a quantity \"\n246|                         \"as second argument.\")\n247|     else:\n248|         return [None, None], _d(unit1)\n249| \n250| \n251| def helper_copysign(f, unit1, unit2):\n252|     # if first arg is not a quantity, just return plain array\n253|     if unit1 is None:\n254|         return [None, None], None\n255|     else:\n256|         return [None, None], unit1\n257| \n258| \n259| def helper_heaviside(f, unit1, unit2):\n260|     try:\n261|         converter2 = (get_converter(unit2, dimensionless_unscaled)\n262|                       if unit2 is not None else None)\n263|     except UnitsError:\n264|         raise UnitTypeError(\"Can only apply 'heaviside' function with a \"\n265|                             \"dimensionless second argument.\")\n266|     return ([None, converter2], dimensionless_unscaled)\n267| \n268| \n269| def helper_two_arg_dimensionless(f, unit1, unit2):\n270|     try:\n271|         converter1 = (get_converter(unit1, dimensionless_unscaled)\n272|                       if unit1 is not None else None)\n273|         converter2 = (get_converter(unit2, dimensionless_unscaled)\n274|                       if unit2 is not None else None)\n275|     except UnitsError:\n276|         raise UnitTypeError(\"Can only apply '{0}' function to \"\n277|                             \"dimensionless quantities\"\n278|                             .format(f.__name__))\n279|     return ([converter1, converter2], dimensionless_unscaled)\n280| \n281| \n282| # This used to be a separate function that just called get_converters_and_unit.\n283| # Using it directly saves a few us; keeping the clearer name.\n284| helper_twoarg_invariant = get_converters_and_unit\n285| \n286| \n287| def helper_twoarg_comparison(f, unit1, unit2):\n288|     converters, _ = get_converters_and_unit(f, unit1, unit2)\n289|     return converters, None\n290| \n291| \n292| def helper_twoarg_invtrig(f, unit1, unit2):\n293|     from astropy.units.si import radian\n294|     converters, _ = get_converters_and_unit(f, unit1, unit2)\n295|     return converters, radian\n296| \n297| \n298| def helper_twoarg_floor_divide(f, unit1, unit2):\n299|     converters, _ = get_converters_and_unit(f, unit1, unit2)\n300|     return converters, dimensionless_unscaled\n301| \n302| \n303| def helper_divmod(f, unit1, unit2):\n304|     converters, result_unit = get_converters_and_unit(f, unit1, unit2)\n305|     return converters, (dimensionless_unscaled, result_unit)\n306| \n307| \n308| def helper_clip(f, unit1, unit2, unit3):\n309|     # Treat the array being clipped as primary.\n310|     converters = [None]\n311|     if unit1 is None:\n312|         result_unit = dimensionless_unscaled\n313|         try:\n314|             converters += [(None if unit is None else\n315|                             get_converter(unit, dimensionless_unscaled))\n316|                            for unit in (unit2, unit3)]\n317|         except UnitsError:\n318|             raise UnitConversionError(\n319|                 \"Can only apply '{0}' function to quantities with \"\n320|                 \"compatible dimensions\".format(f.__name__))\n321| \n322|     else:\n323|         result_unit = unit1\n324|         for unit in unit2, unit3:\n325|             try:\n326|                 converter = get_converter(_d(unit), result_unit)\n327|             except UnitsError:\n328|                 if unit is None:\n329|                     # special case: OK if unitless number is zero, inf, nan\n330|                     converters.append(False)\n331|                 else:\n332|                     raise UnitConversionError(\n333|                         \"Can only apply '{0}' function to quantities with \"\n334|                         \"compatible dimensions\".format(f.__name__))\n335|             else:\n336|                 converters.append(converter)\n337| \n338|     return converters, result_unit\n339| \n340| \n341| # list of ufuncs:\n342| # http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs\n343| \n344| UNSUPPORTED_UFUNCS |= {\n345|     np.bitwise_and, np.bitwise_or, np.bitwise_xor, np.invert, np.left_shift,\n346|     np.right_shift, np.logical_and, np.logical_or, np.logical_xor,\n347|     np.logical_not}\n348| for name in 'isnat', 'gcd', 'lcm':\n349|     # isnat was introduced in numpy 1.14, gcd+lcm in 1.15\n350|     ufunc = getattr(np, name, None)\n351|     if isinstance(ufunc, np.ufunc):\n352|         UNSUPPORTED_UFUNCS |= {ufunc}\n353| \n354| # SINGLE ARGUMENT UFUNCS\n355| \n356| # ufuncs that return a boolean and do not care about the unit\n357| onearg_test_ufuncs = (np.isfinite, np.isinf, np.isnan, np.sign, np.signbit)\n358| for ufunc in onearg_test_ufuncs:\n359|     UFUNC_HELPERS[ufunc] = helper_onearg_test\n360| \n361| # ufuncs that return a value with the same unit as the input\n362| invariant_ufuncs = (np.absolute, np.fabs, np.conj, np.conjugate, np.negative,\n363|                     np.spacing, np.rint, np.floor, np.ceil, np.trunc,\n364|                     np.positive)\n365| for ufunc in invariant_ufuncs:\n366|     UFUNC_HELPERS[ufunc] = helper_invariant\n367| \n368| # ufuncs that require dimensionless input and and give dimensionless output\n369| dimensionless_to_dimensionless_ufuncs = (np.exp, np.expm1, np.exp2, np.log,\n370|                                          np.log10, np.log2, np.log1p)\n371| # As found out in gh-7058, some numpy 1.13 conda installations also provide\n372| # np.erf, even though upstream doesn't have it.  We include it if present.\n373| if isinstance(getattr(np.core.umath, 'erf', None), np.ufunc):\n374|     dimensionless_to_dimensionless_ufuncs += (np.core.umath.erf,)\n375| for ufunc in dimensionless_to_dimensionless_ufuncs:\n376|     UFUNC_HELPERS[ufunc] = helper_dimensionless_to_dimensionless\n377| \n378| # ufuncs that require dimensionless input and give output in radians\n379| dimensionless_to_radian_ufuncs = (np.arccos, np.arcsin, np.arctan, np.arccosh,\n380|                                   np.arcsinh, np.arctanh)\n381| for ufunc in dimensionless_to_radian_ufuncs:\n382|     UFUNC_HELPERS[ufunc] = helper_dimensionless_to_radian\n383| \n384| # ufuncs that require input in degrees and give output in radians\n385| degree_to_radian_ufuncs = (np.radians, np.deg2rad)\n386| for ufunc in degree_to_radian_ufuncs:\n387|     UFUNC_HELPERS[ufunc] = helper_degree_to_radian\n388| \n389| # ufuncs that require input in radians and give output in degrees\n390| radian_to_degree_ufuncs = (np.degrees, np.rad2deg)\n391| for ufunc in radian_to_degree_ufuncs:\n392|     UFUNC_HELPERS[ufunc] = helper_radian_to_degree\n393| \n394| # ufuncs that require input in radians and give dimensionless output\n395| radian_to_dimensionless_ufuncs = (np.cos, np.sin, np.tan, np.cosh, np.sinh,\n396|                                   np.tanh)\n397| for ufunc in radian_to_dimensionless_ufuncs:\n398|     UFUNC_HELPERS[ufunc] = helper_radian_to_dimensionless\n399| \n400| # ufuncs handled as special cases\n401| UFUNC_HELPERS[np.sqrt] = helper_sqrt\n402| UFUNC_HELPERS[np.square] = helper_square\n403| UFUNC_HELPERS[np.reciprocal] = helper_reciprocal\n404| UFUNC_HELPERS[np.cbrt] = helper_cbrt\n405| UFUNC_HELPERS[np.core.umath._ones_like] = helper__ones_like\n406| UFUNC_HELPERS[np.modf] = helper_modf\n407| UFUNC_HELPERS[np.frexp] = helper_frexp\n408| \n409| \n410| # TWO ARGUMENT UFUNCS\n411| \n412| # two argument ufuncs that require dimensionless input and and give\n413| # dimensionless output\n414| two_arg_dimensionless_ufuncs = (np.logaddexp, np.logaddexp2)\n415| for ufunc in two_arg_dimensionless_ufuncs:\n416|     UFUNC_HELPERS[ufunc] = helper_two_arg_dimensionless\n417| \n418| # two argument ufuncs that return a value with the same unit as the input\n419| twoarg_invariant_ufuncs = (np.add, np.subtract, np.hypot, np.maximum,\n420|                            np.minimum, np.fmin, np.fmax, np.nextafter,\n421|                            np.remainder, np.mod, np.fmod)\n422| for ufunc in twoarg_invariant_ufuncs:\n423|     UFUNC_HELPERS[ufunc] = helper_twoarg_invariant\n424| \n425| # two argument ufuncs that need compatible inputs and return a boolean\n426| twoarg_comparison_ufuncs = (np.greater, np.greater_equal, np.less,\n427|                             np.less_equal, np.not_equal, np.equal)\n428| for ufunc in twoarg_comparison_ufuncs:\n429|     UFUNC_HELPERS[ufunc] = helper_twoarg_comparison\n430| \n431| # two argument ufuncs that do inverse trigonometry\n432| twoarg_invtrig_ufuncs = (np.arctan2,)\n433| # another private function in numpy; use getattr in case it disappears\n434| if isinstance(getattr(np.core.umath, '_arg', None), np.ufunc):\n435|     twoarg_invtrig_ufuncs += (np.core.umath._arg,)\n436| for ufunc in twoarg_invtrig_ufuncs:\n437|     UFUNC_HELPERS[ufunc] = helper_twoarg_invtrig\n438| \n439| # ufuncs handled as special cases\n440| UFUNC_HELPERS[np.multiply] = helper_multiplication\n441| if isinstance(getattr(np, 'matmul', None), np.ufunc):\n442|     UFUNC_HELPERS[np.matmul] = helper_multiplication\n443| UFUNC_HELPERS[np.divide] = helper_division\n444| UFUNC_HELPERS[np.true_divide] = helper_division\n445| UFUNC_HELPERS[np.power] = helper_power\n446| UFUNC_HELPERS[np.ldexp] = helper_ldexp\n447| UFUNC_HELPERS[np.copysign] = helper_copysign\n448| UFUNC_HELPERS[np.floor_divide] = helper_twoarg_floor_divide\n449| UFUNC_HELPERS[np.heaviside] = helper_heaviside\n450| UFUNC_HELPERS[np.float_power] = helper_power\n451| UFUNC_HELPERS[np.divmod] = helper_divmod\n452| # Check for clip ufunc; note that np.clip is a wrapper function, not the ufunc.\n453| if isinstance(getattr(np.core.umath, 'clip', None), np.ufunc):\n454|     UFUNC_HELPERS[np.core.umath.clip] = helper_clip\n... Code Truncated ...\n\n[start of astropy/units/utils.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \n3| \"\"\"\n4| Miscellaneous utilities for `astropy.units`.\n5| \n6| None of the functions in the module are meant for use outside of the\n7| package.\n8| \"\"\"\n9| \n10| \n11| import numbers\n12| import io\n13| import re\n14| from fractions import Fraction\n15| \n16| import numpy as np\n17| from numpy import finfo\n18| \n19| \n20| _float_finfo = finfo(float)\n21| # take float here to ensure comparison with another float is fast\n22| # give a little margin since often multiple calculations happened\n23| _JUST_BELOW_UNITY = float(1.-4.*_float_finfo.epsneg)\n24| _JUST_ABOVE_UNITY = float(1.+4.*_float_finfo.eps)\n25| \n26| \n27| def _get_first_sentence(s):\n28|     \"\"\"\n29|     Get the first sentence from a string and remove any carriage\n30|     returns.\n31|     \"\"\"\n32| \n33|     x = re.match(r\".*?\\S\\.\\s\", s)\n34|     if x is not None:\n35|         s = x.group(0)\n36|     return s.replace('\\n', ' ')\n37| \n38| \n39| def _iter_unit_summary(namespace):\n40|     \"\"\"\n41|     Generates the ``(unit, doc, represents, aliases, prefixes)``\n42|     tuple used to format the unit summary docs in `generate_unit_summary`.\n43|     \"\"\"\n44| \n45|     from . import core\n46| \n47|     # Get all of the units, and keep track of which ones have SI\n48|     # prefixes\n49|     units = []\n50|     has_prefixes = set()\n51|     for key, val in namespace.items():\n52|         # Skip non-unit items\n53|         if not isinstance(val, core.UnitBase):\n54|             continue\n55| \n56|         # Skip aliases\n57|         if key != val.name:\n58|             continue\n59| \n60|         if isinstance(val, core.PrefixUnit):\n61|             # This will return the root unit that is scaled by the prefix\n62|             # attached to it\n63|             has_prefixes.add(val._represents.bases[0].name)\n64|         else:\n65|             units.append(val)\n66| \n67|     # Sort alphabetically, case insensitive\n68|     units.sort(key=lambda x: x.name.lower())\n69| \n70|     for unit in units:\n71|         doc = _get_first_sentence(unit.__doc__).strip()\n72|         represents = ''\n73|         if isinstance(unit, core.Unit):\n74|             represents = \":math:`{0}`\".format(\n75|                 unit._represents.to_string('latex')[1:-1])\n76|         aliases = ', '.join('``{0}``'.format(x) for x in unit.aliases)\n77| \n78|         yield (unit, doc, represents, aliases, 'Yes' if unit.name in has_prefixes else 'No')\n79| \n80| \n81| def generate_unit_summary(namespace):\n82|     \"\"\"\n83|     Generates a summary of units from a given namespace.  This is used\n84|     to generate the docstring for the modules that define the actual\n85|     units.\n86| \n87|     Parameters\n88|     ----------\n89|     namespace : dict\n90|         A namespace containing units.\n91| \n92|     Returns\n93|     -------\n94|     docstring : str\n95|         A docstring containing a summary table of the units.\n96|     \"\"\"\n97| \n98|     docstring = io.StringIO()\n99| \n100|     docstring.write(\"\"\"\n101| .. list-table:: Available Units\n102|    :header-rows: 1\n103|    :widths: 10 20 20 20 1\n104| \n105|    * - Unit\n106|      - Description\n107|      - Represents\n108|      - Aliases\n109|      - SI Prefixes\n110| \"\"\")\n111| \n112|     for unit_summary in _iter_unit_summary(namespace):\n113|         docstring.write(\"\"\"\n114|    * - ``{0}``\n115|      - {1}\n116|      - {2}\n117|      - {3}\n118|      - {4}\n119| \"\"\".format(*unit_summary))\n120| \n121|     return docstring.getvalue()\n122| \n123| \n124| def generate_prefixonly_unit_summary(namespace):\n125|     \"\"\"\n126|     Generates table entries for units in a namespace that are just prefixes\n127|     without the base unit.  Note that this is intended to be used *after*\n128|     `generate_unit_summary` and therefore does not include the table header.\n129| \n130|     Parameters\n131|     ----------\n132|     namespace : dict\n133|         A namespace containing units that are prefixes but do *not* have the\n134|         base unit in their namespace.\n135| \n136|     Returns\n137|     -------\n138|     docstring : str\n139|         A docstring containing a summary table of the units.\n140|     \"\"\"\n141|     from . import PrefixUnit\n142| \n143|     faux_namespace = {}\n144|     for nm, unit in namespace.items():\n145|         if isinstance(unit, PrefixUnit):\n146|             base_unit = unit.represents.bases[0]\n147|             faux_namespace[base_unit.name] = base_unit\n148| \n149|     docstring = io.StringIO()\n150| \n151|     for unit_summary in _iter_unit_summary(faux_namespace):\n152|         docstring.write(\"\"\"\n153|    * - Prefixes for ``{0}``\n154|      - {1} prefixes\n155|      - {2}\n156|      - {3}\n157|      - Only\n158| \"\"\".format(*unit_summary))\n159| \n160|     return docstring.getvalue()\n161| \n162| \n163| def is_effectively_unity(value):\n164|     # value is *almost* always real, except, e.g., for u.mag**0.5, when\n165|     # it will be complex.  Use try/except to ensure normal case is fast\n166|     try:\n167|         return _JUST_BELOW_UNITY <= value <= _JUST_ABOVE_UNITY\n168|     except TypeError:  # value is complex\n169|         return (_JUST_BELOW_UNITY <= value.real <= _JUST_ABOVE_UNITY and\n170|                 _JUST_BELOW_UNITY <= value.imag + 1 <= _JUST_ABOVE_UNITY)\n171| \n172| \n173| def sanitize_scale(scale):\n174|     if is_effectively_unity(scale):\n175|         return 1.0\n176| \n177|     # Maximum speed for regular case where scale is a float.\n178|     if scale.__class__ is float:\n179|         return scale\n180| \n181|     # All classes that scale can be (int, float, complex, Fraction)\n182|     # have an \"imag\" attribute.\n183|     if scale.imag:\n184|         if abs(scale.real) > abs(scale.imag):\n185|             if is_effectively_unity(scale.imag/scale.real + 1):\n186|                 return scale.real\n187| \n188|         elif is_effectively_unity(scale.real/scale.imag + 1):\n189|             return complex(0., scale.imag)\n190| \n191|         return scale\n192| \n193|     else:\n194|         return scale.real\n195| \n196| \n197| def validate_power(p, support_tuples=False):\n198|     \"\"\"Convert a power to a floating point value, an integer, or a Fraction.\n199| \n200|     If a fractional power can be represented exactly as a floating point\n201|     number, convert it to a float, to make the math much faster; otherwise,\n202|     retain it as a `fractions.Fraction` object to avoid losing precision.\n203|     Conversely, if the value is indistinguishable from a rational number with a\n204|     low-numbered denominator, convert to a Fraction object.\n205| \n206|     Parameters\n207|     ----------\n208|     p : float, int, Rational, Fraction\n209|         Power to be converted\n210|     \"\"\"\n211|     denom = getattr(p, 'denominator', None)\n212|     if denom is None:\n213|         try:\n214|             p = float(p)\n215|         except Exception:\n216|             if not np.isscalar(p):\n217|                 raise ValueError(\"Quantities and Units may only be raised \"\n218|                                  \"to a scalar power\")\n219|             else:\n220|                 raise\n221| \n222|         if (p % 1.0) == 0.0:\n223|             # Denominators of 1 can just be integers.\n224|             p = int(p)\n225|         elif (p * 8.0) % 1.0 == 0.0:\n226|             # Leave alone if the denominator is exactly 2, 4 or 8, since this\n227|             # can be perfectly represented as a float, which means subsequent\n228|             # operations are much faster.\n229|             pass\n230|         else:\n231|             # Convert floats indistinguishable from a rational to Fraction.\n232|             # Here, we do not need to test values that are divisors of a higher\n233|             # number, such as 3, since it is already addressed by 6.\n234|             for i in (10, 9, 7, 6):\n235|                 scaled = p * float(i)\n236|                 if((scaled + 4. * _float_finfo.eps) % 1.0 <\n237|                    8. * _float_finfo.eps):\n238|                     p = Fraction(int(round(scaled)), i)\n239|                     break\n240| \n241|     elif denom == 1:\n242|         p = int(p.numerator)\n243| \n244|     elif (denom & (denom - 1)) == 0:\n245|         # Above is a bit-twiddling hack to see if denom is a power of two.\n246|         p = float(p)\n247| \n248|     return p\n249| \n250| \n251| def resolve_fractions(a, b):\n252|     \"\"\"\n253|     If either input is a Fraction, convert the other to a Fraction.\n254|     This ensures that any operation involving a Fraction will use\n255|     rational arithmetic and preserve precision.\n256|     \"\"\"\n257|     # We short-circuit on the most common cases of int and float, since\n258|     # isinstance(a, Fraction) is very slow for any non-Fraction instances.\n259|     a_is_fraction = (a.__class__ is not int and a.__class__ is not float and\n260|                      isinstance(a, Fraction))\n261|     b_is_fraction = (b.__class__ is not int and b.__class__ is not float and\n262|                      isinstance(b, Fraction))\n263|     if a_is_fraction and not b_is_fraction:\n264|         b = Fraction(b)\n265|     elif not a_is_fraction and b_is_fraction:\n266|         a = Fraction(a)\n267|     return a, b\n268| \n269| \n270| def quantity_asanyarray(a, dtype=None):\n271|     from .quantity import Quantity\n272|     if not isinstance(a, np.ndarray) and not np.isscalar(a) and any(isinstance(x, Quantity) for x in a):\n273|         return Quantity(a, dtype=dtype)\n274|     else:\n275|         return np.asanyarray(a, dtype=dtype)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "astropy/units/core.py",
      "suspect_lines": [
        952
      ]
    },
    {
      "filename": "astropy/units/quantity.py",
      "suspect_lines": [
        272,
        298,
        380,
        383
      ]
    },
    {
      "filename": "astropy/units/quantity_helper/converters.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/units/quantity_helper/helpers.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/units/utils.py",
      "suspect_lines": []
    }
  ]
}