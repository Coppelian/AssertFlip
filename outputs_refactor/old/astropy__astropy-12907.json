{
  "repo": "astropy/astropy",
  "instance_id": "astropy__astropy-12907",
  "base_commit": "d16bfe05a744909de4b27f5875fe0d4ed41ce607",
  "patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n",
  "test_patch": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -28,6 +28,13 @@\n p1 = models.Polynomial1D(1, name='p1')\n \n \n+cm_4d_expected = (np.array([False, False, True, True]),\n+                  np.array([[True,  True,  False, False],\n+                            [True,  True,  False, False],\n+                            [False, False, True,  False],\n+                            [False, False, False, True]]))\n+\n+\n compound_models = {\n     'cm1': (map3 & sh1 | rot & sh1 | sh1 & sh2 & sh1,\n             (np.array([False, False, True]),\n@@ -52,7 +59,17 @@\n     'cm7': (map2 | p2 & sh1,\n             (np.array([False, True]),\n              np.array([[True, False], [False, True]]))\n-            )\n+            ),\n+    'cm8': (rot & (sh1 & sh2), cm_4d_expected),\n+    'cm9': (rot & sh1 & sh2, cm_4d_expected),\n+    'cm10': ((rot & sh1) & sh2, cm_4d_expected),\n+    'cm11': (rot & sh1 & (scl1 & scl2),\n+             (np.array([False, False, True, True, True]),\n+              np.array([[True,  True,  False, False, False],\n+                        [True,  True,  False, False, False],\n+                        [False, False, True,  False, False],\n+                        [False, False, False, True,  False],\n+                        [False, False, False, False, True]]))),\n }\n \n \n",
  "problem_statement": "Modeling's `separability_matrix` does not compute separability correctly for nested CompoundModels\nConsider the following model:\r\n\r\n```python\r\nfrom astropy.modeling import models as m\r\nfrom astropy.modeling.separable import separability_matrix\r\n\r\ncm = m.Linear1D(10) & m.Linear1D(5)\r\n```\r\n\r\nIt's separability matrix as you might expect is a diagonal:\r\n\r\n```python\r\n>>> separability_matrix(cm)\r\narray([[ True, False],\r\n       [False,  True]])\r\n```\r\n\r\nIf I make the model more complex:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5))\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True, False],\r\n       [False, False, False,  True]])\r\n```\r\n\r\nThe output matrix is again, as expected, the outputs and inputs to the linear models are separable and independent of each other.\r\n\r\nIf however, I nest these compound models:\r\n```python\r\n>>> separability_matrix(m.Pix2Sky_TAN() & cm)\r\narray([[ True,  True, False, False],\r\n       [ True,  True, False, False],\r\n       [False, False,  True,  True],\r\n       [False, False,  True,  True]])\r\n```\r\nSuddenly the inputs and outputs are no longer separable?\r\n\r\nThis feels like a bug to me, but I might be missing something?\n",
  "hints_text": "",
  "created_at": "2022-03-03T15:14:54Z",
  "version": "4.3",
  "FAIL_TO_PASS": "[\"astropy/modeling/tests/test_separable.py::test_separable[compound_model6-result6]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model9-result9]\"]",
  "PASS_TO_PASS": "[\"astropy/modeling/tests/test_separable.py::test_coord_matrix\", \"astropy/modeling/tests/test_separable.py::test_cdot\", \"astropy/modeling/tests/test_separable.py::test_cstack\", \"astropy/modeling/tests/test_separable.py::test_arith_oper\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model0-result0]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model1-result1]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model2-result2]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model3-result3]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model4-result4]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model5-result5]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model7-result7]\", \"astropy/modeling/tests/test_separable.py::test_separable[compound_model8-result8]\", \"astropy/modeling/tests/test_separable.py::test_custom_model_separable\"]",
  "environment_setup_commit": "298ccb478e6bf092953bca67a3d29dc6c35f6752",
  "difficulty": "15 min - 1 hour",
  "test_context": null,
  "localized_code": "[start of astropy/modeling/__init__.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \n3| \"\"\"\n4| This subpackage provides a framework for representing models and\n5| performing model evaluation and fitting. It supports 1D and 2D models\n6| and fitting with parameter constraints. It has some predefined models\n7| and fitting routines.\n8| \"\"\"\n9| \n10| from . import fitting\n11| from . import models\n12| from .core import *\n13| from .parameters import *\n14| from .separable import *\n... Code Truncated ...\n\n[start of astropy/modeling/core.py]\n205| \n206|             >>> from astropy.modeling.models import Rotation2D\n207|             >>> SkyRotation = Rotation2D.rename('SkyRotation')\n208|             >>> SkyRotation\n209|             <class 'astropy.modeling.core.SkyRotation'>\n210|             Name: SkyRotation (Rotation2D)\n211|             N_inputs: 2\n212|             N_outputs: 2\n213|             Fittable parameters: ('angle',)\n214|             >>> issubclass(SkyRotation, Rotation2D)\n215|             True\n216|             >>> r = SkyRotation(90)\n217|             >>> isinstance(r, Rotation2D)\n218|             True\n219|         \"\"\"\n220| \n221|         mod = find_current_module(2)\n222|         if mod:\n223|             modname = mod.__name__\n224|         else:\n225|             modname = '__main__'\n226| \n227|         if name is None:\n228|             name = cls.name\n229|         if inputs is None:\n230|             inputs = cls.inputs\n231|         else:\n232|             if not isinstance(inputs, tuple):\n233|                 raise TypeError(\"Expected 'inputs' to be a tuple of strings.\")\n234|             elif len(inputs) != len(cls.inputs):\n235|                 raise ValueError(f'{cls.name} expects {len(cls.inputs)} inputs')\n236|         if outputs is None:\n237|             outputs = cls.outputs\n238|         else:\n239|             if not isinstance(outputs, tuple):\n240|                 raise TypeError(\"Expected 'outputs' to be a tuple of strings.\")\n241|             elif len(outputs) != len(cls.outputs):\n242|                 raise ValueError(f'{cls.name} expects {len(cls.outputs)} outputs')\n243|         new_cls = type(name, (cls,), {\"inputs\": inputs, \"outputs\": outputs})\n244|         new_cls.__module__ = modname\n245|         new_cls.__qualname__ = name\n246| \n247|         return new_cls\n248| \n249|     def _create_inverse_property(cls, members):\n250|         inverse = members.get('inverse')\n251|         if inverse is None or cls.__bases__[0] is object:\n252|             # The latter clause is the prevent the below code from running on\n253|             # the Model base class, which implements the default getter and\n254|             # setter for .inverse\n255|             return\n256| \n257|         if isinstance(inverse, property):\n258|             # We allow the @property decorator to be omitted entirely from\n259|             # the class definition, though its use should be encouraged for\n260|             # clarity\n261|             inverse = inverse.fget\n262| \n263|         # Store the inverse getter internally, then delete the given .inverse\n264|         # attribute so that cls.inverse resolves to Model.inverse instead\n265|         cls._inverse = inverse\n266|         del cls.inverse\n267| \n268|     def _create_bounding_box_property(cls, members):\n269|         \"\"\"\n270|         Takes any bounding_box defined on a concrete Model subclass (either\n271|         as a fixed tuple or a property or method) and wraps it in the generic\n272|         getter/setter interface for the bounding_box attribute.\n273|         \"\"\"\n274| \n275|         # TODO: Much of this is verbatim from _create_inverse_property--I feel\n276|         # like there could be a way to generify properties that work this way,\n277|         # but for the time being that would probably only confuse things more.\n278|         bounding_box = members.get('bounding_box')\n279|         if bounding_box is None or cls.__bases__[0] is object:\n280|             return\n281| \n282|         if isinstance(bounding_box, property):\n283|             bounding_box = bounding_box.fget\n284| \n285|         if not callable(bounding_box):\n286|             # See if it's a hard-coded bounding_box (as a sequence) and\n287|             # normalize it\n288|             try:\n289|                 bounding_box = ModelBoundingBox.validate(cls, bounding_box, _preserve_ignore=True)\n290|             except ValueError as exc:\n291|                 raise ModelDefinitionError(exc.args[0])\n292|         else:\n293|             sig = signature(bounding_box)\n294|             # May be a method that only takes 'self' as an argument (like a\n295|             # property, but the @property decorator was forgotten)\n296|             #\n297|             # However, if the method takes additional arguments then this is a\n298|             # parameterized bounding box and should be callable\n299|             if len(sig.parameters) > 1:\n300|                 bounding_box = \\\n301|                         cls._create_bounding_box_subclass(bounding_box, sig)\n302| \n303|         # See the Model.bounding_box getter definition for how this attribute\n304|         # is used\n305|         cls._bounding_box = bounding_box\n306|         del cls.bounding_box\n307| \n308|     def _create_bounding_box_subclass(cls, func, sig):\n... Code Truncated ...\n\n[start of astropy/modeling/models.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \n3| \"\"\"\n4| Creates a common namespace for all pre-defined models.\n5| \"\"\"\n6| \n7| # pylint: disable=unused-wildcard-import, unused-import, wildcard-import\n8| \n9| from .core import custom_model, hide_inverse, fix_inputs # pylint: disable=W0611\n10| from .mappings import *\n11| from .projections import *\n12| from .rotations import *\n13| from .polynomial import *\n14| from .functional_models import *\n15| from .physical_models import *\n16| from .powerlaws import *\n17| from .spline import *\n18| from .tabular import *\n19| from . import math_functions as math\n20| \n21| \n22| # Attach a docstring explaining constraints to all models which support them.\n23| # Note: add new models to this list\n24| \n25| CONSTRAINTS_DOC = \"\"\"\n26|     Other Parameters\n27|     ----------------\n28|     fixed : a dict, optional\n29|         A dictionary ``{parameter_name: boolean}`` of parameters to not be\n30|         varied during fitting. True means the parameter is held fixed.\n31|         Alternatively the `~astropy.modeling.Parameter.fixed`\n32|         property of a parameter may be used.\n33|     tied : dict, optional\n34|         A dictionary ``{parameter_name: callable}`` of parameters which are\n35|         linked to some other parameter. The dictionary values are callables\n36|         providing the linking relationship.  Alternatively the\n37|         `~astropy.modeling.Parameter.tied` property of a parameter\n38|         may be used.\n39|     bounds : dict, optional\n40|         A dictionary ``{parameter_name: value}`` of lower and upper bounds of\n41|         parameters. Keys are parameter names. Values are a list or a tuple\n42|         of length 2 giving the desired range for the parameter.\n43|         Alternatively, the\n44|         `~astropy.modeling.Parameter.min` and\n45|         `~astropy.modeling.Parameter.max` properties of a parameter\n46|         may be used.\n47|     eqcons : list, optional\n48|         A list of functions of length ``n`` such that ``eqcons[j](x0,*args) ==\n49|         0.0`` in a successfully optimized problem.\n50|     ineqcons : list, optional\n51|         A list of functions of length ``n`` such that ``ieqcons[j](x0,*args) >=\n52|         0.0`` is a successfully optimized problem.\n53| \"\"\"\n54| \n55| \n56| MODELS_WITH_CONSTRAINTS = [\n57|     AiryDisk2D, Moffat1D, Moffat2D, Box1D, Box2D,\n58|     Const1D, Const2D, Ellipse2D, Disk2D,\n59|     Gaussian1D, Gaussian2D,\n60|     Linear1D, Lorentz1D, RickerWavelet1D, RickerWavelet2D,\n61|     PowerLaw1D, Sersic1D, Sersic2D,\n62|     Sine1D, Cosine1D, Tangent1D, ArcSine1D, ArcCosine1D, ArcTangent1D,\n63|     Trapezoid1D, TrapezoidDisk2D,\n64|     Chebyshev1D, Chebyshev2D, Hermite1D, Hermite2D, Legendre2D, Legendre1D,\n65|     Polynomial1D, Polynomial2D, Voigt1D, KingProjectedAnalytic1D,\n66|     NFW\n67| ]\n68| \n69| \n70| for item in MODELS_WITH_CONSTRAINTS:\n71|     if isinstance(item.__doc__, str):\n72|         item.__doc__ += CONSTRAINTS_DOC\n... Code Truncated ...\n\n[start of astropy/modeling/separable.py]\n61|     is_separable = separable_matrix.sum(1)\n62|     is_separable = np.where(is_separable != 1, False, True)\n63|     return is_separable\n64| \n65| \n66| def separability_matrix(transform):\n67|     \"\"\"\n68|     Compute the correlation between outputs and inputs.\n69| \n70|     Parameters\n71|     ----------\n72|     transform : `~astropy.modeling.core.Model`\n73|         A (compound) model.\n74| \n75|     Returns\n76|     -------\n77|     separable_matrix : ndarray\n78|         A boolean correlation matrix of shape (n_outputs, n_inputs).\n79|         Indicates the dependence of outputs on inputs. For completely\n80|         independent outputs, the diagonal elements are True and\n81|         off-diagonal elements are False.\n82| \n83|     Examples\n84|     --------\n85|     >>> from astropy.modeling.models import Shift, Scale, Rotation2D, Polynomial2D\n86|     >>> separability_matrix(Shift(1) & Shift(2) | Scale(1) & Scale(2))\n87|         array([[ True, False], [False,  True]]...)\n88|     >>> separability_matrix(Shift(1) & Shift(2) | Rotation2D(2))\n89|         array([[ True,  True], [ True,  True]]...)\n90|     >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]) | \\\n91|         Polynomial2D(1) & Polynomial2D(2))\n92|         array([[ True,  True], [ True,  True]]...)\n93|     >>> separability_matrix(Shift(1) & Shift(2) | Mapping([0, 1, 0, 1]))\n94|         array([[ True, False], [False,  True], [ True, False], [False,  True]]...)\n95| \n96|     \"\"\"\n97|     if transform.n_inputs == 1 and transform.n_outputs > 1:\n98|         return np.ones((transform.n_outputs, transform.n_inputs),\n99|                        dtype=np.bool_)\n100|     separable_matrix = _separable(transform)\n101|     separable_matrix = np.where(separable_matrix != 0, True, False)\n102|     return separable_matrix\n103| \n104| \n105| def _compute_n_outputs(left, right):\n106|     \"\"\"\n107|     Compute the number of outputs of two models.\n108| \n109|     The two models are the left and right model to an operation in\n110|     the expression tree of a compound model.\n111| \n112|     Parameters\n113|     ----------\n114|     left, right : `astropy.modeling.Model` or ndarray\n115|         If input is of an array, it is the output of `coord_matrix`.\n116|     \"\"\"\n117|     # Sprout helper calls (structure only; logic preserved)\n118|     lnout = _n_outputs_of(left)\n119|     rnout = _n_outputs_of(right)\n120|     return lnout + rnout\n121| \n122| \n123| def _n_outputs_of(obj):\n124|     \"\"\"\n125|     Bug-preserving helper: return n_outputs for Model, else first dimension for ndarray.\n126|     \"\"\"\n127|     if isinstance(obj, Model):\n128|         return obj.n_outputs\n129|     return obj.shape[0]\n130| \n131| \n132| def _arith_oper(left, right):\n133|     \"\"\"\n134|     Function corresponding to one of the arithmetic operators\n135|     ['+', '-'. '*', '/', '**'].\n136| \n137|     This always returns a nonseparable output.\n138| \n139| \n140|     Parameters\n141|     ----------\n142|     left, right : `astropy.modeling.Model` or ndarray\n143|         If input is of an array, it is the output of `coord_matrix`.\n144| \n145|     Returns\n146|     -------\n147|     result : ndarray\n148|         Result from this operation.\n149|     \"\"\"\n150|     # models have the same number of inputs and outputs\n151|     def _n_inputs_outputs(input):\n152|         if isinstance(input, Model):\n153|             n_outputs, n_inputs = input.n_outputs, input.n_inputs\n154|         else:\n155|             n_outputs, n_inputs = input.shape\n156|         return n_inputs, n_outputs\n157| \n158|     left_inputs, left_outputs = _n_inputs_outputs(left)\n159|     right_inputs, right_outputs = _n_inputs_outputs(right)\n160| \n161|     if left_inputs != right_inputs or left_outputs != right_outputs:\n162|         raise ModelDefinitionError(\n163|             \"Unsupported operands for arithmetic operator: left (n_inputs={}, \"\n164|             \"n_outputs={}) and right (n_inputs={}, n_outputs={}); \"\n165|             \"models must have the same n_inputs and the same \"\n166|             \"n_outputs for this operator.\".format(\n167|                 left_inputs, left_outputs, right_inputs, right_outputs))\n168| \n169|     result = np.ones((left_outputs, left_inputs))\n170|     return result\n171| \n172| \n173| def _coord_matrix(model, pos, noutp):\n174|     \"\"\"\n175|     Create an array representing inputs and outputs of a simple model.\n176| \n177|     The array has a shape (noutp, model.n_inputs).\n178| \n179|     Parameters\n180|     ----------\n181|     model : `astropy.modeling.Model`\n182|         model\n183|     pos : str\n184|         Position of this model in the expression tree.\n185|         One of ['left', 'right'].\n186|     noutp : int\n187|         Number of outputs of the compound model of which the input model\n188|         is a left or right child.\n189| \n190|     \"\"\"\n191|     if isinstance(model, Mapping):\n192|         m = model._separability_axes_matrix()\n193|         mat = np.zeros((noutp, model.n_inputs))\n194|         if pos == \"left\":\n195|             mat[: model.n_outputs, : model.n_inputs] = m\n196|         else:\n197|             mat[-model.n_outputs:, -model.n_inputs:] = m\n198|         return mat\n199| \n200| \n201| def _cstack(left, right):\n202|     \"\"\"\n203|     Coordinate stack for two inputs in a compound model operation.\n204| \n205|     Bug-preserving refactor:\n206|     - Preserves the Model vs ndarray branching.\n207|     - Preserves the unusual behavior for ndarray `right`: padded region is filled with 1.\n208|     \"\"\"\n209|     noutp = _compute_n_outputs(left, right)\n210|     cleft = _pad_left_for_cstack(left, noutp)\n211|     cright = _pad_right_for_cstack(right, noutp)\n212|     return np.hstack([cleft, cright])\n213| \n214| \n215| def _pad_left_for_cstack(left, noutp):\n216|     \"\"\"\n217|     Bug-preserving helper for the left argument of _cstack.\n218|     \"\"\"\n219|     if isinstance(left, Model):\n220|         return _coord_matrix(left, \"left\", noutp)\n221| \n222|     cleft = np.zeros((noutp, left.shape[1]))\n223|     cleft[: left.shape[0], : left.shape[1]] = left\n224|     return cleft\n225| \n226| \n227| def _pad_right_for_cstack(right, noutp):\n228|     \"\"\"\n229|     Bug-preserving helper for the right argument of _cstack.\n230| \n231|     NOTE: The ndarray case intentionally fills the padded region with 1\n232|     (matching the original behavior). Do NOT change this to `= right`.\n233|     \"\"\"\n234|     if isinstance(right, Model):\n235|         return _coord_matrix(right, \"right\", noutp)\n236| \n237|     cright = np.zeros((noutp, right.shape[1]))\n238|     cright[-right.shape[0] :, -right.shape[1] :] = 1\n239|     return cright\n240| \n241| \n242| \n243| def _cdot(left, right):\n244|     \"\"\"\n245|     Function corresponding to \"|\" operation.\n246| \n247|     Parameters\n248|     ----------\n249|     left, right : `astropy.modeling.Model` or ndarray\n250|         If input is of an array, it is the output of `coord_matrix`.\n251| \n252|     Returns\n253|     -------\n254|     result : ndarray\n255|         Result from this operation.\n256|     \"\"\"\n257| \n258|     left, right = right, left\n259| \n260|     def _n_inputs_outputs(input, position):\n261|         \"\"\"\n262|         Return ``n_inputs``, ``n_outputs`` for a model or coord_matrix.\n263|         \"\"\"\n264|         if isinstance(input, Model):\n265|             coords = _coord_matrix(input, position, input.n_outputs)\n266|         else:\n267|             coords = input\n268|         return coords\n269| \n270|     cleft = _n_inputs_outputs(left, 'left')\n271|     cright = _n_inputs_outputs(right, 'right')\n272| \n273|     try:\n274|         result = np.dot(cleft, cright)\n275|     except ValueError:\n276|         raise ModelDefinitionError(\n277|             'Models cannot be combined with the \"|\" operator; '\n278|             'left coord_matrix is {}, right coord_matrix is {}'.format(\n279|                 cright, cleft))\n280|     return result\n281| \n282| \n283| def _separable(transform):\n284|     \"\"\"\n285|     Calculate the separability of outputs.\n286| \n287|     Parameters\n288|     ----------\n289|     transform : `astropy.modeling.Model`\n290|         A transform (usually a compound model).\n291| \n292|     Returns :\n293|     is_separable : ndarray of dtype np.bool\n294|         An array of shape (transform.n_outputs,) of boolean type\n295|         Each element represents the separablity of the corresponding output.\n296|     \"\"\"\n297|     return _SeparabilityCalculator().run(transform)\n298| \n299| \n300| class _SeparabilityCalculator:\n301|     \"\"\"\n302|     Break Out Method Object for _separable.\n303| \n304|     Bug-preserving: same decision order, same recursion order, same operator semantics.\n305|     \"\"\"\n306| \n307|     def __init__(self, operators=None):\n308|         # Parameterize dependency (optional seam). Default preserves old mapping.\n309|         self._operators = _operators if operators is None else operators\n310| \n311|     def run(self, transform):\n312|         # Skeletonize Methods: keep the same control flow order as before.\n313|         transform_matrix = self._try_custom(transform)\n314|         if transform_matrix is not NotImplemented:\n315|             return transform_matrix\n316| \n317|         if isinstance(transform, CompoundModel):\n318|             return self._calc_compound(transform)\n319| \n320|         if isinstance(transform, Model):\n321|             return self._calc_leaf(transform)\n322| \n323|     def _try_custom(self, transform):\n324|         # Extract and Override Call seam: go through hook, but preserve fallback safely.\n325|         hook = getattr(transform, \"_separability_matrix_hook\", None)\n326|         if hook is not None:\n327|             return hook()\n328|         # Fallback for safety (should behave same if hook not present)\n329|         return transform._calculate_separability_matrix()\n330| \n331|     def _calc_compound(self, transform):\n332|         # Preserve recursion order exactly: left first, then right.\n333|         sepleft = self.run(transform.left)\n334|         sepright = self.run(transform.right)\n335|         return self._apply_operator(transform.op, sepleft, sepright)\n336| \n337|     def _calc_leaf(self, transform):\n338|         return _coord_matrix(transform, \"left\", transform.n_outputs)\n339| \n340|     def _apply_operator(self, op, left, right):\n341|         # Introduce seam for operator dispatch.\n342|         return self._operators[op](left, right)\n343| \n344| \n345| # Maps modeling operators to a function computing and represents the\n346| # relationship of axes as an array of 0-es and 1-s\n347| _operators = {'&': _cstack, '|': _cdot, '+': _arith_oper, '-': _arith_oper,\n... Code Truncated ...\n\n[start of astropy/modeling/utils.py]\n1| # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2| \n3| \"\"\"\n4| This module provides utility functions for the models package.\n5| \"\"\"\n6| # pylint: disable=invalid-name\n7| from collections import UserDict\n8| from collections.abc import MutableMapping\n9| from inspect import signature\n10| \n11| import numpy as np\n12| import warnings\n13| \n14| from astropy import units as u\n15| from astropy.utils.decorators import deprecated\n16| \n17| __doctest_skip__ = ['AliasDict']\n18| __all__ = ['AliasDict', 'poly_map_domain', 'comb', 'ellipse_extent']\n19| \n20| \n21| deprecation_msg = \"\"\"\n22| AliasDict is deprecated because it no longer serves a function anywhere\n23| inside astropy.\n24| \"\"\"\n25| \n26| \n27| @deprecated('5.0', deprecation_msg)\n28| class AliasDict(MutableMapping):\n29|     \"\"\"\n30|     Creates a `dict` like object that wraps an existing `dict` or other\n31|     `MutableMapping`, along with a `dict` of *key aliases* that translate\n32|     between specific keys in this dict to different keys in the underlying\n33|     dict.\n34| \n35|     In other words, keys that do not have an associated alias are accessed and\n36|     stored like a normal `dict`.  However, a key that has an alias is accessed\n37|     and stored to the \"parent\" dict via the alias.\n38| \n39|     Parameters\n40|     ----------\n41|     parent : dict-like\n42|         The parent `dict` that aliased keys and accessed from and stored to.\n43| \n44|     aliases : dict-like\n45|         Maps keys in this dict to their associated keys in the parent dict.\n46| \n47|     Examples\n48|     --------\n49| \n50|     >>> parent = {'a': 1, 'b': 2, 'c': 3}\n51|     >>> aliases = {'foo': 'a', 'bar': 'c'}\n52|     >>> alias_dict = AliasDict(parent, aliases)\n53|     >>> alias_dict['foo']\n54|     1\n55|     >>> alias_dict['bar']\n56|     3\n57| \n58|     Keys in the original parent dict are not visible if they were not\n59|     aliased:\n60| \n61|     >>> alias_dict['b']\n62|     Traceback (most recent call last):\n63|     ...\n64|     KeyError: 'b'\n65| \n66|     Likewise, updates to aliased keys are reflected back in the parent dict:\n67| \n68|     >>> alias_dict['foo'] = 42\n69|     >>> alias_dict['foo']\n70|     42\n71|     >>> parent['a']\n72|     42\n73| \n74|     However, updates/insertions to keys that are *not* aliased are not\n75|     reflected in the parent dict:\n76| \n77|     >>> alias_dict['qux'] = 99\n78|     >>> alias_dict['qux']\n79|     99\n80|     >>> 'qux' in parent\n81|     False\n82| \n83|     In particular, updates on the `AliasDict` to a key that is equal to\n84|     one of the aliased keys in the parent dict does *not* update the parent\n85|     dict.  For example, ``alias_dict`` aliases ``'foo'`` to ``'a'``.  But\n86|     assigning to a key ``'a'`` on the `AliasDict` does not impact the\n87|     parent:\n88| \n89|     >>> alias_dict['a'] = 'nope'\n90|     >>> alias_dict['a']\n91|     'nope'\n92|     >>> parent['a']\n93|     42\n94|     \"\"\"\n95| \n96|     _store_type = dict\n97|     \"\"\"\n98|     Subclasses may override this to use other mapping types as the underlying\n99|     storage, for example an `OrderedDict`.  However, even in this case\n100|     additional work may be needed to get things like the ordering right.\n101|     \"\"\"\n102| \n103|     def __init__(self, parent, aliases):\n104|         self._parent = parent\n105|         self._store = self._store_type()\n106|         self._aliases = dict(aliases)\n107| \n108|     def __getitem__(self, key):\n109|         if key in self._aliases:\n110|             try:\n111|                 return self._parent[self._aliases[key]]\n112|             except KeyError:\n113|                 raise KeyError(key)\n114| \n115|         return self._store[key]\n116| \n117|     def __setitem__(self, key, value):\n118|         if key in self._aliases:\n119|             self._parent[self._aliases[key]] = value\n120|         else:\n121|             self._store[key] = value\n122| \n123|     def __delitem__(self, key):\n124|         if key in self._aliases:\n125|             try:\n126|                 del self._parent[self._aliases[key]]\n127|             except KeyError:\n128|                 raise KeyError(key)\n129|         else:\n130|             del self._store[key]\n131| \n132|     def __iter__(self):\n133|         \"\"\"\n134|         First iterates over keys from the parent dict (if the aliased keys are\n135|         present in the parent), followed by any keys in the local store.\n136|         \"\"\"\n137| \n138|         for key, alias in self._aliases.items():\n139|             if alias in self._parent:\n140|                 yield key\n141| \n142|         for key in self._store:\n143|             yield key\n144| \n145|     def __len__(self):\n146|         return len(list(iter(self)))\n147| \n148|     def __repr__(self):\n149|         # repr() just like any other dict--this should look transparent\n150|         store_copy = self._store_type()\n151|         for key, alias in self._aliases.items():\n152|             if alias in self._parent:\n153|                 store_copy[key] = self._parent[alias]\n154| \n155|         store_copy.update(self._store)\n156| \n157|         return repr(store_copy)\n158| \n159| \n160| def make_binary_operator_eval(oper, f, g):\n161|     \"\"\"\n162|     Given a binary operator (as a callable of two arguments) ``oper`` and\n163|     two callables ``f`` and ``g`` which accept the same arguments,\n164|     returns a *new* function that takes the same arguments as ``f`` and ``g``,\n165|     but passes the outputs of ``f`` and ``g`` in the given ``oper``.\n166| \n167|     ``f`` and ``g`` are assumed to return tuples (which may be 1-tuples).  The\n168|     given operator is applied element-wise to tuple outputs).\n169| \n170|     Example\n171|     -------\n172| \n173|     >>> from operator import add\n174|     >>> def prod(x, y):\n175|     ...     return (x * y,)\n176|     ...\n177|     >>> sum_of_prod = make_binary_operator_eval(add, prod, prod)\n178|     >>> sum_of_prod(3, 5)\n179|     (30,)\n180|     \"\"\"\n181| \n182|     return lambda inputs, params: \\\n183|             tuple(oper(x, y) for x, y in zip(f(inputs, params),\n184|                                              g(inputs, params)))\n185| \n186| \n187| def poly_map_domain(oldx, domain, window):\n188|     \"\"\"\n189|     Map domain into window by shifting and scaling.\n190| \n191|     Parameters\n192|     ----------\n193|     oldx : array\n194|           original coordinates\n195|     domain : list or tuple of length 2\n196|           function domain\n197|     window : list or tuple of length 2\n198|           range into which to map the domain\n199|     \"\"\"\n200|     domain = np.array(domain, dtype=np.float64)\n201|     window = np.array(window, dtype=np.float64)\n202|     if domain.shape != (2,) or window.shape != (2,):\n203|         raise ValueError('Expected \"domain\" and \"window\" to be a tuple of size 2.')\n204|     scl = (window[1] - window[0]) / (domain[1] - domain[0])\n205|     off = (window[0] * domain[1] - window[1] * domain[0]) / (domain[1] - domain[0])\n206|     return off + scl * oldx\n207| \n208| \n209| def _validate_domain_window(value):\n210|     if value is not None:\n211|         if np.asanyarray(value).shape != (2, ):\n212|             raise ValueError('domain and window should be tuples of size 2.')\n213|         return tuple(value)\n214|     return value\n215| \n216| \n217| def comb(N, k):\n218|     \"\"\"\n219|     The number of combinations of N things taken k at a time.\n220| \n221|     Parameters\n222|     ----------\n223|     N : int, array\n224|         Number of things.\n225|     k : int, array\n226|         Number of elements taken.\n227| \n228|     \"\"\"\n229|     if (k > N) or (N < 0) or (k < 0):\n230|         return 0\n231|     val = 1\n232|     for j in range(min(k, N - k)):\n233|         val = (val * (N - j)) / (j + 1)\n234|     return val\n235| \n236| \n237| def array_repr_oneline(array):\n238|     \"\"\"\n239|     Represents a multi-dimensional Numpy array flattened onto a single line.\n240|     \"\"\"\n241|     r = np.array2string(array, separator=', ', suppress_small=True)\n242|     return ' '.join(l.strip() for l in r.splitlines())\n243| \n244| \n245| def combine_labels(left, right):\n246|     \"\"\"\n247|     For use with the join operator &: Combine left input/output labels with\n248|     right input/output labels.\n249| \n250|     If none of the labels conflict then this just returns a sum of tuples.\n251|     However if *any* of the labels conflict, this appends '0' to the left-hand\n252|     labels and '1' to the right-hand labels so there is no ambiguity).\n253|     \"\"\"\n254| \n255|     if set(left).intersection(right):\n256|         left = tuple(l + '0' for l in left)\n257|         right = tuple(r + '1' for r in right)\n258| \n259|     return left + right\n260| \n261| \n262| def ellipse_extent(a, b, theta):\n263|     \"\"\"\n264|     Calculates the extent of a box encapsulating a rotated 2D ellipse.\n265| \n266|     Parameters\n267|     ----------\n268|     a : float or `~astropy.units.Quantity`\n269|         Major axis.\n270|     b : float or `~astropy.units.Quantity`\n271|         Minor axis.\n272|     theta : float or `~astropy.units.Quantity` ['angle']\n273|         Rotation angle. If given as a floating-point value, it is assumed to be\n274|         in radians.\n275| \n276|     Returns\n277|     -------\n278|     offsets : tuple\n279|         The absolute value of the offset distances from the ellipse center that\n280|         define its bounding box region, ``(dx, dy)``.\n281| \n282|     Examples\n283|     --------\n284|     .. plot::\n285|         :include-source:\n286| \n287|         import numpy as np\n288|         import matplotlib.pyplot as plt\n289|         from astropy.modeling.models import Ellipse2D\n290|         from astropy.modeling.utils import ellipse_extent, render_model\n291| \n292|         amplitude = 1\n293|         x0 = 50\n294|         y0 = 50\n295|         a = 30\n296|         b = 10\n297|         theta = np.pi/4\n298| \n299|         model = Ellipse2D(amplitude, x0, y0, a, b, theta)\n300| \n301|         dx, dy = ellipse_extent(a, b, theta)\n302| \n303|         limits = [x0 - dx, x0 + dx, y0 - dy, y0 + dy]\n304| \n305|         model.bounding_box = limits\n306| \n307|         image = render_model(model)\n308| \n309|         plt.imshow(image, cmap='binary', interpolation='nearest', alpha=.5,\n310|                   extent = limits)\n311|         plt.show()\n312|     \"\"\"\n313| \n314|     t = np.arctan2(-b * np.tan(theta), a)\n315|     dx = a * np.cos(t) * np.cos(theta) - b * np.sin(t) * np.sin(theta)\n316| \n317|     t = np.arctan2(b, a * np.tan(theta))\n318|     dy = b * np.sin(t) * np.cos(theta) + a * np.cos(t) * np.sin(theta)\n319| \n320|     if isinstance(dx, u.Quantity) or isinstance(dy, u.Quantity):\n321|         return np.abs(u.Quantity([dx, dy]))\n322|     return np.abs([dx, dy])\n323| \n324| \n325| def get_inputs_and_params(func):\n326|     \"\"\"\n327|     Given a callable, determine the input variables and the\n328|     parameters.\n329| \n330|     Parameters\n331|     ----------\n332|     func : callable\n333| \n334|     Returns\n335|     -------\n336|     inputs, params : tuple\n337|         Each entry is a list of inspect.Parameter objects\n338|     \"\"\"\n339|     sig = signature(func)\n340| \n341|     inputs = []\n342|     params = []\n343|     for param in sig.parameters.values():\n344|         if param.kind in (param.VAR_POSITIONAL, param.VAR_KEYWORD):\n345|             raise ValueError(\"Signature must not have *args or **kwargs\")\n346|         if param.default == param.empty:\n347|             inputs.append(param)\n348|         else:\n349|             params.append(param)\n350| \n351|     return inputs, params\n352| \n353| \n354| def _combine_equivalency_dict(keys, eq1=None, eq2=None):\n355|     # Given two dictionaries that give equivalencies for a set of keys, for\n356|     # example input value names, return a dictionary that includes all the\n357|     # equivalencies\n358|     eq = {}\n359|     for key in keys:\n360|         eq[key] = []\n361|         if eq1 is not None and key in eq1:\n362|             eq[key].extend(eq1[key])\n363|         if eq2 is not None and key in eq2:\n364|             eq[key].extend(eq2[key])\n365|     return eq\n366| \n367| \n368| def _to_radian(value):\n369|     \"\"\" Convert ``value`` to radian. \"\"\"\n370|     if isinstance(value, u.Quantity):\n371|         return value.to(u.rad)\n372|     return np.deg2rad(value)\n373| \n374| \n375| def _to_orig_unit(value, raw_unit=None, orig_unit=None):\n376|     \"\"\" Convert value with ``raw_unit`` to ``orig_unit``. \"\"\"\n377|     if raw_unit is not None:\n378|         return (value * raw_unit).to(orig_unit)\n379|     return np.rad2deg(value)\n380| \n381| \n382| class _ConstraintsDict(UserDict):\n383|     \"\"\"\n384|     Wrapper around UserDict to allow updating the constraints\n385|     on a Parameter when the dictionary is updated.\n386|     \"\"\"\n387|     def __init__(self, model, constraint_type):\n388|         self._model = model\n389|         self.constraint_type = constraint_type\n390|         c = {}\n391|         for name in model.param_names:\n392|             param = getattr(model, name)\n393|             c[name] = getattr(param, constraint_type)\n394|         super().__init__(c)\n395| \n396|     def __setitem__(self, key, val):\n397|         super().__setitem__(key, val)\n398|         param = getattr(self._model, key)\n399|         setattr(param, self.constraint_type, val)\n400| \n401| \n402| class _SpecialOperatorsDict(UserDict):\n403|     \"\"\"\n404|     Wrapper around UserDict to allow for better tracking of the Special\n405|     Operators for CompoundModels. This dictionary is structured so that\n406|     one cannot inadvertently overwrite an existing special operator.\n407| \n408|     Parameters\n409|     ----------\n410|     unique_id: int\n411|         the last used unique_id for a SPECIAL OPERATOR\n412|     special_operators: dict\n413|         a dictionary containing the special_operators\n414| \n415|     Notes\n416|     -----\n417|     Direct setting of operators (`dict[key] = value`) into the\n418|     dictionary has been deprecated in favor of the `.add(name, value)`\n419|     method, so that unique dictionary keys can be generated and tracked\n420|     consistently.\n421|     \"\"\"\n422| \n423|     def __init__(self, unique_id=0, special_operators={}):\n424|         super().__init__(special_operators)\n425|         self._unique_id = unique_id\n426| \n427|     def _set_value(self, key, val):\n428|         if key in self:\n429|             raise ValueError(f'Special operator \"{key}\" already exists')\n430|         else:\n431|             super().__setitem__(key, val)\n432| \n433|     def __setitem__(self, key, val):\n434|         self._set_value(key, val)\n435|         warnings.warn(DeprecationWarning(\n436|             \"\"\"\n437|             Special operator dictionary assignment has been deprecated.\n438|             Please use `.add` instead, so that you can capture a unique\n439|             key for your operator.\n440|             \"\"\"\n441|         ))\n442| \n443|     def _get_unique_id(self):\n444|         self._unique_id += 1\n445| \n446|         return self._unique_id\n447| \n448|     def add(self, operator_name, operator):\n449|         \"\"\"\n450|         Adds a special operator to the dictionary, and then returns the\n451|         unique key that the operator is stored under for later reference.\n452| \n453|         Parameters\n454|         ----------\n455|         operator_name: str\n456|             the name for the operator\n457|         operator: function\n458|             the actual operator function which will be used\n459| \n460|         Returns\n461|         -------\n462|         the unique operator key for the dictionary\n463|             `(operator_name, unique_id)`\n464|         \"\"\"\n465|         key = (operator_name, self._get_unique_id())\n466| \n467|         self._set_value(key, operator)\n468| \n469|         return key\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "astropy/modeling/__init__.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/modeling/core.py",
      "suspect_lines": [
        205,
        208
      ]
    },
    {
      "filename": "astropy/modeling/models.py",
      "suspect_lines": []
    },
    {
      "filename": "astropy/modeling/separable.py",
      "suspect_lines": [
        61,
        62,
        96,
        100,
        101,
        102,
        195,
        210,
        213,
        215,
        247
      ]
    },
    {
      "filename": "astropy/modeling/utils.py",
      "suspect_lines": []
    }
  ]
}