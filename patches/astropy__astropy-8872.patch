diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py
index ded609cbe9..bbe2e95e0c 100644
--- a/astropy/units/quantity.py
+++ b/astropy/units/quantity.py
@@ -40,6 +40,63 @@ _UNIT_NOT_INITIALISED = "(Unit not initialised)"
 _UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}
 
 
+class _QuantityUfuncRunner:
+    """
+    Helper for Quantity.__array_ufunc__.
+
+    This class exists to:
+      - isolate the ufunc execution pipeline
+      - introduce seams (override points) without changing decisions/paths
+      - make behavior more observable in tests
+
+    IMPORTANT: Do not change the ordering/conditions in execute();
+    it must mirror the original Quantity.__array_ufunc__ logic.
+    """
+    def __init__(self, q, function, method, inputs, kwargs):
+        self.q = q
+        self.function = function
+        self.method = method
+        self.inputs = inputs
+        self.kwargs = kwargs
+
+        self.converters = None
+        self.unit = None
+        self.out = None
+
+    def execute(self):
+        # 1) Determine converters + result unit (same as original).
+        self.converters, self.unit = self.q._get_converters_and_unit(
+            self.function, self.method, *self.inputs
+        )
+
+        # 2) Normalize out + set kwargs['out'] to array views (same as original).
+        self.out = self.kwargs.get('out', None)
+        if self.out is not None:
+            out_for_check = self.out
+            if self.function.nout == 1:
+                out_for_check = out_for_check[0]
+
+            out_array = self.q._check_output_ufunc(
+                out_for_check, self.unit, self.inputs, function=self.function
+            )
+            self.kwargs['out'] = (out_array,) if self.function.nout == 1 else out_array
+
+        # 3) Convert inputs to plain arrays as needed (same as original loop).
+        arrays = []
+        for input_, converter in zip(self.inputs, self.converters):
+            input_ = getattr(input_, 'value', input_)
+            arrays.append(converter(input_) if converter else input_)
+
+        # 4) Refactor ndarray/parent __array_ufunc__.
+        result = self.q._super_array_ufunc(self.function, self.method, *arrays, **self.kwargs)
+
+        # 5) Keep the existing short-circuit structure.
+        if self.unit is None or result is None or result is NotImplemented:
+            return result
+
+        return self.q._result_as_quantity(result, self.unit, self.out)
+
+
 class Conf(_config.ConfigNamespace):
     """
     Configuration parameters for Quantity
@@ -420,6 +477,16 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
                                   'numpy >=1.13.  Please raise an issue on '
                                   'https://github.com/astropy/astropy')
 
+    # ---- seams for ufunc execution (override in tests/subclasses if needed) ----
+    def _get_converters_and_unit(self, function, method, *inputs):
+        return converters_and_unit(function, method, *inputs)
+
+    def _check_output_ufunc(self, out, unit, inputs, function):
+        return check_output(out, unit, inputs, function=function)
+
+    def _super_array_ufunc(self, function, method, *arrays, **kwargs):
+        return super().__array_ufunc__(function, method, *arrays, **kwargs)
+
     def __array_ufunc__(self, function, method, *inputs, **kwargs):
         """Wrap numpy ufuncs, taking care of units.
 
@@ -443,36 +510,8 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
         # input to that expected (e.g., radian for np.sin), or to get
         # consistent units between two inputs (e.g., in np.add) --
         # and the unit of the result (or tuple of units for nout > 1).
-        converters, unit = converters_and_unit(function, method, *inputs)
-
-        out = kwargs.get('out', None)
-        # Avoid loop back by turning any Quantity output into array views.
-        if out is not None:
-            # If pre-allocated output is used, check it is suitable.
-            # This also returns array view, to ensure we don't loop back.
-            if function.nout == 1:
-                out = out[0]
-            out_array = check_output(out, unit, inputs, function=function)
-            # Ensure output argument remains a tuple.
-            kwargs['out'] = (out_array,) if function.nout == 1 else out_array
-
-        # Same for inputs, but here also convert if necessary.
-        arrays = []
-        for input_, converter in zip(inputs, converters):
-            input_ = getattr(input_, 'value', input_)
-            arrays.append(converter(input_) if converter else input_)
-
-        # Call our superclass's __array_ufunc__
-        result = super().__array_ufunc__(function, method, *arrays, **kwargs)
-        # If unit is None, a plain array is expected (e.g., comparisons), which
-        # means we're done.
-        # We're also done if the result was None (for method 'at') or
-        # NotImplemented, which can happen if other inputs/outputs override
-        # __array_ufunc__; hopefully, they can then deal with us.
-        if unit is None or result is None or result is NotImplemented:
-            return result
-
-        return self._result_as_quantity(result, unit, out)
+        runner = _QuantityUfuncRunner(self, function, method, inputs, kwargs)
+        return runner.execute()
 
     def _result_as_quantity(self, result, unit, out):
         """Turn result into a quantity with the given unit.
@@ -1054,12 +1093,18 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
         return out
 
     def __setitem__(self, i, value):
+        # update indices in info if the info property has been accessed
+        # (in which case 'info' in self.__dict__ is True; this is guaranteed
+        # to be the case if we're part of a table).
+        self._adjust_info_indices_for_setitem(i, value)
+        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))
+
+    def _adjust_info_indices_for_setitem(self, i, value):
         # update indices in info if the info property has been accessed
         # (in which case 'info' in self.__dict__ is True; this is guaranteed
         # to be the case if we're part of a table).
         if not self.isscalar and 'info' in self.__dict__:
             self.info.adjust_indices(i, value, len(self))
-        self.view(np.ndarray).__setitem__(i, self._to_own_unit(value))
 
     # __contains__ is OK
 
@@ -1345,35 +1390,40 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
                                   "list of values with q.value.list()")
 
     def _to_own_unit(self, value, check_precision=True):
+        _value = self._convert_value_to_own_unit(value)
+        if check_precision:
+            _value = self._enforce_no_precision_loss(_value)
+        return _value
+
+    def _convert_value_to_own_unit(self, value):
+        """
+        Convert a value to self.unit, preserving legacy fallbacks and exceptions.
+
+        IMPORTANT: mirrors the original try/except structure in _to_own_unit.
+        """
         try:
-            _value = value.to_value(self.unit)
+            return value.to_value(self.unit)
         except AttributeError:
-            # We're not a Quantity, so let's try a more general conversion.
-            # Plain arrays will be converted to dimensionless in the process,
-            # but anything with a unit attribute will use that.
             as_quantity = Quantity(value)
             try:
-                _value = as_quantity.to_value(self.unit)
+                return as_quantity.to_value(self.unit)
             except UnitsError:
-                # last chance: if this was not something with a unit
-                # and is all 0, inf, or nan, we treat it as arbitrary unit.
                 if (not hasattr(value, 'unit') and
                         can_have_arbitrary_unit(as_quantity.value)):
-                    _value = as_quantity.value
-                else:
-                    raise
+                    return as_quantity.value
+                raise
 
-        if check_precision:
-            # If, e.g., we are casting double to float, we want to fail if
-            # precision is lost, but let things pass if it works.
-            _value = np.array(_value, copy=False)
-            if not np.can_cast(_value.dtype, self.dtype):
-                self_dtype_array = np.array(_value, self.dtype)
-                if not np.all(np.logical_or(self_dtype_array == _value,
-                                            np.isnan(_value))):
-                    raise TypeError("cannot convert value type to array type "
-                                    "without precision loss")
-        return _value
+    def _enforce_no_precision_loss(self, value):
+        """
+        Apply the original precision-loss checks from _to_own_unit, unchanged.
+        """
+        value = np.array(value, copy=False)
+        if not np.can_cast(value.dtype, self.dtype):
+            self_dtype_array = np.array(value, self.dtype)
+            if not np.all(np.logical_or(self_dtype_array == value, np.isnan(value))):
+                raise TypeError("cannot convert value type to array type "
+                                "without precision loss")
+        return value
 
     def itemset(self, *args):
         if len(args) == 0:
diff --git a/astropy/units/quantity_helper/converters.py b/astropy/units/quantity_helper/converters.py
index cfcd744589..f1c784c146 100644
--- a/astropy/units/quantity_helper/converters.py
+++ b/astropy/units/quantity_helper/converters.py
@@ -10,6 +10,9 @@ from astropy.units.core import (UnitsError, UnitConversionError, UnitTypeError,
 __all__ = ['can_have_arbitrary_unit', 'converters_and_unit',
            'check_output', 'UFUNC_HELPERS', 'UNSUPPORTED_UFUNCS']
 
+def _get_unit_converter(unit, to_unit):
+    """Seam for unit conversion lookup (override/monkeypatch in tests)."""
+    return unit._get_converter(to_unit)
 
 class UfuncHelpers(dict):
     """Registry of unit conversion functions to help ufunc evaluation.
@@ -122,7 +125,7 @@ def can_have_arbitrary_unit(value):
     return np.all(np.logical_or(np.equal(value, 0.), ~np.isfinite(value)))
 
 
-def converters_and_unit(function, method, *args):
+def converters_and_unit(function, method, *args, _unit_converter=_get_unit_converter):
     """Determine the required converters and the unit of the ufunc result.
 
     Converters are functions required to convert to a ufunc's expected unit,
@@ -214,8 +217,9 @@ def converters_and_unit(function, method, *args):
                     # Changing the unit does not work for, e.g., array-shaped
                     # power, but this is OK if we're (scaled) dimensionless.
                     try:
-                        converters[0] = units[0]._get_converter(
-                            dimensionless_unscaled)
+                        converters[0] = _unit_converter(
+                            units[0], dimensionless_unscaled
+                        )
                     except UnitConversionError:
                         raise exc
                     else:
diff --git a/astropy/units/quantity_helper/helpers.py b/astropy/units/quantity_helper/helpers.py
index d08c69352f..60dc2f131a 100644
--- a/astropy/units/quantity_helper/helpers.py
+++ b/astropy/units/quantity_helper/helpers.py
@@ -42,7 +42,18 @@ def get_converter(from_unit, to_unit):
         return lambda val: scale * val
 
 
-def get_converters_and_unit(f, unit1, unit2):
+def _get_unit_converter(from_unit, to_unit):
+    """Seam wrapper for get_converter (substitute in tests if needed)."""
+    return get_converter(from_unit, to_unit)
+
+
+def _handle_dimensionless_units_error(converters, changeable, unit2):
+    # special case: would be OK if unitless number is zero, inf, nan
+    converters[1-changeable] = False
+    return converters, unit2
+
+
+def get_converters_and_unit(f, unit1, unit2, _unit_converter=_get_unit_converter):
     converters = [None, None]
     # By default, we try adjusting unit2 to unit1, so that the result will
     # be unit1 as well. But if there is no second unit, we have to try
@@ -64,17 +75,15 @@ def get_converters_and_unit(f, unit1, unit2):
     # Try to get a converter from unit2 to unit1.
     if unit1 is None:
         try:
-            converters[changeable] = get_converter(unit2,
-                                                   dimensionless_unscaled)
+            converters[changeable] = _unit_converter(unit2, dimensionless_unscaled)
+
         except UnitsError:
-            # special case: would be OK if unitless number is zero, inf, nan
-            converters[1-changeable] = False
-            return converters, unit2
+            return _handle_dimensionless_units_error(converters, changeable, unit2)
         else:
             return converters, dimensionless_unscaled
     else:
         try:
-            converters[changeable] = get_converter(unit2, unit1)
+            converters[changeable] = _unit_converter(unit2, unit1)
         except UnitsError:
             raise UnitConversionError(
                 "Can only apply '{0}' function to quantities "
