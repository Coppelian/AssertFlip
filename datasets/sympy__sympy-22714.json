{
  "instance_id": "sympy__sympy-22714",
  "problem_statement": "simpify gives `Imaginary coordinates are not permitted.` with evaluate(False)\n## Issue\r\n`with evaluate(False)` crashes unexpectedly with `Point2D`\r\n\r\n## Code\r\n```python\r\nimport sympy as sp\r\nwith sp.evaluate(False):\r\n  sp.S('Point2D(Integer(1),Integer(2))')\r\n```\r\n\r\n## Error\r\n```\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/home/avinash/.local/lib/python3.8/site-packages/sympy/core/sympify.py\", line 472, in sympify\r\n    expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\r\n  File \"/home/avinash/.local/lib/python3.8/site-packages/sympy/parsing/sympy_parser.py\", line 1026, in parse_expr\r\n    raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\r\n  File \"/home/avinash/.local/lib/python3.8/site-packages/sympy/parsing/sympy_parser.py\", line 1017, in parse_expr\r\n    rv = eval_expr(code, local_dict, global_dict)\r\n  File \"/home/avinash/.local/lib/python3.8/site-packages/sympy/parsing/sympy_parser.py\", line 911, in eval_expr\r\n    expr = eval(\r\n  File \"<string>\", line 1, in <module>\r\n  File \"/home/avinash/.local/lib/python3.8/site-packages/sympy/geometry/point.py\", line 912, in __new__\r\n    args = Point(*args, **kwargs)\r\n  File \"/home/avinash/.local/lib/python3.8/site-packages/sympy/geometry/point.py\", line 153, in __new__\r\n    raise ValueError('Imaginary coordinates are not permitted.')\r\nValueError: Imaginary coordinates are not permitted.\r\n```\r\n\r\nHowever, it works without `with evaluate(False)`. Both of following commands work\r\n```python\r\nsp.S('Point2D(Integer(1),Integer(2))')\r\nsp.S('Point2D(Integer(1),Integer(2))', evaluate=False)\r\n```\n",
  "localized_code": "[start of sympy/geometry/point.py]\n1: \"\"\"Geometrical Points.\n2: \n3: Contains\n4: ========\n5: Point\n6: Point2D\n7: Point3D\n8: \n9: When methods of Point require 1 or more points as arguments, they\n10: can be passed as a sequence of coordinates or Points:\n11: \n12: >>> from sympy.geometry.point import Point\n13: >>> Point(1, 1).is_collinear((2, 2), (3, 4))\n14: False\n15: >>> Point(1, 1).is_collinear(Point(2, 2), Point(3, 4))\n16: False\n17: \n18: \"\"\"\n19: \n20: import warnings\n21: \n22: from sympy.core import S, sympify, Expr\n23: from sympy.core.add import Add\n24: from sympy.core.containers import Tuple\n25: from sympy.core.numbers import Float\n26: from sympy.core.parameters import global_parameters\n27: from sympy.simplify import nsimplify, simplify\n28: from sympy.geometry.exceptions import GeometryError\n29: from sympy.functions.elementary.miscellaneous import sqrt\n30: from sympy.functions.elementary.complexes import im\n31: from sympy.functions.elementary.trigonometric import cos, sin\n32: from sympy.matrices import Matrix\n33: from sympy.matrices.expressions import Transpose\n34: from sympy.utilities.iterables import uniq, is_sequence\n35: from sympy.utilities.misc import filldedent, func_name, Undecidable\n36: \n37: from .entity import GeometryEntity\n38: \n39: from mpmath.libmp.libmpf import prec_to_dps\n40: \n41: \n42: class Point(GeometryEntity):\n43:     \"\"\"A point in a n-dimensional Euclidean space.\n44: \n45:     Parameters\n46:     ==========\n47: \n48:     coords : sequence of n-coordinate values. In the special\n49:         case where n=2 or 3, a Point2D or Point3D will be created\n50:         as appropriate.\n51:     evaluate : if `True` (default), all floats are turn into\n52:         exact types.\n53:     dim : number of coordinates the point should have.  If coordinates\n54:         are unspecified, they are padded with zeros.\n55:     on_morph : indicates what should happen when the number of\n56:         coordinates of a point need to be changed by adding or\n57:         removing zeros.  Possible values are `'warn'`, `'error'`, or\n58:         `ignore` (default).  No warning or error is given when `*args`\n59:         is empty and `dim` is given. An error is always raised when\n60:         trying to remove nonzero coordinates.\n61: \n62: \n63:     Attributes\n64:     ==========\n65: \n66:     length\n67:     origin: A `Point` representing the origin of the\n68:         appropriately-dimensioned space.\n69: \n70:     Raises\n71:     ======\n72: \n73:     TypeError : When instantiating with anything but a Point or sequence\n74:     ValueError : when instantiating with a sequence with length < 2 or\n75:         when trying to reduce dimensions if keyword `on_morph='error'` is\n76:         set.\n77: \n78:     See Also\n79:     ========\n80: \n81:     sympy.geometry.line.Segment : Connects two Points\n82: \n83:     Examples\n84:     ========\n85: \n86:     >>> from sympy.geometry import Point\n87:     >>> from sympy.abc import x\n88:     >>> Point(1, 2, 3)\n89:     Point3D(1, 2, 3)\n90:     >>> Point([1, 2])\n91:     Point2D(1, 2)\n92:     >>> Point(0, x)\n93:     Point2D(0, x)\n94:     >>> Point(dim=4)\n95:     Point(0, 0, 0, 0)\n96: \n97:     Floats are automatically converted to Rational unless the\n98:     evaluate flag is False:\n99: \n100:     >>> Point(0.5, 0.25)\n101:     Point2D(1/2, 1/4)\n102:     >>> Point(0.5, 0.25, evaluate=False)\n103:     Point2D(0.5, 0.25)\n104: \n105:     \"\"\"\n106: \n107:     is_Point = True\n108: \n109:     def __new__(cls, *args, **kwargs):\n110:         evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n111:         on_morph = kwargs.get('on_morph', 'ignore')\n112: \n113:         # unpack into coords\n114:         coords = args[0] if len(args) == 1 else args\n115: \n116:         # check args and handle quickly handle Point instances\n117:         if isinstance(coords, Point):\n118:             # even if we're mutating the dimension of a point, we\n119:             # don't reevaluate its coordinates\n120:             evaluate = False\n121:             if len(coords) == kwargs.get('dim', len(coords)):\n122:                 return coords\n123: \n124:         if not is_sequence(coords):\n125:             raise TypeError(filldedent('''\n126:                 Expecting sequence of coordinates, not `{}`'''\n127:                                        .format(func_name(coords))))\n128:         # A point where only `dim` is specified is initialized\n129:         # to zeros.\n130:         if len(coords) == 0 and kwargs.get('dim', None):\n131:             coords = (S.Zero,)*kwargs.get('dim')\n132: \n133:         coords = Tuple(*coords)\n134:         dim = kwargs.get('dim', len(coords))\n135: \n136:         if len(coords) < 2:\n137:             raise ValueError(filldedent('''\n138:                 Point requires 2 or more coordinates or\n139:                 keyword `dim` > 1.'''))\n140:         if len(coords) != dim:\n141:             message = (\"Dimension of {} needs to be changed \"\n142:                        \"from {} to {}.\").format(coords, len(coords), dim)\n143:             if on_morph == 'ignore':\n144:                 pass\n145:             elif on_morph == \"error\":\n146:                 raise ValueError(message)\n147:             elif on_morph == 'warn':\n148:                 warnings.warn(message)\n149:             else:\n150:                 raise ValueError(filldedent('''\n151:                         on_morph value should be 'error',\n152:                         'warn' or 'ignore'.'''))\n153:         if any(coords[dim:]):\n154:             raise ValueError('Nonzero coordinates cannot be removed.')\n155:         if any(a.is_number and im(a) for a in coords):\n156:             raise ValueError('Imaginary coordinates are not permitted.')\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/geometry/point.py",
      "suspect_lines": [
        155
      ]
    }
  ]
}