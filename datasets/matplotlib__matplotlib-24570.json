{
  "instance_id": "matplotlib__matplotlib-24570",
  "problem_statement": "[Bug]: `align` in `HPacker` is reversed\n### Bug summary\n\nFor the `align` parameter in `HPacker`, the options `top` and `bottom` seems reversed\n\n### Code for reproduction\n\n```python\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.offsetbox import DrawingArea, HPacker, VPacker, AnchoredOffsetbox, TextArea\r\nfrom matplotlib.patches import Rectangle\r\n\r\nda1 = DrawingArea(10, 20)\r\nrect1 = Rectangle((0, 0), 10, 20)\r\nda1.add_artist(rect1)\r\n\r\nda2 = DrawingArea(10, 30)\r\nrect2 = Rectangle((0, 0), 10, 30)\r\nda2.add_artist(rect2)\r\n\r\nalign = \"bottom\"\r\n\r\npack = HPacker(children=[da1, da2], pad=10, sep=10, align=align)\r\ntitle = TextArea(f\"align='{align}'\")\r\npack = VPacker(children=[title, pack], sep=10, pad=10, align=\"center\")\r\n\r\nbox = AnchoredOffsetbox(child=pack, loc=\"center\")\r\n\r\n_, ax = plt.subplots()\r\nax.add_artist(box)\n```\n\n\n### Actual outcome\n\n![download](https://user-images.githubusercontent.com/23433306/200162888-702626bf-ad47-40e2-8751-7dffe91df85c.png)\r\n\n\n### Expected outcome\n\n![download](https://user-images.githubusercontent.com/23433306/200162908-e0e9dfd5-6f8b-4aac-975e-bb363d809c41.png)\r\n\n\n### Additional information\n\n_No response_\n\n### Operating system\n\n_No response_\n\n### Matplotlib Version\n\n3.6.2\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n_No response_\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\n_No response_\n",
  "localized_code": "[start of lib/matplotlib/offsetbox.py]\n1: r\"\"\"\n2: Container classes for `.Artist`\\s.\n3: \n4: `OffsetBox`\n5:     The base of all container artists defined in this module.\n6: \n7: `AnchoredOffsetbox`, `AnchoredText`\n8:     Anchor and align an arbitrary `.Artist` or a text relative to the parent\n9:     axes or a specific anchor point.\n10: \n11: `DrawingArea`\n12:     A container with fixed width and height. Children have a fixed position\n13:     inside the container and may be clipped.\n14: \n15: `HPacker`, `VPacker`\n16:     Containers for layouting their children vertically or horizontally.\n17: \n18: `PaddedBox`\n19:     A container to add a padding around an `.Artist`.\n20: \n21: `TextArea`\n22:     Contains a single `.Text` instance.\n23: \"\"\"\n24: \n25: import numpy as np\n26: \n27: import matplotlib as mpl\n28: from matplotlib import _api, _docstring\n29: import matplotlib.artist as martist\n30: import matplotlib.path as mpath\n31: import matplotlib.text as mtext\n32: import matplotlib.transforms as mtransforms\n33: from matplotlib.font_manager import FontProperties\n34: from matplotlib.image import BboxImage\n35: from matplotlib.patches import (\n36:     FancyBboxPatch, FancyArrowPatch, bbox_artist as mbbox_artist)\n37: from matplotlib.transforms import Bbox, BboxBase, TransformedBbox\n38: \n39: \n40: DEBUG = False\n41: \n42: \n43: # for debugging use\n44: def bbox_artist(*args, **kwargs):\n45:     if DEBUG:\n46:         mbbox_artist(*args, **kwargs)\n47: \n48: \n49: def _get_packed_offsets(widths, total, sep, mode=\"fixed\"):\n50:     r\"\"\"\n51:     Pack boxes specified by their *widths*.\n52: \n53:     For simplicity of the description, the terminology used here assumes a\n54:     horizontal layout, but the function works equally for a vertical layout.\n55: \n56:     There are three packing *mode*\\s:\n57: \n58:     - 'fixed': The elements are packed tight to the left with a spacing of\n59:       *sep* in between. If *total* is *None* the returned total will be the\n60:       right edge of the last box. A non-*None* total will be passed unchecked\n61:       to the output. In particular this means that right edge of the last\n62:       box may be further to the right than the returned total.\n63: \n64:     - 'expand': Distribute the boxes with equal spacing so that the left edge\n65:       of the first box is at 0, and the right edge of the last box is at\n66:       *total*. The parameter *sep* is ignored in this mode. A total of *None*\n67:       is accepted and considered equal to 1. The total is returned unchanged\n68:       (except for the conversion *None* to 1). If the total is smaller than\n69:       the sum of the widths, the laid out boxes will overlap.\n70: \n71:     - 'equal': If *total* is given, the total space is divided in N equal\n72:       ranges and each box is left-aligned within its subspace.\n73:       Otherwise (*total* is *None*), *sep* must be provided and each box is\n74:       left-aligned in its subspace of width ``(max(widths) + sep)``. The\n75:       total width is then calculated to be ``N * (max(widths) + sep)``.\n76: \n77:     Parameters\n78:     ----------\n79:     widths : list of float\n80:         Widths of boxes to be packed.\n81:     total : float or None\n82:         Intended total length. *None* if not used.\n83:     sep : float\n84:         Spacing between boxes.\n85:     mode : {'fixed', 'expand', 'equal'}\n86:         The packing mode.\n87: \n88:     Returns\n89:     -------\n90:     total : float\n91:         The total width needed to accommodate the laid out boxes.\n92:     offsets : array of float\n93:         The left offsets of the boxes.\n94:     \"\"\"\n95:     _api.check_in_list([\"fixed\", \"expand\", \"equal\"], mode=mode)\n96: \n97:     if mode == \"fixed\":\n98:         offsets_ = np.cumsum([0] + [w + sep for w in widths])\n99:         offsets = offsets_[:-1]\n100:         if total is None:\n101:             total = offsets_[-1] - sep\n102:         return total, offsets\n103: \n104:     elif mode == \"expand\":\n105:         # This is a bit of a hack to avoid a TypeError when *total*\n106:         # is None and used in conjugation with tight layout.\n107:         if total is None:\n108:             total = 1\n109:         if len(widths) > 1:\n110:             sep = (total - sum(widths)) / (len(widths) - 1)\n111:         else:\n112:             sep = 0\n113:         offsets_ = np.cumsum([0] + [w + sep for w in widths])\n114:         offsets = offsets_[:-1]\n115:         return total, offsets\n116: \n117:     elif mode == \"equal\":\n118:         maxh = max(widths)\n119:         if total is None:\n120:             if sep is None:\n121:                 raise ValueError(\"total and sep cannot both be None when \"\n122:                                  \"using layout mode 'equal'\")\n123:             total = (maxh + sep) * len(widths)\n124:         else:\n125:             sep = total / len(widths) - maxh\n126:         offsets = (maxh + sep) * np.arange(len(widths))\n127:         return total, offsets\n128: \n129: \n130: def _get_aligned_offsets(hd_list, height, align=\"baseline\"):\n131:     \"\"\"\n132:     Align boxes each specified by their ``(height, descent)`` pair.\n133: \n134:     For simplicity of the description, the terminology used here assumes a\n135:     horizontal layout (i.e., vertical alignment), but the function works\n136:     equally for a vertical layout.\n137: \n138:     Parameters\n139:     ----------\n140:     hd_list\n141:         List of (height, xdescent) of boxes to be aligned.\n142:     height : float or None\n143:         Intended total height. If None, the maximum of the heights in *hd_list*\n144:         is used.\n145:     align : {'baseline', 'left', 'top', 'right', 'bottom', 'center'}\n146:         The alignment anchor of the boxes.\n147: \n148:     Returns\n149:     -------\n150:     height\n151:         The total height of the packing (if a value was originally passed in,\n152:         it is returned without checking that it is actually large enough).\n153:     descent\n154:         The descent of the packing.\n155:     offsets\n156:         The bottom offsets of the boxes.\n157:     \"\"\"\n158: \n159:     if height is None:\n160:         height = max(h for h, d in hd_list)\n161:     _api.check_in_list(\n162:         [\"baseline\", \"left\", \"top\", \"right\", \"bottom\", \"center\"], align=align)\n163: \n164:     if align == \"baseline\":\n165:         height_descent = max(h - d for h, d in hd_list)\n166:         descent = max(d for h, d in hd_list)\n167:         height = height_descent + descent\n168:         offsets = [0. for h, d in hd_list]\n169:     elif align in [\"left\", \"top\"]:\n170:         descent = 0.\n171:         offsets = [d for h, d in hd_list]\n172:     elif align in [\"right\", \"bottom\"]:\n173:         descent = 0.\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/offsetbox.py",
      "suspect_lines": [
        169,
        172
      ]
    }
  ]
}