{
  "instance_id": "django__django-15957",
  "problem_statement": "Prefetch objects don't work with slices\nDescription\n\t\n​Prefetch() objects does not work with sliced querysets. For example the following code results in AssertionError: Cannot filter a query once a slice has been taken.:\nCategory.objects.prefetch_related(Prefetch(\n\t'post_set',\n\tqueryset=Post.objects.all()[:3],\n\tto_attr='example_posts',\n))\nThis behavior is also mentioned in ​this StackOverflow answer. On the other hand it does not seem to be documented in Django Docs.\nWhy is it needed?\nMy use case seems to be a common one: I want to display a list of categories while displaying couple of example objects from each category next to it. If I'm not mistaken there isn't currently an efficient way of doing this. Prefetching without slicing would prefetch all objects (and there may be thousands of them) instead of the three examples that are needed.\n",
  "localized_code": "[start of django/db/models/fields/related_descriptors.py]\n1: \"\"\"\n2: Accessors for related objects.\n3: \n4: When a field defines a relation between two models, each model class provides\n5: an attribute to access related instances of the other model class (unless the\n6: reverse accessor has been disabled with related_name='+').\n7: \n8: Accessors are implemented as descriptors in order to customize access and\n9: assignment. This module defines the descriptor classes.\n10: \n11: Forward accessors follow foreign keys. Reverse accessors trace them back. For\n12: example, with the following models::\n13: \n14:     class Parent(Model):\n15:         pass\n16: \n17:     class Child(Model):\n18:         parent = ForeignKey(Parent, related_name='children')\n19: \n20:  ``child.parent`` is a forward many-to-one relation. ``parent.children`` is a\n21: reverse many-to-one relation.\n22: \n23: There are three types of relations (many-to-one, one-to-one, and many-to-many)\n24: and two directions (forward and reverse) for a total of six combinations.\n25: \n26: 1. Related instance on the forward side of a many-to-one relation:\n27:    ``ForwardManyToOneDescriptor``.\n28: \n29:    Uniqueness of foreign key values is irrelevant to accessing the related\n30:    instance, making the many-to-one and one-to-one cases identical as far as\n31:    the descriptor is concerned. The constraint is checked upstream (unicity\n32:    validation in forms) or downstream (unique indexes in the database).\n33: \n34: 2. Related instance on the forward side of a one-to-one\n35:    relation: ``ForwardOneToOneDescriptor``.\n36: \n37:    It avoids querying the database when accessing the parent link field in\n38:    a multi-table inheritance scenario.\n39: \n40: 3. Related instance on the reverse side of a one-to-one relation:\n41:    ``ReverseOneToOneDescriptor``.\n42: \n43:    One-to-one relations are asymmetrical, despite the apparent symmetry of the\n44:    name, because they're implemented in the database with a foreign key from\n45:    one table to another. As a consequence ``ReverseOneToOneDescriptor`` is\n46:    slightly different from ``ForwardManyToOneDescriptor``.\n47: \n48: 4. Related objects manager for related instances on the reverse side of a\n49:    many-to-one relation: ``ReverseManyToOneDescriptor``.\n50: \n51:    Unlike the previous two classes, this one provides access to a collection\n52:    of objects. It returns a manager rather than an instance.\n53: \n54: 5. Related objects manager for related instances on the forward or reverse\n55:    sides of a many-to-many relation: ``ManyToManyDescriptor``.\n56: \n57:    Many-to-many relations are symmetrical. The syntax of Django models\n58:    requires declaring them on one side but that's an implementation detail.\n59:    They could be declared on the other side without any change in behavior.\n60:    Therefore the forward and reverse descriptors can be the same.\n61: \n62:    If you're looking for ``ForwardManyToManyDescriptor`` or\n63:    ``ReverseManyToManyDescriptor``, use ``ManyToManyDescriptor`` instead.\n64: \"\"\"\n65: \n66: from django.core.exceptions import FieldError\n67: from django.db import connections, router, transaction\n68: from django.db.models import Q, signals\n69: from django.db.models.query import QuerySet\n70: from django.db.models.query_utils import DeferredAttribute\n71: from django.db.models.utils import resolve_callables\n72: from django.utils.functional import cached_property\n73: \n74: \n75: class ForeignKeyDeferredAttribute(DeferredAttribute):\nCode replaced for brevity.\n81: \n82: \n83: \n84: class ForwardManyToOneDescriptor:\nCode replaced for brevity.\n303: \n304: \n305: \n306: class ForwardOneToOneDescriptor(ForwardManyToOneDescriptor):\nCode replaced for brevity.\n354: \n355: \n356: \n357: class ReverseOneToOneDescriptor:\nCode replaced for brevity.\n541: \n542: \n543: \n544: class ReverseManyToOneDescriptor:\nCode replaced for brevity.\n609: \n610: \n611: \n612: def create_reverse_many_to_one_manager(superclass, rel):\n613:     \"\"\"\n614:     Create a manager for the reverse side of a many-to-one relation.\n615: \n616:     This manager subclasses another manager, generally the default manager of\n617:     the related model, and adds behaviors specific to many-to-one relations.\n618:     \"\"\"\n619: \n620:     class RelatedManager(superclass):\n621:         def __init__(self, instance):\n622:             super().__init__()\n623: \n624:             self.instance = instance\n625:             self.model = rel.related_model\n626:             self.field = rel.field\n627: \n628:             self.core_filters = {self.field.name: instance}\n629: \n630:             # Even if this relation is not to pk, we require still pk value.\n631:             # The wish is that the instance has been already saved to DB,\n632:             # although having a pk value isn't a guarantee of that.\n633:             if self.instance.pk is None:\n634:                 raise ValueError(\n635:                     f\"{instance.__class__.__name__!r} instance needs to have a primary \"\n636:                     f\"key value before this relationship can be used.\"\n637:                 )\n638: \n639:         def __call__(self, *, manager):\n640:             manager = getattr(self.model, manager)\n641:             manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)\n642:             return manager_class(self.instance)\n643: \n644:         do_not_call_in_templates = True\n645: \n646:         def _check_fk_val(self):\n647:             for field in self.field.foreign_related_fields:\n648:                 if getattr(self.instance, field.attname) is None:\n649:                     raise ValueError(\n650:                         f'\"{self.instance!r}\" needs to have a value for field '\n651:                         f'\"{field.attname}\" before this relationship can be used.'\n652:                     )\n653: \n654:         def _apply_rel_filters(self, queryset):\n655:             \"\"\"\n656:             Filter the queryset for the instance this manager is bound to.\n657:             \"\"\"\n658:             db = self._db or router.db_for_read(self.model, instance=self.instance)\n659:             empty_strings_as_null = connections[\n660:                 db\n661:             ].features.interprets_empty_strings_as_nulls\n662:             queryset._add_hints(instance=self.instance)\n663:             if self._db:\n664:                 queryset = queryset.using(self._db)\n665:             queryset._defer_next_filter = True\n666:             queryset = queryset.filter(**self.core_filters)\n667:             for field in self.field.foreign_related_fields:\n668:                 val = getattr(self.instance, field.attname)\n669:                 if val is None or (val == \"\" and empty_strings_as_null):\n670:                     return queryset.none()\n671:             if self.field.many_to_one:\n672:                 # Guard against field-like objects such as GenericRelation\n673:                 # that abuse create_reverse_many_to_one_manager() with reverse\n674:                 # one-to-many relationships instead and break known related\n675:                 # objects assignment.\n676:                 try:\n677:                     target_field = self.field.target_field\n678:                 except FieldError:\n679:                     # The relationship has multiple target fields. Use a tuple\n680:                     # for related object id.\n681:                     rel_obj_id = tuple(\n682:                         [\n683:                             getattr(self.instance, target_field.attname)\n684:                             for target_field in self.field.path_infos[-1].target_fields\n685:                         ]\n686:                     )\n687:                 else:\n688:                     rel_obj_id = getattr(self.instance, target_field.attname)\n689:                 queryset._known_related_objects = {\n690:                     self.field: {rel_obj_id: self.instance}\n691:                 }\n692:             return queryset\n693: \n694:         def _remove_prefetched_objects(self):\n695:             try:\n696:                 self.instance._prefetched_objects_cache.pop(\n697:                     self.field.remote_field.get_cache_name()\n698:                 )\n699:             except (AttributeError, KeyError):\n700:                 pass  # nothing to clear from cache\n701: \n702:         def get_queryset(self):\n703:             try:\n704:                 return self.instance._prefetched_objects_cache[\n705:                     self.field.remote_field.get_cache_name()\n706:                 ]\n707:             except (AttributeError, KeyError):\n708:                 queryset = super().get_queryset()\n709:                 return self._apply_rel_filters(queryset)\n710: \n711:         def get_prefetch_queryset(self, instances, queryset=None):\n712:             if queryset is None:\n713:                 queryset = super().get_queryset()\n714: \n715:             queryset._add_hints(instance=instances[0])\n716:             queryset = queryset.using(queryset._db or self._db)\n717: \n718:             rel_obj_attr = self.field.get_local_related_value\n719:             instance_attr = self.field.get_foreign_related_value\n720:             instances_dict = {instance_attr(inst): inst for inst in instances}\n721:             query = {\"%s__in\" % self.field.name: instances}\n722:             queryset = queryset.filter(**query)\n723: \n724:             # Since we just bypassed this class' get_queryset(), we must manage\n725:             # the reverse relation manually.\n726:             for rel_obj in queryset:\n727:                 if not self.field.is_cached(rel_obj):\n728:                     instance = instances_dict[rel_obj_attr(rel_obj)]\n729:                     setattr(rel_obj, self.field.name, instance)\n730:             cache_name = self.field.remote_field.get_cache_name()\n731:             return queryset, rel_obj_attr, instance_attr, False, cache_name, False\n732: \n733:         def add(self, *objs, bulk=True):\n734:             self._check_fk_val()\n735:             self._remove_prefetched_objects()\n736:             db = router.db_for_write(self.model, instance=self.instance)\n737: \n738:             def check_and_update_obj(obj):\n739:                 if not isinstance(obj, self.model):\n740:                     raise TypeError(\n741:                         \"'%s' instance expected, got %r\"\n742:                         % (\n743:                             self.model._meta.object_name,\n744:                             obj,\n745:                         )\n746:                     )\n747:                 setattr(obj, self.field.name, self.instance)\n748: \n749:             if bulk:\n750:                 pks = []\n751:                 for obj in objs:\n752:                     check_and_update_obj(obj)\n753:                     if obj._state.adding or obj._state.db != db:\n754:                         raise ValueError(\n755:                             \"%r instance isn't saved. Use bulk=False or save \"\n756:                             \"the object first.\" % obj\n757:                         )\n758:                     pks.append(obj.pk)\n759:                 self.model._base_manager.using(db).filter(pk__in=pks).update(\n760:                     **{\n761:                         self.field.name: self.instance,\n762:                     }\n763:                 )\n764:             else:\n765:                 with transaction.atomic(using=db, savepoint=False):\n766:                     for obj in objs:\n767:                         check_and_update_obj(obj)\n768:                         obj.save()\n769: \n770:         add.alters_data = True\n771: \n772:         def create(self, **kwargs):\n773:             self._check_fk_val()\n774:             kwargs[self.field.name] = self.instance\n775:             db = router.db_for_write(self.model, instance=self.instance)\n776:             return super(RelatedManager, self.db_manager(db)).create(**kwargs)\n777: \n778:         create.alters_data = True\n779: \n780:         def get_or_create(self, **kwargs):\n781:             self._check_fk_val()\n782:             kwargs[self.field.name] = self.instance\n783:             db = router.db_for_write(self.model, instance=self.instance)\n784:             return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n785: \n786:         get_or_create.alters_data = True\n787: \n788:         def update_or_create(self, **kwargs):\n789:             self._check_fk_val()\n790:             kwargs[self.field.name] = self.instance\n791:             db = router.db_for_write(self.model, instance=self.instance)\n792:             return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n793: \n794:         update_or_create.alters_data = True\n795: \n796:         # remove() and clear() are only provided if the ForeignKey can have a\n797:         # value of null.\n798:         if rel.field.null:\n799: \n800:             def remove(self, *objs, bulk=True):\n801:                 if not objs:\n802:                     return\n803:                 self._check_fk_val()\n804:                 val = self.field.get_foreign_related_value(self.instance)\n805:                 old_ids = set()\n806:                 for obj in objs:\n807:                     if not isinstance(obj, self.model):\n808:                         raise TypeError(\n809:                             \"'%s' instance expected, got %r\"\n810:                             % (\n811:                                 self.model._meta.object_name,\n812:                                 obj,\n813:                             )\n814:                         )\n815:                     # Is obj actually part of this descriptor set?\n816:                     if self.field.get_local_related_value(obj) == val:\n817:                         old_ids.add(obj.pk)\n818:                     else:\n819:                         raise self.field.remote_field.model.DoesNotExist(\n820:                             \"%r is not related to %r.\" % (obj, self.instance)\n821:                         )\n822:                 self._clear(self.filter(pk__in=old_ids), bulk)\n823: \n824:             remove.alters_data = True\n825: \n826:             def clear(self, *, bulk=True):\n827:                 self._check_fk_val()\n828:                 self._clear(self, bulk)\n829: \n830:             clear.alters_data = True\n831: \n832:             def _clear(self, queryset, bulk):\n833:                 self._remove_prefetched_objects()\n834:                 db = router.db_for_write(self.model, instance=self.instance)\n835:                 queryset = queryset.using(db)\n836:                 if bulk:\n837:                     # `QuerySet.update()` is intrinsically atomic.\n838:                     queryset.update(**{self.field.name: None})\n839:                 else:\n840:                     with transaction.atomic(using=db, savepoint=False):\n841:                         for obj in queryset:\n842:                             setattr(obj, self.field.name, None)\n843:                             obj.save(update_fields=[self.field.name])\n844: \n845:             _clear.alters_data = True\n846: \n847:         def set(self, objs, *, bulk=True, clear=False):\n848:             self._check_fk_val()\n849:             # Force evaluation of `objs` in case it's a queryset whose value\n850:             # could be affected by `manager.clear()`. Refs #19816.\n851:             objs = tuple(objs)\n852: \n853:             if self.field.null:\n854:                 db = router.db_for_write(self.model, instance=self.instance)\n855:                 with transaction.atomic(using=db, savepoint=False):\n856:                     if clear:\n857:                         self.clear(bulk=bulk)\n858:                         self.add(*objs, bulk=bulk)\n859:                     else:\n860:                         old_objs = set(self.using(db).all())\n861:                         new_objs = []\n862:                         for obj in objs:\n863:                             if obj in old_objs:\n864:                                 old_objs.remove(obj)\n865:                             else:\n866:                                 new_objs.append(obj)\n867: \n868:                         self.remove(*old_objs, bulk=bulk)\n869:                         self.add(*new_objs, bulk=bulk)\n870:             else:\n871:                 self.add(*objs, bulk=bulk)\n872: \n873:         set.alters_data = True\n874: \n875:     return RelatedManager\n876: \n877: \n878: class ManyToManyDescriptor(ReverseManyToOneDescriptor):\nCode replaced for brevity.\n933: \n934: \n935: \n936: def create_forward_many_to_many_manager(superclass, rel, reverse):\n937:     \"\"\"\n938:     Create a manager for the either side of a many-to-many relation.\n939: \n940:     This manager subclasses another manager, generally the default manager of\n941:     the related model, and adds behaviors specific to many-to-many relations.\n942:     \"\"\"\n943: \n944:     class ManyRelatedManager(superclass):\n945:         def __init__(self, instance=None):\n946:             super().__init__()\n947: \n948:             self.instance = instance\n949: \n950:             if not reverse:\n951:                 self.model = rel.model\n952:                 self.query_field_name = rel.field.related_query_name()\n953:                 self.prefetch_cache_name = rel.field.name\n954:                 self.source_field_name = rel.field.m2m_field_name()\n955:                 self.target_field_name = rel.field.m2m_reverse_field_name()\n956:                 self.symmetrical = rel.symmetrical\n957:             else:\n958:                 self.model = rel.related_model\n959:                 self.query_field_name = rel.field.name\n960:                 self.prefetch_cache_name = rel.field.related_query_name()\n961:                 self.source_field_name = rel.field.m2m_reverse_field_name()\n962:                 self.target_field_name = rel.field.m2m_field_name()\n963:                 self.symmetrical = False\n964: \n965:             self.through = rel.through\n966:             self.reverse = reverse\n967: \n968:             self.source_field = self.through._meta.get_field(self.source_field_name)\n969:             self.target_field = self.through._meta.get_field(self.target_field_name)\n970: \n971:             self.core_filters = {}\n972:             self.pk_field_names = {}\n973:             for lh_field, rh_field in self.source_field.related_fields:\n974:                 core_filter_key = \"%s__%s\" % (self.query_field_name, rh_field.name)\n975:                 self.core_filters[core_filter_key] = getattr(instance, rh_field.attname)\n976:                 self.pk_field_names[lh_field.name] = rh_field.name\n977: \n978:             self.related_val = self.source_field.get_foreign_related_value(instance)\n979:             if None in self.related_val:\n980:                 raise ValueError(\n981:                     '\"%r\" needs to have a value for field \"%s\" before '\n982:                     \"this many-to-many relationship can be used.\"\n983:                     % (instance, self.pk_field_names[self.source_field_name])\n984:                 )\n985:             # Even if this relation is not to pk, we require still pk value.\n986:             # The wish is that the instance has been already saved to DB,\n987:             # although having a pk value isn't a guarantee of that.\n988:             if instance.pk is None:\n989:                 raise ValueError(\n990:                     \"%r instance needs to have a primary key value before \"\n991:                     \"a many-to-many relationship can be used.\"\n992:                     % instance.__class__.__name__\n993:                 )\n994: \n995:         def __call__(self, *, manager):\n996:             manager = getattr(self.model, manager)\n997:             manager_class = create_forward_many_to_many_manager(\n998:                 manager.__class__, rel, reverse\n999:             )\n1000:             return manager_class(instance=self.instance)\n1001: \n1002:         do_not_call_in_templates = True\n1003: \n1004:         def _build_remove_filters(self, removed_vals):\n1005:             filters = Q.create([(self.source_field_name, self.related_val)])\n1006:             # No need to add a subquery condition if removed_vals is a QuerySet without\n1007:             # filters.\n1008:             removed_vals_filters = (\n1009:                 not isinstance(removed_vals, QuerySet) or removed_vals._has_filters()\n1010:             )\n1011:             if removed_vals_filters:\n1012:                 filters &= Q.create([(f\"{self.target_field_name}__in\", removed_vals)])\n1013:             if self.symmetrical:\n1014:                 symmetrical_filters = Q.create(\n1015:                     [(self.target_field_name, self.related_val)]\n1016:                 )\n1017:                 if removed_vals_filters:\n1018:                     symmetrical_filters &= Q.create(\n1019:                         [(f\"{self.source_field_name}__in\", removed_vals)]\n1020:                     )\n1021:                 filters |= symmetrical_filters\n1022:             return filters\n1023: \n1024:         def _apply_rel_filters(self, queryset):\n1025:             \"\"\"\n1026:             Filter the queryset for the instance this manager is bound to.\n1027:             \"\"\"\n1028:             queryset._add_hints(instance=self.instance)\n1029:             if self._db:\n1030:                 queryset = queryset.using(self._db)\n1031:             queryset._defer_next_filter = True\n1032:             return queryset._next_is_sticky().filter(**self.core_filters)\n1033: \n1034:         def _remove_prefetched_objects(self):\n1035:             try:\n1036:                 self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)\n1037:             except (AttributeError, KeyError):\n1038:                 pass  # nothing to clear from cache\n1039: \n1040:         def get_queryset(self):\n1041:             try:\n1042:                 return self.instance._prefetched_objects_cache[self.prefetch_cache_name]\n1043:             except (AttributeError, KeyError):\n1044:                 queryset = super().get_queryset()\n1045:                 return self._apply_rel_filters(queryset)\n1046: \n1047:         def get_prefetch_queryset(self, instances, queryset=None):\n1048:             if queryset is None:\n1049:                 queryset = super().get_queryset()\n1050: \n1051:             queryset._add_hints(instance=instances[0])\n1052:             queryset = queryset.using(queryset._db or self._db)\n1053: \n1054:             query = {\"%s__in\" % self.query_field_name: instances}\n1055:             queryset = queryset._next_is_sticky().filter(**query)\n1056: \n1057:             # M2M: need to annotate the query in order to get the primary model\n1058:             # that the secondary model was actually related to. We know that\n1059:             # there will already be a join on the join table, so we can just add\n1060:             # the select.\n1061: \n1062:             # For non-autocreated 'through' models, can't assume we are\n1063:             # dealing with PK values.\n1064:             fk = self.through._meta.get_field(self.source_field_name)\n1065:             join_table = fk.model._meta.db_table\n1066:             connection = connections[queryset.db]\n1067:             qn = connection.ops.quote_name\n1068:             queryset = queryset.extra(\n1069:                 select={\n1070:                     \"_prefetch_related_val_%s\"\n1071:                     % f.attname: \"%s.%s\"\n1072:                     % (qn(join_table), qn(f.column))\n1073:                     for f in fk.local_related_fields\n1074:                 }\n1075:             )\n1076:             return (\n1077:                 queryset,\n1078:                 lambda result: tuple(\n1079:                     getattr(result, \"_prefetch_related_val_%s\" % f.attname)\n1080:                     for f in fk.local_related_fields\n1081:                 ),\n1082:                 lambda inst: tuple(\n1083:                     f.get_db_prep_value(getattr(inst, f.attname), connection)\n1084:                     for f in fk.foreign_related_fields\n1085:                 ),\n1086:                 False,\n1087:                 self.prefetch_cache_name,\n1088:                 False,\n1089:             )\n1090: \n1091:         def add(self, *objs, through_defaults=None):\n1092:             self._remove_prefetched_objects()\n1093:             db = router.db_for_write(self.through, instance=self.instance)\n1094:             with transaction.atomic(using=db, savepoint=False):\n1095:                 self._add_items(\n1096:                     self.source_field_name,\n1097:                     self.target_field_name,\n1098:                     *objs,\n1099:                     through_defaults=through_defaults,\n1100:                 )\n1101:                 # If this is a symmetrical m2m relation to self, add the mirror\n1102:                 # entry in the m2m table.\n1103:                 if self.symmetrical:\n1104:                     self._add_items(\n1105:                         self.target_field_name,\n1106:                         self.source_field_name,\n1107:                         *objs,\n1108:                         through_defaults=through_defaults,\n1109:                     )\n1110: \n1111:         add.alters_data = True\n1112: \n1113:         def remove(self, *objs):\n1114:             self._remove_prefetched_objects()\n1115:             self._remove_items(self.source_field_name, self.target_field_name, *objs)\n1116: \n1117:         remove.alters_data = True\n1118: \n1119:         def clear(self):\n1120:             db = router.db_for_write(self.through, instance=self.instance)\n1121:             with transaction.atomic(using=db, savepoint=False):\n1122:                 signals.m2m_changed.send(\n1123:                     sender=self.through,\n1124:                     action=\"pre_clear\",\n1125:                     instance=self.instance,\n1126:                     reverse=self.reverse,\n1127:                     model=self.model,\n1128:                     pk_set=None,\n1129:                     using=db,\n1130:                 )\n1131:                 self._remove_prefetched_objects()\n1132:                 filters = self._build_remove_filters(super().get_queryset().using(db))\n1133:                 self.through._default_manager.using(db).filter(filters).delete()\n1134: \n1135:                 signals.m2m_changed.send(\n1136:                     sender=self.through,\n1137:                     action=\"post_clear\",\n1138:                     instance=self.instance,\n1139:                     reverse=self.reverse,\n1140:                     model=self.model,\n1141:                     pk_set=None,\n1142:                     using=db,\n1143:                 )\n1144: \n1145:         clear.alters_data = True\n1146: \n1147:         def set(self, objs, *, clear=False, through_defaults=None):\n1148:             # Force evaluation of `objs` in case it's a queryset whose value\n1149:             # could be affected by `manager.clear()`. Refs #19816.\n1150:             objs = tuple(objs)\n1151: \n1152:             db = router.db_for_write(self.through, instance=self.instance)\n1153:             with transaction.atomic(using=db, savepoint=False):\n1154:                 if clear:\n1155:                     self.clear()\n1156:                     self.add(*objs, through_defaults=through_defaults)\n1157:                 else:\n1158:                     old_ids = set(\n1159:                         self.using(db).values_list(\n1160:                             self.target_field.target_field.attname, flat=True\n1161:                         )\n1162:                     )\n1163: \n1164:                     new_objs = []\n1165:                     for obj in objs:\n1166:                         fk_val = (\n1167:                             self.target_field.get_foreign_related_value(obj)[0]\n1168:                             if isinstance(obj, self.model)\n1169:                             else self.target_field.get_prep_value(obj)\n1170:                         )\n1171:                         if fk_val in old_ids:\n1172:                             old_ids.remove(fk_val)\n1173:                         else:\n1174:                             new_objs.append(obj)\n1175: \n1176:                     self.remove(*old_ids)\n1177:                     self.add(*new_objs, through_defaults=through_defaults)\n1178: \n1179:         set.alters_data = True\n1180: \n1181:         def create(self, *, through_defaults=None, **kwargs):\n1182:             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n1183:             new_obj = super(ManyRelatedManager, self.db_manager(db)).create(**kwargs)\n1184:             self.add(new_obj, through_defaults=through_defaults)\n1185:             return new_obj\n1186: \n1187:         create.alters_data = True\n1188: \n1189:         def get_or_create(self, *, through_defaults=None, **kwargs):\n1190:             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n1191:             obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(\n1192:                 **kwargs\n1193:             )\n1194:             # We only need to add() if created because if we got an object back\n1195:             # from get() then the relationship already exists.\n1196:             if created:\n1197:                 self.add(obj, through_defaults=through_defaults)\n1198:             return obj, created\n1199: \n1200:         get_or_create.alters_data = True\n1201: \n1202:         def update_or_create(self, *, through_defaults=None, **kwargs):\n1203:             db = router.db_for_write(self.instance.__class__, instance=self.instance)\n1204:             obj, created = super(\n1205:                 ManyRelatedManager, self.db_manager(db)\n1206:             ).update_or_create(**kwargs)\n1207:             # We only need to add() if created because if we got an object back\n1208:             # from get() then the relationship already exists.\n1209:             if created:\n1210:                 self.add(obj, through_defaults=through_defaults)\n1211:             return obj, created\n1212: \n1213:         update_or_create.alters_data = True\n1214: \n1215:         def _get_target_ids(self, target_field_name, objs):\n1216:             \"\"\"\n1217:             Return the set of ids of `objs` that the target field references.\n1218:             \"\"\"\n1219:             from django.db.models import Model\n1220: \n1221:             target_ids = set()\n1222:             target_field = self.through._meta.get_field(target_field_name)\n1223:             for obj in objs:\n1224:                 if isinstance(obj, self.model):\n1225:                     if not router.allow_relation(obj, self.instance):\n1226:                         raise ValueError(\n1227:                             'Cannot add \"%r\": instance is on database \"%s\", '\n1228:                             'value is on database \"%s\"'\n1229:                             % (obj, self.instance._state.db, obj._state.db)\n1230:                         )\n1231:                     target_id = target_field.get_foreign_related_value(obj)[0]\n1232:                     if target_id is None:\n1233:                         raise ValueError(\n1234:                             'Cannot add \"%r\": the value for field \"%s\" is None'\n1235:                             % (obj, target_field_name)\n1236:                         )\n1237:                     target_ids.add(target_id)\n1238:                 elif isinstance(obj, Model):\n1239:                     raise TypeError(\n1240:                         \"'%s' instance expected, got %r\"\n1241:                         % (self.model._meta.object_name, obj)\n1242:                     )\n1243:                 else:\n1244:                     target_ids.add(target_field.get_prep_value(obj))\n1245:             return target_ids\n1246: \n1247:         def _get_missing_target_ids(\n1248:             self, source_field_name, target_field_name, db, target_ids\n1249:         ):\n1250:             \"\"\"\n1251:             Return the subset of ids of `objs` that aren't already assigned to\n1252:             this relationship.\n1253:             \"\"\"\n1254:             vals = (\n1255:                 self.through._default_manager.using(db)\n1256:                 .values_list(target_field_name, flat=True)\n1257:                 .filter(\n1258:                     **{\n1259:                         source_field_name: self.related_val[0],\n1260:                         \"%s__in\" % target_field_name: target_ids,\n1261:                     }\n1262:                 )\n1263:             )\n1264:             return target_ids.difference(vals)\n1265: \n1266:         def _get_add_plan(self, db, source_field_name):\n1267:             \"\"\"\n1268:             Return a boolean triple of the way the add should be performed.\n1269: \n1270:             The first element is whether or not bulk_create(ignore_conflicts)\n1271:             can be used, the second whether or not signals must be sent, and\n1272:             the third element is whether or not the immediate bulk insertion\n1273:             with conflicts ignored can be performed.\n1274:             \"\"\"\n1275:             # Conflicts can be ignored when the intermediary model is\n1276:             # auto-created as the only possible collision is on the\n1277:             # (source_id, target_id) tuple. The same assertion doesn't hold for\n1278:             # user-defined intermediary models as they could have other fields\n1279:             # causing conflicts which must be surfaced.\n1280:             can_ignore_conflicts = (\n1281:                 self.through._meta.auto_created is not False\n1282:                 and connections[db].features.supports_ignore_conflicts\n1283:             )\n1284:             # Don't send the signal when inserting duplicate data row\n1285:             # for symmetrical reverse entries.\n1286:             must_send_signals = (\n1287:                 self.reverse or source_field_name == self.source_field_name\n1288:             ) and (signals.m2m_changed.has_listeners(self.through))\n1289:             # Fast addition through bulk insertion can only be performed\n1290:             # if no m2m_changed listeners are connected for self.through\n1291:             # as they require the added set of ids to be provided via\n1292:             # pk_set.\n1293:             return (\n1294:                 can_ignore_conflicts,\n1295:                 must_send_signals,\n1296:                 (can_ignore_conflicts and not must_send_signals),\n1297:             )\n1298: \n1299:         def _add_items(\n1300:             self, source_field_name, target_field_name, *objs, through_defaults=None\n1301:         ):\n1302:             # source_field_name: the PK fieldname in join table for the source object\n1303:             # target_field_name: the PK fieldname in join table for the target object\n1304:             # *objs - objects to add. Either object instances, or primary keys\n1305:             # of object instances.\n1306:             if not objs:\n1307:                 return\n1308: \n1309:             through_defaults = dict(resolve_callables(through_defaults or {}))\n1310:             target_ids = self._get_target_ids(target_field_name, objs)\n1311:             db = router.db_for_write(self.through, instance=self.instance)\n1312:             can_ignore_conflicts, must_send_signals, can_fast_add = self._get_add_plan(\n1313:                 db, source_field_name\n1314:             )\n1315:             if can_fast_add:\n1316:                 self.through._default_manager.using(db).bulk_create(\n1317:                     [\n1318:                         self.through(\n1319:                             **{\n1320:                                 \"%s_id\" % source_field_name: self.related_val[0],\n1321:                                 \"%s_id\" % target_field_name: target_id,\n1322:                             }\n1323:                         )\n1324:                         for target_id in target_ids\n1325:                     ],\n1326:                     ignore_conflicts=True,\n1327:                 )\n1328:                 return\n1329: \n1330:             missing_target_ids = self._get_missing_target_ids(\n1331:                 source_field_name, target_field_name, db, target_ids\n1332:             )\n1333:             with transaction.atomic(using=db, savepoint=False):\n1334:                 if must_send_signals:\n1335:                     signals.m2m_changed.send(\n1336:                         sender=self.through,\n1337:                         action=\"pre_add\",\n1338:                         instance=self.instance,\n1339:                         reverse=self.reverse,\n1340:                         model=self.model,\n1341:                         pk_set=missing_target_ids,\n1342:                         using=db,\n1343:                     )\n1344:                 # Add the ones that aren't there already.\n1345:                 self.through._default_manager.using(db).bulk_create(\n1346:                     [\n1347:                         self.through(\n1348:                             **through_defaults,\n1349:                             **{\n1350:                                 \"%s_id\" % source_field_name: self.related_val[0],\n1351:                                 \"%s_id\" % target_field_name: target_id,\n1352:                             },\n1353:                         )\n1354:                         for target_id in missing_target_ids\n1355:                     ],\n1356:                     ignore_conflicts=can_ignore_conflicts,\n1357:                 )\n1358: \n1359:                 if must_send_signals:\n1360:                     signals.m2m_changed.send(\n1361:                         sender=self.through,\n1362:                         action=\"post_add\",\n1363:                         instance=self.instance,\n1364:                         reverse=self.reverse,\n1365:                         model=self.model,\n1366:                         pk_set=missing_target_ids,\n1367:                         using=db,\n1368:                     )\n1369: \n1370:         def _remove_items(self, source_field_name, target_field_name, *objs):\n1371:             # source_field_name: the PK colname in join table for the source object\n1372:             # target_field_name: the PK colname in join table for the target object\n1373:             # *objs - objects to remove. Either object instances, or primary\n1374:             # keys of object instances.\n1375:             if not objs:\n1376:                 return\n1377: \n1378:             # Check that all the objects are of the right type\n1379:             old_ids = set()\n1380:             for obj in objs:\n1381:                 if isinstance(obj, self.model):\n1382:                     fk_val = self.target_field.get_foreign_related_value(obj)[0]\n1383:                     old_ids.add(fk_val)\n1384:                 else:\n1385:                     old_ids.add(obj)\n1386: \n1387:             db = router.db_for_write(self.through, instance=self.instance)\n1388:             with transaction.atomic(using=db, savepoint=False):\n1389:                 # Send a signal to the other end if need be.\n1390:                 signals.m2m_changed.send(\n1391:                     sender=self.through,\n1392:                     action=\"pre_remove\",\n1393:                     instance=self.instance,\n1394:                     reverse=self.reverse,\n1395:                     model=self.model,\n1396:                     pk_set=old_ids,\n1397:                     using=db,\n1398:                 )\n1399:                 target_model_qs = super().get_queryset()\n1400:                 if target_model_qs._has_filters():\n1401:                     old_vals = target_model_qs.using(db).filter(\n1402:                         **{\"%s__in\" % self.target_field.target_field.attname: old_ids}\n1403:                     )\n1404:                 else:\n1405:                     old_vals = old_ids\n1406:                 filters = self._build_remove_filters(old_vals)\n1407:                 self.through._default_manager.using(db).filter(filters).delete()\n1408: \n1409:                 signals.m2m_changed.send(\n1410:                     sender=self.through,\n1411:                     action=\"post_remove\",\n1412:                     instance=self.instance,\n1413:                     reverse=self.reverse,\n1414:                     model=self.model,\n1415:                     pk_set=old_ids,\n1416:                     using=db,\n1417:                 )\n1418: \n1419:     return ManyRelatedManager\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/related_descriptors.py",
      "suspect_lines": [
        67,
        68,
        721,
        722,
        1053,
        1054,
        1055
      ]
    }
  ]
}