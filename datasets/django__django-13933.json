{
  "instance_id": "django__django-13933",
  "problem_statement": "ModelChoiceField does not provide value of invalid choice when raising ValidationError\nDescription\n\t \n\t\t(last modified by Aaron Wiegel)\n\t \nCompared with ChoiceField and others, ModelChoiceField does not show the value of the invalid choice when raising a validation error. Passing in parameters with the invalid value and modifying the default error message for the code invalid_choice should fix this.\nFrom source code:\nclass ModelMultipleChoiceField(ModelChoiceField):\n\t\"\"\"A MultipleChoiceField whose choices are a model QuerySet.\"\"\"\n\twidget = SelectMultiple\n\thidden_widget = MultipleHiddenInput\n\tdefault_error_messages = {\n\t\t'invalid_list': _('Enter a list of values.'),\n\t\t'invalid_choice': _('Select a valid choice. %(value)s is not one of the'\n\t\t\t\t\t\t\t' available choices.'),\n\t\t'invalid_pk_value': _('“%(pk)s” is not a valid value.')\n\t}\n\t...\nclass ModelChoiceField(ChoiceField):\n\t\"\"\"A ChoiceField whose choices are a model QuerySet.\"\"\"\n\t# This class is a subclass of ChoiceField for purity, but it doesn't\n\t# actually use any of ChoiceField's implementation.\n\tdefault_error_messages = {\n\t\t'invalid_choice': _('Select a valid choice. That choice is not one of'\n\t\t\t\t\t\t\t' the available choices.'),\n\t}\n\t...\n",
  "localized_code": "[start of django/forms/models.py]\n1: \"\"\"\n2: Helper functions for creating Form classes from Django models\n3: and database field objects.\n4: \"\"\"\n5: from itertools import chain\n6: \n7: from django.core.exceptions import (\n8:     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n9: )\n10: from django.forms.fields import ChoiceField, Field\n11: from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n12: from django.forms.formsets import BaseFormSet, formset_factory\n13: from django.forms.utils import ErrorList\n14: from django.forms.widgets import (\n15:     HiddenInput, MultipleHiddenInput, RadioSelect, SelectMultiple,\n16: )\n17: from django.utils.text import capfirst, get_text_list\n18: from django.utils.translation import gettext, gettext_lazy as _\n19: \n20: __all__ = (\n21:     'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',\n22:     'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS',\n23:     'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',\n24:     'inlineformset_factory', 'modelform_factory',\n25: )\n26: \n27: ALL_FIELDS = '__all__'\n28: \n29: \n30: def construct_instance(form, instance, fields=None, exclude=None):\n31:     \"\"\"\n32:     Construct and return a model instance from the bound ``form``'s\n33:     ``cleaned_data``, but do not save the returned instance to the database.\n34:     \"\"\"\n35:     from django.db import models\n36:     opts = instance._meta\n37: \n38:     cleaned_data = form.cleaned_data\n39:     file_field_list = []\n40:     for f in opts.fields:\n41:         if not f.editable or isinstance(f, models.AutoField) \\\n42:                 or f.name not in cleaned_data:\n43:             continue\n44:         if fields is not None and f.name not in fields:\n45:             continue\n46:         if exclude and f.name in exclude:\n47:             continue\n48:         # Leave defaults for fields that aren't in POST data, except for\n49:         # checkbox inputs because they don't appear in POST data if not checked.\n50:         if (\n51:             f.has_default() and\n52:             form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)) and\n53:             cleaned_data.get(f.name) in form[f.name].field.empty_values\n54:         ):\n55:             continue\n56:         # Defer saving file-type fields until after the other fields, so a\n57:         # callable upload_to can use the values from other fields.\n58:         if isinstance(f, models.FileField):\n59:             file_field_list.append(f)\n60:         else:\n61:             f.save_form_data(instance, cleaned_data[f.name])\n62: \n63:     for f in file_field_list:\n64:         f.save_form_data(instance, cleaned_data[f.name])\n65: \n66:     return instance\n67: \n68: \n69: # ModelForms #################################################################\n70: \n71: def model_to_dict(instance, fields=None, exclude=None):\nCode replaced for brevity.\n93: \n94: \n95: \n96: def apply_limit_choices_to_to_formfield(formfield):\nCode replaced for brevity.\n109: \n110: \n111: \n112:                      field_classes=None, *, apply_limit_choices_to=True):\nCode replaced for brevity.\n198: \n199: \n200: \n201: class ModelFormOptions:\nCode replaced for brevity.\n211: \n212: \n213: \n214: class ModelFormMetaclass(DeclarativeFieldsMetaclass):\nCode replaced for brevity.\n283: \n284: \n285: \n286: class BaseModelForm(BaseForm):\nCode replaced for brevity.\n474: \n475: \n476: \n477: class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n478:     pass\n479: \n480: \n481:                       field_classes=None):\nCode replaced for brevity.\n561: \n562: \n563: \n564: # ModelFormSets ##############################################################\n565: \n566: class BaseModelFormSet(BaseFormSet):\nCode replaced for brevity.\n863: \n864: \n865: \n866:                          absolute_max=None, can_delete_extra=True):\nCode replaced for brevity.\n892: \n893: \n894: \n895: # InlineFormSets #############################################################\n896: \n897: class BaseInlineFormSet(BaseModelFormSet):\nCode replaced for brevity.\n994: \n995: \n996: \n997: def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\nCode replaced for brevity.\n1050: \n1051: \n1052: \n1053:                           absolute_max=None, can_delete_extra=True):\nCode replaced for brevity.\n1095: \n1096: \n1097: \n1098: # Fields #####################################################################\n1099: \n1100: class InlineForeignKeyField(Field):\nCode replaced for brevity.\n1138: \n1139: \n1140: \n1141: class ModelChoiceIteratorValue:\nCode replaced for brevity.\n1152: \n1153: \n1154: \n1155: class ModelChoiceIterator:\nCode replaced for brevity.\n1183: \n1184: \n1185: \n1186: class ModelChoiceField(ChoiceField):\n1187:     \"\"\"A ChoiceField whose choices are a model QuerySet.\"\"\"\n1188:     # This class is a subclass of ChoiceField for purity, but it doesn't\n1189:     # actually use any of ChoiceField's implementation.\n1190:     default_error_messages = {\n1191:         'invalid_choice': _('Select a valid choice. That choice is not one of'\n1192:                             ' the available choices.'),\n1193:     }\n1194:     iterator = ModelChoiceIterator\n1195: \n1196:     def __init__(self, queryset, *, empty_label=\"---------\",\n1197:                  required=True, widget=None, label=None, initial=None,\n1198:                  help_text='', to_field_name=None, limit_choices_to=None,\n1199:                  blank=False, **kwargs):\n1200:         # Call Field instead of ChoiceField __init__() because we don't need\n1201:         # ChoiceField.__init__().\n1202:         Field.__init__(\n1203:             self, required=required, widget=widget, label=label,\n1204:             initial=initial, help_text=help_text, **kwargs\n1205:         )\n1206:         if (\n1207:             (required and initial is not None) or\n1208:             (isinstance(self.widget, RadioSelect) and not blank)\n1209:         ):\n1210:             self.empty_label = None\n1211:         else:\n1212:             self.empty_label = empty_label\n1213:         self.queryset = queryset\n1214:         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n1215:         self.to_field_name = to_field_name\n1216: \n1217:     def get_limit_choices_to(self):\n1218:         \"\"\"\n1219:         Return ``limit_choices_to`` for this form field.\n1220: \n1221:         If it is a callable, invoke it and return the result.\n1222:         \"\"\"\n1223:         if callable(self.limit_choices_to):\n1224:             return self.limit_choices_to()\n1225:         return self.limit_choices_to\n1226: \n1227:     def __deepcopy__(self, memo):\n1228:         result = super(ChoiceField, self).__deepcopy__(memo)\n1229:         # Need to force a new ModelChoiceIterator to be created, bug #11183\n1230:         if self.queryset is not None:\n1231:             result.queryset = self.queryset.all()\n1232:         return result\n1233: \n1234:     def _get_queryset(self):\n1235:         return self._queryset\n1236: \n1237:     def _set_queryset(self, queryset):\n1238:         self._queryset = None if queryset is None else queryset.all()\n1239:         self.widget.choices = self.choices\n1240: \n1241:     queryset = property(_get_queryset, _set_queryset)\n1242: \n1243:     # this method will be used to create object labels by the QuerySetIterator.\n1244:     # Override it to customize the label.\n1245:     def label_from_instance(self, obj):\n1246:         \"\"\"\n1247:         Convert objects into strings and generate the labels for the choices\n1248:         presented by this object. Subclasses can override this method to\n1249:         customize the display of the choices.\n1250:         \"\"\"\n1251:         return str(obj)\n1252: \n1253:     def _get_choices(self):\n1254:         # If self._choices is set, then somebody must have manually set\n1255:         # the property self.choices. In this case, just return self._choices.\n1256:         if hasattr(self, '_choices'):\n1257:             return self._choices\n1258: \n1259:         # Otherwise, execute the QuerySet in self.queryset to determine the\n1260:         # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n1261:         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n1262:         # time _get_choices() is called (and, thus, each time self.choices is\n1263:         # accessed) so that we can ensure the QuerySet has not been consumed. This\n1264:         # construct might look complicated but it allows for lazy evaluation of\n1265:         # the queryset.\n1266:         return self.iterator(self)\n1267: \n1268:     choices = property(_get_choices, ChoiceField._set_choices)\n1269: \n1270:     def prepare_value(self, value):\n1271:         if hasattr(value, '_meta'):\n1272:             if self.to_field_name:\n1273:                 return value.serializable_value(self.to_field_name)\n1274:             else:\n1275:                 return value.pk\n1276:         return super().prepare_value(value)\n1277: \n1278:     def to_python(self, value):\n1279:         if value in self.empty_values:\n1280:             return None\n1281:         try:\n1282:             key = self.to_field_name or 'pk'\n1283:             if isinstance(value, self.queryset.model):\n1284:                 value = getattr(value, key)\n1285:             value = self.queryset.get(**{key: value})\n1286:         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n1287:             raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n1288:         return value\n1289: \n1290:     def validate(self, value):\n1291:         return Field.validate(self, value)\n1292: \n1293:     def has_changed(self, initial, data):\n1294:         if self.disabled:\n1295:             return False\n1296:         initial_value = initial if initial is not None else ''\n1297:         data_value = data if data is not None else ''\n1298:         return str(self.prepare_value(initial_value)) != str(data_value)\n1299: \n1300: \n1301: class ModelMultipleChoiceField(ModelChoiceField):\nCode replaced for brevity.\n1393: \n1394: \n1395: \n1396:     retu\nCode replaced for brevity.\n1400: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/forms/models.py",
      "suspect_lines": [
        1287
      ]
    }
  ]
}