{
  "instance_id": "django__django-13512",
  "problem_statement": "Admin doesn't display properly unicode chars in JSONFields.\nDescription\n\t \n\t\t(last modified by ZhaoQi99)\n\t \n>>> import json\n>>> print json.dumps('中国')\n\"\\u4e2d\\u56fd\"\njson.dumps use ASCII encoding by default when serializing Chinese.\nSo when we edit a JsonField which contains Chinese character in Django admin,it will appear in ASCII characters.\nI have try to fix this this problem in ​https://github.com/adamchainz/django-mysql/pull/714.And it works prefectly.\n",
  "localized_code": "[start of django/contrib/admin/utils.py]\n1: import datetime\n2: import decimal\n3: from collections import defaultdict\n4: \n5: from django.core.exceptions import FieldDoesNotExist\n6: from django.db import models, router\n7: from django.db.models.constants import LOOKUP_SEP\n8: from django.db.models.deletion import Collector\n9: from django.forms.utils import pretty_name\n10: from django.urls import NoReverseMatch, reverse\n11: from django.utils import formats, timezone\n12: from django.utils.html import format_html\n13: from django.utils.regex_helper import _lazy_re_compile\n14: from django.utils.text import capfirst\n15: from django.utils.translation import ngettext, override as translation_override\n16: \n17: QUOTE_MAP = {i: '_%02X' % i for i in b'\":/_#?;@&=+$,\"[]<>%\\n\\\\'}\n18: UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}\n19: UNQUOTE_RE = _lazy_re_compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))\n20: \n21: \n22: class FieldIsAForeignKeyColumnName(Exception):\n23:     \"\"\"A field is a foreign key attname, i.e. <FK>_id.\"\"\"\n24:     pass\n25: \n26: \n27: def lookup_needs_distinct(opts, lookup_path):\n28:     \"\"\"\n29:     Return True if 'distinct()' should be used to query the given lookup path.\n30:     \"\"\"\n31:     lookup_fields = lookup_path.split(LOOKUP_SEP)\n32:     # Go through the fields (following all relations) and look for an m2m.\n33:     for field_name in lookup_fields:\n34:         if field_name == 'pk':\n35:             field_name = opts.pk.name\n36:         try:\n37:             field = opts.get_field(field_name)\n38:         except FieldDoesNotExist:\n39:             # Ignore query lookups.\n40:             continue\n41:         else:\n42:             if hasattr(field, 'get_path_info'):\n43:                 # This field is a relation; update opts to follow the relation.\n44:                 path_info = field.get_path_info()\n45:                 opts = path_info[-1].to_opts\n46:                 if any(path.m2m for path in path_info):\n47:                     # This field is a m2m relation so distinct must be called.\n48:                     return True\n49:     return False\n50: \n51: \n52: def prepare_lookup_value(key, value):\nCode replaced for brevity.\n62: \n63: \n64: \n65: def quote(s):\nCode replaced for brevity.\n72: \n73: \n74: \n75: def unquote(s):\nCode replaced for brevity.\n77: \n78: \n79: \n80: def flatten(fields):\nCode replaced for brevity.\n90: \n91: \n92: \n93: def flatten_fieldsets(fieldsets):\nCode replaced for brevity.\n100: \n101: \n102: \n103: def get_deleted_objects(objs, request, admin_site):\nCode replaced for brevity.\n156: \n157: \n158: \n159: class NestedObjects(Collector):\nCode replaced for brevity.\n221: \n222: \n223: \n224: def model_format_dict(obj):\nCode replaced for brevity.\n240: \n241: \n242: \n243: def model_ngettext(obj, n=None):\nCode replaced for brevity.\n258: \n259: \n260: \n261: def lookup_field(name, obj, model_admin=None):\nCode replaced for brevity.\n284: \n285: \n286: \n287: def _get_non_gfk_field(opts, name):\nCode replaced for brevity.\n305: \n306: \n307: \n308: def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\nCode replaced for brevity.\n365: \n366: \n367: \n368: def help_text_for_field(name, model):\nCode replaced for brevity.\n377: \n378: \n379: \n380: def display_for_field(value, field, empty_value_display):\n381:     from django.contrib.admin.templatetags.admin_list import _boolean_icon\n382: \n383:     if getattr(field, 'flatchoices', None):\n384:         return dict(field.flatchoices).get(value, empty_value_display)\n385:     # BooleanField needs special-case null-handling, so it comes before the\n386:     # general null test.\n387:     elif isinstance(field, models.BooleanField):\n388:         return _boolean_icon(value)\n389:     elif value is None:\n390:         return empty_value_display\n391:     elif isinstance(field, models.DateTimeField):\n392:         return formats.localize(timezone.template_localtime(value))\n393:     elif isinstance(field, (models.DateField, models.TimeField)):\n394:         return formats.localize(value)\n395:     elif isinstance(field, models.DecimalField):\n396:         return formats.number_format(value, field.decimal_places)\n397:     elif isinstance(field, (models.IntegerField, models.FloatField)):\n398:         return formats.number_format(value)\n399:     elif isinstance(field, models.FileField) and value:\n400:         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n401:     elif isinstance(field, models.JSONField) and value:\n402:         try:\n403:             return field.get_prep_value(value)\n404:         except TypeError:\n405:             return display_for_value(value, empty_value_display)\n406:     else:\n407:         return display_for_value(value, empty_value_display)\n408: \n409: \n410: def display_for_value(value, empty_value_display, boolean=False):\nCode replaced for brevity.\n428: \n429: \n430: \n431: class NotRelationField(Exception):\n432:     pass\n433: \n434: \n435: def get_model_from_relation(field):\nCode replaced for brevity.\n439: \n440: \n441: \n442: def reverse_field_path(model, path):\nCode replaced for brevity.\n470: \n471: \n472: \n473: def get_fields_from_path(model, path):\nCode replaced for brevity.\n490: \n491: \n492: \n493: def construct_change_message(form, formsets, add):\nCode replaced for brevity.\n539: \n540: \n541: \n542: def _get_changed_field_labels_from_form(form, changed_data):\nCode replaced for brevity.\n550: \n\n[start of django/forms/fields.py]\n1: \"\"\"\n2: Field classes.\n3: \"\"\"\n4: \n5: import copy\n6: import datetime\n7: import json\n8: import math\n9: import operator\n10: import os\n11: import re\n12: import uuid\n13: from decimal import Decimal, DecimalException\n14: from io import BytesIO\n15: from urllib.parse import urlsplit, urlunsplit\n16: \n17: from django.core import validators\n18: from django.core.exceptions import ValidationError\n19: from django.forms.boundfield import BoundField\n20: from django.forms.utils import from_current_timezone, to_current_timezone\n21: from django.forms.widgets import (\n22:     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,\n23:     DateTimeInput, EmailInput, FileInput, HiddenInput, MultipleHiddenInput,\n24:     NullBooleanSelect, NumberInput, Select, SelectMultiple,\n25:     SplitDateTimeWidget, SplitHiddenDateTimeWidget, Textarea, TextInput,\n26:     TimeInput, URLInput,\n27: )\n28: from django.utils import formats\n29: from django.utils.dateparse import parse_datetime, parse_duration\n30: from django.utils.duration import duration_string\n31: from django.utils.ipv6 import clean_ipv6_address\n32: from django.utils.regex_helper import _lazy_re_compile\n33: from django.utils.translation import gettext_lazy as _, ngettext_lazy\n34: \n35: __all__ = (\n36:     'Field', 'CharField', 'IntegerField',\n37:     'DateField', 'TimeField', 'DateTimeField', 'DurationField',\n38:     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',\n39:     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',\n40:     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',\n41:     'SplitDateTimeField', 'GenericIPAddressField', 'FilePathField',\n42:     'JSONField', 'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField',\n43:     'UUIDField',\n44: )\n45: \n46: \n47: class Field:\n48:     widget = TextInput  # Default widget to use when rendering this type of Field.\n49:     hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\n50:     default_validators = []  # Default set of validators\n51:     # Add an 'invalid' entry to default_error_message if you want a specific\n52:     # field error message not raised by the field validators.\n53:     default_error_messages = {\n54:         'required': _('This field is required.'),\n55:     }\n56:     empty_values = list(validators.EMPTY_VALUES)\n57: \n58:     def __init__(self, *, required=True, widget=None, label=None, initial=None,\n59:                  help_text='', error_messages=None, show_hidden_initial=False,\n60:                  validators=(), localize=False, disabled=False, label_suffix=None):\n61:         # required -- Boolean that specifies whether the field is required.\n62:         #             True by default.\n63:         # widget -- A Widget class, or instance of a Widget class, that should\n64:         #           be used for this Field when displaying it. Each Field has a\n65:         #           default Widget that it'll use if you don't specify this. In\n66:         #           most cases, the default widget is TextInput.\n67:         # label -- A verbose name for this field, for use in displaying this\n68:         #          field in a form. By default, Django will use a \"pretty\"\n69:         #          version of the form field name, if the Field is part of a\n70:         #          Form.\n71:         # initial -- A value to use in this Field's initial display. This value\n72:         #            is *not* used as a fallback if data isn't given.\n73:         # help_text -- An optional string to use as \"help text\" for this Field.\n74:         # error_messages -- An optional dictionary to override the default\n75:         #                   messages that the field will raise.\n76:         # show_hidden_initial -- Boolean that specifies if it is needed to render a\n77:         #                        hidden widget with initial value after widget.\n78:         # validators -- List of additional validators to use\n79:         # localize -- Boolean that specifies if the field should be localized.\n80:         # disabled -- Boolean that specifies whether the field is disabled, that\n81:         #             is its widget is shown in the form but not editable.\n82:         # label_suffix -- Suffix to be added to the label. Overrides\n83:         #                 form's label_suffix.\n84:         self.required, self.label, self.initial = required, label, initial\n85:         self.show_hidden_initial = show_hidden_initial\n86:         self.help_text = help_text\n87:         self.disabled = disabled\n88:         self.label_suffix = label_suffix\n89:         widget = widget or self.widget\n90:         if isinstance(widget, type):\n91:             widget = widget()\n92:         else:\n93:             widget = copy.deepcopy(widget)\n94: \n95:         # Trigger the localization machinery if needed.\n96:         self.localize = localize\n97:         if self.localize:\n98:             widget.is_localized = True\n99: \n100:         # Let the widget know whether it should display as required.\n101:         widget.is_required = self.required\n102: \n103:         # Hook into self.widget_attrs() for any Field-specific HTML attributes.\n104:         extra_attrs = self.widget_attrs(widget)\n105:         if extra_attrs:\n106:             widget.attrs.update(extra_attrs)\n107: \n108:         self.widget = widget\n109: \n110:         messages = {}\n111:         for c in reversed(self.__class__.__mro__):\n112:             messages.update(getattr(c, 'default_error_messages', {}))\n113:         messages.update(error_messages or {})\n114:         self.error_messages = messages\n115: \n116:         self.validators = [*self.default_validators, *validators]\n117: \n118:         super().__init__()\n119: \n120:     def prepare_value(self, value):\n121:         return value\n122: \n123:     def to_python(self, value):\n124:         return value\n125: \n126:     def validate(self, value):\n127:         if value in self.empty_values and self.required:\n128:             raise ValidationError(self.error_messages['required'], code='required')\n129: \n130:     def run_validators(self, value):\n131:         if value in self.empty_values:\n132:             return\n133:         errors = []\n134:         for v in self.validators:\n135:             try:\n136:                 v(value)\n137:             except ValidationError as e:\n138:                 if hasattr(e, 'code') and e.code in self.error_messages:\n139:                     e.message = self.error_messages[e.code]\n140:                 errors.extend(e.error_list)\n141:         if errors:\n142:             raise ValidationError(errors)\n143: \n144:     def clean(self, value):\n145:         \"\"\"\n146:         Validate the given value and return its \"cleaned\" value as an\n147:         appropriate Python object. Raise ValidationError for any errors.\n148:         \"\"\"\n149:         value = self.to_python(value)\n150:         self.validate(value)\n151:         self.run_validators(value)\n152:         return value\n153: \n154:     def bound_data(self, data, initial):\n155:         \"\"\"\n156:         Return the value that should be shown for this field on render of a\n157:         bound form, given the submitted POST data for the field and the initial\n158:         data, if any.\n159: \n160:         For most fields, this will simply be data; FileFields need to handle it\n161:         a bit differently.\n162:         \"\"\"\n163:         if self.disabled:\n164:             return initial\n165:         return data\n166: \n167:     def widget_attrs(self, widget):\n168:         \"\"\"\n169:         Given a Widget instance (*not* a Widget class), return a dictionary of\n170:         any HTML attributes that should be added to the Widget, based on this\n171:         Field.\n172:         \"\"\"\n173:         return {}\n174: \n175:     def has_changed(self, initial, data):\n176:         \"\"\"Return True if data differs from initial.\"\"\"\n177:         # Always return False if the field is disabled since self.bound_data\n178:         # always uses the initial value in this case.\n179:         if self.disabled:\n180:             return False\n181:         try:\n182:             data = self.to_python(data)\n183:             if hasattr(self, '_coerce'):\n184:                 return self._coerce(data) != self._coerce(initial)\n185:         except ValidationError:\n186:             return True\n187:         # For purposes of seeing whether something has changed, None is\n188:         # the same as an empty string, if the data or initial value we get\n189:         # is None, replace it with ''.\n190:         initial_value = initial if initial is not None else ''\n191:         data_value = data if data is not None else ''\n192:         return initial_value != data_value\n193: \n194:     def get_bound_field(self, form, field_name):\n195:         \"\"\"\n196:         Return a BoundField instance that will be used when accessing the form\n197:         field in a template.\n198:         \"\"\"\n199:         return BoundField(form, self, field_name)\n200: \n201:     def __deepcopy__(self, memo):\n202:         result = copy.copy(self)\n203:         memo[id(self)] = result\n204:         result.widget = copy.deepcopy(self.widget, memo)\n205:         result.error_messages = self.error_messages.copy()\n206:         result.validators = self.validators[:]\n207:         return result\n208: \n209: \n210: class CharField(Field):\nCode replaced for brevity.\n241: \n242: \n243: \n244: class IntegerField(Field):\nCode replaced for brevity.\n287: \n288: \n289: \n290: class FloatField(IntegerField):\nCode replaced for brevity.\n322: \n323: \n324: \n325: class DecimalField(IntegerField):\nCode replaced for brevity.\n363: \n364: \n365: \n366: class BaseTemporalField(Field):\nCode replaced for brevity.\n384: \n385: \n386: \n387: class DateField(BaseTemporalField):\nCode replaced for brevity.\n408: \n409: \n410: \n411: class TimeField(BaseTemporalField):\nCode replaced for brevity.\n430: \n431: \n432: \n433: class DateTimeFormatsIterator:\nCode replaced for brevity.\n436: \n437: \n438: \n439: class DateTimeField(BaseTemporalField):\nCode replaced for brevity.\n472: \n473: \n474: \n475: class DurationField(Field):\nCode replaced for brevity.\n500: \n501: \n502: \n503: class RegexField(CharField):\nCode replaced for brevity.\n524: \n525: \n526: \n527: class EmailField(CharField):\nCode replaced for brevity.\n532: \n533: \n534: \n535: class FileField(Field):\nCode replaced for brevity.\n599: \n600: \n601: \n602: class ImageField(FileField):\nCode replaced for brevity.\n658: \n659: \n660: \n661: class URLField(CharField):\nCode replaced for brevity.\n700: \n701: \n702: \n703: class BooleanField(Field):\nCode replaced for brevity.\n727: \n728: \n729: \n730: class NullBooleanField(BooleanField):\nCode replaced for brevity.\n754: \n755: \n756: \n757: class CallableChoiceIterator:\nCode replaced for brevity.\n762: \n763: \n764: \n765: class ChoiceField(Field):\nCode replaced for brevity.\n824: \n825: \n826: \n827: class TypedChoiceField(ChoiceField):\nCode replaced for brevity.\n851: \n852: \n853: \n854: class MultipleChoiceField(ChoiceField):\nCode replaced for brevity.\n893: \n894: \n895: \n896: class TypedMultipleChoiceField(MultipleChoiceField):\nCode replaced for brevity.\n929: \n930: \n931: \n932: class ComboField(Field):\nCode replaced for brevity.\n953: \n954: \n955: \n956: class MultiValueField(Field):\nCode replaced for brevity.\n1081: \n1082: \n1083: \n1084: class FilePathField(ChoiceField):\nCode replaced for brevity.\n1125: \n1126: \n1127: \n1128: class SplitDateTimeField(MultiValueField):\nCode replaced for brevity.\n1161: \n1162: \n1163: \n1164: class GenericIPAddressField(CharField):\nCode replaced for brevity.\n1176: \n1177: \n1178: \n1179: class SlugField(CharField):\nCode replaced for brevity.\n1186: \n1187: \n1188: \n1189: class UUIDField(CharField):\nCode replaced for brevity.\n1208: \n1209: \n1210: \n1211: class InvalidJSONInput(str):\n1212:     pass\n1213: \n1214: \n1215: class JSONString(str):\n1216:     pass\n1217: \n1218: \n1219: class JSONField(CharField):\n1220:     default_error_messages = {\n1221:         'invalid': _('Enter a valid JSON.'),\n1222:     }\n1223:     widget = Textarea\n1224: \n1225:     def __init__(self, encoder=None, decoder=None, **kwargs):\n1226:         self.encoder = encoder\n1227:         self.decoder = decoder\n1228:         super().__init__(**kwargs)\n1229: \n1230:     def to_python(self, value):\n1231:         if self.disabled:\n1232:             return value\n1233:         if value in self.empty_values:\n1234:             return None\n1235:         elif isinstance(value, (list, dict, int, float, JSONString)):\n1236:             return value\n1237:         try:\n1238:             converted = json.loads(value, cls=self.decoder)\n1239:         except json.JSONDecodeError:\n1240:             raise ValidationError(\n1241:                 self.error_messages['invalid'],\n1242:                 code='invalid',\n1243:                 params={'value': value},\n1244:             )\n1245:         if isinstance(converted, str):\n1246:             return JSONString(converted)\n1247:         else:\n1248:             return converted\n1249: \n1250:     def bound_data(self, data, initial):\n1251:         if self.disabled:\n1252:             return initial\n1253:         try:\n1254:             return json.loads(data, cls=self.decoder)\n1255:         except json.JSONDecodeError:\n1256:             return InvalidJSONInput(data)\n1257: \n1258:     def prepare_value(self, value):\n1259:         if isinstance(value, InvalidJSONInput):\n1260:             return value\n1261:         return json.dumps(value, cls=self.encoder)\n1262: \n1263:     def has_changed(self, initial, data):\n1264:         if super().has_changed(initial, data):\n1265:             return True\n1266:         # For purposes of seeing whether something has changed, True isn't the\n1267:         # same as 1 and the order of keys doesn't matter.\n1268:         return (\n1269:             json.dumps(initial, sort_keys=True, cls=self.encoder) !=\n1270:             json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)\n1271:         )\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/utils.py",
      "suspect_lines": [
        403
      ]
    },
    {
      "filename": "/django/forms/fields.py",
      "suspect_lines": [
        1261
      ]
    }
  ]
}