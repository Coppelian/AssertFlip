{
  "instance_id": "mwaskom__seaborn-3187",
  "problem_statement": "Wrong legend values of large ranges\nAs of 0.12.1, legends describing large numbers that were created using `ScalarFormatter` with an offset are formatted without their multiplicative offset value. An example:\r\n```python\r\nimport seaborn as sns\r\nimport seaborn.objects as so\r\n\r\npenguins = sns.load_dataset(\"Penguins\")\r\npenguins[\"body_mass_mg\"] = penguins[\"body_mass_g\"]*1000\r\n(\r\n    so.Plot(\r\n        penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\r\n        color=\"species\", pointsize=\"body_mass_mg\",\r\n    )\r\n    .add(so.Dot())\r\n)\r\n```\r\nThe code creates the following plot:\r\n![image](https://user-images.githubusercontent.com/13831112/205512305-778966db-f8d8-43f3-a2c0-5e5ce95bae39.png)\r\nwhich is wrong because `body_mass_mg` is in the order of 1E6. The issue also reproduces if you create the mentioned plot using `scatterplot`.\r\n \r\nI believe the issue stems from not using the offset value of the `ScalarFormatter` used to generate the tick labels:\r\nhttps://github.com/mwaskom/seaborn/blob/ba786bc14eb255f6b4fb7619c8210c5a8016a26f/seaborn/_core/scales.py#L377-L382\r\nExamining the code of `ScalarFormatter` suggests the issue also depends on the following rcParam settings:\r\n`mpl.rcParams['axes.formatter.useoffset']`\r\n`mpl.rcParams['axes.formatter.offset_threshold']`\r\nHowever, I did not test it. \r\n\r\nThe offset value can be safely retrieved from all formatters and based on that it can be used to create the legend title and/or labels.\n",
  "localized_code": "[start of seaborn/_core/scales.py]\n1: from __future__ import annotations\n2: import re\n3: from copy import copy\n4: from collections.abc import Sequence\n5: from dataclasses import dataclass\n6: from functools import partial\n7: from typing import Any, Callable, Tuple, Optional, ClassVar\n8: \n9: import numpy as np\n10: import matplotlib as mpl\n11: from matplotlib.ticker import (\n12:     Locator,\n13:     Formatter,\n14:     AutoLocator,\n15:     AutoMinorLocator,\n16:     FixedLocator,\n17:     LinearLocator,\n18:     LogLocator,\n19:     SymmetricalLogLocator,\n20:     MaxNLocator,\n21:     MultipleLocator,\n22:     EngFormatter,\n23:     FuncFormatter,\n24:     LogFormatterSciNotation,\n25:     ScalarFormatter,\n26:     StrMethodFormatter,\n27: )\n28: from matplotlib.dates import (\n29:     AutoDateLocator,\n30:     AutoDateFormatter,\n31:     ConciseDateFormatter,\n32: )\n33: from matplotlib.axis import Axis\n34: from matplotlib.scale import ScaleBase\n35: from pandas import Series\n36: \n37: from seaborn._core.rules import categorical_order\n38: from seaborn._core.typing import Default, default\n39: \n40: from typing import TYPE_CHECKING\n41: if TYPE_CHECKING:\n42:     from seaborn._core.properties import Property\n43:     from numpy.typing import ArrayLike, NDArray\n44: \n45:     TransFuncs = Tuple[\n46:         Callable[[ArrayLike], ArrayLike], Callable[[ArrayLike], ArrayLike]\n47:     ]\n48: \n49:     # TODO Reverting typing to Any as it was proving too complicated to\n50:     # work out the right way to communicate the types to mypy. Revisit!\n51:     Pipeline = Sequence[Optional[Callable[[Any], Any]]]\n... Code Truncated ...\n\n[start of seaborn/utils.py]\n1: \"\"\"Utility functions, mostly for internal use.\"\"\"\n2: import os\n3: import re\n4: import inspect\n5: import warnings\n6: import colorsys\n7: from contextlib import contextmanager\n8: from urllib.request import urlopen, urlretrieve\n9: \n10: import numpy as np\n11: import pandas as pd\n12: import matplotlib as mpl\n13: from matplotlib.colors import to_rgb\n14: import matplotlib.pyplot as plt\n15: from matplotlib.cbook import normalize_kwargs\n16: \n17: from .external.version import Version\n18: from .external.appdirs import user_cache_dir\n19: \n20: __all__ = [\"desaturate\", \"saturate\", \"set_hls_values\", \"move_legend\",\n21:            \"despine\", \"get_dataset_names\", \"get_data_home\", \"load_dataset\"]\n22: \n23: \n24: def ci_to_errsize(cis, heights):\n25:     \"\"\"Convert intervals to error arguments relative to plot heights.\n26: \n27:     Parameters\n28:     ----------\n29:     cis : 2 x n sequence\n30:         sequence of confidence interval limits\n31:     heights : n sequence\n32:         sequence of plot heights\n33: \n34:     Returns\n35:     -------\n36:     errsize : 2 x n array\n37:         sequence of error size relative to height values in correct\n38:         format as argument for plt.bar\n39: \n40:     \"\"\"\n41:     cis = np.atleast_2d(cis).reshape(2, -1)\n42:     heights = np.atleast_1d(heights)\n43:     errsize = []\n44:     for i, (low, high) in enumerate(np.transpose(cis)):\n45:         h = heights[i]\n46:         elow = h - low\n47:         ehigh = high - h\n48:         errsize.append([elow, ehigh])\n49: \n50:     errsize = np.asarray(errsize).T\n51:     return errsize\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/seaborn/_core/scales.py",
      "suspect_lines": []
    },
    {
      "filename": "/seaborn/utils.py",
      "suspect_lines": []
    }
  ]
}