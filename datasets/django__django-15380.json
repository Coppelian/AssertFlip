{
  "instance_id": "django__django-15380",
  "problem_statement": "Migration autodetector crashes when renaming a model and field.\nDescription\n\t\nMigration autodetector crashes when renaming a model and field in a single step:\n$ python manage.py makemigrations\nDid you rename the test_one.MyModel model to MyModel2? [y/N] y\nTraceback (most recent call last):\n File \"manage.py\", line 22, in <module>\n\tmain()\n File \"manage.py\", line 18, in main\n\texecute_from_command_line(sys.argv)\n File \"/django/django/core/management/__init__.py\", line 419, in execute_from_command_line\n\tutility.execute()\n File \"/django/django/core/management/__init__.py\", line 413, in execute\n\tself.fetch_command(subcommand).run_from_argv(self.argv)\n File \"/django/django/core/management/base.py\", line 354, in run_from_argv\n\tself.execute(*args, **cmd_options)\n File \"/django/django/core/management/base.py\", line 398, in execute\n\toutput = self.handle(*args, **options)\n File \"/django/django/core/management/base.py\", line 89, in wrapped\n\tres = handle_func(*args, **kwargs)\n File \"/django/django/core/management/commands/makemigrations.py\", line 172, in handle\n\tchanges = autodetector.changes(\n File \"/django/django/db/migrations/autodetector.py\", line 43, in changes\n\tchanges = self._detect_changes(convert_apps, graph)\n File \"/django/django/db/migrations/autodetector.py\", line 182, in _detect_changes\n\tself.generate_renamed_fields()\n File \"/django/django/db/migrations/autodetector.py\", line 823, in generate_renamed_fields\n\tnew_model_state = self.to_state.models[app_label, old_model_name]\nKeyError: ('test_one', 'mymodel')\nReported by HoskeOwl.\nRegression in aa4acc164d1247c0de515c959f7b09648b57dc42.\n",
  "localized_code": "[start of django/db/migrations/autodetector.py]\n1: import functools\n2: import re\n3: from itertools import chain\n4: \n5: from django.conf import settings\n6: from django.db import models\n7: from django.db.migrations import operations\n8: from django.db.migrations.migration import Migration\n9: from django.db.migrations.operations.models import AlterModelOptions\n10: from django.db.migrations.optimizer import MigrationOptimizer\n11: from django.db.migrations.questioner import MigrationQuestioner\n12: from django.db.migrations.utils import (\n13:     COMPILED_REGEX_TYPE, RegexObject, resolve_relation,\n14: )\n15: from django.utils.topological_sort import stable_topological_sort\n16: \n17: \n18: class MigrationAutodetector:\n19:     \"\"\"\n20:     Take a pair of ProjectStates and compare them to see what the first would\n21:     need doing to make it match the second (the second usually being the\n22:     project's current state).\n23: \n24:     Note that this naturally operates on entire projects at a time,\n25:     as it's likely that changes interact (for example, you can't\n26:     add a ForeignKey without having a migration to add the table it\n27:     depends on first). A user interface may offer single-app usage\n28:     if it wishes, with the caveat that it may not always be possible.\n29:     \"\"\"\n30: \n31:     def __init__(self, from_state, to_state, questioner=None):\n32:         self.from_state = from_state\n33:         self.to_state = to_state\n34:         self.questioner = questioner or MigrationQuestioner()\n35:         self.existing_apps = {app for app, model in from_state.models}\n36: \n37:     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n38:         \"\"\"\n39:         Main entry point to produce a list of applicable changes.\n40:         Take a graph to base names on and an optional set of apps\n41:         to try and restrict to (restriction is not guaranteed)\n42:         \"\"\"\n43:         changes = self._detect_changes(convert_apps, graph)\n44:         changes = self.arrange_for_graph(changes, graph, migration_name)\n45:         if trim_to_apps:\n46:             changes = self._trim_to_apps(changes, trim_to_apps)\n47:         return changes\n48: \n49:     def deep_deconstruct(self, obj):\n50:         \"\"\"\n51:         Recursive deconstruction for a field and its arguments.\n52:         Used for full comparison for rename/alter; sometimes a single-level\n53:         deconstruction will not compare correctly.\n54:         \"\"\"\n55:         if isinstance(obj, list):\n56:             return [self.deep_deconstruct(value) for value in obj]\n57:         elif isinstance(obj, tuple):\n58:             return tuple(self.deep_deconstruct(value) for value in obj)\n59:         elif isinstance(obj, dict):\n60:             return {\n61:                 key: self.deep_deconstruct(value)\n62:                 for key, value in obj.items()\n63:             }\n64:         elif isinstance(obj, functools.partial):\n65:             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))\n66:         elif isinstance(obj, COMPILED_REGEX_TYPE):\n67:             return RegexObject(obj)\n68:         elif isinstance(obj, type):\n69:             # If this is a type that implements 'deconstruct' as an instance method,\n70:             # avoid treating this as being deconstructible itself - see #22951\n71:             return obj\n72:         elif hasattr(obj, 'deconstruct'):\n73:             deconstructed = obj.deconstruct()\n74:             if isinstance(obj, models.Field):\n75:                 # we have a field which also returns a name\n76:                 deconstructed = deconstructed[1:]\n77:             path, args, kwargs = deconstructed\n78:             return (\n79:                 path,\n80:                 [self.deep_deconstruct(value) for value in args],\n81:                 {\n82:                     key: self.deep_deconstruct(value)\n83:                     for key, value in kwargs.items()\n84:                 },\n85:             )\n86:         else:\n87:             return obj\n88: \n89:     def only_relation_agnostic_fields(self, fields):\n90:         \"\"\"\n91:         Return a definition of the fields that ignores field names and\n92:         what related fields actually relate to. Used for detecting renames (as\n93:         the related fields change during renames).\n94:         \"\"\"\n95:         fields_def = []\n96:         for name, field in sorted(fields.items()):\n97:             deconstruction = self.deep_deconstruct(field)\n98:             if field.remote_field and field.remote_field.model:\n99:                 deconstruction[2].pop('to', None)\n100:             fields_def.append(deconstruction)\n101:         return fields_def\n102: \n103:     def _detect_changes(self, convert_apps=None, graph=None):\n104:         \"\"\"\n105:         Return a dict of migration plans which will achieve the\n106:         change from from_state to to_state. The dict has app labels\n107:         as keys and a list of migrations as values.\n108: \n109:         The resulting migrations aren't specially named, but the names\n110:         do matter for dependencies inside the set.\n111: \n112:         convert_apps is the list of apps to convert to use migrations\n113:         (i.e. to make initial migrations for, in the usual case)\n114: \n115:         graph is an optional argument that, if provided, can help improve\n116:         dependency generation and avoid potential circular dependencies.\n117:         \"\"\"\n118:         # The first phase is generating all the operations for each app\n119:         # and gathering them into a big per-app list.\n120:         # Then go through that list, order it, and split into migrations to\n121:         # resolve dependencies caused by M2Ms and FKs.\n122:         self.generated_operations = {}\n123:         self.altered_indexes = {}\n124:         self.altered_constraints = {}\n125: \n126:         # Prepare some old/new state and model lists, separating\n127:         # proxy models and ignoring unmigrated apps.\n128:         self.old_model_keys = set()\n129:         self.old_proxy_keys = set()\n130:         self.old_unmanaged_keys = set()\n131:         self.new_model_keys = set()\n132:         self.new_proxy_keys = set()\n133:         self.new_unmanaged_keys = set()\n134:         for (app_label, model_name), model_state in self.from_state.models.items():\n135:             if not model_state.options.get('managed', True):\n136:                 self.old_unmanaged_keys.add((app_label, model_name))\n137:             elif app_label not in self.from_state.real_apps:\n138:                 if model_state.options.get('proxy'):\n139:                     self.old_proxy_keys.add((app_label, model_name))\n140:                 else:\n141:                     self.old_model_keys.add((app_label, model_name))\n142: \n143:         for (app_label, model_name), model_state in self.to_state.models.items():\n144:             if not model_state.options.get('managed', True):\n145:                 self.new_unmanaged_keys.add((app_label, model_name))\n146:             elif (\n147:                 app_label not in self.from_state.real_apps or\n148:                 (convert_apps and app_label in convert_apps)\n149:             ):\n150:                 if model_state.options.get('proxy'):\n151:                     self.new_proxy_keys.add((app_label, model_name))\n152:                 else:\n153:                     self.new_model_keys.add((app_label, model_name))\n154: \n155:         self.from_state.resolve_fields_and_relations()\n156:         self.to_state.resolve_fields_and_relations()\n157: \n158:         # Renames have to come first\n159:         self.generate_renamed_models()\n160: \n161:         # Prepare lists of fields and generate through model map\n162:         self._prepare_field_lists()\n163:         self._generate_through_model_map()\n164: \n165:         # Generate non-rename model operations\n166:         self.generate_deleted_models()\n167:         self.generate_created_models()\n168:         self.generate_deleted_proxies()\n169:         self.generate_created_proxies()\n170:         self.generate_altered_options()\n171:         self.generate_altered_managers()\n172: \n173:         # Create the altered indexes and store them in self.altered_indexes.\n174:         # This avoids the same computation in generate_removed_indexes()\n175:         # and generate_added_indexes().\n176:         self.create_altered_indexes()\n177:         self.create_altered_constraints()\n178:         # Generate index removal operations before field is removed\n179:         self.generate_removed_constraints()\n180:         self.generate_removed_indexes()\n181:         # Generate field renaming operations.\n182:         self.generate_renamed_fields()\n183:         # Generate removal of foo together.\n184:         self.generate_removed_altered_unique_together()\n185:         self.generate_removed_altered_index_together()\n186:         # Generate field operations.\n187:         self.generate_removed_fields()\n188:         self.generate_added_fields()\n189:         self.generate_altered_fields()\n190:         self.generate_altered_order_with_respect_to()\n191:         self.generate_altered_unique_together()\n192:         self.generate_altered_index_together()\n193:         self.generate_added_indexes()\n194:         self.generate_added_constraints()\n195:         self.generate_altered_db_table()\n196: \n197:         self._sort_migrations()\n198:         self._build_migration_list(graph)\n199:         self._optimize_migrations()\n200: \n201:         return self.migrations\n202: \n203:     def _prepare_field_lists(self):\n204:         \"\"\"\n205:         Prepare field lists and a list of the fields that used through models\n206:         in the old state so dependencies can be made from the through model\n207:         deletion to the field that uses it.\n208:         \"\"\"\n209:         self.kept_model_keys = self.old_model_keys & self.new_model_keys\n210:         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys\n211:         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys\n212:         self.through_users = {}\n213:         self.old_field_keys = {\n214:             (app_label, model_name, field_name)\n215:             for app_label, model_name in self.kept_model_keys\n216:             for field_name in self.from_state.models[\n217:                 app_label,\n218:                 self.renamed_models.get((app_label, model_name), model_name)\n219:             ].fields\n220:         }\n221:         self.new_field_keys = {\n222:             (app_label, model_name, field_name)\n223:             for app_label, model_name in self.kept_model_keys\n224:             for field_name in self.to_state.models[app_label, model_name].fields\n225:         }\n226: \n227:     def _generate_through_model_map(self):\n228:         \"\"\"Through model map generation.\"\"\"\n229:         for app_label, model_name in sorted(self.old_model_keys):\n230:             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n231:             old_model_state = self.from_state.models[app_label, old_model_name]\n232:             for field_name, field in old_model_state.fields.items():\n233:                 if hasattr(field, 'remote_field') and getattr(field.remote_field, 'through', None):\n234:                     through_key = resolve_relation(field.remote_field.through, app_label, model_name)\n235:                     self.through_users[through_key] = (app_label, old_model_name, field_name)\n236: \n237:     @staticmethod\n238:     def _resolve_dependency(dependency):\n239:         \"\"\"\n240:         Return the resolved dependency and a boolean denoting whether or not\n241:         it was swappable.\n242:         \"\"\"\n243:         if dependency[0] != '__setting__':\n244:             return dependency, False\n245:         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')\n246:         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True\n247: \n248:     def _build_migration_list(self, graph=None):\n249:         \"\"\"\n250:         Chop the lists of operations up into migrations with dependencies on\n251:         each other. Do this by going through an app's list of operations until\n252:         one is found that has an outgoing dependency that isn't in another\n253:         app's migration yet (hasn't been chopped off its list). Then chop off\n254:         the operations before it into a migration and move onto the next app.\n255:         If the loops completes without doing anything, there's a circular\n256:         dependency (which _should_ be impossible as the operations are\n257:         all split at this point so they can't depend and be depended on).\n258:         \"\"\"\n259:         self.migrations = {}\n260:         num_ops = sum(len(x) for x in self.generated_operations.values())\n261:         chop_mode = False\n262:         while num_ops:\n263:             # On every iteration, we step through all the apps and see if there\n264:             # is a completed set of operations.\n265:             # If we find that a subset of the operations are complete we can\n266:             # try to chop it off from the rest and continue, but we only\n267:             # do this if we've already been through the list once before\n268:             # without any chopping and nothing has changed.\n269:             for app_label in sorted(self.generated_operations):\n270:                 chopped = []\n271:                 dependencies = set()\n272:                 for operation in list(self.generated_operations[app_label]):\n273:                     deps_satisfied = True\n274:                     operation_dependencies = set()\n275:                     for dep in operation._auto_deps:\n276:                         # Temporarily resolve the swappable dependency to\n277:                         # prevent circular references. While keeping the\n278:                         # dependency checks on the resolved model, add the\n279:                         # swappable dependencies.\n280:                         original_dep = dep\n281:                         dep, is_swappable_dep = self._resolve_dependency(dep)\n282:                         if dep[0] != app_label:\n283:                             # External app dependency. See if it's not yet\n284:                             # satisfied.\n285:                             for other_operation in self.generated_operations.get(dep[0], []):\n286:                                 if self.check_dependency(other_operation, dep):\n287:                                     deps_satisfied = False\n288:                                     break\n289:                             if not deps_satisfied:\n290:                                 break\n291:                             else:\n292:                                 if is_swappable_dep:\n293:                                     operation_dependencies.add((original_dep[0], original_dep[1]))\n294:                                 elif dep[0] in self.migrations:\n295:                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))\n296:                                 else:\n297:                                     # If we can't find the other app, we add a first/last dependency,\n298:                                     # but only if we've already been through once and checked everything\n299:                                     if chop_mode:\n300:                                         # If the app already exists, we add a dependency on the last migration,\n301:                                         # as we don't know which migration contains the target field.\n302:                                         # If it's not yet migrated or has no migrations, we use __first__\n303:                                         if graph and graph.leaf_nodes(dep[0]):\n304:                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])\n305:                                         else:\n306:                                             operation_dependencies.add((dep[0], \"__first__\"))\n307:                                     else:\n308:                                         deps_satisfied = False\n309:                     if deps_satisfied:\n310:                         chopped.append(operation)\n311:                         dependencies.update(operation_dependencies)\n312:                         del self.generated_operations[app_label][0]\n313:                     else:\n314:                         break\n315:                 # Make a migration! Well, only if there's stuff to put in it\n316:                 if dependencies or chopped:\n317:                     if not self.generated_operations[app_label] or chop_mode:\n318:                         subclass = type(\"Migration\", (Migration,), {\"operations\": [], \"dependencies\": []})\n319:                         instance = subclass(\"auto_%i\" % (len(self.migrations.get(app_label, [])) + 1), app_label)\n320:                         instance.dependencies = list(dependencies)\n321:                         instance.operations = chopped\n322:                         instance.initial = app_label not in self.existing_apps\n323:                         self.migrations.setdefault(app_label, []).append(instance)\n324:                         chop_mode = False\n325:                     else:\n326:                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]\n327:             new_num_ops = sum(len(x) for x in self.generated_operations.values())\n328:             if new_num_ops == num_ops:\n329:                 if not chop_mode:\n330:                     chop_mode = True\n331:                 else:\n332:                     raise ValueError(\"Cannot resolve operation dependencies: %r\" % self.generated_operations)\n333:             num_ops = new_num_ops\n334: \n335:     def _sort_migrations(self):\n336:         \"\"\"\n337:         Reorder to make things possible. Reordering may be needed so FKs work\n338:         nicely inside the same app.\n339:         \"\"\"\n340:         for app_label, ops in sorted(self.generated_operations.items()):\n341:             # construct a dependency graph for intra-app dependencies\n342:             dependency_graph = {op: set() for op in ops}\n343:             for op in ops:\n344:                 for dep in op._auto_deps:\n345:                     # Resolve intra-app dependencies to handle circular\n346:                     # references involving a swappable model.\n347:                     dep = self._resolve_dependency(dep)[0]\n348:                     if dep[0] == app_label:\n349:                         for op2 in ops:\n350:                             if self.check_dependency(op2, dep):\n351:                                 dependency_graph[op].add(op2)\n352: \n353:             # we use a stable sort for deterministic tests & general behavior\n354:             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)\n355: \n356:     def _optimize_migrations(self):\n357:         # Add in internal dependencies among the migrations\n358:         for app_label, migrations in self.migrations.items():\n359:             for m1, m2 in zip(migrations, migrations[1:]):\n360:                 m2.dependencies.append((app_label, m1.name))\n361: \n362:         # De-dupe dependencies\n363:         for migrations in self.migrations.values():\n364:             for migration in migrations:\n365:                 migration.dependencies = list(set(migration.dependencies))\n366: \n367:         # Optimize migrations\n368:         for app_label, migrations in self.migrations.items():\n369:             for migration in migrations:\n370:                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)\n371: \n372:     def check_dependency(self, operation, dependency):\n373:         \"\"\"\n374:         Return True if the given operation depends on the given dependency,\n375:         False otherwise.\n376:         \"\"\"\n377:         # Created model\n378:         if dependency[2] is None and dependency[3] is True:\n379:             return (\n380:                 isinstance(operation, operations.CreateModel) and\n381:                 operation.name_lower == dependency[1].lower()\n382:             )\n383:         # Created field\n384:         elif dependency[2] is not None and dependency[3] is True:\n385:             return (\n386:                 (\n387:                     isinstance(operation, operations.CreateModel) and\n388:                     operation.name_lower == dependency[1].lower() and\n389:                     any(dependency[2] == x for x, y in operation.fields)\n390:                 ) or\n391:                 (\n392:                     isinstance(operation, operations.AddField) and\n393:                     operation.model_name_lower == dependency[1].lower() and\n394:                     operation.name_lower == dependency[2].lower()\n395:                 )\n396:             )\n397:         # Removed field\n398:         elif dependency[2] is not None and dependency[3] is False:\n399:             return (\n400:                 isinstance(operation, operations.RemoveField) and\n401:                 operation.model_name_lower == dependency[1].lower() and\n402:                 operation.name_lower == dependency[2].lower()\n403:             )\n404:         # Removed model\n405:         elif dependency[2] is None and dependency[3] is False:\n406:             return (\n407:                 isinstance(operation, operations.DeleteModel) and\n408:                 operation.name_lower == dependency[1].lower()\n409:             )\n410:         # Field being altered\n411:         elif dependency[2] is not None and dependency[3] == \"alter\":\n412:             return (\n413:                 isinstance(operation, operations.AlterField) and\n414:                 operation.model_name_lower == dependency[1].lower() and\n415:                 operation.name_lower == dependency[2].lower()\n416:             )\n417:         # order_with_respect_to being unset for a field\n418:         elif dependency[2] is not None and dependency[3] == \"order_wrt_unset\":\n419:             return (\n420:                 isinstance(operation, operations.AlterOrderWithRespectTo) and\n421:                 operation.name_lower == dependency[1].lower() and\n422:                 (operation.order_with_respect_to or \"\").lower() != dependency[2].lower()\n423:             )\n424:         # Field is removed and part of an index/unique_together\n425:         elif dependency[2] is not None and dependency[3] == \"foo_together_change\":\n426:             return (\n427:                 isinstance(operation, (operations.AlterUniqueTogether,\n428:                                        operations.AlterIndexTogether)) and\n429:                 operation.name_lower == dependency[1].lower()\n430:             )\n431:         # Unknown dependency. Raise an error.\n432:         else:\n433:             raise ValueError(\"Can't handle dependency %r\" % (dependency,))\n434: \n435:     def add_operation(self, app_label, operation, dependencies=None, beginning=False):\n436:         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)\n437:         operation._auto_deps = dependencies or []\n438:         if beginning:\n439:             self.generated_operations.setdefault(app_label, []).insert(0, operation)\n440:         else:\n441:             self.generated_operations.setdefault(app_label, []).append(operation)\n442: \n443:     def swappable_first_key(self, item):\n444:         \"\"\"\n445:         Place potential swappable models first in lists of created models (only\n446:         real way to solve #22783).\n447:         \"\"\"\n448:         try:\n449:             model_state = self.to_state.models[item]\n450:             base_names = {\n451:                 base if isinstance(base, str) else base.__name__\n452:                 for base in model_state.bases\n453:             }\n454:             string_version = \"%s.%s\" % (item[0], item[1])\n455:             if (\n456:                 model_state.options.get('swappable') or\n457:                 \"AbstractUser\" in base_names or\n458:                 \"AbstractBaseUser\" in base_names or\n459:                 settings.AUTH_USER_MODEL.lower() == string_version.lower()\n460:             ):\n461:                 return (\"___\" + item[0], \"___\" + item[1])\n462:         except LookupError:\n463:             pass\n464:         return item\n465: \n466:     def generate_renamed_models(self):\n467:         \"\"\"\n468:         Find any renamed models, generate the operations for them, and remove\n469:         the old entry from the model lists. Must be run before other\n470:         model-level generation.\n471:         \"\"\"\n472:         self.renamed_models = {}\n473:         self.renamed_models_rel = {}\n474:         added_models = self.new_model_keys - self.old_model_keys\n475:         for app_label, model_name in sorted(added_models):\n476:             model_state = self.to_state.models[app_label, model_name]\n477:             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)\n478: \n479:             removed_models = self.old_model_keys - self.new_model_keys\n480:             for rem_app_label, rem_model_name in removed_models:\n481:                 if rem_app_label == app_label:\n482:                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]\n483:                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)\n484:                     if model_fields_def == rem_model_fields_def:\n485:                         if self.questioner.ask_rename_model(rem_model_state, model_state):\n486:                             dependencies = []\n487:                             fields = list(model_state.fields.values()) + [\n488:                                 field.remote_field\n489:                                 for relations in self.to_state.relations[app_label, model_name].values()\n490:                                 for field in relations.values()\n491:                             ]\n492:                             for field in fields:\n493:                                 if field.is_relation:\n494:                                     dependencies.extend(\n495:                                         self._get_dependencies_for_foreign_key(\n496:                                             app_label, model_name, field, self.to_state,\n497:                                         )\n498:                                     )\n499:                             self.add_operation(\n500:                                 app_label,\n501:                                 operations.RenameModel(\n502:                                     old_name=rem_model_state.name,\n503:                                     new_name=model_state.name,\n504:                                 ),\n505:                                 dependencies=dependencies,\n506:                             )\n507:                             self.renamed_models[app_label, model_name] = rem_model_name\n508:                             renamed_models_rel_key = '%s.%s' % (\n509:                                 rem_model_state.app_label,\n510:                                 rem_model_state.name_lower,\n511:                             )\n512:                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (\n513:                                 model_state.app_label,\n514:                                 model_state.name_lower,\n515:                             )\n516:                             self.old_model_keys.remove((rem_app_label, rem_model_name))\n517:                             self.old_model_keys.add((app_label, model_name))\n518:                             break\n519: \n520:     def generate_created_models(self):\n521:         \"\"\"\n522:         Find all new models (both managed and unmanaged) and make create\n523:         operations for them as well as separate operations to create any\n524:         foreign key or M2M relationships (these are optimized later, if\n525:         possible).\n526: \n527:         Defer any model options that refer to collections of fields that might\n528:         be deferred (e.g. unique_together, index_together).\n529:         \"\"\"\n530:         old_keys = self.old_model_keys | self.old_unmanaged_keys\n531:         added_models = self.new_model_keys - old_keys\n532:         added_unmanaged_models = self.new_unmanaged_keys - old_keys\n533:         all_added_models = chain(\n534:             sorted(added_models, key=self.swappable_first_key, reverse=True),\n535:             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)\n536:         )\n537:         for app_label, model_name in all_added_models:\n538:             model_state = self.to_state.models[app_label, model_name]\n539:             # Gather related fields\n540:             related_fields = {}\n541:             primary_key_rel = None\n542:             for field_name, field in model_state.fields.items():\n543:                 if field.remote_field:\n544:                     if field.remote_field.model:\n545:                         if field.primary_key:\n546:                             primary_key_rel = field.remote_field.model\n547:                         elif not field.remote_field.parent_link:\n548:                             related_fields[field_name] = field\n549:                     if getattr(field.remote_field, 'through', None):\n550:                         related_fields[field_name] = field\n551: \n552:             # Are there indexes/unique|index_together to defer?\n553:             indexes = model_state.options.pop('indexes')\n554:             constraints = model_state.options.pop('constraints')\n555:             unique_together = model_state.options.pop('unique_together', None)\n556:             index_together = model_state.options.pop('index_together', None)\n557:             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)\n558:             # Depend on the deletion of any possible proxy version of us\n559:             dependencies = [\n560:                 (app_label, model_name, None, False),\n561:             ]\n562:             # Depend on all bases\n563:             for base in model_state.bases:\n564:                 if isinstance(base, str) and \".\" in base:\n565:                     base_app_label, base_name = base.split(\".\", 1)\n566:                     dependencies.append((base_app_label, base_name, None, True))\n567:                     # Depend on the removal of base fields if the new model has\n568:                     # a field with the same name.\n569:                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))\n570:                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))\n571:                     if old_base_model_state and new_base_model_state:\n572:                         removed_base_fields = set(old_base_model_state.fields).difference(\n573:                             new_base_model_state.fields,\n574:                         ).intersection(model_state.fields)\n575:                         for removed_base_field in removed_base_fields:\n576:                             dependencies.append((base_app_label, base_name, removed_base_field, False))\n577:             # Depend on the other end of the primary key if it's a relation\n578:             if primary_key_rel:\n579:                 dependencies.append(\n580:                     resolve_relation(\n581:                         primary_key_rel, app_label, model_name,\n582:                     ) + (None, True)\n583:                 )\n584:             # Generate creation operation\n585:             self.add_operation(\n586:                 app_label,\n587:                 operations.CreateModel(\n588:                     name=model_state.name,\n589:                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],\n590:                     options=model_state.options,\n591:                     bases=model_state.bases,\n592:                     managers=model_state.managers,\n593:                 ),\n594:                 dependencies=dependencies,\n595:                 beginning=True,\n596:             )\n597: \n598:             # Don't add operations which modify the database for unmanaged models\n599:             if not model_state.options.get('managed', True):\n600:                 continue\n601: \n602:             # Generate operations for each related field\n603:             for name, field in sorted(related_fields.items()):\n604:                 dependencies = self._get_dependencies_for_foreign_key(\n605:                     app_label, model_name, field, self.to_state,\n606:                 )\n607:                 # Depend on our own model being created\n608:                 dependencies.append((app_label, model_name, None, True))\n609:                 # Make operation\n610:                 self.add_operation(\n611:                     app_label,\n612:                     operations.AddField(\n613:                         model_name=model_name,\n614:                         name=name,\n615:                         field=field,\n616:                     ),\n617:                     dependencies=list(set(dependencies)),\n618:                 )\n619:             # Generate other opns\n620:             if order_with_respect_to:\n621:                 self.add_operation(\n622:                     app_label,\n623:                     operations.AlterOrderWithRespectTo(\n624:                         name=model_name,\n625:                         order_with_respect_to=order_with_respect_to,\n626:                     ),\n627:                     dependencies=[\n628:                         (app_label, model_name, order_with_respect_to, True),\n629:                         (app_label, model_name, None, True),\n630:                     ]\n631:                 )\n632:             related_dependencies = [\n633:                 (app_label, model_name, name, True)\n634:                 for name in sorted(related_fields)\n635:             ]\n636:             related_dependencies.append((app_label, model_name, None, True))\n637:             for index in indexes:\n638:                 self.add_operation(\n639:                     app_label,\n640:                     operations.AddIndex(\n641:                         model_name=model_name,\n642:                         index=index,\n643:                     ),\n644:                     dependencies=related_dependencies,\n645:                 )\n646:             for constraint in constraints:\n647:                 self.add_operation(\n648:                     app_label,\n649:                     operations.AddConstraint(\n650:                         model_name=model_name,\n651:                         constraint=constraint,\n652:                     ),\n653:                     dependencies=related_dependencies,\n654:                 )\n655:             if unique_together:\n656:                 self.add_operation(\n657:                     app_label,\n658:                     operations.AlterUniqueTogether(\n659:                         name=model_name,\n660:                         unique_together=unique_together,\n661:                     ),\n662:                     dependencies=related_dependencies\n663:                 )\n664:             if index_together:\n665:                 self.add_operation(\n666:                     app_label,\n667:                     operations.AlterIndexTogether(\n668:                         name=model_name,\n669:                         index_together=index_together,\n670:                     ),\n671:                     dependencies=related_dependencies\n672:                 )\n673:             # Fix relationships if the model changed from a proxy model to a\n674:             # concrete model.\n675:             relations = self.to_state.relations\n676:             if (app_label, model_name) in self.old_proxy_keys:\n677:                 for related_model_key, related_fields in relations[app_label, model_name].items():\n678:                     related_model_state = self.to_state.models[related_model_key]\n679:                     for related_field_name, related_field in related_fields.items():\n680:                         self.add_operation(\n681:                             related_model_state.app_label,\n682:                             operations.AlterField(\n683:                                 model_name=related_model_state.name,\n684:                                 name=related_field_name,\n685:                                 field=related_field,\n686:                             ),\n687:                             dependencies=[(app_label, model_name, None, True)],\n688:                         )\n689: \n690:     def generate_created_proxies(self):\n691:         \"\"\"\n692:         Make CreateModel statements for proxy models. Use the same statements\n693:         as that way there's less code duplication, but for proxy models it's\n694:         safe to skip all the pointless field stuff and chuck out an operation.\n695:         \"\"\"\n696:         added = self.new_proxy_keys - self.old_proxy_keys\n697:         for app_label, model_name in sorted(added):\n698:             model_state = self.to_state.models[app_label, model_name]\n699:             assert model_state.options.get(\"proxy\")\n700:             # Depend on the deletion of any possible non-proxy version of us\n701:             dependencies = [\n702:                 (app_label, model_name, None, False),\n703:             ]\n704:             # Depend on all bases\n705:             for base in model_state.bases:\n706:                 if isinstance(base, str) and \".\" in base:\n707:                     base_app_label, base_name = base.split(\".\", 1)\n708:                     dependencies.append((base_app_label, base_name, None, True))\n709:             # Generate creation operation\n710:             self.add_operation(\n711:                 app_label,\n712:                 operations.CreateModel(\n713:                     name=model_state.name,\n714:                     fields=[],\n715:                     options=model_state.options,\n716:                     bases=model_state.bases,\n717:                     managers=model_state.managers,\n718:                 ),\n719:                 # Depend on the deletion of any possible non-proxy version of us\n720:                 dependencies=dependencies,\n721:             )\n722: \n723:     def generate_deleted_models(self):\n724:         \"\"\"\n725:         Find all deleted models (managed and unmanaged) and make delete\n726:         operations for them as well as separate operations to delete any\n727:         foreign key or M2M relationships (these are optimized later, if\n728:         possible).\n729: \n730:         Also bring forward removal of any model options that refer to\n731:         collections of fields - the inverse of generate_created_models().\n732:         \"\"\"\n733:         new_keys = self.new_model_keys | self.new_unmanaged_keys\n734:         deleted_models = self.old_model_keys - new_keys\n735:         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys\n736:         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))\n737:         for app_label, model_name in all_deleted_models:\n738:             model_state = self.from_state.models[app_label, model_name]\n739:             # Gather related fields\n740:             related_fields = {}\n741:             for field_name, field in model_state.fields.items():\n742:                 if field.remote_field:\n743:                     if field.remote_field.model:\n744:                         related_fields[field_name] = field\n745:                     if getattr(field.remote_field, 'through', None):\n746:                         related_fields[field_name] = field\n747:             # Generate option removal first\n748:             unique_together = model_state.options.pop('unique_together', None)\n749:             index_together = model_state.options.pop('index_together', None)\n750:             if unique_together:\n751:                 self.add_operation(\n752:                     app_label,\n753:                     operations.AlterUniqueTogether(\n754:                         name=model_name,\n755:                         unique_together=None,\n756:                     )\n757:                 )\n758:             if index_together:\n759:                 self.add_operation(\n760:                     app_label,\n761:                     operations.AlterIndexTogether(\n762:                         name=model_name,\n763:                         index_together=None,\n764:                     )\n765:                 )\n766:             # Then remove each related field\n767:             for name in sorted(related_fields):\n768:                 self.add_operation(\n769:                     app_label,\n770:                     operations.RemoveField(\n771:                         model_name=model_name,\n772:                         name=name,\n773:                     )\n774:                 )\n775:             # Finally, remove the model.\n776:             # This depends on both the removal/alteration of all incoming fields\n777:             # and the removal of all its own related fields, and if it's\n778:             # a through model the field that references it.\n779:             dependencies = []\n780:             relations = self.from_state.relations\n781:             for (related_object_app_label, object_name), relation_related_fields in (\n782:                 relations[app_label, model_name].items()\n783:             ):\n784:                 for field_name, field in relation_related_fields.items():\n785:                     dependencies.append(\n786:                         (related_object_app_label, object_name, field_name, False),\n787:                     )\n788:                     if not field.many_to_many:\n789:                         dependencies.append(\n790:                             (related_object_app_label, object_name, field_name, 'alter'),\n791:                         )\n792: \n793:             for name in sorted(related_fields):\n794:                 dependencies.append((app_label, model_name, name, False))\n795:             # We're referenced in another field's through=\n796:             through_user = self.through_users.get((app_label, model_state.name_lower))\n797:             if through_user:\n798:                 dependencies.append((through_user[0], through_user[1], through_user[2], False))\n799:             # Finally, make the operation, deduping any dependencies\n800:             self.add_operation(\n801:                 app_label,\n802:                 operations.DeleteModel(\n803:                     name=model_state.name,\n804:                 ),\n805:                 dependencies=list(set(dependencies)),\n806:             )\n807: \n808:     def generate_deleted_proxies(self):\n809:         \"\"\"Make DeleteModel options for proxy models.\"\"\"\n810:         deleted = self.old_proxy_keys - self.new_proxy_keys\n811:         for app_label, model_name in sorted(deleted):\n812:             model_state = self.from_state.models[app_label, model_name]\n813:             assert model_state.options.get(\"proxy\")\n814:             self.add_operation(\n815:                 app_label,\n816:                 operations.DeleteModel(\n817:                     name=model_state.name,\n818:                 ),\n819:             )\n820: \n821:     def generate_renamed_fields(self):\n822:         \"\"\"Work out renamed fields.\"\"\"\n823:         self.renamed_fields = {}\n824:         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):\n825:             old_model_name = self.renamed_models.get((app_label, model_name), model_name)\n826:             old_model_state = self.from_state.models[app_label, old_model_name]\n827:             new_model_state = self.to_state.models[app_label, old_model_name]\n828:             field = new_model_state.get_field(field_name)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/autodetector.py",
      "suspect_lines": [
        827
      ]
    }
  ]
}