{
  "instance_id": "sympy__sympy-16597",
  "problem_statement": "a.is_even does not imply a.is_finite\nI'm not sure what the right answer is here:\r\n```julia\r\nIn [1]: m = Symbol('m', even=True)                                                                                                             \r\n\r\nIn [2]: m.is_finite                                                                                                                            \r\n\r\nIn [3]: print(m.is_finite)                                                                                                                     \r\nNone\r\n```\r\nI would expect that a number should be finite before it can be even.\n",
  "localized_code": "[start of sympy/assumptions/ask.py]\n1: \"\"\"Module for querying SymPy objects about assumptions.\"\"\"\n2: from __future__ import print_function, division\n3: \n4: from sympy.assumptions.assume import (global_assumptions, Predicate,\n5:         AppliedPredicate)\n6: from sympy.core import sympify\n7: from sympy.core.cache import cacheit\n8: from sympy.core.decorators import deprecated\n9: from sympy.core.relational import Relational\n10: from sympy.logic.boolalg import (to_cnf, And, Not, Or, Implies, Equivalent,\n11:     BooleanFunction, BooleanAtom)\n12: from sympy.logic.inference import satisfiable\n13: from sympy.utilities.decorator import memoize_property\n14: \n15: \n16: # Deprecated predicates should be added to this list\n17: deprecated_predicates = [\n18:     'bounded',\n19:     'infinity',\n20:     'infinitesimal'\n21: ]\n22: \n23: # Memoization storage for predicates\n24: predicate_storage = {}\n25: predicate_memo = memoize_property(predicate_storage)\n26: # Memoization is necessary for the properties of AssumptionKeys to\n27: # ensure that only one object of Predicate objects are created.\n28: # This is because assumption handlers are registered on those objects.\n29: \n30: \n31: class AssumptionKeys(object):\n32:     \"\"\"\n33:     This class contains all the supported keys by ``ask``.\n34:     \"\"\"\n35: \n36:     @predicate_memo\n37:     def hermitian(self):\n38:         \"\"\"\n39:         Hermitian predicate.\n40: \n41:         ``ask(Q.hermitian(x))`` is true iff ``x`` belongs to the set of\n42:         Hermitian operators.\n43: \n44:         References\n45:         ==========\n46: \n47:         .. [1] http://mathworld.wolfram.com/HermitianOperator.html\n48: \n49:         \"\"\"\n50:         # TODO: Add examples\n51:         return Predicate('hermitian')\n52: \n53:     @predicate_memo\n54:     def antihermitian(self):\n55:         \"\"\"\n56:         Antihermitian predicate.\n57: \n58:         ``Q.antihermitian(x)`` is true iff ``x`` belongs to the field of\n59:         antihermitian operators, i.e., operators in the form ``x*I``, where\n60:         ``x`` is Hermitian.\n61: \n62:         References\n63:         ==========\n64: \n65:         .. [1] http://mathworld.wolfram.com/HermitianOperator.html\n66: \n67:         \"\"\"\n68:         # TODO: Add examples\n69:         return Predicate('antihermitian')\n70: \n71:     @predicate_memo\n72:     def real(self):\n73:         r\"\"\"\n74:         Real number predicate.\n75: \n76:         ``Q.real(x)`` is true iff ``x`` is a real number, i.e., it is in the\n77:         interval `(-\\infty, \\infty)`.  Note that, in particular the infinities\n78:         are not real. Use ``Q.extended_real`` if you want to consider those as\n79:         well.\n80: \n81:         A few important facts about reals:\n82: \n83:         - Every real number is positive, negative, or zero.  Furthermore,\n84:           because these sets are pairwise disjoint, each real number is exactly\n85:           one of those three.\n86: \n87:         - Every real number is also complex.\n88: \n89:         - Every real number is finite.\n90: \n91:         - Every real number is either rational or irrational.\n92: \n93:         - Every real number is either algebraic or transcendental.\n94: \n95:         - The facts ``Q.negative``, ``Q.zero``, ``Q.positive``,\n96:           ``Q.nonnegative``, ``Q.nonpositive``, ``Q.nonzero``, ``Q.integer``,\n97:           ``Q.rational``, and ``Q.irrational`` all imply ``Q.real``, as do all\n98:           facts that imply those facts.\n99: \n100:         - The facts ``Q.algebraic``, and ``Q.transcendental`` do not imply\n101:           ``Q.real``; they imply ``Q.complex``. An algebraic or transcendental\n102:           number may or may not be real.\n103: \n104:         - The \"non\" facts (i.e., ``Q.nonnegative``, ``Q.nonzero``,\n105:           ``Q.nonpositive`` and ``Q.noninteger``) are not equivalent to not the\n106:           fact, but rather, not the fact *and* ``Q.real``.  For example,\n107:           ``Q.nonnegative`` means ``~Q.negative & Q.real``. So for example,\n108:           ``I`` is not nonnegative, nonzero, or nonpositive.\n109: \n110:         Examples\n111:         ========\n112: \n113:         >>> from sympy import Q, ask, symbols\n114:         >>> x = symbols('x')\n115:         >>> ask(Q.real(x), Q.positive(x))\n116:         True\n117:         >>> ask(Q.real(0))\n118:         True\n119: \n120:         References\n121:         ==========\n122: \n123:         .. [1] https://en.wikipedia.org/wiki/Real_number\n124: \n125:         \"\"\"\n126:         return Predicate('real')\n127: \n128:     @predicate_memo\n129:     def extended_real(self):\n130:         r\"\"\"\n131:         Extended real predicate.\n132: \n133:         ``Q.extended_real(x)`` is true iff ``x`` is a real number or\n134:         `\\{-\\infty, \\infty\\}`.\n135: \n136:         See documentation of ``Q.real`` for more information about related facts.\n137: \n138:         Examples\n139:         ========\n140: \n141:         >>> from sympy import ask, Q, oo, I\n142:         >>> ask(Q.extended_real(1))\n143:         True\n144:         >>> ask(Q.extended_real(I))\n145:         False\n146:         >>> ask(Q.extended_real(oo))\n147:         True\n148: \n149:         \"\"\"\n150:         return Predicate('extended_real')\n151: \n152:     @predicate_memo\n153:     def imaginary(self):\n154:         \"\"\"\n155:         Imaginary number predicate.\n156: \n157:         ``Q.imaginary(x)`` is true iff ``x`` can be written as a real\n158:         number multiplied by the imaginary unit ``I``. Please note that ``0``\n159:         is not considered to be an imaginary number.\n160: \n161:         Examples\n162:         ========\n163: \n164:         >>> from sympy import Q, ask, I\n165:         >>> ask(Q.imaginary(3*I))\n166:         True\n167:         >>> ask(Q.imaginary(2 + 3*I))\n168:         False\n169:         >>> ask(Q.imaginary(0))\n170:         False\n171: \n172:         References\n173:         ==========\n174: \n175:         .. [1] https://en.wikipedia.org/wiki/Imaginary_number\n176: \n177:         \"\"\"\n178:         return Predicate('imaginary')\n179: \n180:     @predicate_memo\n181:     def complex(self):\n182:         \"\"\"\n183:         Complex number predicate.\n184: \n185:         ``Q.complex(x)`` is true iff ``x`` belongs to the set of complex\n186:         numbers. Note that every complex number is finite.\n187: \n188:         Examples\n189:         ========\n190: \n191:         >>> from sympy import Q, Symbol, ask, I, oo\n192:         >>> x = Symbol('x')\n193:         >>> ask(Q.complex(0))\n194:         True\n195:         >>> ask(Q.complex(2 + 3*I))\n196:         True\n197:         >>> ask(Q.complex(oo))\n198:         False\n199: \n200:         References\n201:         ==========\n202: \n203:         .. [1] https://en.wikipedia.org/wiki/Complex_number\n204: \n205:         \"\"\"\n206:         return Predicate('complex')\n207: \n208:     @predicate_memo\n209:     def algebraic(self):\n210:         r\"\"\"\n211:         Algebraic number predicate.\n212: \n213:         ``Q.algebraic(x)`` is true iff ``x`` belongs to the set of\n214:         algebraic numbers. ``x`` is algebraic if there is some polynomial\n215:         in ``p(x)\\in \\mathbb\\{Q\\}[x]`` such that ``p(x) = 0``.\n216: \n217:         Examples\n218:         ========\n219: \n220:         >>> from sympy import ask, Q, sqrt, I, pi\n221:         >>> ask(Q.algebraic(sqrt(2)))\n222:         True\n223:         >>> ask(Q.algebraic(I))\n224:         True\n225:         >>> ask(Q.algebraic(pi))\n226:         False\n227: \n228:         References\n229:         ==========\n230: \n231:         .. [1] https://en.wikipedia.org/wiki/Algebraic_number\n232:         \"\"\"\n233:         return Predicate('algebraic')\n234: \n235:     @predicate_memo\n236:     def transcendental(self):\n237:         \"\"\"\n238:         Transcedental number predicate.\n239: \n240:         ``Q.transcendental(x)`` is true iff ``x`` belongs to the set of\n241:         transcendental numbers. A transcendental number is a real\n242:         or complex number that is not algebraic.\n243: \n244:         \"\"\"\n245:         # TODO: Add examples\n246:         return Predicate('transcendental')\n247: \n248:     @predicate_memo\n249:     def integer(self):\n250:         \"\"\"\n251:         Integer predicate.\n252: \n253:         ``Q.integer(x)`` is true iff ``x`` belongs to the set of integer numbers.\n254: \n255:         Examples\n256:         ========\n257: \n258:         >>> from sympy import Q, ask, S\n259:         >>> ask(Q.integer(5))\n260:         True\n261:         >>> ask(Q.integer(S(1)/2))\n262:         False\n263: \n264:         References\n265:         ==========\n266: \n267:         .. [1] https://en.wikipedia.org/wiki/Integer\n268: \n269:         \"\"\"\n270:         return Predicate('integer')\n271: \n272:     @predicate_memo\n273:     def rational(self):\n274:         \"\"\"\n275:         Rational number predicate.\n276: \n277:         ``Q.rational(x)`` is true iff ``x`` belongs to the set of\n278:         rational numbers.\n279: \n280:         Examples\n281:         ========\n282: \n283:         >>> from sympy import ask, Q, pi, S\n284:         >>> ask(Q.rational(0))\n285:         True\n286:         >>> ask(Q.rational(S(1)/2))\n287:         True\n288:         >>> ask(Q.rational(pi))\n289:         False\n290: \n291:         References\n292:         ==========\n293: \n294:         https://en.wikipedia.org/wiki/Rational_number\n295: \n296:         \"\"\"\n297:         return Predicate('rational')\n298: \n299:     @predicate_memo\n300:     def irrational(self):\n301:         \"\"\"\n302:         Irrational number predicate.\n303: \n304:         ``Q.irrational(x)`` is true iff ``x``  is any real number that\n305:         cannot be expressed as a ratio of integers.\n306: \n307:         Examples\n308:         ========\n309: \n310:         >>> from sympy import ask, Q, pi, S, I\n311:         >>> ask(Q.irrational(0))\n312:         False\n313:         >>> ask(Q.irrational(S(1)/2))\n314:         False\n315:         >>> ask(Q.irrational(pi))\n316:         True\n317:         >>> ask(Q.irrational(I))\n318:         False\n319: \n320:         References\n321:         ==========\n322: \n323:         .. [1] https://en.wikipedia.org/wiki/Irrational_number\n324: \n325:         \"\"\"\n326:         return Predicate('irrational')\n327: \n328:     @predicate_memo\n329:     def finite(self):\n330:         \"\"\"\n331:         Finite predicate.\n332: \n333:         ``Q.finite(x)`` is true if ``x`` is neither an infinity\n334:         nor a ``NaN``. In other words, ``ask(Q.finite(x))`` is true for all ``x``\n335:         having a bounded absolute value.\n336: \n337:         Examples\n338:         ========\n339: \n340:         >>> from sympy import Q, ask, Symbol, S, oo, I\n341:         >>> x = Symbol('x')\n342:         >>> ask(Q.finite(S.NaN))\n343:         False\n344:         >>> ask(Q.finite(oo))\n345:         False\n346:         >>> ask(Q.finite(1))\n347:         True\n348:         >>> ask(Q.finite(2 + 3*I))\n349:         True\n350: \n351:         References\n352:         ==========\n353: \n354:         .. [1] https://en.wikipedia.org/wiki/Finite\n355: \n356:         \"\"\"\n357:         return Predicate('finite')\n358: \n359:     @predicate_memo\n360:     @deprecated(useinstead=\"finite\", issue=9425, deprecated_since_version=\"1.0\")\n361:     def bounded(self):\n362:         \"\"\"\n363:         See documentation of ``Q.finite``.\n364:         \"\"\"\n365:         return Predicate('finite')\n366: \n367:     @predicate_memo\n368:     def infinite(self):\n369:         \"\"\"\n370:         Infinite number predicate.\n371: \n372:         ``Q.infinite(x)`` is true iff the absolute value of ``x`` is\n373:         infinity.\n374: \n375:         \"\"\"\n376:         # TODO: Add examples\n377:         return Predicate('infinite')\n378: \n379:     @predicate_memo\n380:     @deprecated(useinstead=\"infinite\", issue=9426, deprecated_since_version=\"1.0\")\n381:     def infinity(self):\n382:         \"\"\"\n383:         See documentation of ``Q.infinite``.\n384:         \"\"\"\n385:         return Predicate('infinite')\n386: \n387:     @predicate_memo\n388:     @deprecated(useinstead=\"zero\", issue=9675, deprecated_since_version=\"1.0\")\n389:     def infinitesimal(self):\n390:         \"\"\"\n391:         See documentation of ``Q.zero``.\n392:         \"\"\"\n393:         return Predicate('zero')\n394: \n395:     @predicate_memo\n396:     def positive(self):\n397:         r\"\"\"\n398:         Positive real number predicate.\n399: \n400:         ``Q.positive(x)`` is true iff ``x`` is real and `x > 0`, that is if ``x``\n401:         is in the interval `(0, \\infty)`.  In particular, infinity is not\n402:         positive.\n403: \n404:         A few important facts about positive numbers:\n405: \n406:         - Note that ``Q.nonpositive`` and ``~Q.positive`` are *not* the same\n407:           thing. ``~Q.positive(x)`` simply means that ``x`` is not positive,\n408:           whereas ``Q.nonpositive(x)`` means that ``x`` is real and not\n409:           positive, i.e., ``Q.nonpositive(x)`` is logically equivalent to\n410:           `Q.negative(x) | Q.zero(x)``.  So for example, ``~Q.positive(I)`` is\n411:           true, whereas ``Q.nonpositive(I)`` is false.\n412: \n413:         - See the documentation of ``Q.real`` for more information about\n414:           related facts.\n415: \n416:         Examples\n417:         ========\n418: \n419:         >>> from sympy import Q, ask, symbols, I\n420:         >>> x = symbols('x')\n421:         >>> ask(Q.positive(x), Q.real(x) & ~Q.negative(x) & ~Q.zero(x))\n422:         True\n423:         >>> ask(Q.positive(1))\n424:         True\n425:         >>> ask(Q.nonpositive(I))\n426:         False\n427:         >>> ask(~Q.positive(I))\n428:         True\n429: \n430:         \"\"\"\n431:         return Predicate('positive')\n432: \n433:     @predicate_memo\n434:     def negative(self):\n435:         r\"\"\"\n436:         Negative number predicate.\n437: \n438:         ``Q.negative(x)`` is true iff ``x`` is a real number and :math:`x < 0`, that is,\n439:         it is in the interval :math:`(-\\infty, 0)`.  Note in particular that negative\n440:         infinity is not negative.\n441: \n442:         A few important facts about negative numbers:\n443: \n444:         - Note that ``Q.nonnegative`` and ``~Q.negative`` are *not* the same\n445:           thing. ``~Q.negative(x)`` simply means that ``x`` is not negative,\n446:           whereas ``Q.nonnegative(x)`` means that ``x`` is real and not\n447:           negative, i.e., ``Q.nonnegative(x)`` is logically equivalent to\n448:           ``Q.zero(x) | Q.positive(x)``.  So for example, ``~Q.negative(I)`` is\n449:           true, whereas ``Q.nonnegative(I)`` is false.\n450: \n451:         - See the documentation of ``Q.real`` for more information about\n452:           related facts.\n453: \n454:         Examples\n455:         ========\n456: \n457:         >>> from sympy import Q, ask, symbols, I\n458:         >>> x = symbols('x')\n459:         >>> ask(Q.negative(x), Q.real(x) & ~Q.positive(x) & ~Q.zero(x))\n460:         True\n461:         >>> ask(Q.negative(-1))\n462:         True\n463:         >>> ask(Q.nonnegative(I))\n464:         False\n465:         >>> ask(~Q.negative(I))\n466:         True\n467: \n468:         \"\"\"\n469:         return Predicate('negative')\n470: \n471:     @predicate_memo\n472:     def zero(self):\n473:         \"\"\"\n474:         Zero number predicate.\n475: \n476:         ``ask(Q.zero(x))`` is true iff the value of ``x`` is zero.\n477: \n478:         Examples\n479:         ========\n480: \n481:         >>> from sympy import ask, Q, oo, symbols\n482:         >>> x, y = symbols('x, y')\n483:         >>> ask(Q.zero(0))\n484:         True\n485:         >>> ask(Q.zero(1/oo))\n486:         True\n487:         >>> ask(Q.zero(0*oo))\n488:         False\n489:         >>> ask(Q.zero(1))\n490:         False\n491:         >>> ask(Q.zero(x*y), Q.zero(x) | Q.zero(y))\n492:         True\n493: \n494:         \"\"\"\n495:         return Predicate('zero')\n496: \n497:     @predicate_memo\n498:     def nonzero(self):\n499:         \"\"\"\n500:         Nonzero real number predicate.\n501: \n502:         ``ask(Q.nonzero(x))`` is true iff ``x`` is real and ``x`` is not zero.  Note in\n503:         particular that ``Q.nonzero(x)`` is false if ``x`` is not real.  Use\n504:         ``~Q.zero(x)`` if you want the negation of being zero without any real\n505:         assumptions.\n506: \n507:         A few important facts about nonzero numbers:\n508: \n509:         - ``Q.nonzero`` is logically equivalent to ``Q.positive | Q.negative``.\n510: \n511:         - See the documentation of ``Q.real`` for more information about\n512:           related facts.\n513: \n514:         Examples\n515:         ========\n516: \n517:         >>> from sympy import Q, ask, symbols, I, oo\n518:         >>> x = symbols('x')\n519:         >>> print(ask(Q.nonzero(x), ~Q.zero(x)))\n520:         None\n521:         >>> ask(Q.nonzero(x), Q.positive(x))\n522:         True\n523:         >>> ask(Q.nonzero(x), Q.zero(x))\n524:         False\n525:         >>> ask(Q.nonzero(0))\n526:         False\n527:         >>> ask(Q.nonzero(I))\n528:         False\n529:         >>> ask(~Q.zero(I))\n530:         True\n531:         >>> ask(Q.nonzero(oo))  #doctest: +SKIP\n532:         False\n533: \n534:         \"\"\"\n535:         return Predicate('nonzero')\n536: \n537:     @predicate_memo\n538:     def nonpositive(self):\n539:         \"\"\"\n540:         Nonpositive real number predicate.\n541: \n542:         ``ask(Q.nonpositive(x))`` is true iff ``x`` belongs to the set of\n543:         negative numbers including zero.\n544: \n545:         - Note that ``Q.nonpositive`` and ``~Q.positive`` are *not* the same\n546:           thing. ``~Q.positive(x)`` simply means that ``x`` is not positive,\n547:           whereas ``Q.nonpositive(x)`` means that ``x`` is real and not\n548:           positive, i.e., ``Q.nonpositive(x)`` is logically equivalent to\n549:           `Q.negative(x) | Q.zero(x)``.  So for example, ``~Q.positive(I)`` is\n550:           true, whereas ``Q.nonpositive(I)`` is false.\n551: \n552:         Examples\n553:         ========\n554: \n555:         >>> from sympy import Q, ask, I\n556:         >>> ask(Q.nonpositive(-1))\n557:         True\n558:         >>> ask(Q.nonpositive(0))\n559:         True\n560:         >>> ask(Q.nonpositive(1))\n561:         False\n562:         >>> ask(Q.nonpositive(I))\n563:         False\n564:         >>> ask(Q.nonpositive(-I))\n565:         False\n566: \n567:         \"\"\"\n568:         return Predicate('nonpositive')\n569: \n570:     @predicate_memo\n571:     def nonnegative(self):\n572:         \"\"\"\n573:         Nonnegative real number predicate.\n574: \n575:         ``ask(Q.nonnegative(x))`` is true iff ``x`` belongs to the set of\n576:         positive numbers including zero.\n577: \n578:         - Note that ``Q.nonnegative`` and ``~Q.negative`` are *not* the same\n579:           thing. ``~Q.negative(x)`` simply means that ``x`` is not negative,\n580:           whereas ``Q.nonnegative(x)`` means that ``x`` is real and not\n581:           negative, i.e., ``Q.nonnegative(x)`` is logically equivalent to\n582:           ``Q.zero(x) | Q.positive(x)``.  So for example, ``~Q.negative(I)`` is\n583:           true, whereas ``Q.nonnegative(I)`` is false.\n584: \n585:         Examples\n586:         ========\n587: \n588:         >>> from sympy import Q, ask, I\n589:         >>> ask(Q.nonnegative(1))\n590:         True\n591:         >>> ask(Q.nonnegative(0))\n592:         True\n593:         >>> ask(Q.nonnegative(-1))\n594:         False\n595:         >>> ask(Q.nonnegative(I))\n596:         False\n597:         >>> ask(Q.nonnegative(-I))\n598:         False\n599: \n600:         \"\"\"\n601:         return Predicate('nonnegative')\n602: \n603:     @predicate_memo\n604:     def even(self):\n605:         \"\"\"\n606:         Even number predicate.\n607: \n608:         ``ask(Q.even(x))`` is true iff ``x`` belongs to the set of even\n609:         integers.\n610: \n611:         Examples\n612:         ========\n613: \n614:         >>> from sympy import Q, ask, pi\n615:         >>> ask(Q.even(0))\n616:         True\n617:         >>> ask(Q.even(2))\n618:         True\n619:         >>> ask(Q.even(3))\n620:         False\n621:         >>> ask(Q.even(pi))\n622:         False\n623: \n624:         \"\"\"\n625:         return Predicate('even')\n626: \n627:     @predicate_memo\n628:     def odd(self):\n629:         \"\"\"\n630:         Odd number predicate.\n631: \n632:         ``ask(Q.odd(x))`` is true iff ``x`` belongs to the set of odd numbers.\n633: \n634:         Examples\n635:         ========\n636: \n637:         >>> from sympy import Q, ask, pi\n638:         >>> ask(Q.odd(0))\n639:         False\n640:         >>> ask(Q.odd(2))\n641:         False\n642:         >>> ask(Q.odd(3))\n643:         True\n644:         >>> ask(Q.odd(pi))\n645:         False\n646: \n647:         \"\"\"\n648:         return Predicate('odd')\n649: \n650:     @predicate_memo\n651:     def prime(self):\n652:         \"\"\"\n653:         Prime number predicate.\n654: \n655:         ``ask(Q.prime(x))`` is true iff ``x`` is a natural number greater\n656:         than 1 that has no positive divisors other than ``1`` and the\n657:         number itself.\n658: \n659:         Examples\n660:         ========\n661: \n662:         >>> from sympy import Q, ask\n663:         >>> ask(Q.prime(0))\n664:         False\n665:         >>> ask(Q.prime(1))\n666:         False\n667:         >>> ask(Q.prime(2))\n668:         True\n669:         >>> ask(Q.prime(20))\n670:         False\n671:         >>> ask(Q.prime(-3))\n672:         False\n673: \n674:         \"\"\"\n675:         return Predicate('prime')\n676: \n677:     @predicate_memo\n678:     def composite(self):\n679:         \"\"\"\n680:         Composite number predicate.\n681: \n682:         ``ask(Q.composite(x))`` is true iff ``x`` is a positive integer and has\n683:         at least one positive divisor other than ``1`` and the number itself.\n684: \n685:         Examples\n686:         ========\n687: \n688:         >>> from sympy import Q, ask\n689:         >>> ask(Q.composite(0))\n690:         False\n691:         >>> ask(Q.composite(1))\n692:         False\n693:         >>> ask(Q.composite(2))\n694:         False\n695:         >>> ask(Q.composite(20))\n696:         True\n697: \n698:         \"\"\"\n699:         return Predicate('composite')\n700: \n701:     @predicate_memo\n702:     def commutative(self):\n703:         \"\"\"\n704:         Commutative predicate.\n705: \n706:         ``ask(Q.commutative(x))`` is true iff ``x`` commutes with any other\n707:         object with respect to multiplication operation.\n708: \n709:         \"\"\"\n710:         # TODO: Add examples\n711:         return Predicate('commutative')\n712: \n713:     @predicate_memo\n714:     def is_true(self):\n715:         \"\"\"\n716:         Generic predicate.\n717: \n718:         ``ask(Q.is_true(x))`` is true iff ``x`` is true. This only makes\n719:         sense if ``x`` is a predicate.\n720: \n721:         Examples\n722:         ========\n723: \n724:         >>> from sympy import ask, Q, symbols\n725:         >>> x = symbols('x')\n726:         >>> ask(Q.is_true(True))\n727:         True\n728: \n729:         \"\"\"\n730:         return Predicate('is_true')\n731: \n732:     @predicate_memo\n733:     def symmetric(self):\n734:         \"\"\"\n735:         Symmetric matrix predicate.\n736: \n737:         ``Q.symmetric(x)`` is true iff ``x`` is a square matrix and is equal to\n738:         its transpose. Every square diagonal matrix is a symmetric matrix.\n739: \n740:         Examples\n741:         ========\n742: \n743:         >>> from sympy import Q, ask, MatrixSymbol\n744:         >>> X = MatrixSymbol('X', 2, 2)\n745:         >>> Y = MatrixSymbol('Y', 2, 3)\n746:         >>> Z = MatrixSymbol('Z', 2, 2)\n747:         >>> ask(Q.symmetric(X*Z), Q.symmetric(X) & Q.symmetric(Z))\n748:         True\n749:         >>> ask(Q.symmetric(X + Z), Q.symmetric(X) & Q.symmetric(Z))\n750:         True\n751:         >>> ask(Q.symmetric(Y))\n752:         False\n753: \n754: \n755:         References\n756:         ==========\n757: \n758:         .. [1] https://en.wikipedia.org/wiki/Symmetric_matrix\n759: \n760:         \"\"\"\n761:         # TODO: Add handlers to make these keys work with\n762:         # actual matrices and add more examples in the docstring.\n763:         return Predicate('symmetric')\n764: \n765:     @predicate_memo\n766:     def invertible(self):\n767:         \"\"\"\n768:         Invertible matrix predicate.\n769: \n770:         ``Q.invertible(x)`` is true iff ``x`` is an invertible matrix.\n771:         A square matrix is called invertible only if its determinant is 0.\n772: \n773:         Examples\n774:         ========\n775: \n776:         >>> from sympy import Q, ask, MatrixSymbol\n777:         >>> X = MatrixSymbol('X', 2, 2)\n778:         >>> Y = MatrixSymbol('Y', 2, 3)\n779:         >>> Z = MatrixSymbol('Z', 2, 2)\n780:         >>> ask(Q.invertible(X*Y), Q.invertible(X))\n781:         False\n782:         >>> ask(Q.invertible(X*Z), Q.invertible(X) & Q.invertible(Z))\n783:         True\n784:         >>> ask(Q.invertible(X), Q.fullrank(X) & Q.square(X))\n785:         True\n786: \n787:         References\n788:         ==========\n789: \n790:         .. [1] https://en.wikipedia.org/wiki/Invertible_matrix\n791: \n792:         \"\"\"\n793:         return Predicate('invertible')\n794: \n795:     @predicate_memo\n796:     def orthogonal(self):\n797:         \"\"\"\n798:         Orthogonal matrix predicate.\n799: \n800:         ``Q.orthogonal(x)`` is true iff ``x`` is an orthogonal matrix.\n801:         A square matrix ``M`` is an orthogonal matrix if it satisfies\n802:         ``M^TM = MM^T = I`` where ``M^T`` is the transpose matrix of\n803:         ``M`` and ``I`` is an identity matrix. Note that an orthogonal\n804:         matrix is necessarily invertible.\n805: \n806:         Examples\n807:         ========\n808: \n809:         >>> from sympy import Q, ask, MatrixSymbol, Identity\n810:         >>> X = MatrixSymbol('X', 2, 2)\n811:         >>> Y = MatrixSymbol('Y', 2, 3)\n812:         >>> Z = MatrixSymbol('Z', 2, 2)\n813:         >>> ask(Q.orthogonal(Y))\n814:         False\n815:         >>> ask(Q.orthogonal(X*Z*X), Q.orthogonal(X) & Q.orthogonal(Z))\n816:         True\n817:         >>> ask(Q.orthogonal(Identity(3)))\n818:         True\n819:         >>> ask(Q.invertible(X), Q.orthogonal(X))\n820:         True\n821: \n822:         References\n823:         ==========\n824: \n825:         .. [1] https://en.wikipedia.org/wiki/Orthogonal_matrix\n826: \n827:         \"\"\"\n828:         return Predicate('orthogonal')\n829: \n830:     @predicate_memo\n831:     def unitary(self):\n832:         \"\"\"\n833:         Unitary matrix predicate.\n834: \n835:         ``Q.unitary(x)`` is true iff ``x`` is a unitary matrix.\n836:         Unitary matrix is an analogue to orthogonal matrix. A square\n837:         matrix ``M`` with complex elements is unitary if :math:``M^TM = MM^T= I``\n838:         where :math:``M^T`` is the conjugate transpose matrix of ``M``.\n839: \n840:         Examples\n841:         ========\n842: \n843:         >>> from sympy import Q, ask, MatrixSymbol, Identity\n844:         >>> X = MatrixSymbol('X', 2, 2)\n845:         >>> Y = MatrixSymbol('Y', 2, 3)\n846:         >>> Z = MatrixSymbol('Z', 2, 2)\n847:         >>> ask(Q.unitary(Y))\n848:         False\n849:         >>> ask(Q.unitary(X*Z*X), Q.unitary(X) & Q.unitary(Z))\n850:         True\n851:         >>> ask(Q.unitary(Identity(3)))\n852:         True\n853: \n854:         References\n855:         ==========\n856: \n857:         .. [1] https://en.wikipedia.org/wiki/Unitary_matrix\n858: \n859:         \"\"\"\n860:         return Predicate('unitary')\n861: \n862:     @predicate_memo\n863:     def positive_definite(self):\n864:         r\"\"\"\n865:         Positive definite matrix predicate.\n866: \n867:         If ``M`` is a :math:``n \\times n`` symmetric real matrix, it is said\n868:         to be positive definite if :math:`Z^TMZ` is positive for\n869:         every non-zero column vector ``Z`` of ``n`` real numbers.\n870: \n871:         Examples\n872:         ========\n873: \n874:         >>> from sympy import Q, ask, MatrixSymbol, Identity\n875:         >>> X = MatrixSymbol('X', 2, 2)\n876:         >>> Y = MatrixSymbol('Y', 2, 3)\n877:         >>> Z = MatrixSymbol('Z', 2, 2)\n878:         >>> ask(Q.positive_definite(Y))\n879:         False\n880:         >>> ask(Q.positive_definite(Identity(3)))\n881:         True\n882:         >>> ask(Q.positive_definite(X + Z), Q.positive_definite(X) &\n883:         ...     Q.positive_definite(Z))\n884:         True\n885: \n886:         References\n887:         ==========\n888: \n889:         .. [1] https://en.wikipedia.org/wiki/Positive-definite_matrix\n890: \n891:         \"\"\"\n892:         return Predicate('positive_definite')\n893: \n894:     @predicate_memo\n895:     def upper_triangular(self):\n896:         \"\"\"\n897:         Upper triangular matrix predicate.\n898: \n899:         A matrix ``M`` is called upper triangular matrix if :math:`M_{ij}=0`\n900:         for :math:`i<j`.\n901: \n902:         Examples\n903:         ========\n904: \n905:         >>> from sympy import Q, ask, ZeroMatrix, Identity\n906:         >>> ask(Q.upper_triangular(Identity(3)))\n907:         True\n908:         >>> ask(Q.upper_triangular(ZeroMatrix(3, 3)))\n909:         True\n910: \n911:         References\n912:         ==========\n913: \n914:         .. [1] http://mathworld.wolfram.com/UpperTriangularMatrix.html\n915: \n916:         \"\"\"\n917:         return Predicate('upper_triangular')\n918: \n919:     @predicate_memo\n920:     def lower_triangular(self):\n921:         \"\"\"\n922:         Lower triangular matrix predicate.\n923: \n924:         A matrix ``M`` is called lower triangular matrix if :math:`a_{ij}=0`\n925:         for :math:`i>j`.\n926: \n927:         Examples\n928:         ========\n929: \n930:         >>> from sympy import Q, ask, ZeroMatrix, Identity\n931:         >>> ask(Q.lower_triangular(Identity(3)))\n932:         True\n933:         >>> ask(Q.lower_triangular(ZeroMatrix(3, 3)))\n934:         True\n935: \n936:         References\n937:         ==========\n938: \n939:         .. [1] http://mathworld.wolfram.com/LowerTriangularMatrix.html\n940:         \"\"\"\n941:         return Predicate('lower_triangular')\n942: \n943:     @predicate_memo\n944:     def diagonal(self):\n945:         \"\"\"\n946:         Diagonal matrix predicate.\n947: \n948:         ``Q.diagonal(x)`` is true iff ``x`` is a diagonal matrix. A diagonal\n949:         matrix is a matrix in which the entries outside the main diagonal\n950:         are all zero.\n951: \n952:         Examples\n953:         ========\n954: \n955:         >>> from sympy import Q, ask, MatrixSymbol, ZeroMatrix\n956:         >>> X = MatrixSymbol('X', 2, 2)\n957:         >>> ask(Q.diagonal(ZeroMatrix(3, 3)))\n958:         True\n959:         >>> ask(Q.diagonal(X), Q.lower_triangular(X) &\n960:         ...     Q.upper_triangular(X))\n961:         True\n962: \n963:         References\n964:         ==========\n965: \n966:         .. [1] https://en.wikipedia.org/wiki/Diagonal_matrix\n967: \n968:         \"\"\"\n969:         return Predicate('diagonal')\n970: \n971:     @predicate_memo\n972:     def fullrank(self):\n973:         \"\"\"\n974:         Fullrank matrix predicate.\n975: \n976:         ``Q.fullrank(x)`` is true iff ``x`` is a full rank matrix.\n977:         A matrix is full rank if all rows and columns of the matrix\n978:         are linearly independent. A square matrix is full rank iff\n979:         its determinant is nonzero.\n980: \n981:         Examples\n982:         ========\n983: \n984:         >>> from sympy import Q, ask, MatrixSymbol, ZeroMatrix, Identity\n985:         >>> X = MatrixSymbol('X', 2, 2)\n986:         >>> ask(Q.fullrank(X.T), Q.fullrank(X))\n987:         True\n988:         >>> ask(Q.fullrank(ZeroMatrix(3, 3)))\n989:         False\n990:         >>> ask(Q.fullrank(Identity(3)))\n991:         True\n992: \n993:         \"\"\"\n994:         return Predicate('fullrank')\n995: \n996:     @predicate_memo\n997:     def square(self):\n998:         \"\"\"\n999:         Square matrix predicate.\n1000: \n1001:         ``Q.square(x)`` is true iff ``x`` is a square matrix. A square matrix\n1002:         is a matrix with the same number of rows and columns.\n1003: \n1004:         Examples\n1005:         ========\n1006: \n1007:         >>> from sympy import Q, ask, MatrixSymbol, ZeroMatrix, Identity\n1008:         >>> X = MatrixSymbol('X', 2, 2)\n1009:         >>> Y = MatrixSymbol('X', 2, 3)\n1010:         >>> ask(Q.square(X))\n1011:         True\n1012:         >>> ask(Q.square(Y))\n1013:         False\n1014:         >>> ask(Q.square(ZeroMatrix(3, 3)))\n1015:         True\n1016:         >>> ask(Q.square(Identity(3)))\n1017:         True\n1018: \n1019:         References\n1020:         ==========\n1021: \n1022:         .. [1] https://en.wikipedia.org/wiki/Square_matrix\n1023: \n1024:         \"\"\"\n1025:         return Predicate('square')\n1026: \n1027:     @predicate_memo\n1028:     def integer_elements(self):\n1029:         \"\"\"\n1030:         Integer elements matrix predicate.\n1031: \n1032:         ``Q.integer_elements(x)`` is true iff all the elements of ``x``\n1033:         are integers.\n1034: \n1035:         Examples\n1036:         ========\n1037: \n1038:         >>> from sympy import Q, ask, MatrixSymbol\n1039:         >>> X = MatrixSymbol('X', 4, 4)\n1040:         >>> ask(Q.integer(X[1, 2]), Q.integer_elements(X))\n1041:         True\n1042: \n1043:         \"\"\"\n1044:         return Predicate('integer_elements')\n1045: \n1046:     @predicate_memo\n1047:     def real_elements(self):\n1048:         \"\"\"\n1049:         Real elements matrix predicate.\n1050: \n1051:         ``Q.real_elements(x)`` is true iff all the elements of ``x``\n1052:         are real numbers.\n1053: \n1054:         Examples\n1055:         ========\n1056: \n1057:         >>> from sympy import Q, ask, MatrixSymbol\n1058:         >>> X = MatrixSymbol('X', 4, 4)\n1059:         >>> ask(Q.real(X[1, 2]), Q.real_elements(X))\n1060:         True\n1061: \n1062:         \"\"\"\n1063:         return Predicate('real_elements')\n1064: \n1065:     @predicate_memo\n1066:     def complex_elements(self):\n1067:         \"\"\"\n1068:         Complex elements matrix predicate.\n1069: \n1070:         ``Q.complex_elements(x)`` is true iff all the elements of ``x``\n1071:         are complex numbers.\n1072: \n1073:         Examples\n1074:         ========\n1075: \n1076:         >>> from sympy import Q, ask, MatrixSymbol\n1077:         >>> X = MatrixSymbol('X', 4, 4)\n1078:         >>> ask(Q.complex(X[1, 2]), Q.complex_elements(X))\n1079:         True\n1080:         >>> ask(Q.complex_elements(X), Q.integer_elements(X))\n1081:         True\n1082: \n1083:         \"\"\"\n1084:         return Predicate('complex_elements')\n1085: \n1086:     @predicate_memo\n1087:     def singular(self):\n1088:         \"\"\"\n1089:         Singular matrix predicate.\n1090: \n1091:         A matrix is singular iff the value of its determinant is 0.\n1092: \n1093:         Examples\n1094:         ========\n1095: \n1096:         >>> from sympy import Q, ask, MatrixSymbol\n1097:         >>> X = MatrixSymbol('X', 4, 4)\n1098:         >>> ask(Q.singular(X), Q.invertible(X))\n1099:         False\n1100:         >>> ask(Q.singular(X), ~Q.invertible(X))\n1101:         True\n1102: \n1103:         References\n1104:         ==========\n1105: \n1106:         .. [1] http://mathworld.wolfram.com/SingularMatrix.html\n1107: \n1108:         \"\"\"\n1109:         return Predicate('singular')\n1110: \n1111:     @predicate_memo\n1112:     def normal(self):\n1113:         \"\"\"\n1114:         Normal matrix predicate.\n1115: \n1116:         A matrix is normal if it commutes with its conjugate transpose.\n1117: \n1118:         Examples\n1119:         ========\n1120: \n1121:         >>> from sympy import Q, ask, MatrixSymbol\n1122:         >>> X = MatrixSymbol('X', 4, 4)\n1123:         >>> ask(Q.normal(X), Q.unitary(X))\n1124:         True\n1125: \n1126:         References\n1127:         ==========\n1128: \n1129:         .. [1] https://en.wikipedia.org/wiki/Normal_matrix\n1130: \n1131:         \"\"\"\n1132:         return Predicate('normal')\n1133: \n1134:     @predicate_memo\n1135:     def triangular(self):\n1136:         \"\"\"\n1137:         Triangular matrix predicate.\n1138: \n1139:         ``Q.triangular(X)`` is true if ``X`` is one that is either lower\n1140:         triangular or upper triangular.\n1141: \n1142:         Examples\n1143:         ========\n1144:         >>> from sympy import Q, ask, MatrixSymbol\n1145:         >>> X = MatrixSymbol('X', 4, 4)\n1146:         >>> ask(Q.triangular(X), Q.upper_triangular(X))\n1147:         True\n1148:         >>> ask(Q.triangular(X), Q.lower_triangular(X))\n1149:         True\n1150: \n1151:         References\n1152:         ==========\n1153: \n1154:         .. [1] https://en.wikipedia.org/wiki/Triangular_matrix\n1155: \n1156:         \"\"\"\n1157:         return Predicate('triangular')\n1158: \n1159:     @predicate_memo\n1160:     def unit_triangular(self):\n1161:         \"\"\"\n1162:         Unit triangular matrix predicate.\n1163: \n1164:         A unit triangular matrix is a triangular matrix with 1s\n1165:         on the diagonal.\n1166: \n1167:         Examples\n1168:         ========\n1169: \n1170:         >>> from sympy import Q, ask, MatrixSymbol\n1171:         >>> X = MatrixSymbol('X', 4, 4)\n1172:         >>> ask(Q.triangular(X), Q.unit_triangular(X))\n1173:         True\n1174: \n1175:         \"\"\"\n1176:         return Predicate('unit_triangular')\n1177: \n1178: \n1179: Q = AssumptionKeys()\n1180: \n1181: def _extract_facts(expr, symbol, check_reversed_rel=True):\nCode replaced for brevity.\n1211: \n1212: \n1213: \n1214: def ask(proposition, assumptions=True, context=global_assumptions):\nCode replaced for brevity.\n1308: \n1309: \n1310: \n1311: def ask_full_inference(proposition, assumptions, known_facts_cnf):\nCode replaced for brevity.\n1320: \n1321: \n1322: \n1323: def register_handler(key, handler):\nCode replaced for brevity.\n1347: \n1348: \n1349: \n1350: def remove_handler(key, handler):\nCode replaced for brevity.\n1354: \n1355: \n1356: \n1357:     # Compute the quick lookup for single facts\nCode replaced for brevity.\n1366: \n1367: \n1368: \n1369: def compute_known_facts(known_facts, known_facts_keys):\nCode replaced for brevity.\n1420: \n1421: \n1422: # handlers tells us what ask handler we should use\n1423: # for a particular key\n1424: _val_template = 'sympy.assumptions.handlers.%s'\n1425: _handlers = [\n1426:     (\"antihermitian\",     \"sets.AskAntiHermitianHandler\"),\n1427:     (\"finite\",           \"calculus.AskFiniteHandler\"),\n1428:     (\"commutative\",       \"AskCommutativeHandler\"),\n1429:     (\"complex\",           \"sets.AskComplexHandler\"),\n1430:     (\"composite\",         \"ntheory.AskCompositeHandler\"),\n1431:     (\"even\",              \"ntheory.AskEvenHandler\"),\n1432:     (\"extended_real\",     \"sets.AskExtendedRealHandler\"),\n1433:     (\"hermitian\",         \"sets.AskHermitianHandler\"),\n1434:     (\"imaginary\",         \"sets.AskImaginaryHandler\"),\n1435:     (\"integer\",           \"sets.AskIntegerHandler\"),\n1436:     (\"irrational\",        \"sets.AskIrrationalHandler\"),\n1437:     (\"rational\",          \"sets.AskRationalHandler\"),\n1438:     (\"negative\",          \"order.AskNegativeHandler\"),\n1439:     (\"nonzero\",           \"order.AskNonZeroHandler\"),\n1440:     (\"nonpositive\",       \"order.AskNonPositiveHandler\"),\n1441:     (\"nonnegative\",       \"order.AskNonNegativeHandler\"),\n1442:     (\"zero\",              \"order.AskZeroHandler\"),\n1443:     (\"positive\",          \"order.AskPositiveHandler\"),\n1444:     (\"prime\",             \"ntheory.AskPrimeHandler\"),\n1445:     (\"real\",              \"sets.AskRealHandler\"),\n1446:     (\"odd\",               \"ntheory.AskOddHandler\"),\n1447:     (\"algebraic\",         \"sets.AskAlgebraicHandler\"),\n1448:     (\"is_true\",           \"common.TautologicalHandler\"),\n1449:     (\"symmetric\",         \"matrices.AskSymmetricHandler\"),\n1450:     (\"invertible\",        \"matrices.AskInvertibleHandler\"),\n1451:     (\"orthogonal\",        \"matrices.AskOrthogonalHandler\"),\n1452:     (\"unitary\",           \"matrices.AskUnitaryHandler\"),\n1453:     (\"positive_definite\", \"matrices.AskPositiveDefiniteHandler\"),\n1454:     (\"upper_triangular\",  \"matrices.AskUpperTriangularHandler\"),\n1455:     (\"lower_triangular\",  \"matrices.AskLowerTriangularHandler\"),\n1456:     (\"diagonal\",          \"matrices.AskDiagonalHandler\"),\n1457:     (\"fullrank\",          \"matrices.AskFullRankHandler\"),\n1458:     (\"square\",            \"matrices.AskSquareHandler\"),\n1459:     (\"integer_elements\",  \"matrices.AskIntegerElementsHandler\"),\n1460:     (\"real_elements\",     \"matrices.AskRealElementsHandler\"),\n1461:     (\"complex_elements\",  \"matrices.AskComplexElementsHandler\"),\n1462: ]\n1463: \n1464: for name, value in _handlers:\n1465:     register_handler(name, _val_template % value)\n1466: \n1467: @cacheit\n1468: def get_known_facts_keys():\nCode replaced for brevity.\n1473: \n1474: \n1475: @cacheit\n1476: def get_known_facts():\n1477:     return And(\n1478:         Implies(Q.infinite, ~Q.finite),\n1479:         Implies(Q.real, Q.complex),\n1480:         Implies(Q.real, Q.hermitian),\n1481:         Equivalent(Q.extended_real, Q.real | Q.infinite),\n1482:         Equivalent(Q.even | Q.odd, Q.integer),\n1483:         Implies(Q.even, ~Q.odd),\n1484:         Equivalent(Q.prime, Q.integer & Q.positive & ~Q.composite),\n1485:         Implies(Q.integer, Q.rational),\n1486:         Implies(Q.rational, Q.algebraic),\n1487:         Implies(Q.algebraic, Q.complex),\n1488:         Equivalent(Q.transcendental | Q.algebraic, Q.complex),\n1489:         Implies(Q.transcendental, ~Q.algebraic),\n1490:         Implies(Q.imaginary, Q.complex & ~Q.real),\n1491:         Implies(Q.imaginary, Q.antihermitian),\n1492:         Implies(Q.antihermitian, ~Q.hermitian),\n1493:         Equivalent(Q.irrational | Q.rational, Q.real),\n1494:         Implies(Q.irrational, ~Q.rational),\n1495:         Implies(Q.zero, Q.even),\n1496: \n1497:         Equivalent(Q.real, Q.negative | Q.zero | Q.positive),\n1498:         Implies(Q.zero, ~Q.negative & ~Q.positive),\n1499:         Implies(Q.negative, ~Q.positive),\n1500:         Equivalent(Q.nonnegative, Q.zero | Q.positive),\n1501:         Equivalent(Q.nonpositive, Q.zero | Q.negative),\n1502:         Equivalent(Q.nonzero, Q.negative | Q.positive),\n1503: \n1504:         Implies(Q.orthogonal, Q.positive_definite),\n1505:         Implies(Q.orthogonal, Q.unitary),\n1506:         Implies(Q.unitary & Q.real, Q.orthogonal),\n1507:         Implies(Q.unitary, Q.normal),\n1508:         Implies(Q.unitary, Q.invertible),\n1509:         Implies(Q.normal, Q.square),\n1510:         Implies(Q.diagonal, Q.normal),\n1511:         Implies(Q.positive_definite, Q.invertible),\n1512:         Implies(Q.diagonal, Q.upper_triangular),\n1513:         Implies(Q.diagonal, Q.lower_triangular),\n1514:         Implies(Q.lower_triangular, Q.triangular),\n1515:         Implies(Q.upper_triangular, Q.triangular),\n1516:         Implies(Q.triangular, Q.upper_triangular | Q.lower_triangular),\n1517:         Implies(Q.upper_triangular & Q.lower_triangular, Q.diagonal),\n1518:         Implies(Q.diagonal, Q.symmetric),\n1519:         Implies(Q.unit_triangular, Q.triangular),\n1520:         Implies(Q.invertible, Q.fullrank),\n1521:         Implies(Q.invertible, Q.square),\n1522:         Implies(Q.symmetric, Q.square),\n1523:         Implies(Q.fullrank & Q.square, Q.invertible),\n1524:         Equivalent(Q.invertible, ~Q.singular),\n1525:         Implies(Q.integer_elements, Q.real_elements),\n1526:         Implies(Q.real_elements, Q.complex_elements),\n1527:     )\n1528: \n1529: from sympy.assumptions.ask_generated import (\n1530:     get_known_facts_dict, get_known_facts_cnf)\n\n[start of sympy/assumptions/ask_generated.py]\n1: \"\"\"\n2: The contents of this file are the return value of\n3: ``sympy.assumptions.ask.compute_known_facts``.\n4: \n5: Do NOT manually edit this file.\n6: Instead, run ./bin/ask_update.py.\n7: \"\"\"\n8: \n9: from sympy.core.cache import cacheit\n10: from sympy.logic.boolalg import And\n11: from sympy.assumptions.ask import Q\n12: \n13: # -{ Known facts in Conjunctive Normal Form }-\n14: @cacheit\n15: def get_known_facts_cnf():\n16:     return And(\n17:         Q.invertible | Q.singular,\n18:         Q.algebraic | ~Q.rational,\n19:         Q.antihermitian | ~Q.imaginary,\n20:         Q.complex | ~Q.algebraic,\n21:         Q.complex | ~Q.imaginary,\n22:         Q.complex | ~Q.real,\n23:         Q.complex | ~Q.transcendental,\n24:         Q.complex_elements | ~Q.real_elements,\n25:         Q.even | ~Q.zero,\n26:         Q.extended_real | ~Q.infinite,\n27:         Q.extended_real | ~Q.real,\n28:         Q.fullrank | ~Q.invertible,\n29:         Q.hermitian | ~Q.real,\n30:         Q.integer | ~Q.even,\n31:         Q.integer | ~Q.odd,\n32:         Q.integer | ~Q.prime,\n33:         Q.invertible | ~Q.positive_definite,\n34:         Q.invertible | ~Q.unitary,\n35:         Q.lower_triangular | ~Q.diagonal,\n36:         Q.nonnegative | ~Q.positive,\n37:         Q.nonnegative | ~Q.zero,\n38:         Q.nonpositive | ~Q.negative,\n39:         Q.nonpositive | ~Q.zero,\n40:         Q.nonzero | ~Q.negative,\n41:         Q.nonzero | ~Q.positive,\n42:         Q.normal | ~Q.diagonal,\n43:         Q.normal | ~Q.unitary,\n44:         Q.positive | ~Q.prime,\n45:         Q.positive_definite | ~Q.orthogonal,\n46:         Q.rational | ~Q.integer,\n47:         Q.real | ~Q.irrational,\n48:         Q.real | ~Q.negative,\n49:         Q.real | ~Q.positive,\n50:         Q.real | ~Q.rational,\n51:         Q.real | ~Q.zero,\n52:         Q.real_elements | ~Q.integer_elements,\n53:         Q.square | ~Q.invertible,\n54:         Q.square | ~Q.normal,\n55:         Q.square | ~Q.symmetric,\n56:         Q.symmetric | ~Q.diagonal,\n57:         Q.triangular | ~Q.lower_triangular,\n58:         Q.triangular | ~Q.unit_triangular,\n59:         Q.triangular | ~Q.upper_triangular,\n60:         Q.unitary | ~Q.orthogonal,\n61:         Q.upper_triangular | ~Q.diagonal,\n62:         ~Q.algebraic | ~Q.transcendental,\n63:         ~Q.antihermitian | ~Q.hermitian,\n64:         ~Q.composite | ~Q.prime,\n65:         ~Q.even | ~Q.odd,\n66:         ~Q.finite | ~Q.infinite,\n67:         ~Q.imaginary | ~Q.real,\n68:         ~Q.invertible | ~Q.singular,\n69:         ~Q.irrational | ~Q.rational,\n70:         ~Q.negative | ~Q.positive,\n71:         ~Q.negative | ~Q.zero,\n72:         ~Q.positive | ~Q.zero,\n73:         Q.algebraic | Q.transcendental | ~Q.complex,\n74:         Q.even | Q.odd | ~Q.integer,\n75:         Q.infinite | Q.real | ~Q.extended_real,\n76:         Q.irrational | Q.rational | ~Q.real,\n77:         Q.lower_triangular | Q.upper_triangular | ~Q.triangular,\n78:         Q.negative | Q.positive | ~Q.nonzero,\n79:         Q.negative | Q.zero | ~Q.nonpositive,\n80:         Q.positive | Q.zero | ~Q.nonnegative,\n81:         Q.diagonal | ~Q.lower_triangular | ~Q.upper_triangular,\n82:         Q.invertible | ~Q.fullrank | ~Q.square,\n83:         Q.orthogonal | ~Q.real | ~Q.unitary,\n84:         Q.negative | Q.positive | Q.zero | ~Q.real,\n85:         Q.composite | Q.prime | ~Q.integer | ~Q.positive\n86:     )\n87: \n88: # -{ Known facts in compressed sets }-\n89: @cacheit\n90: def get_known_facts_dict():\n91:     return {\n92:         Q.algebraic: set([Q.algebraic, Q.complex]),\n93:         Q.antihermitian: set([Q.antihermitian]),\n94:         Q.commutative: set([Q.commutative]),\n95:         Q.complex: set([Q.complex]),\n96:         Q.complex_elements: set([Q.complex_elements]),\n97:         Q.composite: set([Q.composite]),\n98:         Q.diagonal: set([Q.diagonal, Q.lower_triangular, Q.normal, Q.square,\n99:         Q.symmetric, Q.triangular, Q.upper_triangular]),\n100:         Q.even: set([Q.algebraic, Q.complex, Q.even, Q.extended_real,\n101:         Q.hermitian, Q.integer, Q.rational, Q.real]),\n102:         Q.extended_real: set([Q.extended_real]),\n103:         Q.finite: set([Q.finite]),\n104:         Q.fullrank: set([Q.fullrank]),\n105:         Q.hermitian: set([Q.hermitian]),\n106:         Q.imaginary: set([Q.antihermitian, Q.complex, Q.imaginary]),\n107:         Q.infinite: set([Q.extended_real, Q.infinite]),\n108:         Q.integer: set([Q.algebraic, Q.complex, Q.extended_real, Q.hermitian,\n109:         Q.integer, Q.rational, Q.real]),\n110:         Q.integer_elements: set([Q.complex_elements, Q.integer_elements,\n111:         Q.real_elements]),\n112:         Q.invertible: set([Q.fullrank, Q.invertible, Q.square]),\n113:         Q.irrational: set([Q.complex, Q.extended_real, Q.hermitian,\n114:         Q.irrational, Q.nonzero, Q.real]),\n115:         Q.is_true: set([Q.is_true]),\n116:         Q.lower_triangular: set([Q.lower_triangular, Q.triangular]),\n117:         Q.negative: set([Q.complex, Q.extended_real, Q.hermitian, Q.negative,\n118:         Q.nonpositive, Q.nonzero, Q.real]),\n119:         Q.nonnegative: set([Q.complex, Q.extended_real, Q.hermitian,\n120:         Q.nonnegative, Q.real]),\n121:         Q.nonpositive: set([Q.complex, Q.extended_real, Q.hermitian,\n122:         Q.nonpositive, Q.real]),\n123:         Q.nonzero: set([Q.complex, Q.extended_real, Q.hermitian, Q.nonzero,\n124:         Q.real]),\n125:         Q.normal: set([Q.normal, Q.square]),\n126:         Q.odd: set([Q.algebraic, Q.complex, Q.extended_real, Q.hermitian,\n127:         Q.integer, Q.nonzero, Q.odd, Q.rational, Q.real]),\n128:         Q.orthogonal: set([Q.fullrank, Q.invertible, Q.normal, Q.orthogonal,\n129:         Q.positive_definite, Q.square, Q.unitary]),\n130:         Q.positive: set([Q.complex, Q.extended_real, Q.hermitian,\n131:         Q.nonnegative, Q.nonzero, Q.positive, Q.real]),\n132:         Q.positive_definite: set([Q.fullrank, Q.invertible,\n133:         Q.positive_definite, Q.square]),\n134:         Q.prime: set([Q.algebraic, Q.complex, Q.extended_real, Q.hermitian,\n135:         Q.integer, Q.nonnegative, Q.nonzero, Q.positive, Q.prime,\n136:         Q.rational, Q.real]),\n137:         Q.rational: set([Q.algebraic, Q.complex, Q.extended_real, Q.hermitian,\n138:         Q.rational, Q.real]),\n139:         Q.real: set([Q.complex, Q.extended_real, Q.hermitian, Q.real]),\n140:         Q.real_elements: set([Q.complex_elements, Q.real_elements]),\n141:         Q.singular: set([Q.singular]),\n142:         Q.square: set([Q.square]),\n143:         Q.symmetric: set([Q.square, Q.symmetric]),\n144:         Q.transcendental: set([Q.complex, Q.transcendental]),\n145:         Q.triangular: set([Q.triangular]),\n146:         Q.unit_triangular: set([Q.triangular, Q.unit_triangular]),\n147:         Q.unitary: set([Q.fullrank, Q.invertible, Q.normal, Q.square,\n148:         Q.unitary]),\n149:         Q.upper_triangular: set([Q.triangular, Q.upper_triangular]),\n150:         Q.zero: set([Q.algebraic, Q.complex, Q.even, Q.extended_real,\n151:         Q.hermitian, Q.integer, Q.nonnegative, Q.nonpositive,\n152:         Q.rational, Q.real, Q.zero]),\n153:     }\n\n[start of sympy/core/assumptions.py]\n1: \"\"\"\n2: This module contains the machinery handling assumptions.\n3: \n4: All symbolic objects have assumption attributes that can be accessed via\n5: .is_<assumption name> attribute.\n6: \n7: Assumptions determine certain properties of symbolic objects and can\n8: have 3 possible values: True, False, None.  True is returned if the\n9: object has the property and False is returned if it doesn't or can't\n10: (i.e. doesn't make sense):\n11: \n12:     >>> from sympy import I\n13:     >>> I.is_algebraic\n14:     True\n15:     >>> I.is_real\n16:     False\n17:     >>> I.is_prime\n18:     False\n19: \n20: When the property cannot be determined (or when a method is not\n21: implemented) None will be returned, e.g. a generic symbol, x, may or\n22: may not be positive so a value of None is returned for x.is_positive.\n23: \n24: By default, all symbolic values are in the largest set in the given context\n25: without specifying the property. For example, a symbol that has a property\n26: being integer, is also real, complex, etc.\n27: \n28: Here follows a list of possible assumption names:\n29: \n30: .. glossary::\n31: \n32:     commutative\n33:         object commutes with any other object with\n34:         respect to multiplication operation.\n35: \n36:     complex\n37:         object can have only values from the set\n38:         of complex numbers.\n39: \n40:     imaginary\n41:         object value is a number that can be written as a real\n42:         number multiplied by the imaginary unit ``I``.  See\n43:         [3]_.  Please note, that ``0`` is not considered to be an\n44:         imaginary number, see\n45:         `issue #7649 <https://github.com/sympy/sympy/issues/7649>`_.\n46: \n47:     real\n48:         object can have only values from the set\n49:         of real numbers.\n50: \n51:     integer\n52:         object can have only values from the set\n53:         of integers.\n54: \n55:     odd\n56:     even\n57:         object can have only values from the set of\n58:         odd (even) integers [2]_.\n59: \n60:     prime\n61:         object is a natural number greater than ``1`` that has\n62:         no positive divisors other than ``1`` and itself.  See [6]_.\n63: \n64:     composite\n65:         object is a positive integer that has at least one positive\n66:         divisor other than ``1`` or the number itself.  See [4]_.\n67: \n68:     zero\n69:         object has the value of ``0``.\n70: \n71:     nonzero\n72:         object is a real number that is not zero.\n73: \n74:     rational\n75:         object can have only values from the set\n76:         of rationals.\n77: \n78:     algebraic\n79:         object can have only values from the set\n80:         of algebraic numbers [11]_.\n81: \n82:     transcendental\n83:         object can have only values from the set\n84:         of transcendental numbers [10]_.\n85: \n86:     irrational\n87:         object value cannot be represented exactly by Rational, see [5]_.\n88: \n89:     finite\n90:     infinite\n91:         object absolute value is bounded (arbitrarily large).\n92:         See [7]_, [8]_, [9]_.\n93: \n94:     negative\n95:     nonnegative\n96:         object can have only negative (nonnegative)\n97:         values [1]_.\n98: \n99:     positive\n100:     nonpositive\n101:         object can have only positive (only\n102:         nonpositive) values.\n103: \n104:     hermitian\n105:     antihermitian\n106:         object belongs to the field of hermitian\n107:         (antihermitian) operators.\n108: \n109: Examples\n110: ========\n111: \n112:     >>> from sympy import Symbol\n113:     >>> x = Symbol('x', real=True); x\n114:     x\n115:     >>> x.is_real\n116:     True\n117:     >>> x.is_complex\n118:     True\n119: \n120: See Also\n121: ========\n122: \n123: .. seealso::\n124: \n125:     :py:class:`sympy.core.numbers.ImaginaryUnit`\n126:     :py:class:`sympy.core.numbers.Zero`\n127:     :py:class:`sympy.core.numbers.One`\n128: \n129: Notes\n130: =====\n131: \n132: Assumption values are stored in obj._assumptions dictionary or\n133: are returned by getter methods (with property decorators) or are\n134: attributes of objects/classes.\n135: \n136: \n137: References\n138: ==========\n139: \n140: .. [1] https://en.wikipedia.org/wiki/Negative_number\n141: .. [2] https://en.wikipedia.org/wiki/Parity_%28mathematics%29\n142: .. [3] https://en.wikipedia.org/wiki/Imaginary_number\n143: .. [4] https://en.wikipedia.org/wiki/Composite_number\n144: .. [5] https://en.wikipedia.org/wiki/Irrational_number\n145: .. [6] https://en.wikipedia.org/wiki/Prime_number\n146: .. [7] https://en.wikipedia.org/wiki/Finite\n147: .. [8] https://docs.python.org/3/library/math.html#math.isfinite\n148: .. [9] http://docs.scipy.org/doc/numpy/reference/generated/numpy.isfinite.html\n149: .. [10] https://en.wikipedia.org/wiki/Transcendental_number\n150: .. [11] https://en.wikipedia.org/wiki/Algebraic_number\n151: \n152: \"\"\"\n153: from __future__ import print_function, division\n154: \n155: from sympy.core.facts import FactRules, FactKB\n156: from sympy.core.core import BasicMeta\n157: from sympy.core.compatibility import integer_types\n158: \n159: \n160: from random import shuffle\n161: \n162: \n163: _assume_rules = FactRules([\n164: \n165:     'integer        ->  rational',\n166:     'rational       ->  real',\n167:     'rational       ->  algebraic',\n168:     'algebraic      ->  complex',\n169:     'real           ->  complex',\n170:     'real           ->  hermitian',\n171:     'imaginary      ->  complex',\n172:     'imaginary      ->  antihermitian',\n173:     'complex        ->  commutative',\n174: \n175:     'odd            ==  integer & !even',\n176:     'even           ==  integer & !odd',\n177: \n178:     'real           ==  negative | zero | positive',\n179:     'transcendental ==  complex & !algebraic',\n180: \n181:     'negative       ==  nonpositive & nonzero',\n182:     'positive       ==  nonnegative & nonzero',\n183:     'zero           ==  nonnegative & nonpositive',\n184: \n185:     'nonpositive    ==  real & !positive',\n186:     'nonnegative    ==  real & !negative',\n187: \n188:     'zero           ->  even & finite',\n189: \n190:     'prime          ->  integer & positive',\n191:     'composite      ->  integer & positive & !prime',\n192:     '!composite     ->  !positive | !even | prime',\n193: \n194:     'irrational     ==  real & !rational',\n195: \n... Code Truncated ...\n\n[start of sympy/core/power.py]\n1: from __future__ import print_function, division\n2: \n3: from math import log as _log\n4: \n5: from .sympify import _sympify\n6: from .cache import cacheit\n7: from .singleton import S\n8: from .expr import Expr\n9: from .evalf import PrecisionExhausted\n10: from .function import (_coeff_isneg, expand_complex, expand_multinomial,\n11:     expand_mul)\n12: from .logic import fuzzy_bool, fuzzy_not\n13: from .compatibility import as_int, range\n14: from .evaluate import global_evaluate\n15: from sympy.utilities.iterables import sift\n16: \n17: from mpmath.libmp import sqrtrem as mpmath_sqrtrem\n18: \n19: from math import sqrt as _sqrt\n20: \n21: \n22: \n23: def isqrt(n):\n24:     \"\"\"Return the largest integer less than or equal to sqrt(n).\"\"\"\n25:     if n < 17984395633462800708566937239552:\n26:         return int(_sqrt(n))\n27:     return integer_nthroot(int(n), 2)[0]\n28: \n29: \n30: def integer_nthroot(y, n):\n31:     \"\"\"\n32:     Return a tuple containing x = floor(y**(1/n))\n33:     and a boolean indicating whether the result is exact (that is,\n34:     whether x**n == y).\n35: \n36:     Examples\n37:     ========\n38: \n39:     >>> from sympy import integer_nthroot\n40:     >>> integer_nthroot(16, 2)\n41:     (4, True)\n42:     >>> integer_nthroot(26, 2)\n43:     (5, False)\n44: \n45:     To simply determine if a number is a perfect square, the is_square\n46:     function should be used:\n47: \n48:     >>> from sympy.ntheory.primetest import is_square\n49:     >>> is_square(26)\n50:     False\n51: \n... Code Truncated ...\n\n[start of sympy/printing/tree.py]\n1: from __future__ import print_function, division\n2: \n3: \n4: def pprint_nodes(subtrees):\n5:     \"\"\"\n6:     Prettyprints systems of nodes.\n7: \n8:     Examples\n9:     ========\n10: \n11:     >>> from sympy.printing.tree import pprint_nodes\n12:     >>> print(pprint_nodes([\"a\", \"b1\\\\nb2\", \"c\"]))\n13:     +-a\n14:     +-b1\n15:     | b2\n16:     +-c\n17: \n18:     \"\"\"\n19:     def indent(s, type=1):\n20:         x = s.split(\"\\n\")\n21:         r = \"+-%s\\n\" % x[0]\n22:         for a in x[1:]:\n23:             if a == \"\":\n24:                 continue\n25:             if type == 1:\n26:                 r += \"| %s\\n\" % a\n27:             else:\n28:                 r += \"  %s\\n\" % a\n29:         return r\n30:     if not subtrees:\n31:         return \"\"\n32:     f = \"\"\n33:     for a in subtrees[:-1]:\n34:         f += indent(a)\n35:     f += indent(subtrees[-1], 2)\n36:     return f\n37: \n38: \n39: def print_node(node):\n40:     \"\"\"\n41:     Returns information about the \"node\".\n42: \n43:     This includes class name, string representation and assumptions.\n44:     \"\"\"\n45:     s = \"%s: %s\\n\" % (node.__class__.__name__, str(node))\n46:     d = node._assumptions\n47:     if d:\n48:         for a in sorted(d):\n49:             v = d[a]\n50:             if v is None:\n51:                 continue\n... Code Truncated ...\n\n[start of sympy/tensor/indexed.py]\n1: r\"\"\"Module that defines indexed objects\n2: \n3: The classes ``IndexedBase``, ``Indexed``, and ``Idx`` represent a\n4: matrix element ``M[i, j]`` as in the following diagram::\n5: \n6:        1) The Indexed class represents the entire indexed object.\n7:                   |\n8:                ___|___\n9:               '       '\n10:                M[i, j]\n11:               /   \\__\\______\n12:               |             |\n13:               |             |\n14:               |     2) The Idx class represents indices; each Idx can\n15:               |        optionally contain information about its range.\n16:               |\n17:         3) IndexedBase represents the 'stem' of an indexed object, here `M`.\n18:            The stem used by itself is usually taken to represent the entire\n19:            array.\n20: \n21: There can be any number of indices on an Indexed object.  No\n22: transformation properties are implemented in these Base objects, but\n23: implicit contraction of repeated indices is supported.\n24: \n25: Note that the support for complicated (i.e. non-atomic) integer\n26: expressions as indices is limited.  (This should be improved in\n27: future releases.)\n28: \n29: Examples\n30: ========\n31: \n32: To express the above matrix element example you would write:\n33: \n34: >>> from sympy import symbols, IndexedBase, Idx\n35: >>> M = IndexedBase('M')\n36: >>> i, j = symbols('i j', cls=Idx)\n37: >>> M[i, j]\n38: M[i, j]\n39: \n40: Repeated indices in a product implies a summation, so to express a\n41: matrix-vector product in terms of Indexed objects:\n42: \n43: >>> x = IndexedBase('x')\n44: >>> M[i, j]*x[j]\n45: M[i, j]*x[j]\n46: \n47: If the indexed objects will be converted to component based arrays, e.g.\n48: with the code printers or the autowrap framework, you also need to provide\n49: (symbolic or numerical) dimensions.  This can be done by passing an\n50: optional shape parameter to IndexedBase upon construction:\n51: \n52: >>> dim1, dim2 = symbols('dim1 dim2', integer=True)\n53: >>> A = IndexedBase('A', shape=(dim1, 2*dim1, dim2))\n54: >>> A.shape\n55: (dim1, 2*dim1, dim2)\n56: >>> A[i, j, 3].shape\n57: (dim1, 2*dim1, dim2)\n58: \n59: If an IndexedBase object has no shape information, it is assumed that the\n60: array is as large as the ranges of its indices:\n61: \n62: >>> n, m = symbols('n m', integer=True)\n63: >>> i = Idx('i', m)\n64: >>> j = Idx('j', n)\n65: >>> M[i, j].shape\n66: (m, n)\n67: >>> M[i, j].ranges\n68: [(0, m - 1), (0, n - 1)]\n69: \n70: The above can be compared with the following:\n71: \n72: >>> A[i, 2, j].shape\n73: (dim1, 2*dim1, dim2)\n74: >>> A[i, 2, j].ranges\n75: [(0, m - 1), None, (0, n - 1)]\n76: \n77: To analyze the structure of indexed expressions, you can use the methods\n78: get_indices() and get_contraction_structure():\n79: \n80: >>> from sympy.tensor import get_indices, get_contraction_structure\n81: >>> get_indices(A[i, j, j])\n82: ({i}, {})\n83: >>> get_contraction_structure(A[i, j, j])\n84: {(j,): {A[i, j, j]}}\n85: \n86: See the appropriate docstrings for a detailed explanation of the output.\n87: \"\"\"\n88: \n89: #   TODO:  (some ideas for improvement)\n90: #\n91: #   o test and guarantee numpy compatibility\n92: #      - implement full support for broadcasting\n93: #      - strided arrays\n94: #\n95: #   o more functions to analyze indexed expressions\n96: #      - identify standard constructs, e.g matrix-vector product in a subexpression\n97: #\n98: #   o functions to generate component based arrays (numpy and sympy.Matrix)\n99: #      - generate a single array directly from Indexed\n100: #      - convert simple sub-expressions\n101: #\n102: #   o sophisticated indexing (possibly in subclasses to preserve simplicity)\n103: #      - Idx with range smaller than dimension of Indexed\n104: #      - Idx with stepsize != 1\n105: #      - Idx with step determined by function call\n106: \n107: from __future__ import print_function, division\n108: \n109: from sympy.core import Expr, Tuple, Symbol, sympify, S\n110: from sympy.core.compatibility import (is_sequence, string_types, NotIterable,\n111:                                       Iterable)\n112: from sympy.core.sympify import _sympify\n113: from sympy.functions.special.tensor_functions import KroneckerDelta\n114: \n115: \n116: class IndexException(Exception):\n117:     pass\n118: \n119: \n120: class Indexed(Expr):\nCode replaced for brevity.\n331: \n332: \n333: \n334: class IndexedBase(Expr, NotIterable):\nCode replaced for brevity.\n518: \n519: \n520: \n521: class Idx(Expr):\n522:     \"\"\"Represents an integer index as an ``Integer`` or integer expression.\n523: \n524:     There are a number of ways to create an ``Idx`` object.  The constructor\n525:     takes two arguments:\n526: \n527:     ``label``\n528:         An integer or a symbol that labels the index.\n529:     ``range``\n530:         Optionally you can specify a range as either\n531: \n532:         * ``Symbol`` or integer: This is interpreted as a dimension. Lower and\n533:           upper bounds are set to ``0`` and ``range - 1``, respectively.\n534:         * ``tuple``: The two elements are interpreted as the lower and upper\n535:           bounds of the range, respectively.\n536: \n537:     Note: bounds of the range are assumed to be either integer or infinite (oo\n538:     and -oo are allowed to specify an unbounded range). If ``n`` is given as a\n539:     bound, then ``n.is_integer`` must not return false.\n540: \n541:     For convenience, if the label is given as a string it is automatically\n542:     converted to an integer symbol.  (Note: this conversion is not done for\n543:     range or dimension arguments.)\n544: \n545:     Examples\n546:     ========\n547: \n548:     >>> from sympy import IndexedBase, Idx, symbols, oo\n549:     >>> n, i, L, U = symbols('n i L U', integer=True)\n550: \n551:     If a string is given for the label an integer ``Symbol`` is created and the\n552:     bounds are both ``None``:\n553: \n554:     >>> idx = Idx('qwerty'); idx\n555:     qwerty\n556:     >>> idx.lower, idx.upper\n557:     (None, None)\n558: \n559:     Both upper and lower bounds can be specified:\n560: \n561:     >>> idx = Idx(i, (L, U)); idx\n562:     i\n563:     >>> idx.lower, idx.upper\n564:     (L, U)\n565: \n566:     When only a single bound is given it is interpreted as the dimension\n567:     and the lower bound defaults to 0:\n568: \n569:     >>> idx = Idx(i, n); idx.lower, idx.upper\n570:     (0, n - 1)\n571:     >>> idx = Idx(i, 4); idx.lower, idx.upper\n572:     (0, 3)\n573:     >>> idx = Idx(i, oo); idx.lower, idx.upper\n574:     (0, oo)\n575: \n576:     \"\"\"\n577: \n578:     is_integer = True\n579:     is_finite = True\n580:     is_real = True\n581:     is_symbol = True\n582:     is_Atom = True\n583:     _diff_wrt = True\n584: \n585:     def __new__(cls, label, range=None, **kw_args):\n586:         from sympy.utilities.misc import filldedent\n587: \n588:         if isinstance(label, string_types):\n589:             label = Symbol(label, integer=True)\n590:         label, range = list(map(sympify, (label, range)))\n591: \n592:         if label.is_Number:\n593:             if not label.is_integer:\n594:                 raise TypeError(\"Index is not an integer number.\")\n595:             return label\n596: \n597:         if not label.is_integer:\n598:             raise TypeError(\"Idx object requires an integer label.\")\n599: \n600:         elif is_sequence(range):\n601:             if len(range) != 2:\n602:                 raise ValueError(filldedent(\"\"\"\n603:                     Idx range tuple must have length 2, but got %s\"\"\" % len(range)))\n604:             for bound in range:\n605:                 if bound.is_integer is False:\n606:                     raise TypeError(\"Idx object requires integer bounds.\")\n607:             args = label, Tuple(*range)\n608:         elif isinstance(range, Expr):\n609:             if not (range.is_integer or range is S.Infinity):\n610:                 raise TypeError(\"Idx object requires an integer dimension.\")\n611:             args = label, Tuple(0, range - 1)\n612:         elif range:\n613:             raise TypeError(filldedent(\"\"\"\n614:                 The range must be an ordered iterable or\n615:                 integer SymPy expression.\"\"\"))\n616:         else:\n617:             args = label,\n618: \n619:         obj = Expr.__new__(cls, *args, **kw_args)\n620:         obj._assumptions[\"finite\"] = True\n621:         obj._assumptions[\"real\"] = True\n622:         return obj\n623: \n624:     @property\n625:     def label(self):\n626:         \"\"\"Returns the label (Integer or integer expression) of the Idx object.\n627: \n628:         Examples\n629:         ========\n630: \n631:         >>> from sympy import Idx, Symbol\n632:         >>> x = Symbol('x', integer=True)\n633:         >>> Idx(x).label\n634:         x\n635:         >>> j = Symbol('j', integer=True)\n636:         >>> Idx(j).label\n637:         j\n638:         >>> Idx(j + 1).label\n639:         j + 1\n640: \n641:         \"\"\"\n642:         return self.args[0]\n643: \n644:     @property\n645:     def lower(self):\n646:         \"\"\"Returns the lower bound of the ``Idx``.\n647: \n648:         Examples\n649:         ========\n650: \n651:         >>> from sympy import Idx\n652:         >>> Idx('j', 2).lower\n653:         0\n654:         >>> Idx('j', 5).lower\n655:         0\n656:         >>> Idx('j').lower is None\n657:         True\n658: \n659:         \"\"\"\n660:         try:\n661:             return self.args[1][0]\n662:         except IndexError:\n663:             return\n664: \n665:     @property\n666:     def upper(self):\n667:         \"\"\"Returns the upper bound of the ``Idx``.\n668: \n669:         Examples\n670:         ========\n671: \n672:         >>> from sympy import Idx\n673:         >>> Idx('j', 2).upper\n674:         1\n675:         >>> Idx('j', 5).upper\n676:         4\n677:         >>> Idx('j').upper is None\n678:         True\n679: \n680:         \"\"\"\n681:         try:\n682:             return self.args[1][1]\n683:         except IndexError:\n684:             return\n685: \n686:     def _sympystr(self, p):\n687:         return p.doprint(self.label)\n688: \n689:     @property\n690:     def name(self):\n691:         return self.label.name if self.label.is_Symbol else str(self.label)\n692: \n693:     @property\n694:     def free_symbols(self):\n695:         return {self}\n696: \n697:     def __le__(self, other):\n698:         if isinstance(other, Idx):\n699:             other_upper = other if other.upper is None else other.upper\n700:             other_lower = other if other.lower is None else other.lower\n701:         else:\n702:             other_upper = other\n703:             other_lower = other\n704: \n705:         if self.upper is not None and (self.upper <= other_lower) == True:\n706:             return True\n707:         if self.lower is not None and (self.lower > other_upper) == True:\n708:             return False\n709:         return super(Idx, self).__le__(other)\n710: \n711:     def __ge__(self, other):\n712:         if isinstance(other, Idx):\n713:             other_upper = other if other.upper is None else other.upper\n714:             other_lower = other if other.lower is None else other.lower\n715:         else:\n716:             other_upper = other\n717:             other_lower = other\n718: \n719:         if self.lower is not None and (self.lower >= other_upper) == True:\n720:             return True\n721:         if self.upper is not None and (self.upper < other_lower) == True:\n722:             return False\n723:         return super(Idx, self).__ge__(other)\n724: \n725:     def __lt__(self, other):\n726:         if isinstance(other, Idx):\n727:             other_upper = other if other.upper is None else other.upper\n728:             other_lower = other if other.lower is None else other.lower\n729:         else:\n730:             other_upper = other\n731:             other_lower = other\n732: \n733:         if self.upper is not None and (self.upper < other_lower) == True:\n734:             return True\n735:         if self.lower is not None and (self.lower >= other_upper) == True:\n736:             return False\n737:         return super(Idx, self).__lt__(other)\n738: \n739:     def __gt__(self, other):\n740:         if isinstance(other, Idx):\n741:             other_upper = other if other.upper is None else other.upper\n742:             other_lower = other if other.lower is None else other.lower\n743:         else:\n744:             other_upper = other\n745:             other_lower = other\n746: \n747:         if self.lower is not None and (self.lower > other_upper) == True:\n748:             return True\n749:         if self.upper is not None and (self.upper <= other_lower) == True:\n750:             return False\n751:         return super(Idx, self).__gt__(other)\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/assumptions/ask.py",
      "suspect_lines": [
        1488,
        1493
      ]
    },
    {
      "filename": "/sympy/assumptions/ask_generated.py",
      "suspect_lines": [
        73,
        76,
        85,
        92,
        101,
        108,
        109,
        113,
        126,
        127,
        134,
        135,
        136,
        137,
        138,
        144,
        151,
        152
      ]
    },
    {
      "filename": "/sympy/core/assumptions.py",
      "suspect_lines": [
        166,
        168,
        179,
        194
      ]
    },
    {
      "filename": "/sympy/core/power.py",
      "suspect_lines": [
        12
      ]
    },
    {
      "filename": "/sympy/printing/tree.py",
      "suspect_lines": []
    },
    {
      "filename": "/sympy/tensor/indexed.py",
      "suspect_lines": [
        605
      ]
    }
  ]
}