{
  "instance_id": "django__django-13837",
  "problem_statement": "Allow autoreloading of `python -m pkg_other_than_django runserver`\nDescription\n\t \n\t\t(last modified by William Schwartz)\n\t \n​django.utils.autoreload.get_child_arguments detects if Python was launched as python -m django. Currently it detects only when ​-m was passed specifically django (and only in Python environments in which __file__ is set on modules, which is ​not true of all Python environments). Like #32177, this ticket aims to remove one impediment to creating Django-based command-line utilities that have their own ​__main__ sub-module while overriding Django's built-in management commands—in this case, runserver.\nThe fix, which I have submitted in the ​attached PR, is to use Python's ​documented way of determining if -m was used in get_child_arguments:\nThe top-level __main__ module is always the entry point of a ​complete Python program.\n __main__.__spec__ is not None ​if and only if Python was launched with -m or the name of a \"directory, zipfile or other sys.path entry.\" In the latter cases, the ​documentation says\nIf the script name refers to a directory or zipfile, the script name is added to the start of sys.path and the __main__.py file in that location is executed as the __main__ module.\nHence __main__.__spec__.parent (which is ​usually but not always __main__.__package__) exists and is the empty string when Python is started with the name of a directory or zip file.\nTherefore Python was started with -m pkg if and only if __main__.__spec__.parent == \"pkg\".\nFollowing this algorithm is guaranteed to work as long as Python obeys its own documentation, and has the side benefit of avoiding use of __file__.\n",
  "localized_code": "[start of django/utils/autoreload.py]\n1: import functools\n2: import itertools\n3: import logging\n4: import os\n5: import signal\n6: import subprocess\n7: import sys\n8: import threading\n9: import time\n10: import traceback\n11: import weakref\n12: from collections import defaultdict\n13: from pathlib import Path\n14: from types import ModuleType\n15: from zipimport import zipimporter\n16: \n17: import django\n18: from django.apps import apps\n19: from django.core.signals import request_finished\n20: from django.dispatch import Signal\n21: from django.utils.functional import cached_property\n22: from django.utils.version import get_version_tuple\n23: \n24: autoreload_started = Signal()\n25: file_changed = Signal()\n26: \n27: DJANGO_AUTORELOAD_ENV = 'RUN_MAIN'\n28: \n29: logger = logging.getLogger('django.utils.autoreload')\n30: \n31: # If an error is raised while importing a file, it's not placed in sys.modules.\n32: # This means that any future modifications aren't caught. Keep a list of these\n33: # file paths to allow watching them in the future.\n34: _error_files = []\n35: _exception = None\n36: \n37: try:\n38:     import termios\n39: except ImportError:\n40:     termios = None\n41: \n42: \n43: try:\n44:     import pywatchman\n45: except ImportError:\n46:     pywatchman = None\n47: \n48: \n49: def is_django_module(module):\n50:     \"\"\"Return True if the given module is nested under Django.\"\"\"\n51:     return module.__name__.startswith('django.')\n52: \n53: \n54: def is_django_path(path):\nCode replaced for brevity.\n56: \n57: \n58: \n59: def check_errors(fn):\nCode replaced for brevity.\n81: \n82: \n83: \n84: def raise_last_exception():\nCode replaced for brevity.\n87: \n88: \n89: \n90: def ensure_echo_on():\nCode replaced for brevity.\n106: \n107: \n108: \n109:     # aren't loaded on the fly.\nCode replaced for brevity.\n116: \n117: \n118: \n119: @functools.lru_cache(maxsize=1)\n120: def iter_modules_and_files(modules, extra_files):\nCode replaced for brevity.\n162: \n163: \n164: \n165: @functools.lru_cache(maxsize=1)\n166: def common_roots(paths):\nCode replaced for brevity.\n193: \n194: \n195: \n196: def sys_path_directories():\nCode replaced for brevity.\n210: \n211: \n212: \n213: def get_child_arguments():\n214:     \"\"\"\n215:     Return the executable. This contains a workaround for Windows if the\n216:     executable is reported to not have the .exe extension which can cause bugs\n217:     on reloading.\n218:     \"\"\"\n219:     import django.__main__\n220:     django_main_path = Path(django.__main__.__file__)\n221:     py_script = Path(sys.argv[0])\n222: \n223:     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n224:     if py_script == django_main_path:\n225:         # The server was started with `python -m django runserver`.\n226:         args += ['-m', 'django']\n227:         args += sys.argv[1:]\n228:     elif not py_script.exists():\n229:         # sys.argv[0] may not exist for several reasons on Windows.\n230:         # It may exist with a .exe extension or have a -script.py suffix.\n231:         exe_entrypoint = py_script.with_suffix('.exe')\n232:         if exe_entrypoint.exists():\n233:             # Should be executed directly, ignoring sys.executable.\n234:             # TODO: Remove str() when dropping support for PY37.\n235:             # args parameter accepts path-like on Windows from Python 3.8.\n236:             return [str(exe_entrypoint), *sys.argv[1:]]\n237:         script_entrypoint = py_script.with_name('%s-script.py' % py_script.name)\n238:         if script_entrypoint.exists():\n239:             # Should be executed as usual.\n240:             # TODO: Remove str() when dropping support for PY37.\n241:             # args parameter accepts path-like on Windows from Python 3.8.\n242:             return [*args, str(script_entrypoint), *sys.argv[1:]]\n243:         raise RuntimeError('Script %s does not exist.' % py_script)\n244:     else:\n245:         args += sys.argv\n246:     return args\n247: \n248: \n249: def trigger_reload(filename):\nCode replaced for brevity.\n251: \n252: \n253: \n254: def restart_with_reloader():\nCode replaced for brevity.\n260: \n261: \n262: \n263: class BaseReloader:\nCode replaced for brevity.\n365: \n366: \n367: \n368: class StatReloader(BaseReloader):\nCode replaced for brevity.\n403: \n404: \n405: \n406: class WatchmanUnavailable(RuntimeError):\n407:     pass\n408: \n409: \n410: class WatchmanReloader(BaseReloader):\nCode replaced for brevity.\n600: \n601: \n602: \n603: def get_reloader():\nCode replaced for brevity.\n609: \n610: \n611: \n612: def start_django(reloader, main_func, *args, **kwargs):\nCode replaced for brevity.\n628: \n629: \n630: \n631: def run_with_reloader(main_func, *args, **kwargs):\nCode replaced for brevity.\n642: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/autoreload.py",
      "suspect_lines": [
        219,
        220,
        224,
        225,
        226
      ]
    }
  ]
}