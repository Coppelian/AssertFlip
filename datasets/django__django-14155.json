{
  "instance_id": "django__django-14155",
  "problem_statement": "ResolverMatch.__repr__() doesn't handle functools.partial() nicely.\nDescription\n\t \n\t\t(last modified by Nick Pope)\n\t \nWhen a partial function is passed as the view, the __repr__ shows the func argument as functools.partial which isn't very helpful, especially as it doesn't reveal the underlying function or arguments provided.\nBecause a partial function also has arguments provided up front, we need to handle those specially so that they are accessible in __repr__.\nISTM that we can simply unwrap functools.partial objects in ResolverMatch.__init__().\n",
  "localized_code": "[start of django/urls/resolvers.py]\n1: \"\"\"\n2: This module converts requested URLs to callback view functions.\n3: \n4: URLResolver is the main class here. Its resolve() method takes a URL (as\n5: a string) and returns a ResolverMatch object which provides access to all\n6: attributes of the resolved URL match.\n7: \"\"\"\n8: import functools\n9: import inspect\n10: import re\n11: import string\n12: from importlib import import_module\n13: from urllib.parse import quote\n14: \n15: from asgiref.local import Local\n16: \n17: from django.conf import settings\n18: from django.core.checks import Error, Warning\n19: from django.core.checks.urls import check_resolver\n20: from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist\n21: from django.utils.datastructures import MultiValueDict\n22: from django.utils.functional import cached_property\n23: from django.utils.http import RFC3986_SUBDELIMS, escape_leading_slashes\n24: from django.utils.regex_helper import _lazy_re_compile, normalize\n25: from django.utils.translation import get_language\n26: \n27: from .converters import get_converter\n28: from .exceptions import NoReverseMatch, Resolver404\n29: from .utils import get_callable\n30: \n31: \n32: class ResolverMatch:\n33:     def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n34:         self.func = func\n35:         self.args = args\n36:         self.kwargs = kwargs\n37:         self.url_name = url_name\n38:         self.route = route\n39:         self.tried = tried\n40: \n41:         # If a URLRegexResolver doesn't have a namespace or app_name, it passes\n42:         # in an empty value.\n43:         self.app_names = [x for x in app_names if x] if app_names else []\n44:         self.app_name = ':'.join(self.app_names)\n45:         self.namespaces = [x for x in namespaces if x] if namespaces else []\n46:         self.namespace = ':'.join(self.namespaces)\n47: \n48:         if not hasattr(func, '__name__'):\n49:             # A class-based view\n50:             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n51:         else:\n52:             # A function-based view\n53:             self._func_path = func.__module__ + '.' + func.__name__\n54: \n55:         view_path = url_name or self._func_path\n56:         self.view_name = ':'.join(self.namespaces + [view_path])\n57: \n58:     def __getitem__(self, index):\n59:         return (self.func, self.args, self.kwargs)[index]\n60: \n61:     def __repr__(self):\n62:         return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n63:             self._func_path, self.args, self.kwargs, self.url_name,\n64:             self.app_names, self.namespaces, self.route,\n65:         )\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/urls/resolvers.py",
      "suspect_lines": [
        62,
        63,
        64
      ]
    }
  ]
}