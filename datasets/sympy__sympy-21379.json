{
  "instance_id": "sympy__sympy-21379",
  "problem_statement": "Unexpected `PolynomialError` when using simple `subs()` for particular expressions\nI am seeing weird behavior with `subs` for particular expressions with hyperbolic sinusoids with piecewise arguments. When applying `subs`, I obtain an unexpected `PolynomialError`. For context, I was umbrella-applying a casting from int to float of all int atoms for a bunch of random expressions before using a tensorflow lambdify to avoid potential tensorflow type errors. You can pretend the expression below has a `+ 1` at the end, but below is the MWE that I could produce.\r\n\r\nSee the expression below, and the conditions in which the exception arises.\r\n\r\nSympy version: 1.8.dev\r\n\r\n```python\r\nfrom sympy import *\r\nfrom sympy.core.cache import clear_cache\r\n\r\nx, y, z = symbols('x y z')\r\n\r\nclear_cache()\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This works fine\r\nexpr.subs({1: 1.0})\r\n\r\nclear_cache()\r\nx, y, z = symbols('x y z', real=True)\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This fails with \"PolynomialError: Piecewise generators do not make sense\"\r\nexpr.subs({1: 1.0})  # error\r\n# Now run it again (isympy...) w/o clearing cache and everything works as expected without error\r\nexpr.subs({1: 1.0})\r\n```\r\n\r\nI am not really sure where the issue is, but I think it has something to do with the order of assumptions in this specific type of expression. Here is what I found-\r\n\r\n- The error only (AFAIK) happens with `cosh` or `tanh` in place of `sinh`, otherwise it succeeds\r\n- The error goes away if removing the division by `z`\r\n- The error goes away if removing `exp` (but stays for most unary functions, `sin`, `log`, etc.)\r\n- The error only happens with real symbols for `x` and `y` (`z` does not have to be real)\r\n\r\nNot too sure how to debug this one.\n",
  "localized_code": "[start of sympy/core/mod.py]\n1: from sympy.core.numbers import nan\n2: from .function import Function\n3: from .kind import NumberKind\n4: \n5: \n6: class Mod(Function):\n7:     \"\"\"Represents a modulo operation on symbolic expressions.\n8: \n9:     Parameters\n10:     ==========\n11: \n12:     p : Expr\n13:         Dividend.\n14: \n15:     q : Expr\n16:         Divisor.\n17: \n18:     Notes\n19:     =====\n20: \n21:     The convention used is the same as Python's: the remainder always has the\n22:     same sign as the divisor.\n23: \n24:     Examples\n25:     ========\n26: \n27:     >>> from sympy.abc import x, y\n28:     >>> x**2 % y\n29:     Mod(x**2, y)\n30:     >>> _.subs({x: 5, y: 6})\n31:     1\n32: \n33:     \"\"\"\n34: \n35:     kind = NumberKind\n36: \n37:     @classmethod\n38:     def eval(cls, p, q):\n39:         from sympy.core.add import Add\n40:         from sympy.core.mul import Mul\n41:         from sympy.core.singleton import S\n42:         from sympy.core.exprtools import gcd_terms\n43:         from sympy.polys.polytools import gcd\n44: \n45:         def doit(p, q):\n46:             \"\"\"Try to return p % q if both are numbers or +/-p is known\n47:             to be less than or equal q.\n48:             \"\"\"\n49: \n50:             if q.is_zero:\n51:                 raise ZeroDivisionError(\"Modulo by zero\")\n52:             if p.is_finite is False or q.is_finite is False or p is nan or q is nan:\n53:                 return nan\n54:             if p is S.Zero or p == q or p == -q or (p.is_integer and q == 1):\n55:                 return S.Zero\n56: \n57:             if q.is_Number:\n58:                 if p.is_Number:\n59:                     return p%q\n60:                 if q == 2:\n61:                     if p.is_even:\n62:                         return S.Zero\n63:                     elif p.is_odd:\n64:                         return S.One\n65: \n66:             if hasattr(p, '_eval_Mod'):\n67:                 rv = getattr(p, '_eval_Mod')(q)\n68:                 if rv is not None:\n69:                     return rv\n70: \n71:             # by ratio\n72:             r = p/q\n73:             if r.is_integer:\n74:                 return S.Zero\n75:             try:\n76:                 d = int(r)\n77:             except TypeError:\n78:                 pass\n79:             else:\n80:                 if isinstance(d, int):\n81:                     rv = p - d*q\n82:                     if (rv*q < 0) == True:\n83:                         rv += q\n84:                     return rv\n85: \n86:             # by difference\n87:             # -2|q| < p < 2|q|\n88:             d = abs(p)\n89:             for _ in range(2):\n90:                 d -= abs(q)\n91:                 if d.is_negative:\n92:                     if q.is_positive:\n93:                         if p.is_positive:\n94:                             return d + q\n95:                         elif p.is_negative:\n96:                             return -d\n97:                     elif q.is_negative:\n98:                         if p.is_positive:\n99:                             return d\n100:                         elif p.is_negative:\n101:                             return -d + q\n102:                     break\n103: \n104:         rv = doit(p, q)\n105:         if rv is not None:\n106:             return rv\n107: \n108:         # denest\n109:         if isinstance(p, cls):\n110:             qinner = p.args[1]\n111:             if qinner % q == 0:\n112:                 return cls(p.args[0], q)\n113:             elif (qinner*(q - qinner)).is_nonnegative:\n114:                 # |qinner| < |q| and have same sign\n115:                 return p\n116:         elif isinstance(-p, cls):\n117:             qinner = (-p).args[1]\n118:             if qinner % q == 0:\n119:                 return cls(-(-p).args[0], q)\n120:             elif (qinner*(q + qinner)).is_nonpositive:\n121:                 # |qinner| < |q| and have different sign\n122:                 return p\n123:         elif isinstance(p, Add):\n124:             # separating into modulus and non modulus\n125:             both_l = non_mod_l, mod_l = [], []\n126:             for arg in p.args:\n127:                 both_l[isinstance(arg, cls)].append(arg)\n128:             # if q same for all\n129:             if mod_l and all(inner.args[1] == q for inner in mod_l):\n130:                 net = Add(*non_mod_l) + Add(*[i.args[0] for i in mod_l])\n131:                 return cls(net, q)\n132: \n133:         elif isinstance(p, Mul):\n134:             # separating into modulus and non modulus\n135:             both_l = non_mod_l, mod_l = [], []\n136:             for arg in p.args:\n137:                 both_l[isinstance(arg, cls)].append(arg)\n138: \n139:             if mod_l and all(inner.args[1] == q for inner in mod_l):\n140:                 # finding distributive term\n141:                 non_mod_l = [cls(x, q) for x in non_mod_l]\n142:                 mod = []\n143:                 non_mod = []\n144:                 for j in non_mod_l:\n145:                     if isinstance(j, cls):\n146:                         mod.append(j.args[0])\n147:                     else:\n148:                         non_mod.append(j)\n149:                 prod_mod = Mul(*mod)\n150:                 prod_non_mod = Mul(*non_mod)\n151:                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n152:                 net = prod_mod1*prod_mod\n153:                 return prod_non_mod*cls(net, q)\n154: \n155:             if q.is_Integer and q is not S.One:\n156:                 _ = []\n157:                 for i in non_mod_l:\n158:                     if i.is_Integer and (i % q is not S.Zero):\n159:                         _.append(i%q)\n160:                     else:\n161:                         _.append(i)\n162:                 non_mod_l = _\n163: \n164:             p = Mul(*(non_mod_l + mod_l))\n165: \n166:         # XXX other possibilities?\n167: \n168:         # extract gcd; any further simplification should be done by the user\n169:         G = gcd(p, q)\n170:         if G != 1:\n171:             p, q = [\n172:                 gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n173:         pwas, qwas = p, q\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/mod.py",
      "suspect_lines": [
        169,
        170,
        171,
        172
      ]
    }
  ]
}