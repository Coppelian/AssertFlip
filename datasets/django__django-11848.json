{
  "instance_id": "django__django-11848",
  "problem_statement": "django.utils.http.parse_http_date two digit year check is incorrect\nDescription\n\t \n\t\t(last modified by Ad Timmering)\n\t \nRFC 850 does not mention this, but in RFC 7231 (and there's something similar in RFC 2822), there's the following quote:\nRecipients of a timestamp value in rfc850-date format, which uses a\ntwo-digit year, MUST interpret a timestamp that appears to be more\nthan 50 years in the future as representing the most recent year in\nthe past that had the same last two digits.\nCurrent logic is hard coded to consider 0-69 to be in 2000-2069, and 70-99 to be 1970-1999, instead of comparing versus the current year.\n",
  "localized_code": "[start of django/utils/http.py]\n1: import base64\n2: import calendar\n3: import datetime\n4: import re\n5: import unicodedata\n6: import warnings\n7: from binascii import Error as BinasciiError\n8: from email.utils import formatdate\n9: from urllib.parse import (\n10:     ParseResult, SplitResult, _coerce_args, _splitnetloc, _splitparams, quote,\n11:     quote_plus, scheme_chars, unquote, unquote_plus,\n12:     urlencode as original_urlencode, uses_params,\n13: )\n14: \n15: from django.core.exceptions import TooManyFieldsSent\n16: from django.utils.datastructures import MultiValueDict\n17: from django.utils.deprecation import RemovedInDjango40Warning\n18: from django.utils.functional import keep_lazy_text\n19: \n20: # based on RFC 7232, Appendix C\n21: ETAG_MATCH = re.compile(r'''\n22:     \\A(      # start of string and capture group\n23:     (?:W/)?  # optional weak indicator\n24:     \"        # opening quote\n25:     [^\"]*    # any sequence of non-quote characters\n26:     \"        # end quote\n27:     )\\Z      # end of string and capture group\n28: ''', re.X)\n29: \n30: MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec'.split()\n31: __D = r'(?P<day>\\d{2})'\n32: __D2 = r'(?P<day>[ \\d]\\d)'\n33: __M = r'(?P<mon>\\w{3})'\n34: __Y = r'(?P<year>\\d{4})'\n35: __Y2 = r'(?P<year>\\d{2})'\n36: __T = r'(?P<hour>\\d{2}):(?P<min>\\d{2}):(?P<sec>\\d{2})'\n37: RFC1123_DATE = re.compile(r'^\\w{3}, %s %s %s %s GMT$' % (__D, __M, __Y, __T))\n38: RFC850_DATE = re.compile(r'^\\w{6,9}, %s-%s-%s %s GMT$' % (__D, __M, __Y2, __T))\n39: ASCTIME_DATE = re.compile(r'^\\w{3} %s %s %s %s$' % (__M, __D2, __T, __Y))\n40: \n41: RFC3986_GENDELIMS = \":/?#[]@\"\n42: RFC3986_SUBDELIMS = \"!$&'()*+,;=\"\n43: \n44: FIELDS_MATCH = re.compile('[&;]')\n45: \n46: \n47: @keep_lazy_text\n48: def urlquote(url, safe='/'):\n49:     \"\"\"\n50:     A legacy compatibility wrapper to Python's urllib.parse.quote() function.\n51:     (was used for unicode handling on Python 2)\n52:     \"\"\"\n53:     warnings.warn(\n54:         'django.utils.http.urlquote() is deprecated in favor of '\n55:         'urllib.parse.quote().',\n56:         RemovedInDjango40Warning, stacklevel=2,\n57:     )\n58:     return quote(url, safe)\n59: \n60: \n61: @keep_lazy_text\n62: def urlquote_plus(url, safe=''):\nCode replaced for brevity.\n72: \n73: \n74: \n75: @keep_lazy_text\n76: def urlunquote(quoted_url):\nCode replaced for brevity.\n86: \n87: \n88: \n89: @keep_lazy_text\n90: def urlunquote_plus(quoted_url):\nCode replaced for brevity.\n100: \n101: \n102: \n103: def urlencode(query, doseq=False):\nCode replaced for brevity.\n141: \n142: \n143: \n144: def http_date(epoch_seconds=None):\nCode replaced for brevity.\n155: \n156: \n157: \n158: def parse_http_date(date):\n159:     \"\"\"\n160:     Parse a date format as specified by HTTP RFC7231 section 7.1.1.1.\n161: \n162:     The three formats allowed by the RFC are accepted, even if only the first\n163:     one is still in widespread use.\n164: \n165:     Return an integer expressed in seconds since the epoch, in UTC.\n166:     \"\"\"\n167:     # email.utils.parsedate() does the job for RFC1123 dates; unfortunately\n168:     # RFC7231 makes it mandatory to support RFC850 dates too. So we roll\n169:     # our own RFC-compliant parsing.\n170:     for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n171:         m = regex.match(date)\n172:         if m is not None:\n173:             break\n174:     else:\n175:         raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n176:     try:\n177:         year = int(m.group('year'))\n178:         if year < 100:\n179:             if year < 70:\n180:                 year += 2000\n181:             else:\n182:                 year += 1900\n183:         month = MONTHS.index(m.group('mon').lower()) + 1\n184:         day = int(m.group('day'))\n185:         hour = int(m.group('hour'))\n186:         min = int(m.group('min'))\n187:         sec = int(m.group('sec'))\n188:         result = datetime.datetime(year, month, day, hour, min, sec)\n189:         return calendar.timegm(result.utctimetuple())\n190:     except Exception as exc:\n191:         raise ValueError(\"%r is not a valid date\" % date) from exc\n192: \n193: \n194: def parse_http_date_safe(date):\nCode replaced for brevity.\n201: \n202: \n203: \n204: # Base 36 functions: useful for generating compact URLs\n205: \n206: def base36_to_int(s):\nCode replaced for brevity.\n216: \n217: \n218: \n219: def int_to_base36(i):\nCode replaced for brevity.\n230: \n231: \n232: \n233: def urlsafe_base64_encode(s):\nCode replaced for brevity.\n238: \n239: \n240: \n241: def urlsafe_base64_decode(s):\nCode replaced for brevity.\n250: \n251: \n252: \n253: def parse_etags(etag_str):\nCode replaced for brevity.\n264: \n265: \n266: \n267: def quote_etag(etag_str):\nCode replaced for brevity.\n275: \n276: \n277: \n278: def is_same_domain(host, pattern):\nCode replaced for brevity.\n294: \n295: \n296: \n297: def url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False):\nCode replaced for brevity.\n323: \n324: \n325: \n326: def is_safe_url(url, allowed_hosts, require_https=False):\nCode replaced for brevity.\n332: \n333: \n334: \n335: # Copied from urllib.parse.urlparse() but uses fixed urlsplit() function.\n336: def _urlparse(url, scheme='', allow_fragments=True):\nCode replaced for brevity.\n350: \n351: \n352: \n353: # Copied from urllib.parse.urlsplit() with\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/http.py",
      "suspect_lines": [
        179,
        180,
        182
      ]
    }
  ]
}