{
  "instance_id": "sympy__sympy-19954",
  "problem_statement": "sylow_subgroup() IndexError \nI use sympy 1.6.1, with numpy 1.18.5, scipy 1.4.1, under Python '3.8.5 (default, Aug  5 2020, 09:44:06) [MSC v.1916 64 bit (AMD64)]'. \r\n\r\nThe code that I run as the following gives IndexError for sylow_subgroup():\r\n\r\nfrom sympy.combinatorics import DihedralGroup, PermutationGroup, Permutation\r\n\r\nG = DihedralGroup(18)\r\n\r\nS2 = G.sylow_subgroup(p=2)\r\n \r\nTraceback (most recent call last):\r\n  File \"<input>\", line 7, in <module>\r\n  File \"D:\\anaconda38\\envs\\default\\lib\\site-packages\\sympy\\combinatorics\\perm_groups.py\", line 4370, in sylow_subgroup\r\n    blocks = self.minimal_blocks()\r\n  File \"D:\\anaconda38\\envs\\default\\lib\\site-packages\\sympy\\combinatorics\\perm_groups.py\", line 2207, in minimal_blocks\r\n    del num_blocks[i], blocks[i]\r\nIndexError: list assignment index out of range\r\n\r\nThe same error shows up as well when I set: \r\nG = DihedralGroup(2*25)\r\n\r\nS2 = G.sylow_subgroup(p=2)\r\n\r\n\n",
  "localized_code": "[start of sympy/combinatorics/perm_groups.py]\n1: from random import randrange, choice\n2: from math import log\n3: from sympy.ntheory import primefactors\n4: from sympy import multiplicity, factorint, Symbol\n5: \n6: from sympy.combinatorics import Permutation\n7: from sympy.combinatorics.permutations import (_af_commutes_with, _af_invert,\n8:     _af_rmul, _af_rmuln, _af_pow, Cycle)\n9: from sympy.combinatorics.util import (_check_cycles_alt_sym,\n10:     _distribute_gens_by_base, _orbits_transversals_from_bsgs,\n11:     _handle_precomputed_bsgs, _base_ordering, _strong_gens_from_distr,\n12:     _strip, _strip_af)\n13: from sympy.core import Basic\n14: from sympy.functions.combinatorial.factorials import factorial\n15: from sympy.ntheory import sieve\n16: from sympy.utilities.iterables import has_variety, is_sequence, uniq\n17: from sympy.testing.randtest import _randrange\n18: from itertools import islice\n19: from sympy.core.sympify import _sympify\n20: rmul = Permutation.rmul_with_af\n21: _af_new = Permutation._af_new\n22: \n23: \n24: class PermutationGroup(Basic):\n25:     \"\"\"The class defining a Permutation group.\n26: \n27:     PermutationGroup([p1, p2, ..., pn]) returns the permutation group\n28:     generated by the list of permutations. This group can be supplied\n29:     to Polyhedron if one desires to decorate the elements to which the\n30:     indices of the permutation refer.\n31: \n32:     Examples\n33:     ========\n34: \n35:     >>> from sympy.combinatorics import Permutation\n36:     >>> from sympy.combinatorics.polyhedron import Polyhedron\n37:     >>> from sympy.combinatorics.perm_groups import PermutationGroup\n38: \n39:     The permutations corresponding to motion of the front, right and\n40:     bottom face of a 2x2 Rubik's cube are defined:\n41: \n42:     >>> F = Permutation(2, 19, 21, 8)(3, 17, 20, 10)(4, 6, 7, 5)\n43:     >>> R = Permutation(1, 5, 21, 14)(3, 7, 23, 12)(8, 10, 11, 9)\n44:     >>> D = Permutation(6, 18, 14, 10)(7, 19, 15, 11)(20, 22, 23, 21)\n45: \n46:     These are passed as permutations to PermutationGroup:\n47: \n48:     >>> G = PermutationGroup(F, R, D)\n49:     >>> G.order()\n50:     3674160\n51: \n52:     The group can be supplied to a Polyhedron in order to track the\n53:     objects being moved. An example involving the 2x2 Rubik's cube is\n54:     given there, but here is a simple demonstration:\n55: \n56:     >>> a = Permutation(2, 1)\n57:     >>> b = Permutation(1, 0)\n58:     >>> G = PermutationGroup(a, b)\n59:     >>> P = Polyhedron(list('ABC'), pgroup=G)\n60:     >>> P.corners\n61:     (A, B, C)\n62:     >>> P.rotate(0) # apply permutation 0\n63:     >>> P.corners\n64:     (A, C, B)\n65:     >>> P.reset()\n66:     >>> P.corners\n67:     (A, B, C)\n68: \n69:     Or one can make a permutation as a product of selected permutations\n70:     and apply them to an iterable directly:\n71: \n72:     >>> P10 = G.make_perm([0, 1])\n73:     >>> P10('ABC')\n74:     ['C', 'A', 'B']\n75: \n76:     See Also\n77:     ========\n78: \n79:     sympy.combinatorics.polyhedron.Polyhedron,\n80:     sympy.combinatorics.permutations.Permutation\n81: \n82:     References\n83:     ==========\n84: \n85:     .. [1] Holt, D., Eick, B., O'Brien, E.\n86:            \"Handbook of Computational Group Theory\"\n87: \n88:     .. [2] Seress, A.\n89:            \"Permutation Group Algorithms\"\n90: \n91:     .. [3] https://en.wikipedia.org/wiki/Schreier_vector\n92: \n93:     .. [4] https://en.wikipedia.org/wiki/Nielsen_transformation#Product_replacement_algorithm\n94: \n95:     .. [5] Frank Celler, Charles R.Leedham-Green, Scott H.Murray,\n96:            Alice C.Niemeyer, and E.A.O'Brien. \"Generating Random\n97:            Elements of a Finite Group\"\n98: \n99:     .. [6] https://en.wikipedia.org/wiki/Block_%28permutation_group_theory%29\n100: \n101:     .. [7] http://www.algorithmist.com/index.php/Union_Find\n102: \n103:     .. [8] https://en.wikipedia.org/wiki/Multiply_transitive_group#Multiply_transitive_groups\n104: \n105:     .. [9] https://en.wikipedia.org/wiki/Center_%28group_theory%29\n106: \n107:     .. [10] https://en.wikipedia.org/wiki/Centralizer_and_normalizer\n108: \n109:     .. [11] http://groupprops.subwiki.org/wiki/Derived_subgroup\n110: \n111:     .. [12] https://en.wikipedia.org/wiki/Nilpotent_group\n112: \n113:     .. [13] http://www.math.colostate.edu/~hulpke/CGT/cgtnotes.pdf\n114: \n115:     .. [14] https://www.gap-system.org/Manuals/doc/ref/manual.pdf\n116: \n117:     \"\"\"\n118:     is_group = True\n119: \n120:     def __new__(cls, *args, **kwargs):\n121:         \"\"\"The default constructor. Accepts Cycle and Permutation forms.\n122:         Removes duplicates unless ``dups`` keyword is ``False``.\n123:         \"\"\"\n124:         if not args:\n125:             args = [Permutation()]\n126:         else:\n127:             args = list(args[0] if is_sequence(args[0]) else args)\n128:             if not args:\n129:                 args = [Permutation()]\n130:         if any(isinstance(a, Cycle) for a in args):\n131:             args = [Permutation(a) for a in args]\n132:         if has_variety(a.size for a in args):\n133:             degree = kwargs.pop('degree', None)\n134:             if degree is None:\n135:                 degree = max(a.size for a in args)\n136:             for i in range(len(args)):\n137:                 if args[i].size != degree:\n138:                     args[i] = Permutation(args[i], size=degree)\n139:         if kwargs.pop('dups', True):\n140:             args = list(uniq([_af_new(list(a)) for a in args]))\n141:         if len(args) > 1:\n142:             args = [g for g in args if not g.is_identity]\n143:         obj = Basic.__new__(cls, *args, **kwargs)\n144:         obj._generators = args\n145:         obj._order = None\n146:         obj._center = []\n147:         obj._is_abelian = None\n148:         obj._is_transitive = None\n149:         obj._is_sym = None\n150:         obj._is_alt = None\n151:         obj._is_primitive = None\n152:         obj._is_nilpotent = None\n153:         obj._is_solvable = None\n154:         obj._is_trivial = None\n155:         obj._transitivity_degree = None\n156:         obj._max_div = None\n157:         obj._is_perfect = None\n158:         obj._is_cyclic = None\n159:         obj._r = len(obj._generators)\n160:         obj._degree = obj._generators[0].size\n161: \n162:         # these attributes are assigned after running schreier_sims\n163:         obj._base = []\n164:         obj._strong_gens = []\n165:         obj._strong_gens_slp = []\n166:         obj._basic_orbits = []\n167:         obj._transversals = []\n168:         obj._transversal_slp = []\n169: \n170:         # these attributes are assigned after running _random_pr_init\n171:         obj._random_gens = []\n172: \n173:         # finite presentation of the group as an instance of `FpGroup`\n174:         obj._fp_presentation = None\n175:         return obj\n176: \n177:     def __getitem__(self, i):\n178:         return self._generators[i]\n179: \n180:     def __contains__(self, i):\n181:         \"\"\"Return ``True`` if *i* is contained in PermutationGroup.\n182: \n183:         Examples\n184:         ========\n185: \n186:         >>> from sympy.combinatorics import Permutation, PermutationGroup\n187:         >>> p = Permutation(1, 2, 3)\n188:         >>> Permutation(3) in PermutationGroup(p)\n189:         True\n190: \n191:         \"\"\"\n192:         if not isinstance(i, Permutation):\n193:             raise TypeError(\"A PermutationGroup contains only Permutations as \"\n194:                             \"elements, not elements of type %s\" % type(i))\n195:         return self.contains(i)\n196: \n197:     def __len__(self):\n198:         return len(self._generators)\n199: \n200:     def __eq__(self, other):\n201:         \"\"\"Return ``True`` if PermutationGroup generated by elements in the\n202:         group are same i.e they represent the same PermutationGroup.\n203: \n204:         Examples\n205:         ========\n206: \n207:         >>> from sympy.combinatorics import Permutation\n208:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n209:         >>> p = Permutation(0, 1, 2, 3, 4, 5)\n210:         >>> G = PermutationGroup([p, p**2])\n211:         >>> H = PermutationGroup([p**2, p])\n212:         >>> G.generators == H.generators\n213:         False\n214:         >>> G == H\n215:         True\n216: \n217:         \"\"\"\n218:         if not isinstance(other, PermutationGroup):\n219:             return False\n220: \n221:         set_self_gens = set(self.generators)\n222:         set_other_gens = set(other.generators)\n223: \n224:         # before reaching the general case there are also certain\n225:         # optimisation and obvious cases requiring less or no actual\n226:         # computation.\n227:         if set_self_gens == set_other_gens:\n228:             return True\n229: \n230:         # in the most general case it will check that each generator of\n231:         # one group belongs to the other PermutationGroup and vice-versa\n232:         for gen1 in set_self_gens:\n233:             if not other.contains(gen1):\n234:                 return False\n235:         for gen2 in set_other_gens:\n236:             if not self.contains(gen2):\n237:                 return False\n238:         return True\n239: \n240:     def __hash__(self):\n241:         return super().__hash__()\n242: \n243:     def __mul__(self, other):\n244:         \"\"\"\n245:         Return the direct product of two permutation groups as a permutation\n246:         group.\n247: \n248:         This implementation realizes the direct product by shifting the index\n249:         set for the generators of the second group: so if we have ``G`` acting\n250:         on ``n1`` points and ``H`` acting on ``n2`` points, ``G*H`` acts on\n251:         ``n1 + n2`` points.\n252: \n253:         Examples\n254:         ========\n255: \n256:         >>> from sympy.combinatorics.named_groups import CyclicGroup\n257:         >>> G = CyclicGroup(5)\n258:         >>> H = G*G\n259:         >>> H\n260:         PermutationGroup([\n261:             (9)(0 1 2 3 4),\n262:             (5 6 7 8 9)])\n263:         >>> H.order()\n264:         25\n265: \n266:         \"\"\"\n267:         if isinstance(other, Permutation):\n268:             return Coset(other, self, dir='+')\n269:         gens1 = [perm._array_form for perm in self.generators]\n270:         gens2 = [perm._array_form for perm in other.generators]\n271:         n1 = self._degree\n272:         n2 = other._degree\n273:         start = list(range(n1))\n274:         end = list(range(n1, n1 + n2))\n275:         for i in range(len(gens2)):\n276:             gens2[i] = [x + n1 for x in gens2[i]]\n277:         gens2 = [start + gen for gen in gens2]\n278:         gens1 = [gen + end for gen in gens1]\n279:         together = gens1 + gens2\n280:         gens = [_af_new(x) for x in together]\n281:         return PermutationGroup(gens)\n282: \n283:     def _random_pr_init(self, r, n, _random_prec_n=None):\n284:         r\"\"\"Initialize random generators for the product replacement algorithm.\n285: \n286:         The implementation uses a modification of the original product\n287:         replacement algorithm due to Leedham-Green, as described in [1],\n288:         pp. 69-71; also, see [2], pp. 27-29 for a detailed theoretical\n289:         analysis of the original product replacement algorithm, and [4].\n290: \n291:         The product replacement algorithm is used for producing random,\n292:         uniformly distributed elements of a group `G` with a set of generators\n293:         `S`. For the initialization ``_random_pr_init``, a list ``R`` of\n294:         `\\max\\{r, |S|\\}` group generators is created as the attribute\n295:         ``G._random_gens``, repeating elements of `S` if necessary, and the\n296:         identity element of `G` is appended to ``R`` - we shall refer to this\n297:         last element as the accumulator. Then the function ``random_pr()``\n298:         is called ``n`` times, randomizing the list ``R`` while preserving\n299:         the generation of `G` by ``R``. The function ``random_pr()`` itself\n300:         takes two random elements ``g, h`` among all elements of ``R`` but\n301:         the accumulator and replaces ``g`` with a randomly chosen element\n302:         from `\\{gh, g(~h), hg, (~h)g\\}`. Then the accumulator is multiplied\n303:         by whatever ``g`` was replaced by. The new value of the accumulator is\n304:         then returned by ``random_pr()``.\n305: \n306:         The elements returned will eventually (for ``n`` large enough) become\n307:         uniformly distributed across `G` ([5]). For practical purposes however,\n308:         the values ``n = 50, r = 11`` are suggested in [1].\n309: \n310:         Notes\n311:         =====\n312: \n313:         THIS FUNCTION HAS SIDE EFFECTS: it changes the attribute\n314:         self._random_gens\n315: \n316:         See Also\n317:         ========\n318: \n319:         random_pr\n320: \n321:         \"\"\"\n322:         deg = self.degree\n323:         random_gens = [x._array_form for x in self.generators]\n324:         k = len(random_gens)\n325:         if k < r:\n326:             for i in range(k, r):\n327:                 random_gens.append(random_gens[i - k])\n328:         acc = list(range(deg))\n329:         random_gens.append(acc)\n330:         self._random_gens = random_gens\n331: \n332:         # handle randomized input for testing purposes\n333:         if _random_prec_n is None:\n334:             for i in range(n):\n335:                 self.random_pr()\n336:         else:\n337:             for i in range(n):\n338:                 self.random_pr(_random_prec=_random_prec_n[i])\n339: \n340:     def _union_find_merge(self, first, second, ranks, parents, not_rep):\n341:         \"\"\"Merges two classes in a union-find data structure.\n342: \n343:         Used in the implementation of Atkinson's algorithm as suggested in [1],\n344:         pp. 83-87. The class merging process uses union by rank as an\n345:         optimization. ([7])\n346: \n347:         Notes\n348:         =====\n349: \n350:         THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,\n351:         ``parents``, the list of class sizes, ``ranks``, and the list of\n352:         elements that are not representatives, ``not_rep``, are changed due to\n353:         class merging.\n354: \n355:         See Also\n356:         ========\n357: \n358:         minimal_block, _union_find_rep\n359: \n360:         References\n361:         ==========\n362: \n363:         .. [1] Holt, D., Eick, B., O'Brien, E.\n364:                \"Handbook of computational group theory\"\n365: \n366:         .. [7] http://www.algorithmist.com/index.php/Union_Find\n367: \n368:         \"\"\"\n369:         rep_first = self._union_find_rep(first, parents)\n370:         rep_second = self._union_find_rep(second, parents)\n371:         if rep_first != rep_second:\n372:             # union by rank\n373:             if ranks[rep_first] >= ranks[rep_second]:\n374:                 new_1, new_2 = rep_first, rep_second\n375:             else:\n376:                 new_1, new_2 = rep_second, rep_first\n377:             total_rank = ranks[new_1] + ranks[new_2]\n378:             if total_rank > self.max_div:\n379:                 return -1\n380:             parents[new_2] = new_1\n381:             ranks[new_1] = total_rank\n382:             not_rep.append(new_2)\n383:             return 1\n384:         return 0\n385: \n386:     def _union_find_rep(self, num, parents):\n387:         \"\"\"Find representative of a class in a union-find data structure.\n388: \n389:         Used in the implementation of Atkinson's algorithm as suggested in [1],\n390:         pp. 83-87. After the representative of the class to which ``num``\n391:         belongs is found, path compression is performed as an optimization\n392:         ([7]).\n393: \n394:         Notes\n395:         =====\n396: \n397:         THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,\n398:         ``parents``, is altered due to path compression.\n399: \n400:         See Also\n401:         ========\n402: \n403:         minimal_block, _union_find_merge\n404: \n405:         References\n406:         ==========\n407: \n408:         .. [1] Holt, D., Eick, B., O'Brien, E.\n409:                \"Handbook of computational group theory\"\n410: \n411:         .. [7] http://www.algorithmist.com/index.php/Union_Find\n412: \n413:         \"\"\"\n414:         rep, parent = num, parents[num]\n415:         while parent != rep:\n416:             rep = parent\n417:             parent = parents[rep]\n418:         # path compression\n419:         temp, parent = num, parents[num]\n420:         while parent != rep:\n421:             parents[temp] = rep\n422:             temp = parent\n423:             parent = parents[temp]\n424:         return rep\n425: \n426:     @property\n427:     def base(self):\n428:         \"\"\"Return a base from the Schreier-Sims algorithm.\n429: \n430:         For a permutation group `G`, a base is a sequence of points\n431:         `B = (b_1, b_2, ..., b_k)` such that no element of `G` apart\n432:         from the identity fixes all the points in `B`. The concepts of\n433:         a base and strong generating set and their applications are\n434:         discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.\n435: \n436:         An alternative way to think of `B` is that it gives the\n437:         indices of the stabilizer cosets that contain more than the\n438:         identity permutation.\n439: \n440:         Examples\n441:         ========\n442: \n443:         >>> from sympy.combinatorics import Permutation, PermutationGroup\n444:         >>> G = PermutationGroup([Permutation(0, 1, 3)(2, 4)])\n445:         >>> G.base\n446:         [0, 2]\n447: \n448:         See Also\n449:         ========\n450: \n451:         strong_gens, basic_transversals, basic_orbits, basic_stabilizers\n452: \n453:         \"\"\"\n454:         if self._base == []:\n455:             self.schreier_sims()\n456:         return self._base\n457: \n458:     def baseswap(self, base, strong_gens, pos, randomized=False,\n459:                  transversals=None, basic_orbits=None, strong_gens_distr=None):\n460:         r\"\"\"Swap two consecutive base points in base and strong generating set.\n461: \n462:         If a base for a group `G` is given by `(b_1, b_2, ..., b_k)`, this\n463:         function returns a base `(b_1, b_2, ..., b_{i+1}, b_i, ..., b_k)`,\n464:         where `i` is given by ``pos``, and a strong generating set relative\n465:         to that base. The original base and strong generating set are not\n466:         modified.\n467: \n468:         The randomized version (default) is of Las Vegas type.\n469: \n470:         Parameters\n471:         ==========\n472: \n473:         base, strong_gens\n474:             The base and strong generating set.\n475:         pos\n476:             The position at which swapping is performed.\n477:         randomized\n478:             A switch between randomized and deterministic version.\n479:         transversals\n480:             The transversals for the basic orbits, if known.\n481:         basic_orbits\n482:             The basic orbits, if known.\n483:         strong_gens_distr\n484:             The strong generators distributed by basic stabilizers, if known.\n485: \n486:         Returns\n487:         =======\n488: \n489:         (base, strong_gens)\n490:             ``base`` is the new base, and ``strong_gens`` is a generating set\n491:             relative to it.\n492: \n493:         Examples\n494:         ========\n495: \n496:         >>> from sympy.combinatorics.named_groups import SymmetricGroup\n497:         >>> from sympy.combinatorics.testutil import _verify_bsgs\n498:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n499:         >>> S = SymmetricGroup(4)\n500:         >>> S.schreier_sims()\n501:         >>> S.base\n502:         [0, 1, 2]\n503:         >>> base, gens = S.baseswap(S.base, S.strong_gens, 1, randomized=False)\n504:         >>> base, gens\n505:         ([0, 2, 1],\n506:         [(0 1 2 3), (3)(0 1), (1 3 2),\n507:          (2 3), (1 3)])\n508: \n509:         check that base, gens is a BSGS\n510: \n511:         >>> S1 = PermutationGroup(gens)\n512:         >>> _verify_bsgs(S1, base, gens)\n513:         True\n514: \n515:         See Also\n516:         ========\n517: \n518:         schreier_sims\n519: \n520:         Notes\n521:         =====\n522: \n523:         The deterministic version of the algorithm is discussed in\n524:         [1], pp. 102-103; the randomized version is discussed in [1], p.103, and\n525:         [2], p.98. It is of Las Vegas type.\n526:         Notice that [1] contains a mistake in the pseudocode and\n527:         discussion of BASESWAP: on line 3 of the pseudocode,\n528:         `|\\beta_{i+1}^{\\left\\langle T\\right\\rangle}|` should be replaced by\n529:         `|\\beta_{i}^{\\left\\langle T\\right\\rangle}|`, and the same for the\n530:         discussion of the algorithm.\n531: \n532:         \"\"\"\n533:         # construct the basic orbits, generators for the stabilizer chain\n534:         # and transversal elements from whatever was provided\n535:         transversals, basic_orbits, strong_gens_distr = \\\n536:             _handle_precomputed_bsgs(base, strong_gens, transversals,\n537:                                  basic_orbits, strong_gens_distr)\n538:         base_len = len(base)\n539:         degree = self.degree\n540:         # size of orbit of base[pos] under the stabilizer we seek to insert\n541:         # in the stabilizer chain at position pos + 1\n542:         size = len(basic_orbits[pos])*len(basic_orbits[pos + 1]) \\\n543:             //len(_orbit(degree, strong_gens_distr[pos], base[pos + 1]))\n544:         # initialize the wanted stabilizer by a subgroup\n545:         if pos + 2 > base_len - 1:\n546:             T = []\n547:         else:\n548:             T = strong_gens_distr[pos + 2][:]\n549:         # randomized version\n550:         if randomized is True:\n551:             stab_pos = PermutationGroup(strong_gens_distr[pos])\n552:             schreier_vector = stab_pos.schreier_vector(base[pos + 1])\n553:             # add random elements of the stabilizer until they generate it\n554:             while len(_orbit(degree, T, base[pos])) != size:\n555:                 new = stab_pos.random_stab(base[pos + 1],\n556:                                            schreier_vector=schreier_vector)\n557:                 T.append(new)\n558:         # deterministic version\n559:         else:\n560:             Gamma = set(basic_orbits[pos])\n561:             Gamma.remove(base[pos])\n562:             if base[pos + 1] in Gamma:\n563:                 Gamma.remove(base[pos + 1])\n564:             # add elements of the stabilizer until they generate it by\n565:             # ruling out member of the basic orbit of base[pos] along the way\n566:             while len(_orbit(degree, T, base[pos])) != size:\n567:                 gamma = next(iter(Gamma))\n568:                 x = transversals[pos][gamma]\n569:                 temp = x._array_form.index(base[pos + 1]) # (~x)(base[pos + 1])\n570:                 if temp not in basic_orbits[pos + 1]:\n571:                     Gamma = Gamma - _orbit(degree, T, gamma)\n572:                 else:\n573:                     y = transversals[pos + 1][temp]\n574:                     el = rmul(x, y)\n575:                     if el(base[pos]) not in _orbit(degree, T, base[pos]):\n576:                         T.append(el)\n577:                         Gamma = Gamma - _orbit(degree, T, base[pos])\n578:         # build the new base and strong generating set\n579:         strong_gens_new_distr = strong_gens_distr[:]\n580:         strong_gens_new_distr[pos + 1] = T\n581:         base_new = base[:]\n582:         base_new[pos], base_new[pos + 1] = base_new[pos + 1], base_new[pos]\n583:         strong_gens_new = _strong_gens_from_distr(strong_gens_new_distr)\n584:         for gen in T:\n585:             if gen not in strong_gens_new:\n586:                 strong_gens_new.append(gen)\n587:         return base_new, strong_gens_new\n588: \n589:     @property\n590:     def basic_orbits(self):\n591:         \"\"\"\n592:         Return the basic orbits relative to a base and strong generating set.\n593: \n594:         If `(b_1, b_2, ..., b_k)` is a base for a group `G`, and\n595:         `G^{(i)} = G_{b_1, b_2, ..., b_{i-1}}` is the ``i``-th basic stabilizer\n596:         (so that `G^{(1)} = G`), the ``i``-th basic orbit relative to this base\n597:         is the orbit of `b_i` under `G^{(i)}`. See [1], pp. 87-89 for more\n598:         information.\n599: \n600:         Examples\n601:         ========\n602: \n603:         >>> from sympy.combinatorics.named_groups import SymmetricGroup\n604:         >>> S = SymmetricGroup(4)\n605:         >>> S.basic_orbits\n606:         [[0, 1, 2, 3], [1, 2, 3], [2, 3]]\n607: \n608:         See Also\n609:         ========\n610: \n611:         base, strong_gens, basic_transversals, basic_stabilizers\n612: \n613:         \"\"\"\n614:         if self._basic_orbits == []:\n615:             self.schreier_sims()\n616:         return self._basic_orbits\n617: \n618:     @property\n619:     def basic_stabilizers(self):\n620:         \"\"\"\n621:         Return a chain of stabilizers relative to a base and strong generating\n622:         set.\n623: \n624:         The ``i``-th basic stabilizer `G^{(i)}` relative to a base\n625:         `(b_1, b_2, ..., b_k)` is `G_{b_1, b_2, ..., b_{i-1}}`. For more\n626:         information, see [1], pp. 87-89.\n627: \n628:         Examples\n629:         ========\n630: \n631:         >>> from sympy.combinatorics.named_groups import AlternatingGroup\n632:         >>> A = AlternatingGroup(4)\n633:         >>> A.schreier_sims()\n634:         >>> A.base\n635:         [0, 1]\n636:         >>> for g in A.basic_stabilizers:\n637:         ...     print(g)\n638:         ...\n639:         PermutationGroup([\n640:             (3)(0 1 2),\n641:             (1 2 3)])\n642:         PermutationGroup([\n643:             (1 2 3)])\n644: \n645:         See Also\n646:         ========\n647: \n648:         base, strong_gens, basic_orbits, basic_transversals\n649: \n650:         \"\"\"\n651: \n652:         if self._transversals == []:\n653:             self.schreier_sims()\n654:         strong_gens = self._strong_gens\n655:         base = self._base\n656:         if not base: # e.g. if self is trivial\n657:             return []\n658:         strong_gens_distr = _distribute_gens_by_base(base, strong_gens)\n659:         basic_stabilizers = []\n660:         for gens in strong_gens_distr:\n661:             basic_stabilizers.append(PermutationGroup(gens))\n662:         return basic_stabilizers\n663: \n664:     @property\n665:     def basic_transversals(self):\n666:         \"\"\"\n667:         Return basic transversals relative to a base and strong generating set.\n668: \n669:         The basic transversals are transversals of the basic orbits. They\n670:         are provided as a list of dictionaries, each dictionary having\n671:         keys - the elements of one of the basic orbits, and values - the\n672:         corresponding transversal elements. See [1], pp. 87-89 for more\n673:         information.\n674: \n675:         Examples\n676:         ========\n677: \n678:         >>> from sympy.combinatorics.named_groups import AlternatingGroup\n679:         >>> A = AlternatingGroup(4)\n680:         >>> A.basic_transversals\n681:         [{0: (3), 1: (3)(0 1 2), 2: (3)(0 2 1), 3: (0 3 1)}, {1: (3), 2: (1 2 3), 3: (1 3 2)}]\n682: \n683:         See Also\n684:         ========\n685: \n686:         strong_gens, base, basic_orbits, basic_stabilizers\n687: \n688:         \"\"\"\n689: \n690:         if self._transversals == []:\n691:             self.schreier_sims()\n692:         return self._transversals\n693: \n694:     def composition_series(self):\n695:         r\"\"\"\n696:         Return the composition series for a group as a list\n697:         of permutation groups.\n698: \n699:         The composition series for a group `G` is defined as a\n700:         subnormal series `G = H_0 > H_1 > H_2 \\ldots` A composition\n701:         series is a subnormal series such that each factor group\n702:         `H(i+1) / H(i)` is simple.\n703:         A subnormal series is a composition series only if it is of\n704:         maximum length.\n705: \n706:         The algorithm works as follows:\n707:         Starting with the derived series the idea is to fill\n708:         the gap between `G = der[i]` and `H = der[i+1]` for each\n709:         `i` independently. Since, all subgroups of the abelian group\n710:         `G/H` are normal so, first step is to take the generators\n711:         `g` of `G` and add them to generators of `H` one by one.\n712: \n713:         The factor groups formed are not simple in general. Each\n714:         group is obtained from the previous one by adding one\n715:         generator `g`, if the previous group is denoted by `H`\n716:         then the next group `K` is generated by `g` and `H`.\n717:         The factor group `K/H` is cyclic and it's order is\n718:         `K.order()//G.order()`. The series is then extended between\n719:         `K` and `H` by groups generated by powers of `g` and `H`.\n720:         The series formed is then prepended to the already existing\n721:         series.\n722: \n723:         Examples\n724:         ========\n725:         >>> from sympy.combinatorics.named_groups import SymmetricGroup\n726:         >>> from sympy.combinatorics.named_groups import CyclicGroup\n727:         >>> S = SymmetricGroup(12)\n728:         >>> G = S.sylow_subgroup(2)\n729:         >>> C = G.composition_series()\n730:         >>> [H.order() for H in C]\n731:         [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]\n732:         >>> G = S.sylow_subgroup(3)\n733:         >>> C = G.composition_series()\n734:         >>> [H.order() for H in C]\n735:         [243, 81, 27, 9, 3, 1]\n736:         >>> G = CyclicGroup(12)\n737:         >>> C = G.composition_series()\n738:         >>> [H.order() for H in C]\n739:         [12, 6, 3, 1]\n740: \n741:         \"\"\"\n742:         der = self.derived_series()\n743:         if not (all(g.is_identity for g in der[-1].generators)):\n744:             raise NotImplementedError('Group should be solvable')\n745:         series = []\n746: \n747:         for i in range(len(der)-1):\n748:             H = der[i+1]\n749:             up_seg = []\n750:             for g in der[i].generators:\n751:                 K = PermutationGroup([g] + H.generators)\n752:                 order = K.order() // H.order()\n753:                 down_seg = []\n754:                 for p, e in factorint(order).items():\n755:                     for j in range(e):\n756:                         down_seg.append(PermutationGroup([g] + H.generators))\n757:                         g = g**p\n758:                 up_seg = down_seg + up_seg\n759:                 H = K\n760:             up_seg[0] = der[i]\n761:             series.extend(up_seg)\n762:         series.append(der[-1])\n763:         return series\n764: \n765:     def coset_transversal(self, H):\n766:         \"\"\"Return a transversal of the right cosets of self by its subgroup H\n767:         using the second method described in [1], Subsection 4.6.7\n768: \n769:         \"\"\"\n770: \n771:         if not H.is_subgroup(self):\n772:             raise ValueError(\"The argument must be a subgroup\")\n773: \n774:         if H.order() == 1:\n775:             return self._elements\n776: \n777:         self._schreier_sims(base=H.base) # make G.base an extension of H.base\n778: \n779:         base = self.base\n780:         base_ordering = _base_ordering(base, self.degree)\n781:         identity = Permutation(self.degree - 1)\n782: \n783:         transversals = self.basic_transversals[:]\n784:         # transversals is a list of dictionaries. Get rid of the keys\n785:         # so that it is a list of lists and sort each list in\n786:         # the increasing order of base[l]^x\n787:         for l, t in enumerate(transversals):\n788:             transversals[l] = sorted(t.values(),\n789:                                 key = lambda x: base_ordering[base[l]^x])\n790: \n791:         orbits = H.basic_orbits\n792:         h_stabs = H.basic_stabilizers\n793:         g_stabs = self.basic_stabilizers\n794: \n795:         indices = [x.order()//y.order() for x, y in zip(g_stabs, h_stabs)]\n796: \n797:         # T^(l) should be a right transversal of H^(l) in G^(l) for\n798:         # 1<=l<=len(base). While H^(l) is the trivial group, T^(l)\n799:         # contains all the elements of G^(l) so we might just as well\n800:         # start with l = len(h_stabs)-1\n801:         if len(g_stabs) > len(h_stabs):\n802:             T = g_stabs[len(h_stabs)]._elements\n803:         else:\n804:             T = [identity]\n805:         l = len(h_stabs)-1\n806:         t_len = len(T)\n807:         while l > -1:\n808:             T_next = []\n809:             for u in transversals[l]:\n810:                 if u == identity:\n811:                     continue\n812:                 b = base_ordering[base[l]^u]\n813:                 for t in T:\n814:                     p = t*u\n815:                     if all([base_ordering[h^p] >= b for h in orbits[l]]):\n816:                         T_next.append(p)\n817:                     if t_len + len(T_next) == indices[l]:\n818:                         break\n819:                 if t_len + len(T_next) == indices[l]:\n820:                     break\n821:             T += T_next\n822:             t_len += len(T_next)\n823:             l -= 1\n824:         T.remove(identity)\n825:         T = [identity] + T\n826:         return T\n827: \n828:     def _coset_representative(self, g, H):\n829:         \"\"\"Return the representative of Hg from the transversal that\n830:         would be computed by ``self.coset_transversal(H)``.\n831: \n832:         \"\"\"\n833:         if H.order() == 1:\n834:             return g\n835:         # The base of self must be an extension of H.base.\n836:         if not(self.base[:len(H.base)] == H.base):\n837:             self._schreier_sims(base=H.base)\n838:         orbits = H.basic_orbits[:]\n839:         h_transversals = [list(_.values()) for _ in H.basic_transversals]\n840:         transversals = [list(_.values()) for _ in self.basic_transversals]\n841:         base = self.base\n842:         base_ordering = _base_ordering(base, self.degree)\n843:         def step(l, x):\n844:             gamma = sorted(orbits[l], key = lambda y: base_ordering[y^x])[0]\n845:             i = [base[l]^h for h in h_transversals[l]].index(gamma)\n846:             x = h_transversals[l][i]*x\n847:             if l < len(orbits)-1:\n848:                 for u in transversals[l]:\n849:                     if base[l]^u == base[l]^x:\n850:                         break\n851:                 x = step(l+1, x*u**-1)*u\n852:             return x\n853:         return step(0, g)\n854: \n855:     def coset_table(self, H):\n856:         \"\"\"Return the standardised (right) coset table of self in H as\n857:         a list of lists.\n858:         \"\"\"\n859:         # Maybe this should be made to return an instance of CosetTable\n860:         # from fp_groups.py but the class would need to be changed first\n861:         # to be compatible with PermutationGroups\n862: \n863:         from itertools import chain, product\n864:         if not H.is_subgroup(self):\n865:             raise ValueError(\"The argument must be a subgroup\")\n866:         T = self.coset_transversal(H)\n867:         n = len(T)\n868: \n869:         A = list(chain.from_iterable((gen, gen**-1)\n870:                     for gen in self.generators))\n871: \n872:         table = []\n873:         for i in range(n):\n874:             row = [self._coset_representative(T[i]*x, H) for x in A]\n875:             row = [T.index(r) for r in row]\n876:             table.append(row)\n877: \n878:         # standardize (this is the same as the algorithm used in coset_table)\n879:         # If CosetTable is made compatible with PermutationGroups, this\n880:         # should be replaced by table.standardize()\n881:         A = range(len(A))\n882:         gamma = 1\n883:         for alpha, a in product(range(n), A):\n884:             beta = table[alpha][a]\n885:             if beta >= gamma:\n886:                 if beta > gamma:\n887:                     for x in A:\n888:                         z = table[gamma][x]\n889:                         table[gamma][x] = table[beta][x]\n890:                         table[beta][x] = z\n891:                         for i in range(n):\n892:                             if table[i][x] == beta:\n893:                                 table[i][x] = gamma\n894:                             elif table[i][x] == gamma:\n895:                                 table[i][x] = beta\n896:                 gamma += 1\n897:             if gamma >= n-1:\n898:                 return table\n899: \n900:     def center(self):\n901:         r\"\"\"\n902:         Return the center of a permutation group.\n903: \n904:         The center for a group `G` is defined as\n905:         `Z(G) = \\{z\\in G | \\forall g\\in G, zg = gz \\}`,\n906:         the set of elements of `G` that commute with all elements of `G`.\n907:         It is equal to the centralizer of `G` inside `G`, and is naturally a\n908:         subgroup of `G` ([9]).\n909: \n910:         Examples\n911:         ========\n912: \n913:         >>> from sympy.combinatorics.named_groups import DihedralGroup\n914:         >>> D = DihedralGroup(4)\n915:         >>> G = D.center()\n916:         >>> G.order()\n917:         2\n918: \n919:         See Also\n920:         ========\n921: \n922:         centralizer\n923: \n924:         Notes\n925:         =====\n926: \n927:         This is a naive implementation that is a straightforward application\n928:         of ``.centralizer()``\n929: \n930:         \"\"\"\n931:         return self.centralizer(self)\n932: \n933:     def centralizer(self, other):\n934:         r\"\"\"\n935:         Return the centralizer of a group/set/element.\n936: \n937:         The centralizer of a set of permutations ``S`` inside\n938:         a group ``G`` is the set of elements of ``G`` that commute with all\n939:         elements of ``S``::\n940: \n941:             `C_G(S) = \\{ g \\in G | gs = sg \\forall s \\in S\\}` ([10])\n942: \n943:         Usually, ``S`` is a subset of ``G``, but if ``G`` is a proper subgroup of\n944:         the full symmetric group, we allow for ``S`` to have elements outside\n945:         ``G``.\n946: \n947:         It is naturally a subgroup of ``G``; the centralizer of a permutation\n948:         group is equal to the centralizer of any set of generators for that\n949:         group, since any element commuting with the generators commutes with\n950:         any product of the  generators.\n951: \n952:         Parameters\n953:         ==========\n954: \n955:         other\n956:             a permutation group/list of permutations/single permutation\n957: \n958:         Examples\n959:         ========\n960: \n961:         >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n962:         ... CyclicGroup)\n963:         >>> S = SymmetricGroup(6)\n964:         >>> C = CyclicGroup(6)\n965:         >>> H = S.centralizer(C)\n966:         >>> H.is_subgroup(C)\n967:         True\n968: \n969:         See Also\n970:         ========\n971: \n972:         subgroup_search\n973: \n974:         Notes\n975:         =====\n976: \n977:         The implementation is an application of ``.subgroup_search()`` with\n978:         tests using a specific base for the group ``G``.\n979: \n980:         \"\"\"\n981:         if hasattr(other, 'generators'):\n982:             if other.is_trivial or self.is_trivial:\n983:                 return self\n984:             degree = self.degree\n985:             identity = _af_new(list(range(degree)))\n986:             orbits = other.orbits()\n987:             num_orbits = len(orbits)\n988:             orbits.sort(key=lambda x: -len(x))\n989:             long_base = []\n990:             orbit_reps = [None]*num_orbits\n991:             orbit_reps_indices = [None]*num_orbits\n992:             orbit_descr = [None]*degree\n993:             for i in range(num_orbits):\n994:                 orbit = list(orbits[i])\n995:                 orbit_reps[i] = orbit[0]\n996:                 orbit_reps_indices[i] = len(long_base)\n997:                 for point in orbit:\n998:                     orbit_descr[point] = i\n999:                 long_base = long_base + orbit\n1000:             base, strong_gens = self.schreier_sims_incremental(base=long_base)\n1001:             strong_gens_distr = _distribute_gens_by_base(base, strong_gens)\n1002:             i = 0\n1003:             for i in range(len(base)):\n1004:                 if strong_gens_distr[i] == [identity]:\n1005:                     break\n1006:             base = base[:i]\n1007:             base_len = i\n1008:             for j in range(num_orbits):\n1009:                 if base[base_len - 1] in orbits[j]:\n1010:                     break\n1011:             rel_orbits = orbits[: j + 1]\n1012:             num_rel_orbits = len(rel_orbits)\n1013:             transversals = [None]*num_rel_orbits\n1014:             for j in range(num_rel_orbits):\n1015:                 rep = orbit_reps[j]\n1016:                 transversals[j] = dict(\n1017:                     other.orbit_transversal(rep, pairs=True))\n1018:             trivial_test = lambda x: True\n1019:             tests = [None]*base_len\n1020:             for l in range(base_len):\n1021:                 if base[l] in orbit_reps:\n1022:                     tests[l] = trivial_test\n1023:                 else:\n1024:                     def test(computed_words, l=l):\n1025:                         g = computed_words[l]\n1026:                         rep_orb_index = orbit_descr[base[l]]\n1027:                         rep = orbit_reps[rep_orb_index]\n1028:                         im = g._array_form[base[l]]\n1029:                         im_rep = g._array_form[rep]\n1030:                         tr_el = transversals[rep_orb_index][base[l]]\n1031:                         # using the definition of transversal,\n1032:                         # base[l]^g = rep^(tr_el*g);\n1033:                         # if g belongs to the centralizer, then\n1034:                         # base[l]^g = (rep^g)^tr_el\n1035:                         return im == tr_el._array_form[im_rep]\n1036:                     tests[l] = test\n1037: \n1038:             def prop(g):\n1039:                 return [rmul(g, gen) for gen in other.generators] == \\\n1040:                        [rmul(gen, g) for gen in other.generators]\n1041:             return self.subgroup_search(prop, base=base,\n1042:                                         strong_gens=strong_gens, tests=tests)\n1043:         elif hasattr(other, '__getitem__'):\n1044:             gens = list(other)\n1045:             return self.centralizer(PermutationGroup(gens))\n1046:         elif hasattr(other, 'array_form'):\n1047:             return self.centralizer(PermutationGroup([other]))\n1048: \n1049:     def commutator(self, G, H):\n1050:         \"\"\"\n1051:         Return the commutator of two subgroups.\n1052: \n1053:         For a permutation group ``K`` and subgroups ``G``, ``H``, the\n1054:         commutator of ``G`` and ``H`` is defined as the group generated\n1055:         by all the commutators `[g, h] = hgh^{-1}g^{-1}` for ``g`` in ``G`` and\n1056:         ``h`` in ``H``. It is naturally a subgroup of ``K`` ([1], p.27).\n1057: \n1058:         Examples\n1059:         ========\n1060: \n1061:         >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n1062:         ... AlternatingGroup)\n1063:         >>> S = SymmetricGroup(5)\n1064:         >>> A = AlternatingGroup(5)\n1065:         >>> G = S.commutator(S, A)\n1066:         >>> G.is_subgroup(A)\n1067:         True\n1068: \n1069:         See Also\n1070:         ========\n1071: \n1072:         derived_subgroup\n1073: \n1074:         Notes\n1075:         =====\n1076: \n1077:         The commutator of two subgroups `H, G` is equal to the normal closure\n1078:         of the commutators of all the generators, i.e. `hgh^{-1}g^{-1}` for `h`\n1079:         a generator of `H` and `g` a generator of `G` ([1], p.28)\n1080: \n1081:         \"\"\"\n1082:         ggens = G.generators\n1083:         hgens = H.generators\n1084:         commutators = []\n1085:         for ggen in ggens:\n1086:             for hgen in hgens:\n1087:                 commutator = rmul(hgen, ggen, ~hgen, ~ggen)\n1088:                 if commutator not in commutators:\n1089:                     commutators.append(commutator)\n1090:         res = self.normal_closure(commutators)\n1091:         return res\n1092: \n1093:     def coset_factor(self, g, factor_index=False):\n1094:         \"\"\"Return ``G``'s (self's) coset factorization of ``g``\n1095: \n1096:         If ``g`` is an element of ``G`` then it can be written as the product\n1097:         of permutations drawn from the Schreier-Sims coset decomposition,\n1098: \n1099:         The permutations returned in ``f`` are those for which\n1100:         the product gives ``g``: ``g = f[n]*...f[1]*f[0]`` where ``n = len(B)``\n1101:         and ``B = G.base``. f[i] is one of the permutations in\n1102:         ``self._basic_orbits[i]``.\n1103: \n1104:         If factor_index==True,\n1105:         returns a tuple ``[b[0],..,b[n]]``, where ``b[i]``\n1106:         belongs to ``self._basic_orbits[i]``\n1107: \n1108:         Examples\n1109:         ========\n1110: \n1111:         >>> from sympy.combinatorics import Permutation, PermutationGroup\n1112:         >>> a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)\n1113:         >>> b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)\n1114:         >>> G = PermutationGroup([a, b])\n1115: \n1116:         Define g:\n1117: \n1118:         >>> g = Permutation(7)(1, 2, 4)(3, 6, 5)\n1119: \n1120:         Confirm that it is an element of G:\n1121: \n1122:         >>> G.contains(g)\n1123:         True\n1124: \n1125:         Thus, it can be written as a product of factors (up to\n1126:         3) drawn from u. See below that a factor from u1 and u2\n1127:         and the Identity permutation have been used:\n1128: \n1129:         >>> f = G.coset_factor(g)\n1130:         >>> f[2]*f[1]*f[0] == g\n1131:         True\n1132:         >>> f1 = G.coset_factor(g, True); f1\n1133:         [0, 4, 4]\n1134:         >>> tr = G.basic_transversals\n1135:         >>> f[0] == tr[0][f1[0]]\n1136:         True\n1137: \n1138:         If g is not an element of G then [] is returned:\n1139: \n1140:         >>> c = Permutation(5, 6, 7)\n1141:         >>> G.coset_factor(c)\n1142:         []\n1143: \n1144:         See Also\n1145:         ========\n1146: \n1147:         sympy.combinatorics.util._strip\n1148: \n1149:         \"\"\"\n1150:         if isinstance(g, (Cycle, Permutation)):\n1151:             g = g.list()\n1152:         if len(g) != self._degree:\n1153:             # this could either adjust the size or return [] immediately\n1154:             # but we don't choose between the two and just signal a possible\n1155:             # error\n1156:             raise ValueError('g should be the same size as permutations of G')\n1157:         I = list(range(self._degree))\n1158:         basic_orbits = self.basic_orbits\n1159:         transversals = self._transversals\n1160:         factors = []\n1161:         base = self.base\n1162:         h = g\n1163:         for i in range(len(base)):\n1164:             beta = h[base[i]]\n1165:             if beta == base[i]:\n1166:                 factors.append(beta)\n1167:                 continue\n1168:             if beta not in basic_orbits[i]:\n1169:                 return []\n1170:             u = transversals[i][beta]._array_form\n1171:             h = _af_rmul(_af_invert(u), h)\n1172:             factors.append(beta)\n1173:         if h != I:\n1174:             return []\n1175:         if factor_index:\n1176:             return factors\n1177:         tr = self.basic_transversals\n1178:         factors = [tr[i][factors[i]] for i in range(len(base))]\n1179:         return factors\n1180: \n1181:     def generator_product(self, g, original=False):\n1182:         '''\n1183:         Return a list of strong generators `[s1, ..., sn]`\n1184:         s.t `g = sn*...*s1`. If `original=True`, make the list\n1185:         contain only the original group generators\n1186: \n1187:         '''\n1188:         product = []\n1189:         if g.is_identity:\n1190:             return []\n1191:         if g in self.strong_gens:\n1192:             if not original or g in self.generators:\n1193:                 return [g]\n1194:             else:\n1195:                 slp = self._strong_gens_slp[g]\n1196:                 for s in slp:\n1197:                     product.extend(self.generator_product(s, original=True))\n1198:                 return product\n1199:         elif g**-1 in self.strong_gens:\n1200:             g = g**-1\n1201:             if not original or g in self.generators:\n1202:                 return [g**-1]\n1203:             else:\n1204:                 slp = self._strong_gens_slp[g]\n1205:                 for s in slp:\n1206:                     product.extend(self.generator_product(s, original=True))\n1207:                 l = len(product)\n1208:                 product = [product[l-i-1]**-1 for i in range(l)]\n1209:                 return product\n1210: \n1211:         f = self.coset_factor(g, True)\n1212:         for i, j in enumerate(f):\n1213:             slp = self._transversal_slp[i][j]\n1214:             for s in slp:\n1215:                 if not original:\n1216:                     product.append(self.strong_gens[s])\n1217:                 else:\n1218:                     s = self.strong_gens[s]\n1219:                     product.extend(self.generator_product(s, original=True))\n1220:         return product\n1221: \n1222:     def coset_rank(self, g):\n1223:         \"\"\"rank using Schreier-Sims representation\n1224: \n1225:         The coset rank of ``g`` is the ordering number in which\n1226:         it appears in the lexicographic listing according to the\n1227:         coset decomposition\n1228: \n1229:         The ordering is the same as in G.generate(method='coset').\n1230:         If ``g`` does not belong to the group it returns None.\n1231: \n1232:         Examples\n1233:         ========\n1234: \n1235:         >>> from sympy.combinatorics import Permutation\n1236:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1237:         >>> a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)\n1238:         >>> b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)\n1239:         >>> G = PermutationGroup([a, b])\n1240:         >>> c = Permutation(7)(2, 4)(3, 5)\n1241:         >>> G.coset_rank(c)\n1242:         16\n1243:         >>> G.coset_unrank(16)\n1244:         (7)(2 4)(3 5)\n1245: \n1246:         See Also\n1247:         ========\n1248: \n1249:         coset_factor\n1250: \n1251:         \"\"\"\n1252:         factors = self.coset_factor(g, True)\n1253:         if not factors:\n1254:             return None\n1255:         rank = 0\n1256:         b = 1\n1257:         transversals = self._transversals\n1258:         base = self._base\n1259:         basic_orbits = self._basic_orbits\n1260:         for i in range(len(base)):\n1261:             k = factors[i]\n1262:             j = basic_orbits[i].index(k)\n1263:             rank += b*j\n1264:             b = b*len(transversals[i])\n1265:         return rank\n1266: \n1267:     def coset_unrank(self, rank, af=False):\n1268:         \"\"\"unrank using Schreier-Sims representation\n1269: \n1270:         coset_unrank is the inverse operation of coset_rank\n1271:         if 0 <= rank < order; otherwise it returns None.\n1272: \n1273:         \"\"\"\n1274:         if rank < 0 or rank >= self.order():\n1275:             return None\n1276:         base = self.base\n1277:         transversals = self.basic_transversals\n1278:         basic_orbits = self.basic_orbits\n1279:         m = len(base)\n1280:         v = [0]*m\n1281:         for i in range(m):\n1282:             rank, c = divmod(rank, len(transversals[i]))\n1283:             v[i] = basic_orbits[i][c]\n1284:         a = [transversals[i][v[i]]._array_form for i in range(m)]\n1285:         h = _af_rmuln(*a)\n1286:         if af:\n1287:             return h\n1288:         else:\n1289:             return _af_new(h)\n1290: \n1291:     @property\n1292:     def degree(self):\n1293:         \"\"\"Returns the size of the permutations in the group.\n1294: \n1295:         The number of permutations comprising the group is given by\n1296:         ``len(group)``; the number of permutations that can be generated\n1297:         by the group is given by ``group.order()``.\n1298: \n1299:         Examples\n1300:         ========\n1301: \n1302:         >>> from sympy.combinatorics import Permutation\n1303:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1304:         >>> a = Permutation([1, 0, 2])\n1305:         >>> G = PermutationGroup([a])\n1306:         >>> G.degree\n1307:         3\n1308:         >>> len(G)\n1309:         1\n1310:         >>> G.order()\n1311:         2\n1312:         >>> list(G.generate())\n1313:         [(2), (2)(0 1)]\n1314: \n1315:         See Also\n1316:         ========\n1317: \n1318:         order\n1319:         \"\"\"\n1320:         return self._degree\n1321: \n1322:     @property\n1323:     def identity(self):\n1324:         '''\n1325:         Return the identity element of the permutation group.\n1326: \n1327:         '''\n1328:         return _af_new(list(range(self.degree)))\n1329: \n1330:     @property\n1331:     def elements(self):\n1332:         \"\"\"Returns all the elements of the permutation group as a set\n1333: \n1334:         Examples\n1335:         ========\n1336: \n1337:         >>> from sympy.combinatorics import Permutation, PermutationGroup\n1338:         >>> p = PermutationGroup(Permutation(1, 3), Permutation(1, 2))\n1339:         >>> p.elements\n1340:         {(1 2 3), (1 3 2), (1 3), (2 3), (3), (3)(1 2)}\n1341: \n1342:         \"\"\"\n1343:         return set(self._elements)\n1344: \n1345:     @property\n1346:     def _elements(self):\n1347:         \"\"\"Returns all the elements of the permutation group as a list\n1348: \n1349:         Examples\n1350:         ========\n1351: \n1352:         >>> from sympy.combinatorics import Permutation, PermutationGroup\n1353:         >>> p = PermutationGroup(Permutation(1, 3), Permutation(1, 2))\n1354:         >>> p._elements\n1355:         [(3), (3)(1 2), (1 3), (2 3), (1 2 3), (1 3 2)]\n1356: \n1357:         \"\"\"\n1358:         return list(islice(self.generate(), None))\n1359: \n1360:     def derived_series(self):\n1361:         r\"\"\"Return the derived series for the group.\n1362: \n1363:         The derived series for a group `G` is defined as\n1364:         `G = G_0 > G_1 > G_2 > \\ldots` where `G_i = [G_{i-1}, G_{i-1}]`,\n1365:         i.e. `G_i` is the derived subgroup of `G_{i-1}`, for\n1366:         `i\\in\\mathbb{N}`. When we have `G_k = G_{k-1}` for some\n1367:         `k\\in\\mathbb{N}`, the series terminates.\n1368: \n1369:         Returns\n1370:         =======\n1371: \n1372:         A list of permutation groups containing the members of the derived\n1373:         series in the order `G = G_0, G_1, G_2, \\ldots`.\n1374: \n1375:         Examples\n1376:         ========\n1377: \n1378:         >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n1379:         ... AlternatingGroup, DihedralGroup)\n1380:         >>> A = AlternatingGroup(5)\n1381:         >>> len(A.derived_series())\n1382:         1\n1383:         >>> S = SymmetricGroup(4)\n1384:         >>> len(S.derived_series())\n1385:         4\n1386:         >>> S.derived_series()[1].is_subgroup(AlternatingGroup(4))\n1387:         True\n1388:         >>> S.derived_series()[2].is_subgroup(DihedralGroup(2))\n1389:         True\n1390: \n1391:         See Also\n1392:         ========\n1393: \n1394:         derived_subgroup\n1395: \n1396:         \"\"\"\n1397:         res = [self]\n1398:         current = self\n1399:         next = self.derived_subgroup()\n1400:         while not current.is_subgroup(next):\n1401:             res.append(next)\n1402:             current = next\n1403:             next = next.derived_subgroup()\n1404:         return res\n1405: \n1406:     def derived_subgroup(self):\n1407:         r\"\"\"Compute the derived subgroup.\n1408: \n1409:         The derived subgroup, or commutator subgroup is the subgroup generated\n1410:         by all commutators `[g, h] = hgh^{-1}g^{-1}` for `g, h\\in G` ; it is\n1411:         equal to the normal closure of the set of commutators of the generators\n1412:         ([1], p.28, [11]).\n1413: \n1414:         Examples\n1415:         ========\n1416: \n1417:         >>> from sympy.combinatorics import Permutation\n1418:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1419:         >>> a = Permutation([1, 0, 2, 4, 3])\n1420:         >>> b = Permutation([0, 1, 3, 2, 4])\n1421:         >>> G = PermutationGroup([a, b])\n1422:         >>> C = G.derived_subgroup()\n1423:         >>> list(C.generate(af=True))\n1424:         [[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]\n1425: \n1426:         See Also\n1427:         ========\n1428: \n1429:         derived_series\n1430: \n1431:         \"\"\"\n1432:         r = self._r\n1433:         gens = [p._array_form for p in self.generators]\n1434:         set_commutators = set()\n1435:         degree = self._degree\n1436:         rng = list(range(degree))\n1437:         for i in range(r):\n1438:             for j in range(r):\n1439:                 p1 = gens[i]\n1440:                 p2 = gens[j]\n1441:                 c = list(range(degree))\n1442:                 for k in rng:\n1443:                     c[p2[p1[k]]] = p1[p2[k]]\n1444:                 ct = tuple(c)\n1445:                 if not ct in set_commutators:\n1446:                     set_commutators.add(ct)\n1447:         cms = [_af_new(p) for p in set_commutators]\n1448:         G2 = self.normal_closure(cms)\n1449:         return G2\n1450: \n1451:     def generate(self, method=\"coset\", af=False):\n1452:         \"\"\"Return iterator to generate the elements of the group\n1453: \n1454:         Iteration is done with one of these methods::\n1455: \n1456:           method='coset'  using the Schreier-Sims coset representation\n1457:           method='dimino' using the Dimino method\n1458: \n1459:         If af = True it yields the array form of the permutations\n1460: \n1461:         Examples\n1462:         ========\n1463: \n1464:         >>> from sympy.combinatorics import PermutationGroup\n1465:         >>> from sympy.combinatorics.polyhedron import tetrahedron\n1466: \n1467:         The permutation group given in the tetrahedron object is also\n1468:         true groups:\n1469: \n1470:         >>> G = tetrahedron.pgroup\n1471:         >>> G.is_group\n1472:         True\n1473: \n1474:         Also the group generated by the permutations in the tetrahedron\n1475:         pgroup -- even the first two -- is a proper group:\n1476: \n1477:         >>> H = PermutationGroup(G[0], G[1])\n1478:         >>> J = PermutationGroup(list(H.generate())); J\n1479:         PermutationGroup([\n1480:             (0 1)(2 3),\n1481:             (1 2 3),\n1482:             (1 3 2),\n1483:             (0 3 1),\n1484:             (0 2 3),\n1485:             (0 3)(1 2),\n1486:             (0 1 3),\n1487:             (3)(0 2 1),\n1488:             (0 3 2),\n1489:             (3)(0 1 2),\n1490:             (0 2)(1 3)])\n1491:         >>> _.is_group\n1492:         True\n1493:         \"\"\"\n1494:         if method == \"coset\":\n1495:             return self.generate_schreier_sims(af)\n1496:         elif method == \"dimino\":\n1497:             return self.generate_dimino(af)\n1498:         else:\n1499:             raise NotImplementedError('No generation defined for %s' % method)\n1500: \n1501:     def generate_dimino(self, af=False):\n1502:         \"\"\"Yield group elements using Dimino's algorithm\n1503: \n1504:         If af == True it yields the array form of the permutations\n1505: \n1506:         Examples\n1507:         ========\n1508: \n1509:         >>> from sympy.combinatorics import Permutation\n1510:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1511:         >>> a = Permutation([0, 2, 1, 3])\n1512:         >>> b = Permutation([0, 2, 3, 1])\n1513:         >>> g = PermutationGroup([a, b])\n1514:         >>> list(g.generate_dimino(af=True))\n1515:         [[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1],\n1516:          [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]\n1517: \n1518:         References\n1519:         ==========\n1520: \n1521:         .. [1] The Implementation of Various Algorithms for Permutation Groups in\n1522:                the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis\n1523: \n1524:         \"\"\"\n1525:         idn = list(range(self.degree))\n1526:         order = 0\n1527:         element_list = [idn]\n1528:         set_element_list = {tuple(idn)}\n1529:         if af:\n1530:             yield idn\n1531:         else:\n1532:             yield _af_new(idn)\n1533:         gens = [p._array_form for p in self.generators]\n1534: \n1535:         for i in range(len(gens)):\n1536:             # D elements of the subgroup G_i generated by gens[:i]\n1537:             D = element_list[:]\n1538:             N = [idn]\n1539:             while N:\n1540:                 A = N\n1541:                 N = []\n1542:                 for a in A:\n1543:                     for g in gens[:i + 1]:\n1544:                         ag = _af_rmul(a, g)\n1545:                         if tuple(ag) not in set_element_list:\n1546:                             # produce G_i*g\n1547:                             for d in D:\n1548:                                 order += 1\n1549:                                 ap = _af_rmul(d, ag)\n1550:                                 if af:\n1551:                                     yield ap\n1552:                                 else:\n1553:                                     p = _af_new(ap)\n1554:                                     yield p\n1555:                                 element_list.append(ap)\n1556:                                 set_element_list.add(tuple(ap))\n1557:                                 N.append(ap)\n1558:         self._order = len(element_list)\n1559: \n1560:     def generate_schreier_sims(self, af=False):\n1561:         \"\"\"Yield group elements using the Schreier-Sims representation\n1562:         in coset_rank order\n1563: \n1564:         If ``af = True`` it yields the array form of the permutations\n1565: \n1566:         Examples\n1567:         ========\n1568: \n1569:         >>> from sympy.combinatorics import Permutation\n1570:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1571:         >>> a = Permutation([0, 2, 1, 3])\n1572:         >>> b = Permutation([0, 2, 3, 1])\n1573:         >>> g = PermutationGroup([a, b])\n1574:         >>> list(g.generate_schreier_sims(af=True))\n1575:         [[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 2, 1],\n1576:          [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2]]\n1577:         \"\"\"\n1578: \n1579:         n = self._degree\n1580:         u = self.basic_transversals\n1581:         basic_orbits = self._basic_orbits\n1582:         if len(u) == 0:\n1583:             for x in self.generators:\n1584:                 if af:\n1585:                     yield x._array_form\n1586:                 else:\n1587:                     yield x\n1588:             return\n1589:         if len(u) == 1:\n1590:             for i in basic_orbits[0]:\n1591:                 if af:\n1592:                     yield u[0][i]._array_form\n1593:                 else:\n1594:                     yield u[0][i]\n1595:             return\n1596: \n1597:         u = list(reversed(u))\n1598:         basic_orbits = basic_orbits[::-1]\n1599:         # stg stack of group elements\n1600:         stg = [list(range(n))]\n1601:         posmax = [len(x) for x in u]\n1602:         n1 = len(posmax) - 1\n1603:         pos = [0]*n1\n1604:         h = 0\n1605:         while 1:\n1606:             # backtrack when finished iterating over coset\n1607:             if pos[h] >= posmax[h]:\n1608:                 if h == 0:\n1609:                     return\n1610:                 pos[h] = 0\n1611:                 h -= 1\n1612:                 stg.pop()\n1613:                 continue\n1614:             p = _af_rmul(u[h][basic_orbits[h][pos[h]]]._array_form, stg[-1])\n1615:             pos[h] += 1\n1616:             stg.append(p)\n1617:             h += 1\n1618:             if h == n1:\n1619:                 if af:\n1620:                     for i in basic_orbits[-1]:\n1621:                         p = _af_rmul(u[-1][i]._array_form, stg[-1])\n1622:                         yield p\n1623:                 else:\n1624:                     for i in basic_orbits[-1]:\n1625:                         p = _af_rmul(u[-1][i]._array_form, stg[-1])\n1626:                         p1 = _af_new(p)\n1627:                         yield p1\n1628:                 stg.pop()\n1629:                 h -= 1\n1630: \n1631:     @property\n1632:     def generators(self):\n1633:         \"\"\"Returns the generators of the group.\n1634: \n1635:         Examples\n1636:         ========\n1637: \n1638:         >>> from sympy.combinatorics import Permutation\n1639:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1640:         >>> a = Permutation([0, 2, 1])\n1641:         >>> b = Permutation([1, 0, 2])\n1642:         >>> G = PermutationGroup([a, b])\n1643:         >>> G.generators\n1644:         [(1 2), (2)(0 1)]\n1645: \n1646:         \"\"\"\n1647:         return self._generators\n1648: \n1649:     def contains(self, g, strict=True):\n1650:         \"\"\"Test if permutation ``g`` belong to self, ``G``.\n1651: \n1652:         If ``g`` is an element of ``G`` it can be written as a product\n1653:         of factors drawn from the cosets of ``G``'s stabilizers. To see\n1654:         if ``g`` is one of the actual generators defining the group use\n1655:         ``G.has(g)``.\n1656: \n1657:         If ``strict`` is not ``True``, ``g`` will be resized, if necessary,\n1658:         to match the size of permutations in ``self``.\n1659: \n1660:         Examples\n1661:         ========\n1662: \n1663:         >>> from sympy.combinatorics import Permutation\n1664:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1665: \n1666:         >>> a = Permutation(1, 2)\n1667:         >>> b = Permutation(2, 3, 1)\n1668:         >>> G = PermutationGroup(a, b, degree=5)\n1669:         >>> G.contains(G[0]) # trivial check\n1670:         True\n1671:         >>> elem = Permutation([[2, 3]], size=5)\n1672:         >>> G.contains(elem)\n1673:         True\n1674:         >>> G.contains(Permutation(4)(0, 1, 2, 3))\n1675:         False\n1676: \n1677:         If strict is False, a permutation will be resized, if\n1678:         necessary:\n1679: \n1680:         >>> H = PermutationGroup(Permutation(5))\n1681:         >>> H.contains(Permutation(3))\n1682:         False\n1683:         >>> H.contains(Permutation(3), strict=False)\n1684:         True\n1685: \n1686:         To test if a given permutation is present in the group:\n1687: \n1688:         >>> elem in G.generators\n1689:         False\n1690:         >>> G.has(elem)\n1691:         False\n1692: \n1693:         See Also\n1694:         ========\n1695: \n1696:         coset_factor, sympy.core.basic.Basic.has, __contains__\n1697: \n1698:         \"\"\"\n1699:         if not isinstance(g, Permutation):\n1700:             return False\n1701:         if g.size != self.degree:\n1702:             if strict:\n1703:                 return False\n1704:             g = Permutation(g, size=self.degree)\n1705:         if g in self.generators:\n1706:             return True\n1707:         return bool(self.coset_factor(g.array_form, True))\n1708: \n1709:     @property\n1710:     def is_perfect(self):\n1711:         \"\"\"Return ``True`` if the group is perfect.\n1712:         A group is perfect if it equals to its derived subgroup.\n1713: \n1714:         Examples\n1715:         ========\n1716: \n1717:         >>> from sympy.combinatorics import Permutation\n1718:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1719:         >>> a = Permutation(1,2,3)(4,5)\n1720:         >>> b = Permutation(1,2,3,4,5)\n1721:         >>> G = PermutationGroup([a, b])\n1722:         >>> G.is_perfect\n1723:         False\n1724: \n1725:         \"\"\"\n1726:         if self._is_perfect is None:\n1727:             self._is_perfect = self == self.derived_subgroup()\n1728:         return self._is_perfect\n1729: \n1730:     @property\n1731:     def is_abelian(self):\n1732:         \"\"\"Test if the group is Abelian.\n1733: \n1734:         Examples\n1735:         ========\n1736: \n1737:         >>> from sympy.combinatorics import Permutation\n1738:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1739:         >>> a = Permutation([0, 2, 1])\n1740:         >>> b = Permutation([1, 0, 2])\n1741:         >>> G = PermutationGroup([a, b])\n1742:         >>> G.is_abelian\n1743:         False\n1744:         >>> a = Permutation([0, 2, 1])\n1745:         >>> G = PermutationGroup([a])\n1746:         >>> G.is_abelian\n1747:         True\n1748: \n1749:         \"\"\"\n1750:         if self._is_abelian is not None:\n1751:             return self._is_abelian\n1752: \n1753:         self._is_abelian = True\n1754:         gens = [p._array_form for p in self.generators]\n1755:         for x in gens:\n1756:             for y in gens:\n1757:                 if y <= x:\n1758:                     continue\n1759:                 if not _af_commutes_with(x, y):\n1760:                     self._is_abelian = False\n1761:                     return False\n1762:         return True\n1763: \n1764:     def abelian_invariants(self):\n1765:         \"\"\"\n1766:         Returns the abelian invariants for the given group.\n1767:         Let ``G`` be a nontrivial finite abelian group. Then G is isomorphic to\n1768:         the direct product of finitely many nontrivial cyclic groups of\n1769:         prime-power order.\n1770: \n1771:         The prime-powers that occur as the orders of the factors are uniquely\n1772:         determined by G. More precisely, the primes that occur in the orders of the\n1773:         factors in any such decomposition of ``G`` are exactly the primes that divide\n1774:         ``|G|`` and for any such prime ``p``, if the orders of the factors that are\n1775:         p-groups in one such decomposition of ``G`` are ``p^{t_1} >= p^{t_2} >= ... p^{t_r}``,\n1776:         then the orders of the factors that are p-groups in any such decomposition of ``G``\n1777:         are ``p^{t_1} >= p^{t_2} >= ... p^{t_r}``.\n1778: \n1779:         The uniquely determined integers ``p^{t_1} >= p^{t_2} >= ... p^{t_r}``, taken\n1780:         for all primes that divide ``|G|`` are called the invariants of the nontrivial\n1781:         group ``G`` as suggested in ([14], p. 542).\n1782: \n1783:         Notes\n1784:         =====\n1785: \n1786:         We adopt the convention that the invariants of a trivial group are [].\n1787: \n1788:         Examples\n1789:         ========\n1790: \n1791:         >>> from sympy.combinatorics import Permutation\n1792:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1793:         >>> a = Permutation([0, 2, 1])\n1794:         >>> b = Permutation([1, 0, 2])\n1795:         >>> G = PermutationGroup([a, b])\n1796:         >>> G.abelian_invariants()\n1797:         [2]\n1798:         >>> from sympy.combinatorics.named_groups import CyclicGroup\n1799:         >>> G = CyclicGroup(7)\n1800:         >>> G.abelian_invariants()\n1801:         [7]\n1802: \n1803:         \"\"\"\n1804:         if self.is_trivial:\n1805:             return []\n1806:         gns = self.generators\n1807:         inv = []\n1808:         G = self\n1809:         H = G.derived_subgroup()\n1810:         Hgens = H.generators\n1811:         for p in primefactors(G.order()):\n1812:             ranks = []\n1813:             while True:\n1814:                 pows = []\n1815:                 for g in gns:\n1816:                     elm = g**p\n1817:                     if not H.contains(elm):\n1818:                         pows.append(elm)\n1819:                 K = PermutationGroup(Hgens + pows) if pows else H\n1820:                 r = G.order()//K.order()\n1821:                 G = K\n1822:                 gns = pows\n1823:                 if r == 1:\n1824:                     break;\n1825:                 ranks.append(multiplicity(p, r))\n1826: \n1827:             if ranks:\n1828:                 pows = [1]*ranks[0]\n1829:                 for i in ranks:\n1830:                     for j in range(0, i):\n1831:                         pows[j] = pows[j]*p\n1832:                 inv.extend(pows)\n1833:         inv.sort()\n1834:         return inv\n1835: \n1836:     def is_elementary(self, p):\n1837:         \"\"\"Return ``True`` if the group is elementary abelian. An elementary\n1838:         abelian group is a finite abelian group, where every nontrivial\n1839:         element has order `p`, where `p` is a prime.\n1840: \n1841:         Examples\n1842:         ========\n1843: \n1844:         >>> from sympy.combinatorics import Permutation\n1845:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n1846:         >>> a = Permutation([0, 2, 1])\n1847:         >>> G = PermutationGroup([a])\n1848:         >>> G.is_elementary(2)\n1849:         True\n1850:         >>> a = Permutation([0, 2, 1, 3])\n1851:         >>> b = Permutation([3, 1, 2, 0])\n1852:         >>> G = PermutationGroup([a, b])\n1853:         >>> G.is_elementary(2)\n1854:         True\n1855:         >>> G.is_elementary(3)\n1856:         False\n1857: \n1858:         \"\"\"\n1859:         return self.is_abelian and all(g.order() == p for g in self.generators)\n1860: \n1861:     def _eval_is_alt_sym_naive(self, only_sym=False, only_alt=False):\n1862:         \"\"\"A naive test using the group order.\"\"\"\n1863:         if only_sym and only_alt:\n1864:             raise ValueError(\n1865:                 \"Both {} and {} cannot be set to True\"\n1866:                 .format(only_sym, only_alt))\n1867: \n1868:         n = self.degree\n1869:         sym_order = 1\n1870:         for i in range(2, n+1):\n1871:             sym_order *= i\n1872:         order = self.order()\n1873: \n1874:         if order == sym_order:\n1875:             self._is_sym = True\n1876:             self._is_alt = False\n1877:             if only_alt:\n1878:                 return False\n1879:             return True\n1880: \n1881:         elif 2*order == sym_order:\n1882:             self._is_sym = False\n1883:             self._is_alt = True\n1884:             if only_sym:\n1885:                 return False\n1886:             return True\n1887: \n1888:         return False\n1889: \n1890:     def _eval_is_alt_sym_monte_carlo(self, eps=0.05, perms=None):\n1891:         \"\"\"A test using monte-carlo algorithm.\n1892: \n1893:         Parameters\n1894:         ==========\n1895: \n1896:         eps : float, optional\n1897:             The criterion for the incorrect ``False`` return.\n1898: \n1899:         perms : list[Permutation], optional\n1900:             If explicitly given, it tests over the given candidats\n1901:             for testing.\n1902: \n1903:             If ``None``, it randomly computes ``N_eps`` and chooses\n1904:             ``N_eps`` sample of the permutation from the group.\n1905: \n1906:         See Also\n1907:         ========\n1908: \n1909:         _check_cycles_alt_sym\n1910:         \"\"\"\n1911:         if perms is None:\n1912:             n = self.degree\n1913:             if n < 17:\n1914:                 c_n = 0.34\n1915:             else:\n1916:                 c_n = 0.57\n1917:             d_n = (c_n*log(2))/log(n)\n1918:             N_eps = int(-log(eps)/d_n)\n1919: \n1920:             perms = (self.random_pr() for i in range(N_eps))\n1921:             return self._eval_is_alt_sym_monte_carlo(perms=perms)\n1922: \n1923:         for perm in perms:\n1924:             if _check_cycles_alt_sym(perm):\n1925:                 return True\n1926:         return False\n1927: \n1928:     def is_alt_sym(self, eps=0.05, _random_prec=None):\n1929:         r\"\"\"Monte Carlo test for the symmetric/alternating group for degrees\n1930:         >= 8.\n1931: \n1932:         More specifically, it is one-sided Monte Carlo with the\n1933:         answer True (i.e., G is symmetric/alternating) guaranteed to be\n1934:         correct, and the answer False being incorrect with probability eps.\n1935: \n1936:         For degree < 8, the order of the group is checked so the test\n1937:         is deterministic.\n1938: \n1939:         Notes\n1940:         =====\n1941: \n1942:         The algorithm itself uses some nontrivial results from group theory and\n1943:         number theory:\n1944:         1) If a transitive group ``G`` of degree ``n`` contains an element\n1945:         with a cycle of length ``n/2 < p < n-2`` for ``p`` a prime, ``G`` is the\n1946:         symmetric or alternating group ([1], pp. 81-82)\n1947:         2) The proportion of elements in the symmetric/alternating group having\n1948:         the property described in 1) is approximately `\\log(2)/\\log(n)`\n1949:         ([1], p.82; [2], pp. 226-227).\n1950:         The helper function ``_check_cycles_alt_sym`` is used to\n1951:         go over the cycles in a permutation and look for ones satisfying 1).\n1952: \n1953:         Examples\n1954:         ========\n1955: \n1956:         >>> from sympy.combinatorics.named_groups import DihedralGroup\n1957:         >>> D = DihedralGroup(10)\n1958:         >>> D.is_alt_sym()\n1959:         False\n1960: \n1961:         See Also\n1962:         ========\n1963: \n1964:         _check_cycles_alt_sym\n1965: \n1966:         \"\"\"\n1967:         if _random_prec is not None:\n1968:             N_eps = _random_prec['N_eps']\n1969:             perms= (_random_prec[i] for i in range(N_eps))\n1970:             return self._eval_is_alt_sym_monte_carlo(perms=perms)\n1971: \n1972:         if self._is_sym or self._is_alt:\n1973:             return True\n1974:         if self._is_sym is False and self._is_alt is False:\n1975:             return False\n1976: \n1977:         n = self.degree\n1978:         if n < 8:\n1979:             return self._eval_is_alt_sym_naive()\n1980:         elif self.is_transitive():\n1981:             return self._eval_is_alt_sym_monte_carlo(eps=eps)\n1982: \n1983:         self._is_sym, self._is_alt = False, False\n1984:         return False\n1985: \n1986:     @property\n1987:     def is_nilpotent(self):\n1988:         \"\"\"Test if the group is nilpotent.\n1989: \n1990:         A group `G` is nilpotent if it has a central series of finite length.\n1991:         Alternatively, `G` is nilpotent if its lower central series terminates\n1992:         with the trivial group. Every nilpotent group is also solvable\n1993:         ([1], p.29, [12]).\n1994: \n1995:         Examples\n1996:         ========\n1997: \n1998:         >>> from sympy.combinatorics.named_groups import (SymmetricGroup,\n1999:         ... CyclicGroup)\n2000:         >>> C = CyclicGroup(6)\n2001:         >>> C.is_nilpotent\n2002:         True\n2003:         >>> S = SymmetricGroup(5)\n2004:         >>> S.is_nilpotent\n2005:         False\n2006: \n2007:         See Also\n2008:         ========\n2009: \n2010:         lower_central_series, is_solvable\n2011: \n2012:         \"\"\"\n2013:         if self._is_nilpotent is None:\n2014:             lcs = self.lower_central_series()\n2015:             terminator = lcs[len(lcs) - 1]\n2016:             gens = terminator.generators\n2017:             degree = self.degree\n2018:             identity = _af_new(list(range(degree)))\n2019:             if all(g == identity for g in gens):\n2020:                 self._is_solvable = True\n2021:                 self._is_nilpotent = True\n2022:                 return True\n2023:             else:\n2024:                 self._is_nilpotent = False\n2025:                 return False\n2026:         else:\n2027:             return self._is_nilpotent\n2028: \n2029:     def is_normal(self, gr, strict=True):\n2030:         \"\"\"Test if ``G=self`` is a normal subgroup of ``gr``.\n2031: \n2032:         G is normal in gr if\n2033:         for each g2 in G, g1 in gr, ``g = g1*g2*g1**-1`` belongs to G\n2034:         It is sufficient to check this for each g1 in gr.generators and\n2035:         g2 in G.generators.\n2036: \n2037:         Examples\n2038:         ========\n2039: \n2040:         >>> from sympy.combinatorics import Permutation\n2041:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n2042:         >>> a = Permutation([1, 2, 0])\n2043:         >>> b = Permutation([1, 0, 2])\n2044:         >>> G = PermutationGroup([a, b])\n2045:         >>> G1 = PermutationGroup([a, Permutation([2, 0, 1])])\n2046:         >>> G1.is_normal(G)\n2047:         True\n2048: \n2049:         \"\"\"\n2050:         if not self.is_subgroup(gr, strict=strict):\n2051:             return False\n2052:         d_self = self.degree\n2053:         d_gr = gr.degree\n2054:         if self.is_trivial and (d_self == d_gr or not strict):\n2055:             return True\n2056:         if self._is_abelian:\n2057:             return True\n2058:         new_self = self.copy()\n2059:         if not strict and d_self != d_gr:\n2060:             if d_self < d_gr:\n2061:                 new_self = PermGroup(new_self.generators + [Permutation(d_gr - 1)])\n2062:             else:\n2063:                 gr = PermGroup(gr.generators + [Permutation(d_self - 1)])\n2064:         gens2 = [p._array_form for p in new_self.generators]\n2065:         gens1 = [p._array_form for p in gr.generators]\n2066:         for g1 in gens1:\n2067:             for g2 in gens2:\n2068:                 p = _af_rmuln(g1, g2, _af_invert(g1))\n2069:                 if not new_self.coset_factor(p, True):\n2070:                     return False\n2071:         return True\n2072: \n2073:     def is_primitive(self, randomized=True):\n2074:         r\"\"\"Test if a group is primitive.\n2075: \n2076:         A permutation group ``G`` acting on a set ``S`` is called primitive if\n2077:         ``S`` contains no nontrivial block under the action of ``G``\n2078:         (a block is nontrivial if its cardinality is more than ``1``).\n2079: \n2080:         Notes\n2081:         =====\n2082: \n2083:         The algorithm is described in [1], p.83, and uses the function\n2084:         minimal_block to search for blocks of the form `\\{0, k\\}` for ``k``\n2085:         ranging over representatives for the orbits of `G_0`, the stabilizer of\n2086:         ``0``. This algorithm has complexity `O(n^2)` where ``n`` is the degree\n2087:         of the group, and will perform badly if `G_0` is small.\n2088: \n2089:         There are two implementations offered: one finds `G_0`\n2090:         deterministically using the function ``stabilizer``, and the other\n2091:         (default) produces random elements of `G_0` using ``random_stab``,\n2092:         hoping that they generate a subgroup of `G_0` with not too many more\n2093:         orbits than `G_0` (this is suggested in [1], p.83). Behavior is changed\n2094:         by the ``randomized`` flag.\n2095: \n2096:         Examples\n2097:         ========\n2098: \n2099:         >>> from sympy.combinatorics.named_groups import DihedralGroup\n2100:         >>> D = DihedralGroup(10)\n2101:         >>> D.is_primitive()\n2102:         False\n2103: \n2104:         See Also\n2105:         ========\n2106: \n2107:         minimal_block, random_stab\n2108: \n2109:         \"\"\"\n2110:         if self._is_primitive is not None:\n2111:             return self._is_primitive\n2112: \n2113:         if self.is_transitive() is False:\n2114:             return False\n2115: \n2116:         if randomized:\n2117:             random_stab_gens = []\n2118:             v = self.schreier_vector(0)\n2119:             for i in range(len(self)):\n2120:                 random_stab_gens.append(self.random_stab(0, v))\n2121:             stab = PermutationGroup(random_stab_gens)\n2122:         else:\n2123:             stab = self.stabilizer(0)\n2124:         orbits = stab.orbits()\n2125:         for orb in orbits:\n2126:             x = orb.pop()\n2127:             if x != 0 and any(e != 0 for e in self.minimal_block([0, x])):\n2128:                 self._is_primitive = False\n2129:                 return False\n2130:         self._is_primitive = True\n2131:         return True\n2132: \n2133:     def minimal_blocks(self, randomized=True):\n2134:         '''\n2135:         For a transitive group, return the list of all minimal\n2136:         block systems. If a group is intransitive, return `False`.\n2137: \n2138:         Examples\n2139:         ========\n2140:         >>> from sympy.combinatorics import Permutation\n2141:         >>> from sympy.combinatorics.perm_groups import PermutationGroup\n2142:         >>> from sympy.combinatorics.named_groups import DihedralGroup\n2143:         >>> DihedralGroup(6).minimal_blocks()\n2144:         [[0, 1, 0, 1, 0, 1], [0, 1, 2, 0, 1, 2]]\n2145:         >>> G = PermutationGroup(Permutation(1,2,5))\n2146:         >>> G.minimal_blocks()\n2147:         False\n2148: \n2149:         See Also\n2150:         ========\n2151: \n2152:         minimal_block, is_transitive, is_primitive\n2153: \n2154:         '''\n2155:         def _number_blocks(blocks):\n2156:             # number the blocks of a block system\n2157:             # in order and return the number of\n2158:             # blocks and the tuple with the\n2159:             # reordering\n2160:             n = len(blocks)\n2161:             appeared = {}\n2162:             m = 0\n2163:             b = [None]*n\n2164:             for i in range(n):\n2165:                 if blocks[i] not in appeared:\n2166:                     appeared[blocks[i]] = m\n2167:                     b[i] = m\n2168:                     m += 1\n2169:                 else:\n2170:                     b[i] = appeared[blocks[i]]\n2171:             return tuple(b), m\n2172: \n2173:         if not self.is_transitive():\n2174:             return False\n2175:         blocks = []\n2176:         num_blocks = []\n2177:         rep_blocks = []\n2178:         if randomized:\n2179:             random_stab_gens = []\n2180:             v = self.schreier_vector(0)\n2181:             for i in range(len(self)):\n2182:                 random_stab_gens.append(self.random_stab(0, v))\n2183:             stab = PermutationGroup(random_stab_gens)\n2184:         else:\n2185:             stab = self.stabilizer(0)\n2186:         orbits = stab.orbits()\n2187:         for orb in orbits:\n2188:             x = orb.pop()\n2189:             if x != 0:\n2190:                 block = self.minimal_block([0, x])\n2191:                 num_block, m = _number_blocks(block)\n2192:                 # a representative block (containing 0)\n2193:                 rep = {j for j in range(self.degree) if num_block[j] == 0}\n2194:                 # check if the system is minimal with\n2195:                 # respect to the already discovere ones\n2196:                 minimal = True\n2197:                 to_remove = []\n2198:                 for i, r in enumerate(rep_blocks):\n2199:                     if len(r) > len(rep) and rep.issubset(r):\n2200:                         # i-th block system is not minimal\n2201:                         del num_blocks[i], blocks[i]\n2202:                         to_remove.append(rep_blocks[i])\n2203:                     elif len(r) < len(rep) and r.issubset(rep):\n2204:                         # the system being checked is not minimal\n2205:                         minimal = False\n2206:                         break\n2207:                 # remove non-minimal representative blocks\n2208:                 rep_blocks = [r for r in rep_blocks if r not in to_remove]\n2209: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/combinatorics/perm_groups.py",
      "suspect_lines": [
        2197,
        2201,
        2202,
        2208
      ]
    }
  ]
}