{
  "instance_id": "django__django-15814",
  "problem_statement": "QuerySet.only() after select_related() crash on proxy models.\nDescription\n\t\nWhen I optimize a query using select_related() and only() methods from the proxy model I encounter an error:\nWindows 10; Python 3.10; Django 4.0.5\nTraceback (most recent call last):\n File \"D:\\study\\django_college\\manage.py\", line 22, in <module>\n\tmain()\n File \"D:\\study\\django_college\\manage.py\", line 18, in main\n\texecute_from_command_line(sys.argv)\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\core\\management\\__init__.py\", line 446, in execute_from_command_line\n\tutility.execute()\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\core\\management\\__init__.py\", line 440, in execute\n\tself.fetch_command(subcommand).run_from_argv(self.argv)\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\core\\management\\base.py\", line 414, in run_from_argv\n\tself.execute(*args, **cmd_options)\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\core\\management\\base.py\", line 460, in execute\n\toutput = self.handle(*args, **options)\n File \"D:\\study\\django_college\\project\\users\\management\\commands\\test_proxy.py\", line 9, in handle\n\tobjs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\db\\models\\query.py\", line 302, in __len__\n\tself._fetch_all()\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\db\\models\\query.py\", line 1507, in _fetch_all\n\tself._result_cache = list(self._iterable_class(self))\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\db\\models\\query.py\", line 71, in __iter__\n\trelated_populators = get_related_populators(klass_info, select, db)\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\db\\models\\query.py\", line 2268, in get_related_populators\n\trel_cls = RelatedPopulator(rel_klass_info, select, db)\n File \"D:\\Anaconda3\\envs\\django\\lib\\site-packages\\django\\db\\models\\query.py\", line 2243, in __init__\n\tself.pk_idx = self.init_list.index(self.model_cls._meta.pk.attname)\nValueError: 'id' is not in list\nModels:\nclass CustomModel(models.Model):\n\tname = models.CharField(max_length=16)\nclass ProxyCustomModel(CustomModel):\n\tclass Meta:\n\t\tproxy = True\nclass AnotherModel(models.Model):\n\tcustom = models.ForeignKey(\n\t\tProxyCustomModel,\n\t\ton_delete=models.SET_NULL,\n\t\tnull=True,\n\t\tblank=True,\n\t)\nCommand:\nclass Command(BaseCommand):\n\tdef handle(self, *args, **options):\n\t\tlist(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\nAt django/db/models/sql/query.py in 745 line there is snippet:\nopts = cur_model._meta\nIf I replace it by \nopts = cur_model._meta.concrete_model._meta\nall works as expected.\n",
  "localized_code": "[start of django/db/models/sql/query.py]\n1: \"\"\"\n2: Create SQL statements for QuerySets.\n3: \n4: The code in here encapsulates all of the SQL construction so that QuerySets\n5: themselves do not have to (and could be backed by things other than SQL\n6: databases). The abstraction barrier only works one way: this module has to know\n7: all about the internals of models in order to get the information it needs.\n8: \"\"\"\n9: import copy\n10: import difflib\n11: import functools\n12: import sys\n13: from collections import Counter, namedtuple\n14: from collections.abc import Iterator, Mapping\n15: from itertools import chain, count, product\n16: from string import ascii_uppercase\n17: \n18: from django.core.exceptions import FieldDoesNotExist, FieldError\n19: from django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\n20: from django.db.models.aggregates import Count\n21: from django.db.models.constants import LOOKUP_SEP\n22: from django.db.models.expressions import (\n23:     BaseExpression,\n24:     Col,\n25:     Exists,\n26:     F,\n27:     OuterRef,\n28:     Ref,\n29:     ResolvedOuterRef,\n30:     Value,\n31: )\n32: from django.db.models.fields import Field\n33: from django.db.models.fields.related_lookups import MultiColSource\n34: from django.db.models.lookups import Lookup\n35: from django.db.models.query_utils import (\n36:     Q,\n37:     check_rel_lookup_compatibility,\n38:     refs_expression,\n39: )\n40: from django.db.models.sql.constants import INNER, LOUTER, ORDER_DIR, SINGLE\n41: from django.db.models.sql.datastructures import BaseTable, Empty, Join, MultiJoin\n42: from django.db.models.sql.where import AND, OR, ExtraWhere, NothingNode, WhereNode\n43: from django.utils.functional import cached_property\n44: from django.utils.regex_helper import _lazy_re_compile\n45: from django.utils.tree import Node\n46: \n47: __all__ = [\"Query\", \"RawQuery\"]\n48: \n49: # Quotation marks ('\"`[]), whitespace characters, semicolons, or inline\n50: # SQL comments are forbidden in column aliases.\n51: FORBIDDEN_ALIAS_PATTERN = _lazy_re_compile(r\"['`\\\"\\]\\[;\\s]|--|/\\*|\\*/\")\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/sql/query.py",
      "suspect_lines": []
    }
  ]
}