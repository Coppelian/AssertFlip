{
  "instance_id": "matplotlib__matplotlib-22871",
  "problem_statement": "[Bug]: ConciseDateFormatter not showing year anywhere when plotting <12 months\n### Bug summary\n\nWhen I plot < 1 year and January is not included in the x-axis, the year doesn't show up anywhere.\r\nThis bug is different from bug #21670 (fixed in #21785).\n\n### Code for reproduction\n\n```python\nimport matplotlib.pyplot as plt\r\nimport matplotlib.dates as mdates\r\nfrom datetime import datetime, timedelta\r\n\r\n#create time array\r\ninitial = datetime(2021,2,14,0,0,0)\r\ntime_array = [initial + timedelta(days=x) for x in range(1,200)]\r\n\r\n#create data array\r\ndata = [-x**2/20000 for x in range(1,200)]\r\n\r\n\r\n#plot data\r\nfig,ax = plt.subplots()\r\nax.plot(time_array,data) \r\n        \r\nlocator = mdates.AutoDateLocator()\r\nformatter = mdates.ConciseDateFormatter(locator)\r\n\r\nax.grid(True)\r\nax.set_ylabel(\"Temperature ($\\degree$C)\")\r\nax.xaxis.set_major_locator(locator)   \r\nax.xaxis.set_major_formatter(formatter)\r\nfig.autofmt_xdate() #automatically makes the x-labels rotate\n```\n\n\n### Actual outcome\n\n![image](https://user-images.githubusercontent.com/15143365/154090257-c7813f1c-f9ea-4252-86bf-f84e449c2f46.png)\r\n\n\n### Expected outcome\n\nI expect the year \"2021\" to show in the offset, to the right of the x-axis\n\n### Additional information\n\nI'm using Spyder IDE, v5.1.5\n\n### Operating system\n\nWindows 10\n\n### Matplotlib Version\n\n3.4.3\n\n### Matplotlib Backend\n\nQt5Agg\n\n### Python version\n\n3.9.1\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\nconda\n",
  "localized_code": "[start of lib/matplotlib/dates.py]\n1: \"\"\"\n2: Matplotlib provides sophisticated date plotting capabilities, standing on the\n3: shoulders of python :mod:`datetime` and the add-on module dateutil_.\n4: \n5: By default, Matplotlib uses the units machinery described in\n6: `~matplotlib.units` to convert `datetime.datetime`, and `numpy.datetime64`\n7: objects when plotted on an x- or y-axis. The user does not\n8: need to do anything for dates to be formatted, but dates often have strict\n9: formatting needs, so this module provides many axis locators and formatters.\n10: A basic example using `numpy.datetime64` is::\n11: \n12:     import numpy as np\n13: \n14:     times = np.arange(np.datetime64('2001-01-02'),\n15:                       np.datetime64('2002-02-03'), np.timedelta64(75, 'm'))\n16:     y = np.random.randn(len(times))\n17: \n18:     fig, ax = plt.subplots()\n19:     ax.plot(times, y)\n20: \n21: .. seealso::\n22: \n23:     - :doc:`/gallery/text_labels_and_annotations/date`\n24:     - :doc:`/gallery/ticks/date_concise_formatter`\n25:     - :doc:`/gallery/ticks/date_demo_convert`\n26: \n27: .. _date-format:\n28: \n29: Matplotlib date format\n30: ----------------------\n31: \n32: Matplotlib represents dates using floating point numbers specifying the number\n33: of days since a default epoch of 1970-01-01 UTC; for example,\n34: 1970-01-01, 06:00 is the floating point number 0.25. The formatters and\n35: locators require the use of `datetime.datetime` objects, so only dates between\n36: year 0001 and 9999 can be represented.  Microsecond precision\n37: is achievable for (approximately) 70 years on either side of the epoch, and\n38: 20 microseconds for the rest of the allowable range of dates (year 0001 to\n39: 9999). The epoch can be changed at import time via `.dates.set_epoch` or\n40: :rc:`dates.epoch` to other dates if necessary; see\n41: :doc:`/gallery/ticks/date_precision_and_epochs` for a discussion.\n42: \n43: .. note::\n44: \n45:    Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern\n46:    microsecond precision and also made the default axis limit of 0 an invalid\n47:    datetime.  In 3.3 the epoch was changed as above.  To convert old\n48:    ordinal floats to the new epoch, users can do::\n49: \n50:      new_ordinal = old_ordinal + mdates.date2num(np.datetime64('0000-12-31'))\n51: \n52: \n53: There are a number of helper functions to convert between :mod:`datetime`\n54: objects and Matplotlib dates:\n55: \n56: .. currentmodule:: matplotlib.dates\n57: \n58: .. autosummary::\n59:    :nosignatures:\n60: \n61:    datestr2num\n62:    date2num\n63:    num2date\n64:    num2timedelta\n65:    drange\n66:    set_epoch\n67:    get_epoch\n68: \n69: .. note::\n70: \n71:    Like Python's `datetime.datetime`, Matplotlib uses the Gregorian calendar\n72:    for all conversions between dates and floating point numbers. This practice\n73:    is not universal, and calendar differences can cause confusing\n74:    differences between what Python and Matplotlib give as the number of days\n75:    since 0001-01-01 and what other software and databases yield.  For\n76:    example, the US Naval Observatory uses a calendar that switches\n77:    from Julian to Gregorian in October, 1582.  Hence, using their\n78:    calculator, the number of days between 0001-01-01 and 2006-04-01 is\n79:    732403, whereas using the Gregorian calendar via the datetime\n80:    module we find::\n81: \n82:      In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()\n83:      Out[1]: 732401\n84: \n85: All the Matplotlib date converters, tickers and formatters are timezone aware.\n86: If no explicit timezone is provided, :rc:`timezone` is assumed, provided as a\n87: string.  If you want to use a different timezone, pass the *tz* keyword\n88: argument of `num2date` to any date tickers or locators you create.  This can\n89: be either a `datetime.tzinfo` instance or a string with the timezone name that\n90: can be parsed by `~dateutil.tz.gettz`.\n91: \n92: A wide range of specific and general purpose date tick locators and\n93: formatters are provided in this module.  See\n94: :mod:`matplotlib.ticker` for general information on tick locators\n95: and formatters.  These are described below.\n96: \n97: The dateutil_ module provides additional code to handle date ticking, making it\n98: easy to place ticks on any kinds of dates.  See examples below.\n99: \n100: .. _dateutil: https://dateutil.readthedocs.io\n101: \n102: Date tickers\n103: ------------\n104: \n105: Most of the date tickers can locate single or multiple values.  For example::\n106: \n107:     # import constants for the days of the week\n108:     from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU\n109: \n110:     # tick on mondays every week\n111:     loc = WeekdayLocator(byweekday=MO, tz=tz)\n112: \n113:     # tick on mondays and saturdays\n114:     loc = WeekdayLocator(byweekday=(MO, SA))\n115: \n116: In addition, most of the constructors take an interval argument::\n117: \n118:     # tick on mondays every second week\n119:     loc = WeekdayLocator(byweekday=MO, interval=2)\n120: \n121: The rrule locator allows completely general date ticking::\n122: \n123:     # tick every 5th easter\n124:     rule = rrulewrapper(YEARLY, byeaster=1, interval=5)\n125:     loc = RRuleLocator(rule)\n126: \n127: The available date tickers are:\n128: \n129: * `MicrosecondLocator`: Locate microseconds.\n130: \n131: * `SecondLocator`: Locate seconds.\n132: \n133: * `MinuteLocator`: Locate minutes.\n134: \n135: * `HourLocator`: Locate hours.\n136: \n137: * `DayLocator`: Locate specified days of the month.\n138: \n139: * `WeekdayLocator`: Locate days of the week, e.g., MO, TU.\n140: \n141: * `MonthLocator`: Locate months, e.g., 7 for July.\n142: \n143: * `YearLocator`: Locate years that are multiples of base.\n144: \n145: * `RRuleLocator`: Locate using a ``matplotlib.dates.rrulewrapper``.\n146:   ``rrulewrapper`` is a simple wrapper around dateutil_'s `dateutil.rrule`\n147:   which allow almost arbitrary date tick specifications.\n148:   See :doc:`rrule example </gallery/ticks/date_demo_rrule>`.\n149: \n150: * `AutoDateLocator`: On autoscale, this class picks the best `DateLocator`\n151:   (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If\n152:   called with ``interval_multiples=True`` it will make ticks line up with\n153:   sensible multiples of the tick intervals.  E.g. if the interval is 4 hours,\n154:   it will pick hours 0, 4, 8, etc as ticks.  This behaviour is not guaranteed\n155:   by default.\n156: \n157: Date formatters\n158: ---------------\n159: \n160: The available date formatters are:\n161: \n162: * `AutoDateFormatter`: attempts to figure out the best format to use.  This is\n163:   most useful when used with the `AutoDateLocator`.\n164: \n165: * `ConciseDateFormatter`: also attempts to figure out the best format to use,\n166:   and to make the format as compact as possible while still having complete\n167:   date information.  This is most useful when used with the `AutoDateLocator`.\n168: \n169: * `DateFormatter`: use `~datetime.datetime.strftime` format strings.\n170: \"\"\"\n171: \n172: import datetime\n173: import functools\n174: import logging\n175: import math\n176: \n177: from dateutil.rrule import (rrule, MO, TU, WE, TH, FR, SA, SU, YEARLY,\n178:                             MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,\n179:                             SECONDLY)\n180: from dateutil.relativedelta import relativedelta\n181: import dateutil.parser\n182: import dateutil.tz\n183: import numpy as np\n184: \n185: import matplotlib as mpl\n186: from matplotlib import _api, cbook, ticker, units\n187: \n188: __all__ = ('datestr2num', 'date2num', 'num2date', 'num2timedelta', 'drange',\n189:            'epoch2num', 'num2epoch', 'set_epoch', 'get_epoch', 'DateFormatter',\n190:            'ConciseDateFormatter', 'AutoDateFormatter',\n191:            'DateLocator', 'RRuleLocator', 'AutoDateLocator', 'YearLocator',\n192:            'MonthLocator', 'WeekdayLocator',\n193:            'DayLocator', 'HourLocator', 'MinuteLocator',\n194:            'SecondLocator', 'MicrosecondLocator',\n195:            'rrule', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU',\n196:            'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',\n197:            'HOURLY', 'MINUTELY', 'SECONDLY', 'MICROSECONDLY', 'relativedelta',\n198:            'DateConverter', 'ConciseDateConverter')\n199: \n200: \n201: _log = logging.getLogger(__name__)\n202: UTC = datetime.timezone.utc\n203: \n204: \n205: def _get_tzinfo(tz=None):\nCode replaced for brevity.\n222: \n223: \n224: \n225: # Time-related constants.\n226: EPOCH_OFFSET = float(datetime.datetime(1970, 1, 1).toordinal())\n227: # EPOCH_OFFSET is not used by matplotlib\n228: JULIAN_OFFSET = 1721424.5  # Julian date at 0000-12-31\n229: # note that the Julian day epoch is achievable w/\n230: # np.datetime64('-4713-11-24T12:00:00'); datetime64 is proleptic\n231: # Gregorian and BC has a one-year offset.  So\n232: # np.datetime64('0000-12-31') - np.datetime64('-4713-11-24T12:00') = 1721424.5\n233: # Ref: https://en.wikipedia.org/wiki/Julian_day\n234: MICROSECONDLY = SECONDLY + 1\n235: HOURS_PER_DAY = 24.\n236: MIN_PER_HOUR = 60.\n237: SEC_PER_MIN = 60.\n238: MONTHS_PER_YEAR = 12.\n239: \n240: DAYS_PER_WEEK = 7.\n241: DAYS_PER_MONTH = 30.\n242: DAYS_PER_YEAR = 365.0\n243: \n244: MINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY\n245: \n246: SEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR\n247: SEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY\n248: SEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK\n249: \n250: MUSECONDS_PER_DAY = 1e6 * SEC_PER_DAY\n251: \n252: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY = (\n253:     MO, TU, WE, TH, FR, SA, SU)\n254: WEEKDAYS = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)\n255: \n256: # default epoch: passed to np.datetime64...\n257: _epoch = None\n258: \n259: \n260: def _reset_epoch_test_example():\nCode replaced for brevity.\n267: \n268: \n269: \n270: def set_epoch(epoch):\nCode replaced for brevity.\n296: \n297: \n298: \n299: def get_epoch():\nCode replaced for brevity.\n312: \n313: \n314: \n315: def _dt64_to_ordinalf(d):\nCode replaced for brevity.\n340: \n341: \n342: \n343: def _from_ordinalf(x, tz=None):\nCode replaced for brevity.\n379: \n380: \n381: \n382: # a version of _from_ordinalf that can operate on numpy arrays\n383: _from_ordinalf_np_vectorized = np.vectorize(_from_ordinalf, otypes=\"O\")\n384: \n385: \n386: # a version of dateutil.parser.parse that can operate on numpy arrays\n387: _dateutil_parser_parse_np_vectorized = np.vectorize(dateutil.parser.parse)\n388: \n389: \n390: def datestr2num(d, default=None):\nCode replaced for brevity.\n413: \n414: \n415: \n416: def date2num(d):\nCode replaced for brevity.\n462: \n463: \n464: \n465: def julian2num(j):\nCode replaced for brevity.\n485: \n486: \n487: \n488: def num2julian(n):\nCode replaced for brevity.\n507: \n508: \n509: \n510: def num2date(x, tz=None):\nCode replaced for brevity.\n538: \n539: \n540: \n541: _ordinalf_to_timedelta_np_vectorized = np.vectorize(\n542:     lambda x: datetime.timedelta(days=x), otypes=\"O\")\n543: \n544: \n545: def num2timedelta(x):\nCode replaced for brevity.\n561: \n562: \n563: \n564: def drange(dstart, dend, delta):\nCode replaced for brevity.\n601: \n602: \n603: \n604: def _wrap_in_tex(text):\nCode replaced for brevity.\n605: \n606: \n607: \n608: ## date tickers and formatters ###\n609: \n610: \n611: class DateFormatter(ticker.Formatter):\nCode replaced for brevity.\n639: \n640: \n641: \n642: class ConciseDateFormatter(ticker.Formatter):\n643:     \"\"\"\n644:     A `.Formatter` which attempts to figure out the best format to use for the\n645:     date, and to make it as compact as possible, but still be complete. This is\n646:     most useful when used with the `AutoDateLocator`::\n647: \n648:     >>> locator = AutoDateLocator()\n649:     >>> formatter = ConciseDateFormatter(locator)\n650: \n651:     Parameters\n652:     ----------\n653:     locator : `.ticker.Locator`\n654:         Locator that this axis is using.\n655: \n656:     tz : str or `~datetime.tzinfo`, default: :rc:`timezone`\n657:         Passed to `.dates.num2date`.\n658: \n659:     formats : list of 6 strings, optional\n660:         Format strings for 6 levels of tick labelling: mostly years,\n661:         months, days, hours, minutes, and seconds.  Strings use\n662:         the same format codes as `~datetime.datetime.strftime`.  Default is\n663:         ``['%Y', '%b', '%d', '%H:%M', '%H:%M', '%S.%f']``\n664: \n665:     zero_formats : list of 6 strings, optional\n666:         Format strings for tick labels that are \"zeros\" for a given tick\n667:         level.  For instance, if most ticks are months, ticks around 1 Jan 2005\n668:         will be labeled \"Dec\", \"2005\", \"Feb\".  The default is\n669:         ``['', '%Y', '%b', '%b-%d', '%H:%M', '%H:%M']``\n670: \n671:     offset_formats : list of 6 strings, optional\n672:         Format strings for the 6 levels that is applied to the \"offset\"\n673:         string found on the right side of an x-axis, or top of a y-axis.\n674:         Combined with the tick labels this should completely specify the\n675:         date.  The default is::\n676: \n677:             ['', '%Y', '%Y-%b', '%Y-%b-%d', '%Y-%b-%d', '%Y-%b-%d %H:%M']\n678: \n679:     show_offset : bool, default: True\n680:         Whether to show the offset or not.\n681: \n682:     usetex : bool, default: :rc:`text.usetex`\n683:         To enable/disable the use of TeX's math mode for rendering the results\n684:         of the formatter.\n685: \n686:     Examples\n687:     --------\n688:     See :doc:`/gallery/ticks/date_concise_formatter`\n689: \n690:     .. plot::\n691: \n692:         import datetime\n693:         import matplotlib.dates as mdates\n694: \n695:         base = datetime.datetime(2005, 2, 1)\n696:         dates = np.array([base + datetime.timedelta(hours=(2 * i))\n697:                           for i in range(732)])\n698:         N = len(dates)\n699:         np.random.seed(19680801)\n700:         y = np.cumsum(np.random.randn(N))\n701: \n702:         fig, ax = plt.subplots(constrained_layout=True)\n703:         locator = mdates.AutoDateLocator()\n704:         formatter = mdates.ConciseDateFormatter(locator)\n705:         ax.xaxis.set_major_locator(locator)\n706:         ax.xaxis.set_major_formatter(formatter)\n707: \n708:         ax.plot(dates, y)\n709:         ax.set_title('Concise Date Formatter')\n710: \n711:     \"\"\"\n712: \n713:     def __init__(self, locator, tz=None, formats=None, offset_formats=None,\n714:                  zero_formats=None, show_offset=True, *, usetex=None):\n715:         \"\"\"\n716:         Autoformat the date labels.  The default format is used to form an\n717:         initial string, and then redundant elements are removed.\n718:         \"\"\"\n719:         self._locator = locator\n720:         self._tz = tz\n721:         self.defaultfmt = '%Y'\n722:         # there are 6 levels with each level getting a specific format\n723:         # 0: mostly years,  1: months,  2: days,\n724:         # 3: hours, 4: minutes, 5: seconds\n725:         if formats:\n726:             if len(formats) != 6:\n727:                 raise ValueError('formats argument must be a list of '\n728:                                  '6 format strings (or None)')\n729:             self.formats = formats\n730:         else:\n731:             self.formats = ['%Y',  # ticks are mostly years\n732:                             '%b',          # ticks are mostly months\n733:                             '%d',          # ticks are mostly days\n734:                             '%H:%M',       # hrs\n735:                             '%H:%M',       # min\n736:                             '%S.%f',       # secs\n737:                             ]\n738:         # fmt for zeros ticks at this level.  These are\n739:         # ticks that should be labeled w/ info the level above.\n740:         # like 1 Jan can just be labelled \"Jan\".  02:02:00 can\n741:         # just be labeled 02:02.\n742:         if zero_formats:\n743:             if len(zero_formats) != 6:\n744:                 raise ValueError('zero_formats argument must be a list of '\n745:                                  '6 format strings (or None)')\n746:             self.zero_formats = zero_formats\n747:         elif formats:\n748:             # use the users formats for the zero tick formats\n749:             self.zero_formats = [''] + self.formats[:-1]\n750:         else:\n751:             # make the defaults a bit nicer:\n752:             self.zero_formats = [''] + self.formats[:-1]\n753:             self.zero_formats[3] = '%b-%d'\n754: \n755:         if offset_formats:\n756:             if len(offset_formats) != 6:\n757:                 raise ValueError('offset_formats argument must be a list of '\n758:                                  '6 format strings (or None)')\n759:             self.offset_formats = offset_formats\n760:         else:\n761:             self.offset_formats = ['',\n762:                                    '%Y',\n763:                                    '%Y-%b',\n764:                                    '%Y-%b-%d',\n765:                                    '%Y-%b-%d',\n766:                                    '%Y-%b-%d %H:%M']\n767:         self.offset_string = ''\n768:         self.show_offset = show_offset\n769:         self._usetex = (usetex if usetex is not None else\n770:                         mpl.rcParams['text.usetex'])\n771: \n772:     def __call__(self, x, pos=None):\n773:         formatter = DateFormatter(self.defaultfmt, self._tz,\n774:                                   usetex=self._usetex)\n775:         return formatter(x, pos=pos)\n776: \n777:     def format_ticks(self, values):\n778:         tickdatetime = [num2date(value, tz=self._tz) for value in values]\n779:         tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n780: \n781:         # basic algorithm:\n782:         # 1) only display a part of the date if it changes over the ticks.\n783:         # 2) don't display the smaller part of the date if:\n784:         #    it is always the same or if it is the start of the\n785:         #    year, month, day etc.\n786:         # fmt for most ticks at this level\n787:         fmts = self.formats\n788:         # format beginnings of days, months, years, etc.\n789:         zerofmts = self.zero_formats\n790:         # offset fmt are for the offset in the upper left of the\n791:         # or lower right of the axis.\n792:         offsetfmts = self.offset_formats\n793:         show_offset = self.show_offset\n794: \n795:         # determine the level we will label at:\n796:         # mostly 0: years,  1: months,  2: days,\n797:         # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n798:         for level in range(5, -1, -1):\n799:             if len(np.unique(tickdate[:, level])) > 1:\n800:                 if level < 2:\n801:                     show_offset = False\n802:                 break\n803:             elif level == 0:\n804:                 # all tickdate are the same, so only micros might be different\n805:                 # set to the most precise (6: microseconds doesn't exist...)\n806:                 level = 5\n807: \n808:         # level is the basic level we will label at.\n809:         # now loop through and decide the actual ticklabels\n810:         zerovals = [0, 1, 1, 0, 0, 0, 0]\n811:         labels = [''] * len(tickdate)\n812:         for nn in range(len(tickdate)):\n813:             if level < 5:\n814:                 if tickdate[nn][level] == zerovals[level]:\n815:                     fmt = zerofmts[level]\n816:                 else:\n817:                     fmt = fmts[level]\n818:             else:\n819:                 # special handling for seconds + microseconds\n820:                 if (tickdatetime[nn].second == tickdatetime[nn].microsecond\n821:                         == 0):\n822:                     fmt = zerofmts[level]\n823:                 else:\n824:                     fmt = fmts[level]\n825:             labels[nn] = tickdatetime[nn].strftime(fmt)\n826: \n827:         # special handling of seconds and microseconds:\n828:         # strip extra zeros and decimal if possible.\n829:         # this is complicated by two factors.  1) we have some level-4 strings\n830:         # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the\n831:         # same number of decimals for each string (i.e. 0.5 and 1.0).\n832:         if level >= 5:\n833:             trailing_zeros = min(\n834:                 (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),\n835:                 default=None)\n836:             if trailing_zeros:\n837:                 for nn in range(len(labels)):\n838:                     if '.' in labels[nn]:\n839:                         labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n840: \n841:         if show_offset:\n842:             # set the offset string:\n843:             self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n844:             if self._usetex:\n845:                 self.offset_string = _wrap_in_tex(self.offset_string)\n846:         else:\n847:             self.offset_string = ''\n848: \n849:         if self._usetex:\n850:             return [_wrap_in_tex(l) for l in labels]\n851:         else:\n852:             return labels\n853: \n854:     def get_offset(self):\n855:         return self.offset_string\n856: \n857:     def format_data_short(self, value):\n858:         return num2date(value, tz=self._tz).strftime('%Y-%m-%d %H:%M:%S')\n859: \n860: \n861: class AutoDateFormatter(ticker.Formatter):\nCode replaced for brevity.\n978: \n979: \n980: \n981: class rrulewrapper:\nCode replaced for brevity.\n1087: \n1088: \n1089: \n1090: class DateLocator(ticker.Locator):\nCode replaced for brevity.\n1157: \n1158: \n1159: \n1160:     # use the dateutil rrule instance\nCode replaced for brevity.\n1233: \n1234: \n1235: \n1236: class AutoDateLocator(DateLocator):\nCode replaced for brevity.\n1466: \n1467: \n1468: \n1469: class YearLocator(RRuleLocator):\nCode replaced for brevity.\n1507: \n1508: \n1509: \n1510: class MonthLocator(RRuleLocator):\nCode replaced for brevity.\n1532: \n1533: \n1534: \n1535: class WeekdayLocator(RRuleLocator):\nCode replaced for brevity.\n1560: \n1561: \n1562: \n1563: class DayLocator(RRuleLocator):\nCode replaced for brevity.\n1586: \n1587: \n1588: \n1589: class HourLocator(RRuleLocator):\nCode replaced for brevity.\n1606: \n1607: \n1608: \n1609: class MinuteLocator(RRuleLocator):\nCode replaced for brevity.\n1626: \n1627: \n1628: \n1629: class SecondLocator(RRuleLocator):\nCode replaced for brevity.\n1646: \n1647: \n1648: \n1649: class MicrosecondLocator(DateLocator):\nCode replaced for brevity.\n1723: \n1724: \n1725: \n1726: @_api.deprecated(\n1727:     \"3.5\",\n1728:     alternative=\"``[date2num(datetime.utcfromtimestamp(t)) for t in e]`` or \"\n1729:                 \"numpy.datetime64 types\")\n1730: def epoch2num(e):\nCode replaced for brevity.\n1748: \n1749: \n1750: \n1751: @_api.deprecated(\"3.5\", alternative=\"`num2date(e).timestamp()<.num2date>`\")\n1752: def num2epoch(d):\nCode replaced for brevity.\n1769: \n1770: \n1771: \n1772: def date_ticker_factory(span, tz=None, numticks=5):\nCode replaced for brevity.\n1811: \n1812: \n1813: \n1814: class DateConverter(units.ConversionInterface):\nCode replaced for brevity.\n1871: \n1872: \n1873: \n1874:     # docstring inherited\nCode replaced for brevity.\n1898: \n1899: \n1900: \n1901: class _SwitchableDateConverter:\nCode replaced for brevity.\n1923: \n1924: \n1925: \n1926: units.registry[np.datetime64] = \\\n1927:     units.registry[datetime.date] = \\\n1928:     units.registry[datetime.datetime] = \\\n1929:     _SwitchableDateConverter()\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/dates.py",
      "suspect_lines": [
        799,
        800
      ]
    }
  ]
}