{
  "instance_id": "django__django-11885",
  "problem_statement": "Combine fast delete queries\nDescription\n\t\nWhen emulating ON DELETE CASCADE via on_delete=models.CASCADE the deletion.Collector will try to perform fast queries which are DELETE FROM table WHERE table.pk IN .... There's a few conditions required for this fast path to be taken but when this happens the collection logic should combine such queries by table to reduce the number of roundtrips to the database.\nFor example, given the following models\nclass Person(models.Model):\n\tfriends = models.ManyToManyField('self')\nclass User(models.Model):\n\tpass\nclass Entry(models.Model):\n\tcreated_by = models.ForeignKey(User)\n\tupdated_by = models.ForeignKey(User)\nIssuing a person.delete() or user.delete() will result in 3 queries of the form\nDELETE FROM person_friends WHERE from_id = :id\nDELETE FROM person_friends WHERE to_id = :id\nDELETE FROM person WHERE id = :id\nDELETE FROM entry WHERE created_by_id = :id\nDELETE FROM entry WHERE updated_by = :id\nDELETRE FROM user WHERE id = :id\nBut both queries (or N queries depending on the number of foreign relationships) can be combined into a single one by using OR\nDELETE FROM person_friends WHERE from_id = :id OR to_id = :id\nDELETE FROM person WHERE id = :id\nDELETE FROM entry WHERE created_by_id = :id OR updated_by = :id\nDELETE FROM user WHERE id = :id\n",
  "localized_code": "[start of django/contrib/admin/utils.py]\n1: import datetime\n2: import decimal\n3: import re\n4: from collections import defaultdict\n5: \n6: from django.core.exceptions import FieldDoesNotExist\n7: from django.db import models, router\n8: from django.db.models.constants import LOOKUP_SEP\n9: from django.db.models.deletion import Collector\n10: from django.forms.utils import pretty_name\n11: from django.urls import NoReverseMatch, reverse\n12: from django.utils import formats, timezone\n13: from django.utils.html import format_html\n14: from django.utils.text import capfirst\n15: from django.utils.translation import ngettext, override as translation_override\n16: \n17: QUOTE_MAP = {i: '_%02X' % i for i in b'\":/_#?;@&=+$,\"[]<>%\\n\\\\'}\n18: UNQUOTE_MAP = {v: chr(k) for k, v in QUOTE_MAP.items()}\n19: UNQUOTE_RE = re.compile('_(?:%s)' % '|'.join([x[1:] for x in UNQUOTE_MAP]))\n20: \n21: \n22: class FieldIsAForeignKeyColumnName(Exception):\n23:     \"\"\"A field is a foreign key attname, i.e. <FK>_id.\"\"\"\n24:     pass\n25: \n26: \n27: def lookup_needs_distinct(opts, lookup_path):\n28:     \"\"\"\n29:     Return True if 'distinct()' should be used to query the given lookup path.\n30:     \"\"\"\n31:     lookup_fields = lookup_path.split(LOOKUP_SEP)\n32:     # Go through the fields (following all relations) and look for an m2m.\n33:     for field_name in lookup_fields:\n34:         if field_name == 'pk':\n35:             field_name = opts.pk.name\n36:         try:\n37:             field = opts.get_field(field_name)\n38:         except FieldDoesNotExist:\n39:             # Ignore query lookups.\n40:             continue\n41:         else:\n42:             if hasattr(field, 'get_path_info'):\n43:                 # This field is a relation; update opts to follow the relation.\n44:                 path_info = field.get_path_info()\n45:                 opts = path_info[-1].to_opts\n46:                 if any(path.m2m for path in path_info):\n47:                     # This field is a m2m relation so distinct must be called.\n48:                     return True\n49:     return False\n50: \n51: \n52: def prepare_lookup_value(key, value):\nCode replaced for brevity.\n62: \n63: \n64: \n65: def quote(s):\nCode replaced for brevity.\n72: \n73: \n74: \n75: def unquote(s):\nCode replaced for brevity.\n77: \n78: \n79: \n80: def flatten(fields):\nCode replaced for brevity.\n90: \n91: \n92: \n93: def flatten_fieldsets(fieldsets):\nCode replaced for brevity.\n100: \n101: \n102: \n103: def get_deleted_objects(objs, request, admin_site):\nCode replaced for brevity.\n156: \n157: \n158: \n159: class NestedObjects(Collector):\n160:     def __init__(self, *args, **kwargs):\n161:         super().__init__(*args, **kwargs)\n162:         self.edges = {}  # {from_instance: [to_instances]}\n163:         self.protected = set()\n164:         self.model_objs = defaultdict(set)\n165: \n166:     def add_edge(self, source, target):\n167:         self.edges.setdefault(source, []).append(target)\n168: \n169:     def collect(self, objs, source=None, source_attr=None, **kwargs):\n170:         for obj in objs:\n171:             if source_attr and not source_attr.endswith('+'):\n172:                 related_name = source_attr % {\n173:                     'class': source._meta.model_name,\n174:                     'app_label': source._meta.app_label,\n175:                 }\n176:                 self.add_edge(getattr(obj, related_name), obj)\n177:             else:\n178:                 self.add_edge(None, obj)\n179:             self.model_objs[obj._meta.model].add(obj)\n180:         try:\n181:             return super().collect(objs, source_attr=source_attr, **kwargs)\n182:         except models.ProtectedError as e:\n183:             self.protected.update(e.protected_objects)\n184: \n185:     def related_objects(self, related, objs):\n186:         qs = super().related_objects(related, objs)\n187:         return qs.select_related(related.field.name)\n188: \n189:     def _nested(self, obj, seen, format_callback):\n190:         if obj in seen:\n191:             return []\n192:         seen.add(obj)\n193:         children = []\n194:         for child in self.edges.get(obj, ()):\n195:             children.extend(self._nested(child, seen, format_callback))\n196:         if format_callback:\n197:             ret = [format_callback(obj)]\n198:         else:\n199:             ret = [obj]\n200:         if children:\n201:             ret.append(children)\n202:         return ret\n203: \n204:     def nested(self, format_callback=None):\n205:         \"\"\"\n206:         Return the graph as a nested list.\n207:         \"\"\"\n208:         seen = set()\n209:         roots = []\n210:         for root in self.edges.get(None, ()):\n211:             roots.extend(self._nested(root, seen, format_callback))\n212:         return roots\n213: \n214:     def can_fast_delete(self, *args, **kwargs):\n215:         \"\"\"\n216:         We always want to load the objects into memory so that we can display\n217:         them to the user in confirm page.\n218:         \"\"\"\n219:         return False\n220: \n221: \n222: def model_format_dict(obj):\nCode replaced for brevity.\n238: \n239: \n240: \n241: def model_ngettext(obj, n=None):\nCode replaced for brevity.\n256: \n257: \n258: \n259: def lookup_field(name, obj, model_admin=None):\nCode replaced for brevity.\n282: \n283: \n284: \n285: def _get_non_gfk_field(opts, name):\nCode replaced for brevity.\n303: \n304: \n305: \n306: def label_for_field(name, model, model_admin=None, return_attr=False, form=None):\nCode replaced for brevity.\n363: \n364: \n365: \n366: def help_text_for_field(name, model):\nCode replaced for brevity.\n375: \n376: \n377: \n378: def display_for_field(value, field, empty_value_display):\nCode replaced for brevity.\n400: \n401: \n402: \n403: def display_for_value(value, empty_value_display, boolean=False):\nCode replaced for brevity.\n421: \n422: \n423: \n424: class NotRelationField(Exception):\n425:     pass\n426: \n427: \n... Code Truncated ...\n\n[start of django/db/models/deletion.py]\n1: from collections import Counter\n2: from itertools import chain\n3: from operator import attrgetter\n4: \n5: from django.db import IntegrityError, connections, transaction\n6: from django.db.models import signals, sql\n7: \n8: \n9: class ProtectedError(IntegrityError):\n10:     def __init__(self, msg, protected_objects):\n11:         self.protected_objects = protected_objects\n12:         super().__init__(msg, protected_objects)\n13: \n14: \n15: def CASCADE(collector, field, sub_objs, using):\n16:     collector.collect(sub_objs, source=field.remote_field.model,\n17:                       source_attr=field.name, nullable=field.null)\n18:     if field.null and not connections[using].features.can_defer_constraint_checks:\n19:         collector.add_field_update(field, None, sub_objs)\n20: \n21: \n22: def PROTECT(collector, field, sub_objs, using):\n23:     raise ProtectedError(\n24:         \"Cannot delete some instances of model '%s' because they are \"\n25:         \"referenced through a protected foreign key: '%s.%s'\" % (\n26:             field.remote_field.model.__name__, sub_objs[0].__class__.__name__, field.name\n27:         ),\n28:         sub_objs\n29:     )\n30: \n31: \n32: def SET(value):\n33:     if callable(value):\n34:         def set_on_delete(collector, field, sub_objs, using):\n35:             collector.add_field_update(field, value(), sub_objs)\n36:     else:\n37:         def set_on_delete(collector, field, sub_objs, using):\n38:             collector.add_field_update(field, value, sub_objs)\n39:     set_on_delete.deconstruct = lambda: ('django.db.models.SET', (value,), {})\n40:     return set_on_delete\n41: \n42: \n43: def SET_NULL(collector, field, sub_objs, using):\n44:     collector.add_field_update(field, None, sub_objs)\n45: \n46: \n47: def SET_DEFAULT(collector, field, sub_objs, using):\n48:     collector.add_field_update(field, field.get_default(), sub_objs)\n49: \n50: \n51: def DO_NOTHING(collector, field, sub_objs, using):\n52:     pass\n53: \n54: \n55:     # N-N  (i.e., many-to-many) relations aren't candidates for deletion.\nCode replaced for brevity.\n61: \n62: \n63: \n64: class Collector:\n65:     def __init__(self, using):\n66:         self.using = using\n67:         # Initially, {model: {instances}}, later values become lists.\n68:         self.data = {}\n69:         self.field_updates = {}  # {model: {(field, value): {instances}}}\n70:         # fast_deletes is a list of queryset-likes that can be deleted without\n71:         # fetching the objects into memory.\n72:         self.fast_deletes = []\n73: \n74:         # Tracks deletion-order dependency for databases without transactions\n75:         # or ability to defer constraint checks. Only concrete model classes\n76:         # should be included, as the dependencies exist only between actual\n77:         # database tables; proxy models are represented here by their concrete\n78:         # parent.\n79:         self.dependencies = {}  # {model: {models}}\n80: \n81:     def add(self, objs, source=None, nullable=False, reverse_dependency=False):\n82:         \"\"\"\n83:         Add 'objs' to the collection of objects to be deleted.  If the call is\n84:         the result of a cascade, 'source' should be the model that caused it,\n85:         and 'nullable' should be set to True if the relation can be null.\n86: \n87:         Return a list of all objects that were not already collected.\n88:         \"\"\"\n89:         if not objs:\n90:             return []\n91:         new_objs = []\n92:         model = objs[0].__class__\n93:         instances = self.data.setdefault(model, set())\n94:         for obj in objs:\n95:             if obj not in instances:\n96:                 new_objs.append(obj)\n97:         instances.update(new_objs)\n98:         # Nullable relationships can be ignored -- they are nulled out before\n99:         # deleting, and therefore do not affect the order in which objects have\n100:         # to be deleted.\n101:         if source is not None and not nullable:\n102:             if reverse_dependency:\n103:                 source, model = model, source\n104:             self.dependencies.setdefault(\n105:                 source._meta.concrete_model, set()).add(model._meta.concrete_model)\n106:         return new_objs\n107: \n108:     def add_field_update(self, field, value, objs):\n109:         \"\"\"\n110:         Schedule a field update. 'objs' must be a homogeneous iterable\n111:         collection of model instances (e.g. a QuerySet).\n112:         \"\"\"\n113:         if not objs:\n114:             return\n115:         model = objs[0].__class__\n116:         self.field_updates.setdefault(\n117:             model, {}).setdefault(\n118:             (field, value), set()).update(objs)\n119: \n120:     def _has_signal_listeners(self, model):\n121:         return (\n122:             signals.pre_delete.has_listeners(model) or\n123:             signals.post_delete.has_listeners(model)\n124:         )\n125: \n126:     def can_fast_delete(self, objs, from_field=None):\n127:         \"\"\"\n128:         Determine if the objects in the given queryset-like or single object\n129:         can be fast-deleted. This can be done if there are no cascades, no\n130:         parents and no signal listeners for the object class.\n131: \n132:         The 'from_field' tells where we are coming from - we need this to\n133:         determine if the objects are in fact to be deleted. Allow also\n134:         skipping parent -> child -> parent chain preventing fast delete of\n135:         the child.\n136:         \"\"\"\n137:         if from_field and from_field.remote_field.on_delete is not CASCADE:\n138:             return False\n139:         if hasattr(objs, '_meta'):\n140:             model = type(objs)\n141:         elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n142:             model = objs.model\n143:         else:\n144:             return False\n145:         if self._has_signal_listeners(model):\n146:             return False\n147:         # The use of from_field comes from the need to avoid cascade back to\n148:         # parent when parent delete is cascading to child.\n149:         opts = model._meta\n150:         return (\n151:             all(link == from_field for link in opts.concrete_model._meta.parents.values()) and\n152:             # Foreign keys pointing to this model.\n153:             all(\n154:                 related.field.remote_field.on_delete is DO_NOTHING\n155:                 for related in get_candidate_relations_to_delete(opts)\n156:             ) and (\n157:                 # Something like generic foreign key.\n158:                 not any(hasattr(field, 'bulk_related_objects') for field in opts.private_fields)\n159:             )\n160:         )\n161: \n162:     def get_del_batches(self, objs, field):\n163:         \"\"\"\n164:         Return the objs in suitably sized batches for the used connection.\n165:         \"\"\"\n166:         conn_batch_size = max(\n167:             connections[self.using].ops.bulk_batch_size([field.name], objs), 1)\n168:         if len(objs) > conn_batch_size:\n169:             return [objs[i:i + conn_batch_size]\n170:                     for i in range(0, len(objs), conn_batch_size)]\n171:         else:\n172:             return [objs]\n173: \n174:     def collect(self, objs, source=None, nullable=False, collect_related=True,\n175:                 source_attr=None, reverse_dependency=False, keep_parents=False):\n176:         \"\"\"\n177:         Add 'objs' to the collection of objects to be deleted as well as all\n178:         parent instances.  'objs' must be a homogeneous iterable collection of\n179:         model instances (e.g. a QuerySet).  If 'collect_related' is True,\n180:         related objects will be handled by their respective on_delete handler.\n181: \n182:         If the call is the result of a cascade, 'source' should be the model\n183:         that caused it and 'nullable' should be set to True, if the relation\n184:         can be null.\n185: \n186:         If 'reverse_dependency' is True, 'source' will be deleted before the\n187:         current model, rather than after. (Needed for cascading to parent\n188:         models, the one case in which the cascade follows the forwards\n189:         direction of an FK rather than the reverse direction.)\n190: \n191:         If 'keep_parents' is True, data of parent model's will be not deleted.\n192:         \"\"\"\n193:         if self.can_fast_delete(objs):\n194:             self.fast_deletes.append(objs)\n195:             return\n196:         new_objs = self.add(objs, source, nullable,\n197:                             reverse_dependency=reverse_dependency)\n198:         if not new_objs:\n199:             return\n200: \n201:         model = new_objs[0].__class__\n202: \n203:         if not keep_parents:\n204:             # Recursively collect concrete model's parent models, but not their\n205:             # related objects. These will be found by meta.get_fields()\n206:             concrete_model = model._meta.concrete_model\n207:             for ptr in concrete_model._meta.parents.values():\n208:                 if ptr:\n209:                     parent_objs = [getattr(obj, ptr.name) for obj in new_objs]\n210:                     self.collect(parent_objs, source=model,\n211:                                  source_attr=ptr.remote_field.related_name,\n212:                                  collect_related=False,\n213:                                  reverse_dependency=True)\n214:         if collect_related:\n215:             if keep_parents:\n216:                 parents = set(model._meta.get_parent_list())\n217:             for related in get_candidate_relations_to_delete(model._meta):\n218:                 # Preserve parent reverse relationships if keep_parents=True.\n219:                 if keep_parents and related.model in parents:\n220:                     continue\n221:                 field = related.field\n222:                 if field.remote_field.on_delete == DO_NOTHING:\n223:                     continue\n224:                 batches = self.get_del_batches(new_objs, field)\n225:                 for batch in batches:\n226:                     sub_objs = self.related_objects(related, batch)\n227:                     if self.can_fast_delete(sub_objs, from_field=field):\n228:                         self.fast_deletes.append(sub_objs)\n229:                     else:\n230:                         related_model = related.related_model\n231:                         # Non-referenced fields can be deferred if no signal\n232:                         # receivers are connected for the related model as\n233:                         # they'll never be exposed to the user. Skip field\n234:                         # deferring when some relationships are select_related\n235:                         # as interactions between both features are hard to\n236:                         # get right. This should only happen in the rare\n237:                         # cases where .related_objects is overridden anyway.\n238:                         if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):\n239:                             referenced_fields = set(chain.from_iterable(\n240:                                 (rf.attname for rf in rel.field.foreign_related_fields)\n241:                                 for rel in get_candidate_relations_to_delete(related_model._meta)\n242:                             ))\n243:                             sub_objs = sub_objs.only(*tuple(referenced_fields))\n244:                         if sub_objs:\n245:                             field.remote_field.on_delete(self, field, sub_objs, self.using)\n246:             for field in model._meta.private_fields:\n247:                 if hasattr(field, 'bulk_related_objects'):\n248:                     # It's something like generic foreign key.\n249:                     sub_objs = field.bulk_related_objects(new_objs, self.using)\n250:                     self.collect(sub_objs, source=model, nullable=True)\n251: \n252:     def related_objects(self, related, objs):\n253:         \"\"\"\n254:         Get a QuerySet of objects related to `objs` via the relation `related`.\n255:         \"\"\"\n256:         return related.related_model._base_manager.using(self.using).filter(\n257:             **{\"%s__in\" % related.field.name: objs}\n258:         )\n259: \n260:     def instances_with_model(self):\n261:         for model, instances in self.data.items():\n262:             for obj in instances:\n263:                 yield model, obj\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/utils.py",
      "suspect_lines": [
        185,
        186,
        187
      ]
    },
    {
      "filename": "/django/db/models/deletion.py",
      "suspect_lines": [
        1,
        6,
        68,
        69,
        79,
        93,
        104,
        105,
        116,
        117,
        118,
        140,
        162,
        167,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        254,
        256,
        257,
        258
      ]
    }
  ]
}