{
  "instance_id": "django__django-15278",
  "problem_statement": "Adding nullable OneToOneField crashes on SQLite.\nDescription\n\t\nThis new sqlite3 error has cropped up between building django-oauth-toolkit between Django 4.0 and main branch for migrations.AddField of a OneToOneField (see â€‹https://github.com/jazzband/django-oauth-toolkit/issues/1064):\nself = <django.db.backends.sqlite3.base.SQLiteCursorWrapper object at 0x10b8038b0>\nquery = 'ALTER TABLE \"oauth2_provider_accesstoken\" ADD COLUMN \"source_refresh_token_id\" bigint NULL UNIQUE REFERENCES \"oauth2_provider_refreshtoken\" (\"id\") DEFERRABLE INITIALLY DEFERRED'\nparams = []\n\tdef execute(self, query, params=None):\n\t\tif params is None:\n\t\t\treturn Database.Cursor.execute(self, query)\n\t\tquery = self.convert_query(query)\n>\t return Database.Cursor.execute(self, query, params)\nE\t django.db.utils.OperationalError: Cannot add a UNIQUE column\nHere's the relevant migration snippet: \n\t\tmigrations.AddField(\n\t\t\tmodel_name='AccessToken',\n\t\t\tname='source_refresh_token',\n\t\t\tfield=models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=oauth2_settings.REFRESH_TOKEN_MODEL, related_name=\"refreshed_access_token\"),\n\t\t),\nI see there have been a lot of sqlite3 changes in #33355 since the 4.0 release....\n",
  "localized_code": "[start of django/db/backends/sqlite3/schema.py]\n1: import copy\n2: from decimal import Decimal\n3: \n4: from django.apps.registry import Apps\n5: from django.db import NotSupportedError\n6: from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n7: from django.db.backends.ddl_references import Statement\n8: from django.db.backends.utils import strip_quotes\n9: from django.db.models import UniqueConstraint\n10: from django.db.transaction import atomic\n11: \n12: \n13: class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):\n14: \n15:     sql_delete_table = \"DROP TABLE %(table)s\"\n16:     sql_create_fk = None\n17:     sql_create_inline_fk = \"REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED\"\n18:     sql_create_column_inline_fk = sql_create_inline_fk\n19:     sql_create_unique = \"CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)\"\n20:     sql_delete_unique = \"DROP INDEX %(name)s\"\n21: \n22:     def __enter__(self):\n23:         # Some SQLite schema alterations need foreign key constraints to be\n24:         # disabled. Enforce it here for the duration of the schema edition.\n25:         if not self.connection.disable_constraint_checking():\n26:             raise NotSupportedError(\n27:                 'SQLite schema editor cannot be used while foreign key '\n28:                 'constraint checks are enabled. Make sure to disable them '\n29:                 'before entering a transaction.atomic() context because '\n30:                 'SQLite does not support disabling them in the middle of '\n31:                 'a multi-statement transaction.'\n32:             )\n33:         return super().__enter__()\n34: \n35:     def __exit__(self, exc_type, exc_value, traceback):\n36:         self.connection.check_constraints()\n37:         super().__exit__(exc_type, exc_value, traceback)\n38:         self.connection.enable_constraint_checking()\n39: \n40:     def quote_value(self, value):\n41:         # The backend \"mostly works\" without this function and there are use\n42:         # cases for compiling Python without the sqlite3 libraries (e.g.\n43:         # security hardening).\n44:         try:\n45:             import sqlite3\n46:             value = sqlite3.adapt(value)\n47:         except ImportError:\n48:             pass\n49:         except sqlite3.ProgrammingError:\n50:             pass\n51:         # Manual emulation of SQLite parameter quoting\n52:         if isinstance(value, bool):\n53:             return str(int(value))\n54:         elif isinstance(value, (Decimal, float, int)):\n55:             return str(value)\n56:         elif isinstance(value, str):\n57:             return \"'%s'\" % value.replace(\"\\'\", \"\\'\\'\")\n58:         elif value is None:\n59:             return \"NULL\"\n60:         elif isinstance(value, (bytes, bytearray, memoryview)):\n61:             # Bytes are only allowed for BLOB fields, encoded as string\n62:             # literals containing hexadecimal data and preceded by a single \"X\"\n63:             # character.\n64:             return \"X'%s'\" % value.hex()\n65:         else:\n66:             raise ValueError(\"Cannot quote parameter value %r of type %s\" % (value, type(value)))\n67: \n68:     def prepare_default(self, value):\n69:         return self.quote_value(value)\n70: \n71:     def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_self=False):\n72:         \"\"\"\n73:         Return whether or not the provided table name is referenced by another\n74:         one. If `column_name` is specified, only references pointing to that\n75:         column are considered. If `ignore_self` is True, self-referential\n76:         constraints are ignored.\n77:         \"\"\"\n78:         with self.connection.cursor() as cursor:\n79:             for other_table in self.connection.introspection.get_table_list(cursor):\n80:                 if ignore_self and other_table.name == table_name:\n81:                     continue\n82:                 relations = self.connection.introspection.get_relations(cursor, other_table.name)\n83:                 for constraint_column, constraint_table in relations.values():\n84:                     if (constraint_table == table_name and\n85:                             (column_name is None or constraint_column == column_name)):\n86:                         return True\n87:         return False\n88: \n89:     def alter_db_table(self, model, old_db_table, new_db_table, disable_constraints=True):\n90:         if (not self.connection.features.supports_atomic_references_rename and\n91:                 disable_constraints and self._is_referenced_by_fk_constraint(old_db_table)):\n92:             if self.connection.in_atomic_block:\n93:                 raise NotSupportedError((\n94:                     'Renaming the %r table while in a transaction is not '\n95:                     'supported on SQLite < 3.26 because it would break referential '\n96:                     'integrity. Try adding `atomic = False` to the Migration class.'\n97:                 ) % old_db_table)\n98:             self.connection.enable_constraint_checking()\n99:             super().alter_db_table(model, old_db_table, new_db_table)\n100:             self.connection.disable_constraint_checking()\n101:         else:\n102:             super().alter_db_table(model, old_db_table, new_db_table)\n103: \n104:     def alter_field(self, model, old_field, new_field, strict=False):\n105:         if not self._field_should_be_altered(old_field, new_field):\n106:             return\n107:         old_field_name = old_field.name\n108:         table_name = model._meta.db_table\n109:         _, old_column_name = old_field.get_attname_column()\n110:         if (new_field.name != old_field_name and\n111:                 not self.connection.features.supports_atomic_references_rename and\n112:                 self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):\n113:             if self.connection.in_atomic_block:\n114:                 raise NotSupportedError((\n115:                     'Renaming the %r.%r column while in a transaction is not '\n116:                     'supported on SQLite < 3.26 because it would break referential '\n117:                     'integrity. Try adding `atomic = False` to the Migration class.'\n118:                 ) % (model._meta.db_table, old_field_name))\n119:             with atomic(self.connection.alias):\n120:                 super().alter_field(model, old_field, new_field, strict=strict)\n121:                 # Follow SQLite's documented procedure for performing changes\n122:                 # that don't affect the on-disk content.\n123:                 # https://sqlite.org/lang_altertable.html#otheralter\n124:                 with self.connection.cursor() as cursor:\n125:                     schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]\n126:                     cursor.execute('PRAGMA writable_schema = 1')\n127:                     references_template = ' REFERENCES \"%s\" (\"%%s\") ' % table_name\n128:                     new_column_name = new_field.get_attname_column()[1]\n129:                     search = references_template % old_column_name\n130:                     replacement = references_template % new_column_name\n131:                     cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))\n132:                     cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))\n133:                     cursor.execute('PRAGMA writable_schema = 0')\n134:                     # The integrity check will raise an exception and rollback\n135:                     # the transaction if the sqlite_master updates corrupt the\n136:                     # database.\n137:                     cursor.execute('PRAGMA integrity_check')\n138:             # Perform a VACUUM to refresh the database representation from\n139:             # the sqlite_master table.\n140:             with self.connection.cursor() as cursor:\n141:                 cursor.execute('VACUUM')\n142:         else:\n143:             super().alter_field(model, old_field, new_field, strict=strict)\n144: \n145:     def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):\n146:         \"\"\"\n147:         Shortcut to transform a model from old_model into new_model\n148: \n149:         This follows the correct procedure to perform non-rename or column\n150:         addition operations based on SQLite's documentation\n151: \n152:         https://www.sqlite.org/lang_altertable.html#caution\n153: \n154:         The essential steps are:\n155:           1. Create a table with the updated definition called \"new__app_model\"\n156:           2. Copy the data from the existing \"app_model\" table to the new table\n157:           3. Drop the \"app_model\" table\n158:           4. Rename the \"new__app_model\" table to \"app_model\"\n159:           5. Restore any index of the previous \"app_model\" table.\n160:         \"\"\"\n161:         # Self-referential fields must be recreated rather than copied from\n162:         # the old model to ensure their remote_field.field_name doesn't refer\n163:         # to an altered field.\n164:         def is_self_referential(f):\n165:             return f.is_relation and f.remote_field.model is model\n166:         # Work out the new fields dict / mapping\n167:         body = {\n168:             f.name: f.clone() if is_self_referential(f) else f\n169:             for f in model._meta.local_concrete_fields\n170:         }\n171:         # Since mapping might mix column names and default values,\n172:         # its values must be already quoted.\n173:         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}\n174:         # This maps field names (not columns) for things like unique_together\n175:         rename_mapping = {}\n176:         # If any of the new or altered fields is introducing a new PK,\n177:         # remove the old one\n178:         restore_pk_field = None\n179:         if getattr(create_field, 'primary_key', False) or (\n180:                 alter_field and getattr(alter_field[1], 'primary_key', False)):\n181:             for name, field in list(body.items()):\n182:                 if field.primary_key:\n183:                     field.primary_key = False\n184:                     restore_pk_field = field\n185:                     if field.auto_created:\n186:                         del body[name]\n187:                         del mapping[field.column]\n188:         # Add in any created fields\n189:         if create_field:\n190:             body[create_field.name] = create_field\n191:             # Choose a default and insert it into the copy map\n192:             if not create_field.many_to_many and create_field.concrete:\n193:                 mapping[create_field.column] = self.prepare_default(\n194:                     self.effective_default(create_field),\n195:                 )\n196:         # Add in any altered fields\n197:         if alter_field:\n198:             old_field, new_field = alter_field\n199:             body.pop(old_field.name, None)\n200:             mapping.pop(old_field.column, None)\n201:             body[new_field.name] = new_field\n202:             if old_field.null and not new_field.null:\n203:                 case_sql = \"coalesce(%(col)s, %(default)s)\" % {\n204:                     'col': self.quote_name(old_field.column),\n205:                     'default': self.prepare_default(self.effective_default(new_field)),\n206:                 }\n207:                 mapping[new_field.column] = case_sql\n208:             else:\n209:                 mapping[new_field.column] = self.quote_name(old_field.column)\n210:             rename_mapping[old_field.name] = new_field.name\n211:         # Remove any deleted fields\n212:         if delete_field:\n213:             del body[delete_field.name]\n214:             del mapping[delete_field.column]\n215:             # Remove any implicit M2M tables\n216:             if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:\n217:                 return self.delete_model(delete_field.remote_field.through)\n218:         # Work inside a new app registry\n219:         apps = Apps()\n220: \n221:         # Work out the new value of unique_together, taking renames into\n222:         # account\n223:         unique_together = [\n224:             [rename_mapping.get(n, n) for n in unique]\n225:             for unique in model._meta.unique_together\n226:         ]\n227: \n228:         # Work out the new value for index_together, taking renames into\n229:         # account\n230:         index_together = [\n231:             [rename_mapping.get(n, n) for n in index]\n232:             for index in model._meta.index_together\n233:         ]\n234: \n235:         indexes = model._meta.indexes\n236:         if delete_field:\n237:             indexes = [\n238:                 index for index in indexes\n239:                 if delete_field.name not in index.fields\n240:             ]\n241: \n242:         constraints = list(model._meta.constraints)\n243: \n244:         # Provide isolated instances of the fields to the new model body so\n245:         # that the existing model's internals aren't interfered with when\n246:         # the dummy model is constructed.\n247:         body_copy = copy.deepcopy(body)\n248: \n249:         # Construct a new model with the new fields to allow self referential\n250:         # primary key to resolve to. This model won't ever be materialized as a\n251:         # table and solely exists for foreign key reference resolution purposes.\n252:         # This wouldn't be required if the schema editor was operating on model\n253:         # states instead of rendered models.\n254:         meta_contents = {\n255:             'app_label': model._meta.app_label,\n256:             'db_table': model._meta.db_table,\n257:             'unique_together': unique_together,\n258:             'index_together': index_together,\n259:             'indexes': indexes,\n260:             'constraints': constraints,\n261:             'apps': apps,\n262:         }\n263:         meta = type(\"Meta\", (), meta_contents)\n264:         body_copy['Meta'] = meta\n265:         body_copy['__module__'] = model.__module__\n266:         type(model._meta.object_name, model.__bases__, body_copy)\n267: \n268:         # Construct a model with a renamed table name.\n269:         body_copy = copy.deepcopy(body)\n270:         meta_contents = {\n271:             'app_label': model._meta.app_label,\n272:             'db_table': 'new__%s' % strip_quotes(model._meta.db_table),\n273:             'unique_together': unique_together,\n274:             'index_together': index_together,\n275:             'indexes': indexes,\n276:             'constraints': constraints,\n277:             'apps': apps,\n278:         }\n279:         meta = type(\"Meta\", (), meta_contents)\n280:         body_copy['Meta'] = meta\n281:         body_copy['__module__'] = model.__module__\n282:         new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)\n283: \n284:         # Create a new table with the updated schema.\n285:         self.create_model(new_model)\n286: \n287:         # Copy data from the old table into the new table\n288:         self.execute(\"INSERT INTO %s (%s) SELECT %s FROM %s\" % (\n289:             self.quote_name(new_model._meta.db_table),\n290:             ', '.join(self.quote_name(x) for x in mapping),\n291:             ', '.join(mapping.values()),\n292:             self.quote_name(model._meta.db_table),\n293:         ))\n294: \n295:         # Delete the old table to make way for the new\n296:         self.delete_model(model, handle_autom2m=False)\n297: \n298:         # Rename the new table to take way for the old\n299:         self.alter_db_table(\n300:             new_model, new_model._meta.db_table, model._meta.db_table,\n301:             disable_constraints=False,\n302:         )\n303: \n304:         # Run deferred SQL on correct table\n305:         for sql in self.deferred_sql:\n306:             self.execute(sql)\n307:         self.deferred_sql = []\n308:         # Fix any PK-removed field\n309:         if restore_pk_field:\n310:             restore_pk_field.primary_key = True\n311: \n312:     def delete_model(self, model, handle_autom2m=True):\n313:         if handle_autom2m:\n314:             super().delete_model(model)\n315:         else:\n316:             # Delete the table (and only that)\n317:             self.execute(self.sql_delete_table % {\n318:                 \"table\": self.quote_name(model._meta.db_table),\n319:             })\n320:             # Remove all deferred statements referencing the deleted table.\n321:             for sql in list(self.deferred_sql):\n322:                 if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):\n323:                     self.deferred_sql.remove(sql)\n324: \n325:     def add_field(self, model, field):\n326:         \"\"\"Create a field on a model.\"\"\"\n327:         # Fields with default values cannot by handled by ALTER TABLE ADD\n328:         # COLUMN statement because DROP DEFAULT is not supported in\n329:         # ALTER TABLE.\n330:         if not field.null or self.effective_default(field) is not None:\n331:             self._remake_table(model, create_field=field)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/backends/sqlite3/schema.py",
      "suspect_lines": [
        327,
        328,
        329,
        330
      ]
    }
  ]
}