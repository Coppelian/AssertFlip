{
  "instance_id": "sympy__sympy-18763",
  "problem_statement": "Incorrect parenthesizing of Subs\nHere is an example.\r\n```python\r\n>>> from sympy import Subs\r\n>>> from sympy.abc import x,y\r\n>>> 3*Subs(-x+y, (x,),(1,))\r\n```\r\nLaTeX printing of this gives:  \r\n```python\r\n'3 \\\\left. - x + y \\\\right|_{\\\\substack{ x=1 }}'\r\n```\r\n\r\n![image](https://quicklatex.com/cache3/76/ql_9672fd7e62c909ff3d9ac8543c2e2576_l3.png)\r\n\r\n\r\nIt would be better to be parenthesized to:  \r\n```python\r\n'3 \\\\left. \\\\left(- x + y\\\\right) \\\\right|_{\\\\substack{ x=1 }}'\r\n```\r\n\r\n![image](https://quicklatex.com/cache3/bf/ql_936ffdb876e784206d4c54bb93d28dbf_l3.png)\r\n\n",
  "localized_code": "[start of sympy/printing/latex.py]\n1: \"\"\"\n2: A Printer which converts an expression into its LaTeX equivalent.\n3: \"\"\"\n4: \n5: from __future__ import print_function, division\n6: \n7: import itertools\n8: \n9: from sympy.core import S, Add, Symbol, Mod\n10: from sympy.core.alphabets import greeks\n11: from sympy.core.containers import Tuple\n12: from sympy.core.function import _coeff_isneg, AppliedUndef, Derivative\n13: from sympy.core.operations import AssocOp\n14: from sympy.core.sympify import SympifyError\n15: from sympy.logic.boolalg import true\n16: \n17: # sympy.printing imports\n18: from sympy.printing.precedence import precedence_traditional\n19: from sympy.printing.printer import Printer\n20: from sympy.printing.conventions import split_super_sub, requires_partial\n21: from sympy.printing.precedence import precedence, PRECEDENCE\n22: \n23: import mpmath.libmp as mlib\n24: from mpmath.libmp import prec_to_dps\n25: \n26: from sympy.core.compatibility import default_sort_key, range\n27: from sympy.utilities.iterables import has_variety\n28: \n29: import re\n30: \n31: # Hand-picked functions which can be used directly in both LaTeX and MathJax\n32: # Complete list at\n33: # https://docs.mathjax.org/en/latest/tex.html#supported-latex-commands\n34: # This variable only contains those functions which sympy uses.\n35: accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan',\n36:                             'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec',\n37:                             'csc', 'cot', 'coth', 're', 'im', 'frac', 'root',\n38:                             'arg',\n39:                             ]\n40: \n41: tex_greek_dictionary = {\n42:     'Alpha': 'A',\n43:     'Beta': 'B',\n44:     'Gamma': r'\\Gamma',\n45:     'Delta': r'\\Delta',\n46:     'Epsilon': 'E',\n47:     'Zeta': 'Z',\n48:     'Eta': 'H',\n49:     'Theta': r'\\Theta',\n50:     'Iota': 'I',\n51:     'Kappa': 'K',\n52:     'Lambda': r'\\Lambda',\n53:     'Mu': 'M',\n54:     'Nu': 'N',\n55:     'Xi': r'\\Xi',\n56:     'omicron': 'o',\n57:     'Omicron': 'O',\n58:     'Pi': r'\\Pi',\n59:     'Rho': 'P',\n60:     'Sigma': r'\\Sigma',\n61:     'Tau': 'T',\n62:     'Upsilon': r'\\Upsilon',\n63:     'Phi': r'\\Phi',\n64:     'Chi': 'X',\n65:     'Psi': r'\\Psi',\n66:     'Omega': r'\\Omega',\n67:     'lamda': r'\\lambda',\n68:     'Lamda': r'\\Lambda',\n69:     'khi': r'\\chi',\n70:     'Khi': r'X',\n71:     'varepsilon': r'\\varepsilon',\n72:     'varkappa': r'\\varkappa',\n73:     'varphi': r'\\varphi',\n74:     'varpi': r'\\varpi',\n75:     'varrho': r'\\varrho',\n76:     'varsigma': r'\\varsigma',\n77:     'vartheta': r'\\vartheta',\n78: }\n79: \n80: other_symbols = set(['aleph', 'beth', 'daleth', 'gimel', 'ell', 'eth', 'hbar',\n81:                      'hslash', 'mho', 'wp', ])\n82: \n83: # Variable name modifiers\n84: modifier_dict = {\n85:     # Accents\n86:     'mathring': lambda s: r'\\mathring{'+s+r'}',\n87:     'ddddot': lambda s: r'\\ddddot{'+s+r'}',\n88:     'dddot': lambda s: r'\\dddot{'+s+r'}',\n89:     'ddot': lambda s: r'\\ddot{'+s+r'}',\n90:     'dot': lambda s: r'\\dot{'+s+r'}',\n91:     'check': lambda s: r'\\check{'+s+r'}',\n92:     'breve': lambda s: r'\\breve{'+s+r'}',\n93:     'acute': lambda s: r'\\acute{'+s+r'}',\n94:     'grave': lambda s: r'\\grave{'+s+r'}',\n95:     'tilde': lambda s: r'\\tilde{'+s+r'}',\n96:     'hat': lambda s: r'\\hat{'+s+r'}',\n97:     'bar': lambda s: r'\\bar{'+s+r'}',\n98:     'vec': lambda s: r'\\vec{'+s+r'}',\n99:     'prime': lambda s: \"{\"+s+\"}'\",\n100:     'prm': lambda s: \"{\"+s+\"}'\",\n101:     # Faces\n102:     'bold': lambda s: r'\\boldsymbol{'+s+r'}',\n103:     'bm': lambda s: r'\\boldsymbol{'+s+r'}',\n104:     'cal': lambda s: r'\\mathcal{'+s+r'}',\n105:     'scr': lambda s: r'\\mathscr{'+s+r'}',\n106:     'frak': lambda s: r'\\mathfrak{'+s+r'}',\n107:     # Brackets\n108:     'norm': lambda s: r'\\left\\|{'+s+r'}\\right\\|',\n109:     'avg': lambda s: r'\\left\\langle{'+s+r'}\\right\\rangle',\n110:     'abs': lambda s: r'\\left|{'+s+r'}\\right|',\n111:     'mag': lambda s: r'\\left|{'+s+r'}\\right|',\n112: }\n113: \n114: greek_letters_set = frozenset(greeks)\n115: \n116: _between_two_numbers_p = (\n117:     re.compile(r'[0-9][} ]*$'),  # search\n118:     re.compile(r'[{ ]*[-+0-9]'),  # match\n119: )\n120: \n121: \n122: class LatexPrinter(Printer):\n123:     printmethod = \"_latex\"\n124: \n125:     _default_settings = {\n126:         \"fold_frac_powers\": False,\n127:         \"fold_func_brackets\": False,\n128:         \"fold_short_frac\": None,\n129:         \"inv_trig_style\": \"abbreviated\",\n130:         \"itex\": False,\n131:         \"ln_notation\": False,\n132:         \"long_frac_ratio\": None,\n133:         \"mat_delim\": \"[\",\n134:         \"mat_str\": None,\n135:         \"mode\": \"plain\",\n136:         \"mul_symbol\": None,\n137:         \"order\": None,\n138:         \"symbol_names\": {},\n139:         \"root_notation\": True,\n140:         \"mat_symbol_style\": \"plain\",\n141:         \"imaginary_unit\": \"i\",\n142:         \"gothic_re_im\": False,\n143:         \"decimal_separator\": \"period\",\n144:     }\n145: \n146:     def __init__(self, settings=None):\n147:         Printer.__init__(self, settings)\n148: \n149:         if 'mode' in self._settings:\n150:             valid_modes = ['inline', 'plain', 'equation',\n151:                            'equation*']\n152:             if self._settings['mode'] not in valid_modes:\n153:                 raise ValueError(\"'mode' must be one of 'inline', 'plain', \"\n154:                                  \"'equation' or 'equation*'\")\n155: \n156:         if self._settings['fold_short_frac'] is None and \\\n157:                 self._settings['mode'] == 'inline':\n158:             self._settings['fold_short_frac'] = True\n159: \n160:         mul_symbol_table = {\n161:             None: r\" \",\n162:             \"ldot\": r\" \\,.\\, \",\n163:             \"dot\": r\" \\cdot \",\n164:             \"times\": r\" \\times \"\n165:         }\n166:         try:\n167:             self._settings['mul_symbol_latex'] = \\\n168:                 mul_symbol_table[self._settings['mul_symbol']]\n169:         except KeyError:\n170:             self._settings['mul_symbol_latex'] = \\\n171:                 self._settings['mul_symbol']\n172:         try:\n173:             self._settings['mul_symbol_latex_numbers'] = \\\n174:                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n175:         except KeyError:\n176:             if (self._settings['mul_symbol'].strip() in\n177:                     ['', ' ', '\\\\', '\\\\,', '\\\\:', '\\\\;', '\\\\quad']):\n178:                 self._settings['mul_symbol_latex_numbers'] = \\\n179:                     mul_symbol_table['dot']\n180:             else:\n181:                 self._settings['mul_symbol_latex_numbers'] = \\\n182:                     self._settings['mul_symbol']\n183: \n184:         self._delim_dict = {'(': ')', '[': ']'}\n185: \n186:         imaginary_unit_table = {\n187:             None: r\"i\",\n188:             \"i\": r\"i\",\n189:             \"ri\": r\"\\mathrm{i}\",\n190:             \"ti\": r\"\\text{i}\",\n191:             \"j\": r\"j\",\n192:             \"rj\": r\"\\mathrm{j}\",\n193:             \"tj\": r\"\\text{j}\",\n194:         }\n195:         try:\n196:             self._settings['imaginary_unit_latex'] = \\\n197:                 imaginary_unit_table[self._settings['imaginary_unit']]\n198:         except KeyError:\n199:             self._settings['imaginary_unit_latex'] = \\\n200:                 self._settings['imaginary_unit']\n201: \n202:     def parenthesize(self, item, level, strict=False):\n203:         prec_val = precedence_traditional(item)\n204:         if (prec_val < level) or ((not strict) and prec_val <= level):\n205:             return r\"\\left({}\\right)\".format(self._print(item))\n206:         else:\n207:             return self._print(item)\n208: \n209:     def parenthesize_super(self, s):\n210:         \"\"\" Parenthesize s if there is a superscript in s\"\"\"\n211:         if \"^\" in s:\n212:             return r\"\\left({}\\right)\".format(s)\n213:         return s\n214: \n215:     def embed_super(self, s):\n216:         \"\"\" Embed s in {} if there is a superscript in s\"\"\"\n217:         if \"^\" in s:\n218:             return \"{{{}}}\".format(s)\n219:         return s\n220: \n221:     def doprint(self, expr):\n222:         tex = Printer.doprint(self, expr)\n223: \n224:         if self._settings['mode'] == 'plain':\n225:             return tex\n226:         elif self._settings['mode'] == 'inline':\n227:             return r\"$%s$\" % tex\n228:         elif self._settings['itex']:\n229:             return r\"$$%s$$\" % tex\n230:         else:\n231:             env_str = self._settings['mode']\n232:             return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n233: \n234:     def _needs_brackets(self, expr):\n235:         \"\"\"\n236:         Returns True if the expression needs to be wrapped in brackets when\n237:         printed, False otherwise. For example: a + b => True; a => False;\n238:         10 => False; -10 => True.\n239:         \"\"\"\n240:         return not ((expr.is_Integer and expr.is_nonnegative)\n241:                     or (expr.is_Atom and (expr is not S.NegativeOne\n242:                                           and expr.is_Rational is False)))\n243: \n244:     def _needs_function_brackets(self, expr):\n245:         \"\"\"\n246:         Returns True if the expression needs to be wrapped in brackets when\n247:         passed as an argument to a function, False otherwise. This is a more\n248:         liberal version of _needs_brackets, in that many expressions which need\n249:         to be wrapped in brackets when added/subtracted/raised to a power do\n250:         not need them when passed to a function. Such an example is a*b.\n251:         \"\"\"\n252:         if not self._needs_brackets(expr):\n253:             return False\n254:         else:\n255:             # Muls of the form a*b*c... can be folded\n256:             if expr.is_Mul and not self._mul_is_clean(expr):\n257:                 return True\n258:             # Pows which don't need brackets can be folded\n259:             elif expr.is_Pow and not self._pow_is_clean(expr):\n260:                 return True\n261:             # Add and Function always need brackets\n262:             elif expr.is_Add or expr.is_Function:\n263:                 return True\n264:             else:\n265:                 return False\n266: \n267:     def _needs_mul_brackets(self, expr, first=False, last=False):\n268:         \"\"\"\n269:         Returns True if the expression needs to be wrapped in brackets when\n270:         printed as part of a Mul, False otherwise. This is True for Add,\n271:         but also for some container objects that would not need brackets\n272:         when appearing last in a Mul, e.g. an Integral. ``last=True``\n273:         specifies that this expr is the last to appear in a Mul.\n274:         ``first=True`` specifies that this expr is the first to appear in\n275:         a Mul.\n276:         \"\"\"\n277:         from sympy import Integral, Product, Sum\n278: \n279:         if expr.is_Mul:\n280:             if not first and _coeff_isneg(expr):\n281:                 return True\n282:         elif precedence_traditional(expr) < PRECEDENCE[\"Mul\"]:\n283:             return True\n284:         elif expr.is_Relational:\n285:             return True\n286:         if expr.is_Piecewise:\n287:             return True\n288:         if any([expr.has(x) for x in (Mod,)]):\n289:             return True\n290:         if (not last and\n291:                 any([expr.has(x) for x in (Integral, Product, Sum)])):\n292:             return True\n293: \n294:         return False\n295: \n296:     def _needs_add_brackets(self, expr):\n297:         \"\"\"\n298:         Returns True if the expression needs to be wrapped in brackets when\n299:         printed as part of an Add, False otherwise.  This is False for most\n300:         things.\n301:         \"\"\"\n302:         if expr.is_Relational:\n303:             return True\n304:         if any([expr.has(x) for x in (Mod,)]):\n305:             return True\n306:         if expr.is_Add:\n307:             return True\n308:         return False\n309: \n310:     def _mul_is_clean(self, expr):\n311:         for arg in expr.args:\n312:             if arg.is_Function:\n313:                 return False\n314:         return True\n315: \n316:     def _pow_is_clean(self, expr):\n317:         return not self._needs_brackets(expr.base)\n318: \n319:     def _do_exponent(self, expr, exp):\n320:         if exp is not None:\n321:             return r\"\\left(%s\\right)^{%s}\" % (expr, exp)\n322:         else:\n323:             return expr\n324: \n325:     def _print_Basic(self, expr):\n326:         ls = [self._print(o) for o in expr.args]\n327:         return self._deal_with_super_sub(expr.__class__.__name__) + \\\n328:             r\"\\left(%s\\right)\" % \", \".join(ls)\n329: \n330:     def _print_bool(self, e):\n331:         return r\"\\text{%s}\" % e\n332: \n333:     _print_BooleanTrue = _print_bool\n334:     _print_BooleanFalse = _print_bool\n335: \n336:     def _print_NoneType(self, e):\n337:         return r\"\\text{%s}\" % e\n338: \n339:     def _print_Add(self, expr, order=None):\n340:         if self.order == 'none':\n341:             terms = list(expr.args)\n342:         else:\n343:             terms = self._as_ordered_terms(expr, order=order)\n344: \n345:         tex = \"\"\n346:         for i, term in enumerate(terms):\n347:             if i == 0:\n348:                 pass\n349:             elif _coeff_isneg(term):\n350:                 tex += \" - \"\n351:                 term = -term\n352:             else:\n353:                 tex += \" + \"\n354:             term_tex = self._print(term)\n355:             if self._needs_add_brackets(term):\n356:                 term_tex = r\"\\left(%s\\right)\" % term_tex\n357:             tex += term_tex\n358: \n359:         return tex\n360: \n361:     def _print_Cycle(self, expr):\n362:         from sympy.combinatorics.permutations import Permutation\n363:         if expr.size == 0:\n364:             return r\"\\left( \\right)\"\n365:         expr = Permutation(expr)\n366:         expr_perm = expr.cyclic_form\n367:         siz = expr.size\n368:         if expr.array_form[-1] == siz - 1:\n369:             expr_perm = expr_perm + [[siz - 1]]\n370:         term_tex = ''\n371:         for i in expr_perm:\n372:             term_tex += str(i).replace(',', r\"\\;\")\n373:         term_tex = term_tex.replace('[', r\"\\left( \")\n374:         term_tex = term_tex.replace(']', r\"\\right)\")\n375:         return term_tex\n376: \n377:     _print_Permutation = _print_Cycle\n378: \n379:     def _print_Float(self, expr):\n380:         # Based off of that in StrPrinter\n381:         dps = prec_to_dps(expr._prec)\n382:         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n383: \n384:         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n385:         # thus we use the number separator\n386:         separator = self._settings['mul_symbol_latex_numbers']\n387: \n388:         if 'e' in str_real:\n389:             (mant, exp) = str_real.split('e')\n390: \n391:             if exp[0] == '+':\n392:                 exp = exp[1:]\n393:             if self._settings['decimal_separator'] == 'comma':\n394:                 mant = mant.replace('.','{,}')\n395: \n396:             return r\"%s%s10^{%s}\" % (mant, separator, exp)\n397:         elif str_real == \"+inf\":\n398:             return r\"\\infty\"\n399:         elif str_real == \"-inf\":\n400:             return r\"- \\infty\"\n401:         else:\n402:             if self._settings['decimal_separator'] == 'comma':\n403:                 str_real = str_real.replace('.','{,}')\n404:             return str_real\n405: \n406:     def _print_Cross(self, expr):\n407:         vec1 = expr._expr1\n408:         vec2 = expr._expr2\n409:         return r\"%s \\times %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n410:                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n411: \n412:     def _print_Curl(self, expr):\n413:         vec = expr._expr\n414:         return r\"\\nabla\\times %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n415: \n416:     def _print_Divergence(self, expr):\n417:         vec = expr._expr\n418:         return r\"\\nabla\\cdot %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n419: \n420:     def _print_Dot(self, expr):\n421:         vec1 = expr._expr1\n422:         vec2 = expr._expr2\n423:         return r\"%s \\cdot %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n424:                                  self.parenthesize(vec2, PRECEDENCE['Mul']))\n425: \n426:     def _print_Gradient(self, expr):\n427:         func = expr._expr\n428:         return r\"\\nabla %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n429: \n430:     def _print_Laplacian(self, expr):\n431:         func = expr._expr\n432:         return r\"\\triangle %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n433: \n434:     def _print_Mul(self, expr):\n435:         from sympy.core.power import Pow\n436:         from sympy.physics.units import Quantity\n437:         include_parens = False\n438:         if _coeff_isneg(expr):\n439:             expr = -expr\n440:             tex = \"- \"\n441:             if expr.is_Add:\n442:                 tex += \"(\"\n443:                 include_parens = True\n444:         else:\n445:             tex = \"\"\n446: \n447:         from sympy.simplify import fraction\n448:         numer, denom = fraction(expr, exact=True)\n449:         separator = self._settings['mul_symbol_latex']\n450:         numbersep = self._settings['mul_symbol_latex_numbers']\n451: \n452:         def convert(expr):\n453:             if not expr.is_Mul:\n454:                 return str(self._print(expr))\n455:             else:\n456:                 _tex = last_term_tex = \"\"\n457: \n458:                 if self.order not in ('old', 'none'):\n459:                     args = expr.as_ordered_factors()\n460:                 else:\n461:                     args = list(expr.args)\n462: \n463:                 # If quantities are present append them at the back\n464:                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or\n465:                               (isinstance(x, Pow) and\n466:                                isinstance(x.base, Quantity)))\n467: \n468:                 for i, term in enumerate(args):\n469:                     term_tex = self._print(term)\n470: \n471:                     if self._needs_mul_brackets(term, first=(i == 0),\n472:                                                 last=(i == len(args) - 1)):\n473:                         term_tex = r\"\\left(%s\\right)\" % term_tex\n474: \n475:                     if _between_two_numbers_p[0].search(last_term_tex) and \\\n476:                             _between_two_numbers_p[1].match(term_tex):\n477:                         # between two numbers\n478:                         _tex += numbersep\n479:                     elif _tex:\n480:                         _tex += separator\n481: \n482:                     _tex += term_tex\n483:                     last_term_tex = term_tex\n484:                 return _tex\n485: \n486:         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:\n487:             # use the original expression here, since fraction() may have\n488:             # altered it when producing numer and denom\n489:             tex += convert(expr)\n490: \n491:         else:\n492:             snumer = convert(numer)\n493:             sdenom = convert(denom)\n494:             ldenom = len(sdenom.split())\n495:             ratio = self._settings['long_frac_ratio']\n496:             if self._settings['fold_short_frac'] and ldenom <= 2 and \\\n497:                     \"^\" not in sdenom:\n498:                 # handle short fractions\n499:                 if self._needs_mul_brackets(numer, last=False):\n500:                     tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n501:                 else:\n502:                     tex += r\"%s / %s\" % (snumer, sdenom)\n503:             elif ratio is not None and \\\n504:                     len(snumer.split()) > ratio*ldenom:\n505:                 # handle long fractions\n506:                 if self._needs_mul_brackets(numer, last=True):\n507:                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n508:                         % (sdenom, separator, snumer)\n509:                 elif numer.is_Mul:\n510:                     # split a long numerator\n511:                     a = S.One\n512:                     b = S.One\n513:                     for x in numer.args:\n514:                         if self._needs_mul_brackets(x, last=False) or \\\n515:                                 len(convert(a*x).split()) > ratio*ldenom or \\\n516:                                 (b.is_commutative is x.is_commutative is False):\n517:                             b *= x\n518:                         else:\n519:                             a *= x\n520:                     if self._needs_mul_brackets(b, last=True):\n521:                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n522:                             % (convert(a), sdenom, separator, convert(b))\n523:                     else:\n524:                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n525:                             % (convert(a), sdenom, separator, convert(b))\n526:                 else:\n527:                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n528:             else:\n529:                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n530: \n531:         if include_parens:\n532:             tex += \")\"\n533:         return tex\n534: \n535:     def _print_Pow(self, expr):\n536:         # Treat x**Rational(1,n) as special case\n537:         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \\\n538:                 and self._settings['root_notation']:\n539:             base = self._print(expr.base)\n540:             expq = expr.exp.q\n541: \n542:             if expq == 2:\n543:                 tex = r\"\\sqrt{%s}\" % base\n544:             elif self._settings['itex']:\n545:                 tex = r\"\\root{%d}{%s}\" % (expq, base)\n546:             else:\n547:                 tex = r\"\\sqrt[%d]{%s}\" % (expq, base)\n548: \n549:             if expr.exp.is_negative:\n550:                 return r\"\\frac{1}{%s}\" % tex\n551:             else:\n552:                 return tex\n553:         elif self._settings['fold_frac_powers'] \\\n554:             and expr.exp.is_Rational \\\n555:                 and expr.exp.q != 1:\n556:             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n557:             p, q = expr.exp.p, expr.exp.q\n558:             # issue #12886: add parentheses for superscripts raised to powers\n559:             if '^' in base and expr.base.is_Symbol:\n560:                 base = r\"\\left(%s\\right)\" % base\n561:             if expr.base.is_Function:\n562:                 return self._print(expr.base, exp=\"%s/%s\" % (p, q))\n563:             return r\"%s^{%s/%s}\" % (base, p, q)\n564:         elif expr.exp.is_Rational and expr.exp.is_negative and \\\n565:                 expr.base.is_commutative:\n566:             # special case for 1^(-x), issue 9216\n567:             if expr.base == 1:\n568:                 return r\"%s^{%s}\" % (expr.base, expr.exp)\n569:             # things like 1/x\n570:             return self._print_Mul(expr)\n571:         else:\n572:             if expr.base.is_Function:\n573:                 return self._print(expr.base, exp=self._print(expr.exp))\n574:             else:\n575:                 tex = r\"%s^{%s}\"\n576:                 return self._helper_print_standard_power(expr, tex)\n577: \n578:     def _helper_print_standard_power(self, expr, template):\n579:         exp = self._print(expr.exp)\n580:         # issue #12886: add parentheses around superscripts raised\n581:         # to powers\n582:         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n583:         if '^' in base and expr.base.is_Symbol:\n584:             base = r\"\\left(%s\\right)\" % base\n585:         elif (isinstance(expr.base, Derivative)\n586:             and base.startswith(r'\\left(')\n587:             and re.match(r'\\\\left\\(\\\\d?d?dot', base)\n588:             and base.endswith(r'\\right)')):\n589:             # don't use parentheses around dotted derivative\n590:             base = base[6: -7]  # remove outermost added parens\n591:         return template % (base, exp)\n592: \n593:     def _print_UnevaluatedExpr(self, expr):\n594:         return self._print(expr.args[0])\n595: \n596:     def _print_Sum(self, expr):\n597:         if len(expr.limits) == 1:\n598:             tex = r\"\\sum_{%s=%s}^{%s} \" % \\\n599:                 tuple([self._print(i) for i in expr.limits[0]])\n600:         else:\n601:             def _format_ineq(l):\n602:                 return r\"%s \\leq %s \\leq %s\" % \\\n603:                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n604: \n605:             tex = r\"\\sum_{\\substack{%s}} \" % \\\n606:                 str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n607: \n608:         if isinstance(expr.function, Add):\n609:             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n610:         else:\n611:             tex += self._print(expr.function)\n612: \n613:         return tex\n614: \n615:     def _print_Product(self, expr):\n616:         if len(expr.limits) == 1:\n617:             tex = r\"\\prod_{%s=%s}^{%s} \" % \\\n618:                 tuple([self._print(i) for i in expr.limits[0]])\n619:         else:\n620:             def _format_ineq(l):\n621:                 return r\"%s \\leq %s \\leq %s\" % \\\n622:                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n623: \n624:             tex = r\"\\prod_{\\substack{%s}} \" % \\\n625:                 str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n626: \n627:         if isinstance(expr.function, Add):\n628:             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n629:         else:\n630:             tex += self._print(expr.function)\n631: \n632:         return tex\n633: \n634:     def _print_BasisDependent(self, expr):\n635:         from sympy.vector import Vector\n636: \n637:         o1 = []\n638:         if expr == expr.zero:\n639:             return expr.zero._latex_form\n640:         if isinstance(expr, Vector):\n641:             items = expr.separate().items()\n642:         else:\n643:             items = [(0, expr)]\n644: \n645:         for system, vect in items:\n646:             inneritems = list(vect.components.items())\n647:             inneritems.sort(key=lambda x: x[0].__str__())\n648:             for k, v in inneritems:\n649:                 if v == 1:\n650:                     o1.append(' + ' + k._latex_form)\n651:                 elif v == -1:\n652:                     o1.append(' - ' + k._latex_form)\n653:                 else:\n654:                     arg_str = '(' + LatexPrinter().doprint(v) + ')'\n655:                     o1.append(' + ' + arg_str + k._latex_form)\n656: \n657:         outstr = (''.join(o1))\n658:         if outstr[1] != '-':\n659:             outstr = outstr[3:]\n660:         else:\n661:             outstr = outstr[1:]\n662:         return outstr\n663: \n664:     def _print_Indexed(self, expr):\n665:         tex_base = self._print(expr.base)\n666:         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(\n667:             map(self._print, expr.indices))\n668:         return tex\n669: \n670:     def _print_IndexedBase(self, expr):\n671:         return self._print(expr.label)\n672: \n673:     def _print_Derivative(self, expr):\n674:         if requires_partial(expr.expr):\n675:             diff_symbol = r'\\partial'\n676:         else:\n677:             diff_symbol = r'd'\n678: \n679:         tex = \"\"\n680:         dim = 0\n681:         for x, num in reversed(expr.variable_count):\n682:             dim += num\n683:             if num == 1:\n684:                 tex += r\"%s %s\" % (diff_symbol, self._print(x))\n685:             else:\n686:                 tex += r\"%s %s^{%s}\" % (diff_symbol,\n687:                                         self.parenthesize_super(self._print(x)),\n688:                                         self._print(num))\n689: \n690:         if dim == 1:\n691:             tex = r\"\\frac{%s}{%s}\" % (diff_symbol, tex)\n692:         else:\n693:             tex = r\"\\frac{%s^{%s}}{%s}\" % (diff_symbol, self._print(dim), tex)\n694: \n695:         return r\"%s %s\" % (tex, self.parenthesize(expr.expr,\n696:                                                   PRECEDENCE[\"Mul\"],\n697:                                                   strict=True))\n698: \n699:     def _print_Subs(self, subs):\n700:         expr, old, new = subs.args\n701:         latex_expr = self._print(expr)\n702:         latex_old = (self._print(e) for e in old)\n703:         latex_new = (self._print(e) for e in new)\n704:         latex_subs = r'\\\\ '.join(\n705:             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n706:         return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr,\n707:                                                          latex_subs)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/printing/latex.py",
      "suspect_lines": [
        706
      ]
    }
  ]
}