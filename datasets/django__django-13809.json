{
  "instance_id": "django__django-13809",
  "problem_statement": "Add --skip-checks option to the runserver command.\nDescription\n\t\nRationale:\nIt would be consistent with other management commands performing system checks\nIt would help people like me who would rather have checks enabled exclusively in CI/CD than wait 15-20 seconds for each project reload during development\nRelated StackOverflow question:\nâ€‹https://stackoverflow.com/questions/41438593/skip-system-checks-on-django-server-in-debug-mode-in-pycharm/41725866\n",
  "localized_code": "[start of django/core/management/commands/runserver.py]\n1: import errno\n2: import os\n3: import re\n4: import socket\n5: import sys\n6: from datetime import datetime\n7: \n8: from django.conf import settings\n9: from django.core.management.base import BaseCommand, CommandError\n10: from django.core.servers.basehttp import (\n11:     WSGIServer, get_internal_wsgi_application, run,\n12: )\n13: from django.utils import autoreload\n14: from django.utils.regex_helper import _lazy_re_compile\n15: \n16: naiveip_re = _lazy_re_compile(r\"\"\"^(?:\n17: (?P<addr>\n18:     (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |         # IPv4 address\n19:     (?P<ipv6>\\[[a-fA-F0-9:]+\\]) |               # IPv6 address\n20:     (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) # FQDN\n21: ):)?(?P<port>\\d+)$\"\"\", re.X)\n22: \n23: \n24: class Command(BaseCommand):\n25:     help = \"Starts a lightweight Web server for development.\"\n26: \n27:     # Validation is called explicitly each time the server is reloaded.\n28:     requires_system_checks = []\n29:     stealth_options = ('shutdown_message',)\n30: \n31:     default_addr = '127.0.0.1'\n32:     default_addr_ipv6 = '::1'\n33:     default_port = '8000'\n34:     protocol = 'http'\n35:     server_cls = WSGIServer\n36: \n37:     def add_arguments(self, parser):\n38:         parser.add_argument(\n39:             'addrport', nargs='?',\n40:             help='Optional port number, or ipaddr:port'\n41:         )\n42:         parser.add_argument(\n43:             '--ipv6', '-6', action='store_true', dest='use_ipv6',\n44:             help='Tells Django to use an IPv6 address.',\n45:         )\n46:         parser.add_argument(\n47:             '--nothreading', action='store_false', dest='use_threading',\n48:             help='Tells Django to NOT use threading.',\n49:         )\n50:         parser.add_argument(\n51:             '--noreload', action='store_false', dest='use_reloader',\n52:             help='Tells Django to NOT use the auto-reloader.',\n53:         )\n54: \n55:     def execute(self, *args, **options):\n56:         if options['no_color']:\n57:             # We rely on the environment because it's currently the only\n58:             # way to reach WSGIRequestHandler. This seems an acceptable\n59:             # compromise considering `runserver` runs indefinitely.\n60:             os.environ[\"DJANGO_COLORS\"] = \"nocolor\"\n61:         super().execute(*args, **options)\n62: \n63:     def get_handler(self, *args, **options):\n64:         \"\"\"Return the default WSGI handler for the runner.\"\"\"\n65:         return get_internal_wsgi_application()\n66: \n67:     def handle(self, *args, **options):\n68:         if not settings.DEBUG and not settings.ALLOWED_HOSTS:\n69:             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')\n70: \n71:         self.use_ipv6 = options['use_ipv6']\n72:         if self.use_ipv6 and not socket.has_ipv6:\n73:             raise CommandError('Your Python does not support IPv6.')\n74:         self._raw_ipv6 = False\n75:         if not options['addrport']:\n76:             self.addr = ''\n77:             self.port = self.default_port\n78:         else:\n79:             m = re.match(naiveip_re, options['addrport'])\n80:             if m is None:\n81:                 raise CommandError('\"%s\" is not a valid port number '\n82:                                    'or address:port pair.' % options['addrport'])\n83:             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()\n84:             if not self.port.isdigit():\n85:                 raise CommandError(\"%r is not a valid port number.\" % self.port)\n86:             if self.addr:\n87:                 if _ipv6:\n88:                     self.addr = self.addr[1:-1]\n89:                     self.use_ipv6 = True\n90:                     self._raw_ipv6 = True\n91:                 elif self.use_ipv6 and not _fqdn:\n92:                     raise CommandError('\"%s\" is not a valid IPv6 address.' % self.addr)\n93:         if not self.addr:\n94:             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr\n95:             self._raw_ipv6 = self.use_ipv6\n96:         self.run(**options)\n97: \n98:     def run(self, **options):\n99:         \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n100:         use_reloader = options['use_reloader']\n101: \n102:         if use_reloader:\n103:             autoreload.run_with_reloader(self.inner_run, **options)\n104:         else:\n105:             self.inner_run(None, **options)\n106: \n107:     def inner_run(self, *args, **options):\n108:         # If an exception was silenced in ManagementUtility.execute in order\n109:         # to be raised in the child process, raise it now.\n110:         autoreload.raise_last_exception()\n111: \n112:         threading = options['use_threading']\n113:         # 'shutdown_message' is a stealth option.\n114:         shutdown_message = options.get('shutdown_message', '')\n115:         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'\n116: \n117:         self.stdout.write(\"Performing system checks...\\n\\n\")\n118:         self.check(display_num_errors=True)\n119:         # Need to check migrations here, so can't use the\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/management/commands/runserver.py",
      "suspect_lines": [
        117,
        118
      ]
    }
  ]
}