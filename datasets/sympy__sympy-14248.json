{
  "instance_id": "sympy__sympy-14248",
  "problem_statement": "The difference of MatrixSymbols prints as a sum with (-1) coefficient\nInternally, differences like a-b are represented as the sum of a with `(-1)*b`, but they are supposed to print like a-b. This does not happen with MatrixSymbols. I tried three printers: str, pretty, and latex: \r\n```\r\nfrom sympy import *\r\nA = MatrixSymbol('A', 2, 2)\r\nB = MatrixSymbol('B', 2, 2)\r\nprint(A - A*B - B)\r\npprint(A - A*B - B)\r\nlatex(A - A*B - B)\r\n```\r\nOutput:\r\n```\r\n(-1)*B + (-1)*A*B + A\r\n-B + -Aâ‹…B + A\r\n'-1 B + -1 A B + A'\r\n```\r\n\r\nBased on a [Stack Overflow post](https://stackoverflow.com/q/48826611)\n",
  "localized_code": "[start of sympy/printing/latex.py]\n1: \"\"\"\n2: A Printer which converts an expression into its LaTeX equivalent.\n3: \"\"\"\n4: \n5: from __future__ import print_function, division\n6: \n7: import itertools\n8: \n9: from sympy.core import S, Add, Symbol, Mod\n10: from sympy.core.function import _coeff_isneg\n11: from sympy.core.sympify import SympifyError\n12: from sympy.core.alphabets import greeks\n13: from sympy.core.operations import AssocOp\n14: from sympy.core.containers import Tuple\n15: from sympy.logic.boolalg import true\n16: from sympy.core.function import UndefinedFunction, AppliedUndef\n17: \n18: ## sympy.printing imports\n19: from sympy.printing.precedence import precedence_traditional\n20: from .printer import Printer\n21: from .conventions import split_super_sub, requires_partial\n22: from .precedence import precedence, PRECEDENCE\n23: \n24: import mpmath.libmp as mlib\n25: from mpmath.libmp import prec_to_dps\n26: \n27: from sympy.core.compatibility import default_sort_key, range\n28: from sympy.utilities.iterables import has_variety\n29: \n30: import re\n31: \n32: # Hand-picked functions which can be used directly in both LaTeX and MathJax\n33: # Complete list at http://www.mathjax.org/docs/1.1/tex.html#supported-latex-commands\n34: # This variable only contains those functions which sympy uses.\n35: accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan',\n36:                     'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec', 'csc',\n37:                     'cot', 'coth', 're', 'im', 'frac', 'root', 'arg',\n38:                     ]\n39: \n40: tex_greek_dictionary = {\n41:     'Alpha': 'A',\n42:     'Beta': 'B',\n43:     'Gamma': r'\\Gamma',\n44:     'Delta': r'\\Delta',\n45:     'Epsilon': 'E',\n46:     'Zeta': 'Z',\n47:     'Eta': 'H',\n48:     'Theta': r'\\Theta',\n49:     'Iota': 'I',\n50:     'Kappa': 'K',\n51:     'Lambda': r'\\Lambda',\n52:     'Mu': 'M',\n53:     'Nu': 'N',\n54:     'Xi': r'\\Xi',\n55:     'omicron': 'o',\n56:     'Omicron': 'O',\n57:     'Pi': r'\\Pi',\n58:     'Rho': 'P',\n59:     'Sigma': r'\\Sigma',\n60:     'Tau': 'T',\n61:     'Upsilon': r'\\Upsilon',\n62:     'Phi': r'\\Phi',\n63:     'Chi': 'X',\n64:     'Psi': r'\\Psi',\n65:     'Omega': r'\\Omega',\n66:     'lamda': r'\\lambda',\n67:     'Lamda': r'\\Lambda',\n68:     'khi': r'\\chi',\n69:     'Khi': r'X',\n70:     'varepsilon': r'\\varepsilon',\n71:     'varkappa': r'\\varkappa',\n72:     'varphi': r'\\varphi',\n73:     'varpi': r'\\varpi',\n74:     'varrho': r'\\varrho',\n75:     'varsigma': r'\\varsigma',\n76:     'vartheta': r'\\vartheta',\n77: }\n78: \n79: other_symbols = set(['aleph', 'beth', 'daleth', 'gimel', 'ell', 'eth', 'hbar',\n80:                      'hslash', 'mho', 'wp', ])\n81: \n82: # Variable name modifiers\n83: modifier_dict = {\n84:     # Accents\n85:     'mathring': lambda s: r'\\mathring{'+s+r'}',\n86:     'ddddot': lambda s: r'\\ddddot{'+s+r'}',\n87:     'dddot': lambda s: r'\\dddot{'+s+r'}',\n88:     'ddot': lambda s: r'\\ddot{'+s+r'}',\n89:     'dot': lambda s: r'\\dot{'+s+r'}',\n90:     'check': lambda s: r'\\check{'+s+r'}',\n91:     'breve': lambda s: r'\\breve{'+s+r'}',\n92:     'acute': lambda s: r'\\acute{'+s+r'}',\n93:     'grave': lambda s: r'\\grave{'+s+r'}',\n94:     'tilde': lambda s: r'\\tilde{'+s+r'}',\n95:     'hat': lambda s: r'\\hat{'+s+r'}',\n96:     'bar': lambda s: r'\\bar{'+s+r'}',\n97:     'vec': lambda s: r'\\vec{'+s+r'}',\n98:     'prime': lambda s: \"{\"+s+\"}'\",\n99:     'prm': lambda s: \"{\"+s+\"}'\",\n100:     # Faces\n101:     'bold': lambda s: r'\\boldsymbol{'+s+r'}',\n102:     'bm': lambda s: r'\\boldsymbol{'+s+r'}',\n103:     'cal': lambda s: r'\\mathcal{'+s+r'}',\n104:     'scr': lambda s: r'\\mathscr{'+s+r'}',\n105:     'frak': lambda s: r'\\mathfrak{'+s+r'}',\n106:     # Brackets\n107:     'norm': lambda s: r'\\left\\|{'+s+r'}\\right\\|',\n108:     'avg': lambda s: r'\\left\\langle{'+s+r'}\\right\\rangle',\n109:     'abs': lambda s: r'\\left|{'+s+r'}\\right|',\n110:     'mag': lambda s: r'\\left|{'+s+r'}\\right|',\n111: }\n112: \n113: greek_letters_set = frozenset(greeks)\n114: \n115: _between_two_numbers_p = (\n116:     re.compile(r'[0-9][} ]*$'),  # search\n117:     re.compile(r'[{ ]*[-+0-9]'),  # match\n118: )\n119: \n120: \n121: class LatexPrinter(Printer):\n122:     printmethod = \"_latex\"\n123: \n124:     _default_settings = {\n125:         \"order\": None,\n126:         \"mode\": \"plain\",\n127:         \"itex\": False,\n128:         \"fold_frac_powers\": False,\n129:         \"fold_func_brackets\": False,\n130:         \"fold_short_frac\": None,\n131:         \"long_frac_ratio\": 2,\n132:         \"mul_symbol\": None,\n133:         \"inv_trig_style\": \"abbreviated\",\n134:         \"mat_str\": None,\n135:         \"mat_delim\": \"[\",\n136:         \"symbol_names\": {},\n137:         \"ln_notation\": False,\n138:     }\n139: \n140:     def __init__(self, settings=None):\n141:         Printer.__init__(self, settings)\n142: \n143:         if 'mode' in self._settings:\n144:             valid_modes = ['inline', 'plain', 'equation',\n145:                            'equation*']\n146:             if self._settings['mode'] not in valid_modes:\n147:                 raise ValueError(\"'mode' must be one of 'inline', 'plain', \"\n148:                     \"'equation' or 'equation*'\")\n149: \n150:         if self._settings['fold_short_frac'] is None and \\\n151:                 self._settings['mode'] == 'inline':\n152:             self._settings['fold_short_frac'] = True\n153: \n154:         mul_symbol_table = {\n155:             None: r\" \",\n156:             \"ldot\": r\" \\,.\\, \",\n157:             \"dot\": r\" \\cdot \",\n158:             \"times\": r\" \\times \"\n159:         }\n160:         try:\n161:             self._settings['mul_symbol_latex'] = \\\n162:                 mul_symbol_table[self._settings['mul_symbol']]\n163:         except KeyError:\n164:             self._settings['mul_symbol_latex'] = \\\n165:                 self._settings['mul_symbol']\n166:         try:\n167:             self._settings['mul_symbol_latex_numbers'] = \\\n168:                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n169:         except KeyError:\n170:             if (self._settings['mul_symbol'].strip() in\n171:                     ['', ' ', '\\\\', '\\\\,', '\\\\:', '\\\\;', '\\\\quad']):\n172:                 self._settings['mul_symbol_latex_numbers'] = \\\n173:                     mul_symbol_table['dot']\n174:             else:\n175:                 self._settings['mul_symbol_latex_numbers'] = \\\n176:                     self._settings['mul_symbol']\n177: \n178:         self._delim_dict = {'(': ')', '[': ']'}\n179: \n180:     def parenthesize(self, item, level, strict=False):\n181:         prec_val = precedence_traditional(item)\n182:         if (prec_val < level) or ((not strict) and prec_val <= level):\n183:             return r\"\\left(%s\\right)\" % self._print(item)\n184:         else:\n185:             return self._print(item)\n186: \n187:     def doprint(self, expr):\n188:         tex = Printer.doprint(self, expr)\n189: \n190:         if self._settings['mode'] == 'plain':\n191:             return tex\n192:         elif self._settings['mode'] == 'inline':\n193:             return r\"$%s$\" % tex\n194:         elif self._settings['itex']:\n195:             return r\"$$%s$$\" % tex\n196:         else:\n197:             env_str = self._settings['mode']\n198:             return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n199: \n200:     def _needs_brackets(self, expr):\n201:         \"\"\"\n202:         Returns True if the expression needs to be wrapped in brackets when\n203:         printed, False otherwise. For example: a + b => True; a => False;\n204:         10 => False; -10 => True.\n205:         \"\"\"\n206:         return not ((expr.is_Integer and expr.is_nonnegative)\n207:                     or (expr.is_Atom and (expr is not S.NegativeOne\n208:                                           and expr.is_Rational is False)))\n209: \n210:     def _needs_function_brackets(self, expr):\n211:         \"\"\"\n212:         Returns True if the expression needs to be wrapped in brackets when\n213:         passed as an argument to a function, False otherwise. This is a more\n214:         liberal version of _needs_brackets, in that many expressions which need\n215:         to be wrapped in brackets when added/subtracted/raised to a power do\n216:         not need them when passed to a function. Such an example is a*b.\n217:         \"\"\"\n218:         if not self._needs_brackets(expr):\n219:             return False\n220:         else:\n221:             # Muls of the form a*b*c... can be folded\n222:             if expr.is_Mul and not self._mul_is_clean(expr):\n223:                 return True\n224:             # Pows which don't need brackets can be folded\n225:             elif expr.is_Pow and not self._pow_is_clean(expr):\n226:                 return True\n227:             # Add and Function always need brackets\n228:             elif expr.is_Add or expr.is_Function:\n229:                 return True\n230:             else:\n231:                 return False\n232: \n233:     def _needs_mul_brackets(self, expr, first=False, last=False):\n234:         \"\"\"\n235:         Returns True if the expression needs to be wrapped in brackets when\n236:         printed as part of a Mul, False otherwise. This is True for Add,\n237:         but also for some container objects that would not need brackets\n238:         when appearing last in a Mul, e.g. an Integral. ``last=True``\n239:         specifies that this expr is the last to appear in a Mul.\n240:         ``first=True`` specifies that this expr is the first to appear in a Mul.\n241:         \"\"\"\n242:         from sympy import Integral, Piecewise, Product, Sum\n243: \n244:         if expr.is_Mul:\n245:             if not first and _coeff_isneg(expr):\n246:                 return True\n247:         elif precedence_traditional(expr) < PRECEDENCE[\"Mul\"]:\n248:             return True\n249:         elif expr.is_Relational:\n250:             return True\n251:         if expr.is_Piecewise:\n252:             return True\n253:         if any([expr.has(x) for x in (Mod,)]):\n254:             return True\n255:         if (not last and\n256:             any([expr.has(x) for x in (Integral, Product, Sum)])):\n257:             return True\n258: \n259:         return False\n260: \n261: \n262:     def _needs_add_brackets(self, expr):\n263:         \"\"\"\n264:         Returns True if the expression needs to be wrapped in brackets when\n265:         printed as part of an Add, False otherwise.  This is False for most\n266:         things.\n267:         \"\"\"\n268:         if expr.is_Relational:\n269:             return True\n270:         if any([expr.has(x) for x in (Mod,)]):\n271:             return True\n272:         if expr.is_Add:\n273:             return True\n274:         return False\n275: \n276: \n277:     def _mul_is_clean(self, expr):\n278:         for arg in expr.args:\n279:             if arg.is_Function:\n280:                 return False\n281:         return True\n282: \n283:     def _pow_is_clean(self, expr):\n284:         return not self._needs_brackets(expr.base)\n285: \n286:     def _do_exponent(self, expr, exp):\n287:         if exp is not None:\n288:             return r\"\\left(%s\\right)^{%s}\" % (expr, exp)\n289:         else:\n290:             return expr\n291: \n292:     def _print_bool(self, e):\n293:         return r\"\\mathrm{%s}\" % e\n294: \n295:     _print_BooleanTrue = _print_bool\n296:     _print_BooleanFalse = _print_bool\n297: \n298:     def _print_NoneType(self, e):\n299:         return r\"\\mathrm{%s}\" % e\n300: \n301: \n302:     def _print_Add(self, expr, order=None):\n303:         if self.order == 'none':\n304:             terms = list(expr.args)\n305:         else:\n306:             terms = self._as_ordered_terms(expr, order=order)\n307: \n308:         tex = \"\"\n309:         for i, term in enumerate(terms):\n310:             if i == 0:\n311:                 pass\n312:             elif _coeff_isneg(term):\n313:                 tex += \" - \"\n314:                 term = -term\n315:             else:\n316:                 tex += \" + \"\n317:             term_tex = self._print(term)\n318:             if self._needs_add_brackets(term):\n319:                 term_tex = r\"\\left(%s\\right)\" % term_tex\n320:             tex += term_tex\n321: \n322:         return tex\n323: \n324:     def _print_Cycle(self, expr):\n325:         from sympy.combinatorics.permutations import Permutation\n326:         if expr.size == 0:\n327:             return r\"\\left( \\right)\"\n328:         expr = Permutation(expr)\n329:         expr_perm = expr.cyclic_form\n330:         siz = expr.size\n331:         if expr.array_form[-1] == siz - 1:\n332:             expr_perm = expr_perm + [[siz - 1]]\n333:         term_tex = ''\n334:         for i in expr_perm:\n335:             term_tex += str(i).replace(',', r\"\\;\")\n336:         term_tex = term_tex.replace('[', r\"\\left( \")\n337:         term_tex = term_tex.replace(']', r\"\\right)\")\n338:         return term_tex\n339: \n340:     _print_Permutation = _print_Cycle\n341: \n342:     def _print_Float(self, expr):\n343:         # Based off of that in StrPrinter\n344:         dps = prec_to_dps(expr._prec)\n345:         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n346: \n347:         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n348:         # thus we use the number separator\n349:         separator = self._settings['mul_symbol_latex_numbers']\n350: \n351:         if 'e' in str_real:\n352:             (mant, exp) = str_real.split('e')\n353: \n354:             if exp[0] == '+':\n355:                 exp = exp[1:]\n356: \n357:             return r\"%s%s10^{%s}\" % (mant, separator, exp)\n358:         elif str_real == \"+inf\":\n359:             return r\"\\infty\"\n360:         elif str_real == \"-inf\":\n361:             return r\"- \\infty\"\n362:         else:\n363:             return str_real\n364: \n365:     def _print_Cross(self, expr):\n366:         vec1 = expr._expr1\n367:         vec2 = expr._expr2\n368:         return r\"%s \\times %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n369:                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n370: \n371:     def _print_Curl(self, expr):\n372:         vec = expr._expr\n373:         return r\"\\nabla\\times %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n374: \n375:     def _print_Divergence(self, expr):\n376:         vec = expr._expr\n377:         return r\"\\nabla\\cdot %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n378: \n379:     def _print_Dot(self, expr):\n380:         vec1 = expr._expr1\n381:         vec2 = expr._expr2\n382:         return r\"%s \\cdot %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n383:                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n384: \n385:     def _print_Gradient(self, expr):\n386:         func = expr._expr\n387:         return r\"\\nabla\\cdot %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n388: \n389:     def _print_Mul(self, expr):\n390:         from sympy.core.power import Pow\n391:         from sympy.physics.units import Quantity\n392:         include_parens = False\n393:         if _coeff_isneg(expr):\n394:             expr = -expr\n395:             tex = \"- \"\n396:             if expr.is_Add:\n397:                 tex += \"(\"\n398:                 include_parens = True\n399:         else:\n400:             tex = \"\"\n401: \n402:         from sympy.simplify import fraction\n403:         numer, denom = fraction(expr, exact=True)\n404:         separator = self._settings['mul_symbol_latex']\n405:         numbersep = self._settings['mul_symbol_latex_numbers']\n406: \n407:         def convert(expr):\n408:             if not expr.is_Mul:\n409:                 return str(self._print(expr))\n410:             else:\n411:                 _tex = last_term_tex = \"\"\n412: \n413:                 if self.order not in ('old', 'none'):\n414:                     args = expr.as_ordered_factors()\n415:                 else:\n416:                     args = list(expr.args)\n417: \n418:                 # If quantities are present append them at the back\n419:                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or\n420:                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))\n421: \n422:                 for i, term in enumerate(args):\n423:                     term_tex = self._print(term)\n424: \n425:                     if self._needs_mul_brackets(term, first=(i == 0),\n426:                                                 last=(i == len(args) - 1)):\n427:                         term_tex = r\"\\left(%s\\right)\" % term_tex\n428: \n429:                     if _between_two_numbers_p[0].search(last_term_tex) and \\\n430:                             _between_two_numbers_p[1].match(term_tex):\n431:                         # between two numbers\n432:                         _tex += numbersep\n433:                     elif _tex:\n434:                         _tex += separator\n435: \n436:                     _tex += term_tex\n437:                     last_term_tex = term_tex\n438:                 return _tex\n439: \n440:         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:\n441:             # use the original expression here, since fraction() may have\n442:             # altered it when producing numer and denom\n443:             tex += convert(expr)\n444: \n445:         else:\n446:             snumer = convert(numer)\n447:             sdenom = convert(denom)\n448:             ldenom = len(sdenom.split())\n449:             ratio = self._settings['long_frac_ratio']\n450:             if self._settings['fold_short_frac'] \\\n451:                     and ldenom <= 2 and not \"^\" in sdenom:\n452:                 # handle short fractions\n453:                 if self._needs_mul_brackets(numer, last=False):\n454:                     tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n455:                 else:\n456:                     tex += r\"%s / %s\" % (snumer, sdenom)\n457:             elif len(snumer.split()) > ratio*ldenom:\n458:                 # handle long fractions\n459:                 if self._needs_mul_brackets(numer, last=True):\n460:                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n461:                         % (sdenom, separator, snumer)\n462:                 elif numer.is_Mul:\n463:                     # split a long numerator\n464:                     a = S.One\n465:                     b = S.One\n466:                     for x in numer.args:\n467:                         if self._needs_mul_brackets(x, last=False) or \\\n468:                                 len(convert(a*x).split()) > ratio*ldenom or \\\n469:                                 (b.is_commutative is x.is_commutative is False):\n470:                             b *= x\n471:                         else:\n472:                             a *= x\n473:                     if self._needs_mul_brackets(b, last=True):\n474:                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n475:                             % (convert(a), sdenom, separator, convert(b))\n476:                     else:\n477:                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n478:                             % (convert(a), sdenom, separator, convert(b))\n479:                 else:\n480:                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n481:             else:\n482:                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n483: \n484:         if include_parens:\n485:             tex += \")\"\n486:         return tex\n487: \n488:     def _print_Pow(self, expr):\n489:         # Treat x**Rational(1,n) as special case\n490:         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:\n491:             base = self._print(expr.base)\n492:             expq = expr.exp.q\n493: \n494:             if expq == 2:\n495:                 tex = r\"\\sqrt{%s}\" % base\n496:             elif self._settings['itex']:\n497:                 tex = r\"\\root{%d}{%s}\" % (expq, base)\n498:             else:\n499:                 tex = r\"\\sqrt[%d]{%s}\" % (expq, base)\n500: \n501:             if expr.exp.is_negative:\n502:                 return r\"\\frac{1}{%s}\" % tex\n503:             else:\n504:                 return tex\n505:         elif self._settings['fold_frac_powers'] \\\n506:             and expr.exp.is_Rational \\\n507:                 and expr.exp.q != 1:\n508:             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q\n509:             #fixes issue #12886, adds parentheses before superscripts raised to powers\n510:             if '^' in base and expr.base.is_Symbol:\n511:                 base = r\"\\left(%s\\right)\" % base\n512:             if expr.base.is_Function:\n513:                 return self._print(expr.base, \"%s/%s\" % (p, q))\n514:             return r\"%s^{%s/%s}\" % (base, p, q)\n515:         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:\n516:             # Things like 1/x\n517:             return self._print_Mul(expr)\n518:         else:\n519:             if expr.base.is_Function:\n520:                 return self._print(expr.base, self._print(expr.exp))\n521:             else:\n522:                 if expr.is_commutative and expr.exp == -1:\n523:                     #solves issue 4129\n524:                     #As Mul always simplify 1/x to x**-1\n525:                     #The objective is achieved with this hack\n526:                     #first we get the latex for -1 * expr,\n527:                     #which is a Mul expression\n528:                     tex = self._print(S.NegativeOne * expr).strip()\n529:                     #the result comes with a minus and a space, so we remove\n530:                     if tex[:1] == \"-\":\n531:                         return tex[1:].strip()\n532:                 tex = r\"%s^{%s}\"\n533:                 #fixes issue #12886, adds parentheses before superscripts raised to powers\n534:                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n535:                 if '^' in base and expr.base.is_Symbol:\n536:                     base = r\"\\left(%s\\right)\" % base\n537:                 exp = self._print(expr.exp)\n538: \n539:                 return tex % (base, exp)\n540: \n541:     def _print_UnevaluatedExpr(self, expr):\n542:         return self._print(expr.args[0])\n543: \n544:     def _print_Sum(self, expr):\n545:         if len(expr.limits) == 1:\n546:             tex = r\"\\sum_{%s=%s}^{%s} \" % \\\n547:                 tuple([ self._print(i) for i in expr.limits[0] ])\n548:         else:\n549:             def _format_ineq(l):\n550:                 return r\"%s \\leq %s \\leq %s\" % \\\n551:                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n552: \n553:             tex = r\"\\sum_{\\substack{%s}} \" % \\\n554:                 str.join('\\\\\\\\', [ _format_ineq(l) for l in expr.limits ])\n555: \n556:         if isinstance(expr.function, Add):\n557:             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n558:         else:\n559:             tex += self._print(expr.function)\n560: \n561:         return tex\n562: \n563:     def _print_Product(self, expr):\n564:         if len(expr.limits) == 1:\n565:             tex = r\"\\prod_{%s=%s}^{%s} \" % \\\n566:                 tuple([ self._print(i) for i in expr.limits[0] ])\n567:         else:\n568:             def _format_ineq(l):\n569:                 return r\"%s \\leq %s \\leq %s\" % \\\n570:                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n571: \n572:             tex = r\"\\prod_{\\substack{%s}} \" % \\\n573:                 str.join('\\\\\\\\', [ _format_ineq(l) for l in expr.limits ])\n574: \n575:         if isinstance(expr.function, Add):\n576:             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n577:         else:\n578:             tex += self._print(expr.function)\n579: \n580:         return tex\n581: \n582:     def _print_BasisDependent(self, expr):\n583:         from sympy.vector import Vector\n584: \n585:         o1 = []\n586:         if expr == expr.zero:\n587:             return expr.zero._latex_form\n588:         if isinstance(expr, Vector):\n589:             items = expr.separate().items()\n590:         else:\n591:             items = [(0, expr)]\n592: \n593:         for system, vect in items:\n594:             inneritems = list(vect.components.items())\n595:             inneritems.sort(key = lambda x:x[0].__str__())\n596:             for k, v in inneritems:\n597:                 if v == 1:\n598:                     o1.append(' + ' + k._latex_form)\n599:                 elif v == -1:\n600:                     o1.append(' - ' + k._latex_form)\n601:                 else:\n602:                     arg_str = '(' + LatexPrinter().doprint(v) + ')'\n603:                     o1.append(' + ' + arg_str + k._latex_form)\n604: \n605:         outstr = (''.join(o1))\n606:         if outstr[1] != '-':\n607:             outstr = outstr[3:]\n608:         else:\n609:             outstr = outstr[1:]\n610:         return outstr\n611: \n612:     def _print_Indexed(self, expr):\n613:         tex = self._print(expr.base)+'_{%s}' % ','.join(\n614:             map(self._print, expr.indices))\n615:         return tex\n616: \n617:     def _print_IndexedBase(self, expr):\n618:         return self._print(expr.label)\n619: \n620:     def _print_Derivative(self, expr):\n621:         if requires_partial(expr):\n622:             diff_symbol = r'\\partial'\n623:         else:\n624:             diff_symbol = r'd'\n625: \n626:         tex = \"\"\n627:         dim = 0\n628:         for x, num in reversed(expr.variable_count):\n629:             dim += num\n630:             if num == 1:\n631:                 tex += r\"%s %s\" % (diff_symbol, self._print(x))\n632:             else:\n633:                 tex += r\"%s %s^{%s}\" % (diff_symbol, self._print(x), num)\n634: \n635:         if dim == 1:\n636:             tex = r\"\\frac{%s}{%s}\" % (diff_symbol, tex)\n637:         else:\n638:             tex = r\"\\frac{%s^{%s}}{%s}\" % (diff_symbol, dim, tex)\n639: \n640:         return r\"%s %s\" % (tex, self.parenthesize(expr.expr, PRECEDENCE[\"Mul\"], strict=True))\n641: \n642:     def _print_Subs(self, subs):\n643:         expr, old, new = subs.args\n644:         latex_expr = self._print(expr)\n645:         latex_old = (self._print(e) for e in old)\n646:         latex_new = (self._print(e) for e in new)\n647:         latex_subs = r'\\\\ '.join(\n648:             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n649:         return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr, latex_subs)\n650: \n651:     def _print_Integral(self, expr):\n652:         tex, symbols = \"\", []\n653: \n654:         # Only up to \\iiiint exists\n655:         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):\n656:             # Use len(expr.limits)-1 so that syntax highlighters don't think\n657:             # \\\" is an escaped quote\n658:             tex = r\"\\i\" + \"i\"*(len(expr.limits) - 1) + \"nt\"\n659:             symbols = [r\"\\, d%s\" % self._print(symbol[0])\n660:                        for symbol in expr.limits]\n661: \n662:         else:\n663:             for lim in reversed(expr.limits):\n664:                 symbol = lim[0]\n665:                 tex += r\"\\int\"\n666: \n667:                 if len(lim) > 1:\n668:                     if self._settings['mode'] in ['equation', 'equation*'] \\\n669:                             and not self._settings['itex']:\n670:                         tex += r\"\\limits\"\n671: \n672:                     if len(lim) == 3:\n673:                         tex += \"_{%s}^{%s}\" % (self._print(lim[1]),\n674:                                                self._print(lim[2]))\n675:                     if len(lim) == 2:\n676:                         tex += \"^{%s}\" % (self._print(lim[1]))\n677: \n678:                 symbols.insert(0, r\"\\, d%s\" % self._print(symbol))\n679: \n680:         return r\"%s %s%s\" % (tex,\n681:             self.parenthesize(expr.function, PRECEDENCE[\"Mul\"], strict=True), \"\".join(symbols))\n682: \n683:     def _print_Limit(self, expr):\n684:         e, z, z0, dir = expr.args\n685: \n686:         tex = r\"\\lim_{%s \\to \" % self._print(z)\n687:         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n688:             tex += r\"%s}\" % self._print(z0)\n689:         else:\n690:             tex += r\"%s^%s}\" % (self._print(z0), self._print(dir))\n691: \n692:         if isinstance(e, AssocOp):\n693:             return r\"%s\\left(%s\\right)\" % (tex, self._print(e))\n694:         else:\n695:             return r\"%s %s\" % (tex, self._print(e))\n696: \n697:     def _hprint_Function(self, func):\n698:         r'''\n699:         Logic to decide how to render a function to latex\n700:           - if it is a recognized latex name, use the appropriate latex command\n701:           - if it is a single letter, just use that letter\n702:           - if it is a longer name, then put \\operatorname{} around it and be\n703:             mindful of undercores in the name\n704:         '''\n705:         func = self._deal_with_super_sub(func)\n706:         if func in accepted_latex_functions:\n707:             name = r\"\\%s\" % func\n708:         elif len(func) == 1 or func.startswith('\\\\'):\n709:             name = func\n710:         else:\n711:             name = r\"\\operatorname{%s}\" % func\n712:         return name\n713: \n714:     def _print_Function(self, expr, exp=None):\n715:         r'''\n716:         Render functions to LaTeX, handling functions that LaTeX knows about\n717:         e.g., sin, cos, ... by using the proper LaTeX command (\\sin, \\cos, ...).\n718:         For single-letter function names, render them as regular LaTeX math\n719:         symbols. For multi-letter function names that LaTeX does not know\n720:         about, (e.g., Li, sech) use \\operatorname{} so that the function name\n721:         is rendered in Roman font and LaTeX handles spacing properly.\n722: \n723:         expr is the expression involving the function\n724:         exp is an exponent\n725:         '''\n726:         func = expr.func.__name__\n727:         if hasattr(self, '_print_' + func) and \\\n728:             not isinstance(expr.func, UndefinedFunction):\n729:             return getattr(self, '_print_' + func)(expr, exp)\n730:         else:\n731:             args = [ str(self._print(arg)) for arg in expr.args ]\n732:             # How inverse trig functions should be displayed, formats are:\n733:             # abbreviated: asin, full: arcsin, power: sin^-1\n734:             inv_trig_style = self._settings['inv_trig_style']\n735:             # If we are dealing with a power-style inverse trig function\n736:             inv_trig_power_case = False\n737:             # If it is applicable to fold the argument brackets\n738:             can_fold_brackets = self._settings['fold_func_brackets'] and \\\n739:                 len(args) == 1 and \\\n740:                 not self._needs_function_brackets(expr.args[0])\n741: \n742:             inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acot\"]\n743: \n744:             # If the function is an inverse trig function, handle the style\n745:             if func in inv_trig_table:\n746:                 if inv_trig_style == \"abbreviated\":\n747:                     func = func\n748:                 elif inv_trig_style == \"full\":\n749:                     func = \"arc\" + func[1:]\n750:                 elif inv_trig_style == \"power\":\n751:                     func = func[1:]\n752:                     inv_trig_power_case = True\n753: \n754:                     # Can never fold brackets if we're raised to a power\n755:                     if exp is not None:\n756:                         can_fold_brackets = False\n757: \n758:             if inv_trig_power_case:\n759:                 if func in accepted_latex_functions:\n760:                     name = r\"\\%s^{-1}\" % func\n761:                 else:\n762:                     name = r\"\\operatorname{%s}^{-1}\" % func\n763:             elif exp is not None:\n764:                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)\n765:             else:\n766:                 name = self._hprint_Function(func)\n767: \n768:             if can_fold_brackets:\n769:                 if func in accepted_latex_functions:\n770:                     # Wrap argument safely to avoid parse-time conflicts\n771:                     # with the function name itself\n772:                     name += r\" {%s}\"\n773:                 else:\n774:                     name += r\"%s\"\n775:             else:\n776:                 name += r\"{\\left (%s \\right )}\"\n777: \n778:             if inv_trig_power_case and exp is not None:\n779:                 name += r\"^{%s}\" % exp\n780: \n781:             return name % \",\".join(args)\n782: \n783:     def _print_UndefinedFunction(self, expr):\n784:         return self._hprint_Function(str(expr))\n785: \n786:     @property\n787:     def _special_function_classes(self):\n788:         from sympy.functions.special.tensor_functions import KroneckerDelta\n789:         from sympy.functions.special.gamma_functions import gamma, lowergamma\n790:         from sympy.functions.special.beta_functions import beta\n791:         from sympy.functions.special.delta_functions import DiracDelta\n792:         from sympy.functions.special.error_functions import Chi\n793:         return {KroneckerDelta: r'\\delta',\n794:                 gamma:  r'\\Gamma',\n795:                 lowergamma: r'\\gamma',\n796:                 beta: r'\\operatorname{B}',\n797:                 DiracDelta: r'\\delta',\n798:                 Chi: r'\\operatorname{Chi}'}\n799: \n800:     def _print_FunctionClass(self, expr):\n801:         for cls in self._special_function_classes:\n802:             if issubclass(expr, cls) and expr.__name__ == cls.__name__:\n803:                 return self._special_function_classes[cls]\n804:         return self._hprint_Function(str(expr))\n805: \n806:     def _print_Lambda(self, expr):\n807:         symbols, expr = expr.args\n808: \n809:         if len(symbols) == 1:\n810:             symbols = self._print(symbols[0])\n811:         else:\n812:             symbols = self._print(tuple(symbols))\n813: \n814:         args = (symbols, self._print(expr))\n815:         tex = r\"\\left( %s \\mapsto %s \\right)\" % (symbols, self._print(expr))\n816: \n817:         return tex\n818: \n819:     def _print_Min(self, expr, exp=None):\n820:         args = sorted(expr.args, key=default_sort_key)\n821:         texargs = [r\"%s\" % self._print(symbol) for symbol in args]\n822:         tex = r\"\\min\\left(%s\\right)\" % \", \".join(texargs)\n823: \n824:         if exp is not None:\n825:             return r\"%s^{%s}\" % (tex, exp)\n826:         else:\n827:             return tex\n828: \n829:     def _print_Max(self, expr, exp=None):\n830:         args = sorted(expr.args, key=default_sort_key)\n831:         texargs = [r\"%s\" % self._print(symbol) for symbol in args]\n832:         tex = r\"\\max\\left(%s\\right)\" % \", \".join(texargs)\n833: \n834:         if exp is not None:\n835:             return r\"%s^{%s}\" % (tex, exp)\n836:         else:\n837:             return tex\n838: \n839:     def _print_floor(self, expr, exp=None):\n840:         tex = r\"\\lfloor{%s}\\rfloor\" % self._print(expr.args[0])\n841: \n842:         if exp is not None:\n843:             return r\"%s^{%s}\" % (tex, exp)\n844:         else:\n845:             return tex\n846: \n847:     def _print_ceiling(self, expr, exp=None):\n848:         tex = r\"\\lceil{%s}\\rceil\" % self._print(expr.args[0])\n849: \n850:         if exp is not None:\n851:             return r\"%s^{%s}\" % (tex, exp)\n852:         else:\n853:             return tex\n854: \n855:     def _print_log(self, expr, exp=None):\n856:         if not self._settings[\"ln_notation\"]:\n857:             tex = r\"\\log{\\left (%s \\right )}\" % self._print(expr.args[0])\n858:         else:\n859:             tex = r\"\\ln{\\left (%s \\right )}\" % self._print(expr.args[0])\n860: \n861:         if exp is not None:\n862:             return r\"%s^{%s}\" % (tex, exp)\n863:         else:\n864:             return tex\n865: \n866:     def _print_Abs(self, expr, exp=None):\n867:         tex = r\"\\left|{%s}\\right|\" % self._print(expr.args[0])\n868: \n869:         if exp is not None:\n870:             return r\"%s^{%s}\" % (tex, exp)\n871:         else:\n872:             return tex\n873:     _print_Determinant = _print_Abs\n874: \n875:     def _print_re(self, expr, exp=None):\n876:         tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n877: \n878:         return self._do_exponent(tex, exp)\n879: \n880:     def _print_im(self, expr, exp=None):\n881:         tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])\n882: \n883:         return self._do_exponent(tex, exp)\n884: \n885:     def _print_Not(self, e):\n886:         from sympy import Equivalent, Implies\n887:         if isinstance(e.args[0], Equivalent):\n888:             return self._print_Equivalent(e.args[0], r\"\\not\\Leftrightarrow\")\n889:         if isinstance(e.args[0], Implies):\n890:             return self._print_Implies(e.args[0], r\"\\not\\Rightarrow\")\n891:         if (e.args[0].is_Boolean):\n892:             return r\"\\neg (%s)\" % self._print(e.args[0])\n893:         else:\n894:             return r\"\\neg %s\" % self._print(e.args[0])\n895: \n896:     def _print_LogOp(self, args, char):\n897:         arg = args[0]\n898:         if arg.is_Boolean and not arg.is_Not:\n899:             tex = r\"\\left(%s\\right)\" % self._print(arg)\n900:         else:\n901:             tex = r\"%s\" % self._print(arg)\n902: \n903:         for arg in args[1:]:\n904:             if arg.is_Boolean and not arg.is_Not:\n905:                 tex += r\" %s \\left(%s\\right)\" % (char, self._print(arg))\n906:             else:\n907:                 tex += r\" %s %s\" % (char, self._print(arg))\n908: \n909:         return tex\n910: \n911:     def _print_And(self, e):\n912:         args = sorted(e.args, key=default_sort_key)\n913:         return self._print_LogOp(args, r\"\\wedge\")\n914: \n915:     def _print_Or(self, e):\n916:         args = sorted(e.args, key=default_sort_key)\n917:         return self._print_LogOp(args, r\"\\vee\")\n918: \n919:     def _print_Xor(self, e):\n920:         args = sorted(e.args, key=default_sort_key)\n921:         return self._print_LogOp(args, r\"\\veebar\")\n922: \n923:     def _print_Implies(self, e, altchar=None):\n924:         return self._print_LogOp(e.args, altchar or r\"\\Rightarrow\")\n925: \n926:     def _print_Equivalent(self, e, altchar=None):\n927:         args = sorted(e.args, key=default_sort_key)\n928:         return self._print_LogOp(args, altchar or r\"\\Leftrightarrow\")\n929: \n930:     def _print_conjugate(self, expr, exp=None):\n931:         tex = r\"\\overline{%s}\" % self._print(expr.args[0])\n932: \n933:         if exp is not None:\n934:             return r\"%s^{%s}\" % (tex, exp)\n935:         else:\n936:             return tex\n937: \n938:     def _print_polar_lift(self, expr, exp=None):\n939:         func = r\"\\operatorname{polar\\_lift}\"\n940:         arg = r\"{\\left (%s \\right )}\" % self._print(expr.args[0])\n941: \n942:         if exp is not None:\n943:             return r\"%s^{%s}%s\" % (func, exp, arg)\n944:         else:\n945:             return r\"%s%s\" % (func, arg)\n946: \n947:     def _print_ExpBase(self, expr, exp=None):\n948:         # TODO should exp_polar be printed differently?\n949:         #      what about exp_polar(0), exp_polar(1)?\n950:         tex = r\"e^{%s}\" % self._print(expr.args[0])\n951:         return self._do_exponent(tex, exp)\n952: \n953:     def _print_elliptic_k(self, expr, exp=None):\n954:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n955:         if exp is not None:\n956:             return r\"K^{%s}%s\" % (exp, tex)\n957:         else:\n958:             return r\"K%s\" % tex\n959: \n960:     def _print_elliptic_f(self, expr, exp=None):\n961:         tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n962:             (self._print(expr.args[0]), self._print(expr.args[1]))\n963:         if exp is not None:\n964:             return r\"F^{%s}%s\" % (exp, tex)\n965:         else:\n966:             return r\"F%s\" % tex\n967: \n968:     def _print_elliptic_e(self, expr, exp=None):\n969:         if len(expr.args) == 2:\n970:             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n971:                 (self._print(expr.args[0]), self._print(expr.args[1]))\n972:         else:\n973:             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n974:         if exp is not None:\n975:             return r\"E^{%s}%s\" % (exp, tex)\n976:         else:\n977:             return r\"E%s\" % tex\n978: \n979:     def _print_elliptic_pi(self, expr, exp=None):\n980:         if len(expr.args) == 3:\n981:             tex = r\"\\left(%s; %s\\middle| %s\\right)\" % \\\n982:                 (self._print(expr.args[0]), self._print(expr.args[1]), \\\n983:                  self._print(expr.args[2]))\n984:         else:\n985:             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n986:                 (self._print(expr.args[0]), self._print(expr.args[1]))\n987:         if exp is not None:\n988:             return r\"\\Pi^{%s}%s\" % (exp, tex)\n989:         else:\n990:             return r\"\\Pi%s\" % tex\n991: \n992:     def _print_beta(self, expr, exp=None):\n993:         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n994:                                         self._print(expr.args[1]))\n995: \n996:         if exp is not None:\n997:             return r\"\\operatorname{B}^{%s}%s\" % (exp, tex)\n998:         else:\n999:             return r\"\\operatorname{B}%s\" % tex\n1000: \n1001:     def _print_gamma(self, expr, exp=None):\n1002:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1003: \n1004:         if exp is not None:\n1005:             return r\"\\Gamma^{%s}%s\" % (exp, tex)\n1006:         else:\n1007:             return r\"\\Gamma%s\" % tex\n1008: \n1009:     def _print_uppergamma(self, expr, exp=None):\n1010:         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1011:                                         self._print(expr.args[1]))\n1012: \n1013:         if exp is not None:\n1014:             return r\"\\Gamma^{%s}%s\" % (exp, tex)\n1015:         else:\n1016:             return r\"\\Gamma%s\" % tex\n1017: \n1018:     def _print_lowergamma(self, expr, exp=None):\n1019:         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1020:                                         self._print(expr.args[1]))\n1021: \n1022:         if exp is not None:\n1023:             return r\"\\gamma^{%s}%s\" % (exp, tex)\n1024:         else:\n1025:             return r\"\\gamma%s\" % tex\n1026: \n1027:     def _print_Chi(self, expr, exp=None):\n1028:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1029: \n1030:         if exp is not None:\n1031:             return r\"\\operatorname{Chi}^{%s}%s\" % (exp, tex)\n1032:         else:\n1033:             return r\"\\operatorname{Chi}%s\" % tex\n1034: \n1035:     def _print_expint(self, expr, exp=None):\n1036:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[1])\n1037:         nu = self._print(expr.args[0])\n1038: \n1039:         if exp is not None:\n1040:             return r\"\\operatorname{E}_{%s}^{%s}%s\" % (nu, exp, tex)\n1041:         else:\n1042:             return r\"\\operatorname{E}_{%s}%s\" % (nu, tex)\n1043: \n1044:     def _print_fresnels(self, expr, exp=None):\n1045:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1046: \n1047:         if exp is not None:\n1048:             return r\"S^{%s}%s\" % (exp, tex)\n1049:         else:\n1050:             return r\"S%s\" % tex\n1051: \n1052:     def _print_fresnelc(self, expr, exp=None):\n1053:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1054: \n1055:         if exp is not None:\n1056:             return r\"C^{%s}%s\" % (exp, tex)\n1057:         else:\n1058:             return r\"C%s\" % tex\n1059: \n1060:     def _print_subfactorial(self, expr, exp=None):\n1061:         tex = r\"!%s\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1062: \n1063:         if exp is not None:\n1064:             return r\"%s^{%s}\" % (tex, exp)\n1065:         else:\n1066:             return tex\n1067: \n1068:     def _print_factorial(self, expr, exp=None):\n1069:         tex = r\"%s!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1070: \n1071:         if exp is not None:\n1072:             return r\"%s^{%s}\" % (tex, exp)\n1073:         else:\n1074:             return tex\n1075: \n1076:     def _print_factorial2(self, expr, exp=None):\n1077:         tex = r\"%s!!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1078: \n1079:         if exp is not None:\n1080:             return r\"%s^{%s}\" % (tex, exp)\n1081:         else:\n1082:             return tex\n1083: \n1084:     def _print_binomial(self, expr, exp=None):\n1085:         tex = r\"{\\binom{%s}{%s}}\" % (self._print(expr.args[0]),\n1086:                                      self._print(expr.args[1]))\n1087: \n1088:         if exp is not None:\n1089:             return r\"%s^{%s}\" % (tex, exp)\n1090:         else:\n1091:             return tex\n1092: \n1093:     def _print_RisingFactorial(self, expr, exp=None):\n1094:         n, k = expr.args\n1095:         base = r\"%s\" % self.parenthesize(n, PRECEDENCE['Func'])\n1096: \n1097:         tex = r\"{%s}^{\\left(%s\\right)}\" % (base, self._print(k))\n1098: \n1099:         return self._do_exponent(tex, exp)\n1100: \n1101:     def _print_FallingFactorial(self, expr, exp=None):\n1102:         n, k = expr.args\n1103:         sub = r\"%s\" % self.parenthesize(k, PRECEDENCE['Func'])\n1104: \n1105:         tex = r\"{\\left(%s\\right)}_{%s}\" % (self._print(n), sub)\n1106: \n1107:         return self._do_exponent(tex, exp)\n1108: \n1109:     def _hprint_BesselBase(self, expr, exp, sym):\n1110:         tex = r\"%s\" % (sym)\n1111: \n1112:         need_exp = False\n1113:         if exp is not None:\n1114:             if tex.find('^') == -1:\n1115:                 tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1116:             else:\n1117:                 need_exp = True\n1118: \n1119:         tex = r\"%s_{%s}\\left(%s\\right)\" % (tex, self._print(expr.order),\n1120:                                            self._print(expr.argument))\n1121: \n1122:         if need_exp:\n1123:             tex = self._do_exponent(tex, exp)\n1124:         return tex\n1125: \n1126:     def _hprint_vec(self, vec):\n1127:         if len(vec) == 0:\n1128:             return \"\"\n1129:         s = \"\"\n1130:         for i in vec[:-1]:\n1131:             s += \"%s, \" % self._print(i)\n1132:         s += self._print(vec[-1])\n1133:         return s\n1134: \n1135:     def _print_besselj(self, expr, exp=None):\n1136:         return self._hprint_BesselBase(expr, exp, 'J')\n1137: \n1138:     def _print_besseli(self, expr, exp=None):\n1139:         return self._hprint_BesselBase(expr, exp, 'I')\n1140: \n1141:     def _print_besselk(self, expr, exp=None):\n1142:         return self._hprint_BesselBase(expr, exp, 'K')\n1143: \n1144:     def _print_bessely(self, expr, exp=None):\n1145:         return self._hprint_BesselBase(expr, exp, 'Y')\n1146: \n1147:     def _print_yn(self, expr, exp=None):\n1148:         return self._hprint_BesselBase(expr, exp, 'y')\n1149: \n1150:     def _print_jn(self, expr, exp=None):\n1151:         return self._hprint_BesselBase(expr, exp, 'j')\n1152: \n1153:     def _print_hankel1(self, expr, exp=None):\n1154:         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')\n1155: \n1156:     def _print_hankel2(self, expr, exp=None):\n1157:         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')\n1158: \n1159:     def _print_hn1(self, expr, exp=None):\n1160:         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')\n1161: \n1162:     def _print_hn2(self, expr, exp=None):\n1163:         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')\n1164: \n1165:     def _hprint_airy(self, expr, exp=None, notation=\"\"):\n1166:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1167: \n1168:         if exp is not None:\n1169:             return r\"%s^{%s}%s\" % (notation, exp, tex)\n1170:         else:\n1171:             return r\"%s%s\" % (notation, tex)\n1172: \n1173:     def _hprint_airy_prime(self, expr, exp=None, notation=\"\"):\n1174:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1175: \n1176:         if exp is not None:\n1177:             return r\"{%s^\\prime}^{%s}%s\" % (notation, exp, tex)\n1178:         else:\n1179:             return r\"%s^\\prime%s\" % (notation, tex)\n1180: \n1181:     def _print_airyai(self, expr, exp=None):\n1182:         return self._hprint_airy(expr, exp, 'Ai')\n1183: \n1184:     def _print_airybi(self, expr, exp=None):\n1185:         return self._hprint_airy(expr, exp, 'Bi')\n1186: \n1187:     def _print_airyaiprime(self, expr, exp=None):\n1188:         return self._hprint_airy_prime(expr, exp, 'Ai')\n1189: \n1190:     def _print_airybiprime(self, expr, exp=None):\n1191:         return self._hprint_airy_prime(expr, exp, 'Bi')\n1192: \n1193:     def _print_hyper(self, expr, exp=None):\n1194:         tex = r\"{{}_{%s}F_{%s}\\left(\\begin{matrix} %s \\\\ %s \\end{matrix}\" \\\n1195:               r\"\\middle| {%s} \\right)}\" % \\\n1196:             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1197:               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),\n1198:               self._print(expr.argument))\n1199: \n1200:         if exp is not None:\n1201:             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1202:         return tex\n1203: \n1204:     def _print_meijerg(self, expr, exp=None):\n1205:         tex = r\"{G_{%s, %s}^{%s, %s}\\left(\\begin{matrix} %s & %s \\\\\" \\\n1206:               r\"%s & %s \\end{matrix} \\middle| {%s} \\right)}\" % \\\n1207:             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1208:               self._print(len(expr.bm)), self._print(len(expr.an)),\n1209:               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),\n1210:               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),\n1211:               self._print(expr.argument))\n1212: \n1213:         if exp is not None:\n1214:             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1215:         return tex\n1216: \n1217:     def _print_dirichlet_eta(self, expr, exp=None):\n1218:         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1219:         if exp is not None:\n1220:             return r\"\\eta^{%s}%s\" % (self._print(exp), tex)\n1221:         return r\"\\eta%s\" % tex\n1222: \n1223:     def _print_zeta(self, expr, exp=None):\n1224:         if len(expr.args) == 2:\n1225:             tex = r\"\\left(%s, %s\\right)\" % tuple(map(self._print, expr.args))\n1226:         else:\n1227:             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1228:         if exp is not None:\n1229:             return r\"\\zeta^{%s}%s\" % (self._print(exp), tex)\n1230:         return r\"\\zeta%s\" % tex\n1231: \n1232:     def _print_lerchphi(self, expr, exp=None):\n1233:         tex = r\"\\left(%s, %s, %s\\right)\" % tuple(map(self._print, expr.args))\n1234:         if exp is None:\n1235:             return r\"\\Phi%s\" % tex\n1236:         return r\"\\Phi^{%s}%s\" % (self._print(exp), tex)\n1237: \n1238:     def _print_polylog(self, expr, exp=None):\n1239:         s, z = map(self._print, expr.args)\n1240:         tex = r\"\\left(%s\\right)\" % z\n1241:         if exp is None:\n1242:             return r\"\\operatorname{Li}_{%s}%s\" % (s, tex)\n1243:         return r\"\\operatorname{Li}_{%s}^{%s}%s\" % (s, self._print(exp), tex)\n1244: \n1245:     def _print_jacobi(self, expr, exp=None):\n1246:         n, a, b, x = map(self._print, expr.args)\n1247:         tex = r\"P_{%s}^{\\left(%s,%s\\right)}\\left(%s\\right)\" % (n, a, b, x)\n1248:         if exp is not None:\n1249:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1250:         return tex\n1251: \n1252:     def _print_gegenbauer(self, expr, exp=None):\n1253:         n, a, x = map(self._print, expr.args)\n1254:         tex = r\"C_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1255:         if exp is not None:\n1256:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1257:         return tex\n1258: \n1259:     def _print_chebyshevt(self, expr, exp=None):\n1260:         n, x = map(self._print, expr.args)\n1261:         tex = r\"T_{%s}\\left(%s\\right)\" % (n, x)\n1262:         if exp is not None:\n1263:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1264:         return tex\n1265: \n1266:     def _print_chebyshevu(self, expr, exp=None):\n1267:         n, x = map(self._print, expr.args)\n1268:         tex = r\"U_{%s}\\left(%s\\right)\" % (n, x)\n1269:         if exp is not None:\n1270:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1271:         return tex\n1272: \n1273:     def _print_legendre(self, expr, exp=None):\n1274:         n, x = map(self._print, expr.args)\n1275:         tex = r\"P_{%s}\\left(%s\\right)\" % (n, x)\n1276:         if exp is not None:\n1277:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1278:         return tex\n1279: \n1280:     def _print_assoc_legendre(self, expr, exp=None):\n1281:         n, a, x = map(self._print, expr.args)\n1282:         tex = r\"P_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1283:         if exp is not None:\n1284:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1285:         return tex\n1286: \n1287:     def _print_hermite(self, expr, exp=None):\n1288:         n, x = map(self._print, expr.args)\n1289:         tex = r\"H_{%s}\\left(%s\\right)\" % (n, x)\n1290:         if exp is not None:\n1291:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1292:         return tex\n1293: \n1294:     def _print_laguerre(self, expr, exp=None):\n1295:         n, x = map(self._print, expr.args)\n1296:         tex = r\"L_{%s}\\left(%s\\right)\" % (n, x)\n1297:         if exp is not None:\n1298:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1299:         return tex\n1300: \n1301:     def _print_assoc_laguerre(self, expr, exp=None):\n1302:         n, a, x = map(self._print, expr.args)\n1303:         tex = r\"L_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1304:         if exp is not None:\n1305:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1306:         return tex\n1307: \n1308:     def _print_Ynm(self, expr, exp=None):\n1309:         n, m, theta, phi = map(self._print, expr.args)\n1310:         tex = r\"Y_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1311:         if exp is not None:\n1312:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1313:         return tex\n1314: \n1315:     def _print_Znm(self, expr, exp=None):\n1316:         n, m, theta, phi = map(self._print, expr.args)\n1317:         tex = r\"Z_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1318:         if exp is not None:\n1319:             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1320:         return tex\n1321: \n1322:     def _print_Rational(self, expr):\n1323:         if expr.q != 1:\n1324:             sign = \"\"\n1325:             p = expr.p\n1326:             if expr.p < 0:\n1327:                 sign = \"- \"\n1328:                 p = -p\n1329:             if self._settings['fold_short_frac']:\n1330:                 return r\"%s%d / %d\" % (sign, p, expr.q)\n1331:             return r\"%s\\frac{%d}{%d}\" % (sign, p, expr.q)\n1332:         else:\n1333:             return self._print(expr.p)\n1334: \n1335:     def _print_Order(self, expr):\n1336:         s = self._print(expr.expr)\n1337:         if expr.point and any(p != S.Zero for p in expr.point) or \\\n1338:            len(expr.variables) > 1:\n1339:             s += '; '\n1340:             if len(expr.variables) > 1:\n1341:                 s += self._print(expr.variables)\n1342:             elif len(expr.variables):\n1343:                 s += self._print(expr.variables[0])\n1344:             s += r'\\rightarrow '\n1345:             if len(expr.point) > 1:\n1346:                 s += self._print(expr.point)\n1347:             else:\n1348:                 s += self._print(expr.point[0])\n1349:         return r\"O\\left(%s\\right)\" % s\n1350: \n1351:     def _print_Symbol(self, expr):\n1352:         if expr in self._settings['symbol_names']:\n1353:             return self._settings['symbol_names'][expr]\n1354: \n1355:         return self._deal_with_super_sub(expr.name) if \\\n1356:             '\\\\' not in expr.name else expr.name\n1357: \n1358:     _print_RandomSymbol = _print_Symbol\n1359:     _print_MatrixSymbol = _print_Symbol\n1360: \n1361:     def _deal_with_super_sub(self, string):\n1362:         if '{' in string:\n1363:             return string\n1364: \n1365:         name, supers, subs = split_super_sub(string)\n1366: \n1367:         name = translate(name)\n1368:         supers = [translate(sup) for sup in supers]\n1369:         subs = [translate(sub) for sub in subs]\n1370: \n1371:         # glue all items together:\n1372:         if len(supers) > 0:\n1373:             name += \"^{%s}\" % \" \".join(supers)\n1374:         if len(subs) > 0:\n1375:             name += \"_{%s}\" % \" \".join(subs)\n1376: \n1377:         return name\n1378: \n1379:     def _print_Relational(self, expr):\n1380:         if self._settings['itex']:\n1381:             gt = r\"\\gt\"\n1382:             lt = r\"\\lt\"\n1383:         else:\n1384:             gt = \">\"\n1385:             lt = \"<\"\n1386: \n1387:         charmap = {\n1388:             \"==\": \"=\",\n1389:             \">\": gt,\n1390:             \"<\": lt,\n1391:             \">=\": r\"\\geq\",\n1392:             \"<=\": r\"\\leq\",\n1393:             \"!=\": r\"\\neq\",\n1394:         }\n1395: \n1396:         return \"%s %s %s\" % (self._print(expr.lhs),\n1397:             charmap[expr.rel_op], self._print(expr.rhs))\n1398: \n1399:     def _print_Piecewise(self, expr):\n1400:         ecpairs = [r\"%s & \\text{for}\\: %s\" % (self._print(e), self._print(c))\n1401:                    for e, c in expr.args[:-1]]\n1402:         if expr.args[-1].cond == true:\n1403:             ecpairs.append(r\"%s & \\text{otherwise}\" %\n1404:                            self._print(expr.args[-1].expr))\n1405:         else:\n1406:             ecpairs.append(r\"%s & \\text{for}\\: %s\" %\n1407:                            (self._print(expr.args[-1].expr),\n1408:                             self._print(expr.args[-1].cond)))\n1409:         tex = r\"\\begin{cases} %s \\end{cases}\"\n1410:         return tex % r\" \\\\\".join(ecpairs)\n1411: \n1412:     def _print_MatrixBase(self, expr):\n1413:         lines = []\n1414: \n1415:         for line in range(expr.rows):  # horrible, should be 'rows'\n1416:             lines.append(\" & \".join([ self._print(i) for i in expr[line, :] ]))\n1417: \n1418:         mat_str = self._settings['mat_str']\n1419:         if mat_str is None:\n1420:             if self._settings['mode'] == 'inline':\n1421:                 mat_str = 'smallmatrix'\n1422:             else:\n1423:                 if (expr.cols <= 10) is True:\n1424:                     mat_str = 'matrix'\n1425:                 else:\n1426:                     mat_str = 'array'\n1427: \n1428:         out_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1429:         out_str = out_str.replace('%MATSTR%', mat_str)\n1430:         if mat_str == 'array':\n1431:             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')\n1432:         if self._settings['mat_delim']:\n1433:             left_delim = self._settings['mat_delim']\n1434:             right_delim = self._delim_dict[left_delim]\n1435:             out_str = r'\\left' + left_delim + out_str + \\\n1436:                       r'\\right' + right_delim\n1437:         return out_str % r\"\\\\\".join(lines)\n1438:     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \\\n1439:                            = _print_Matrix \\\n1440:                            = _print_MatrixBase\n1441: \n1442:     def _print_MatrixElement(self, expr):\n1443:         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n1444:             + '_{%s, %s}' % (expr.i, expr.j)\n1445: \n1446:     def _print_MatrixSlice(self, expr):\n1447:         def latexslice(x):\n1448:             x = list(x)\n1449:             if x[2] == 1:\n1450:                 del x[2]\n1451:             if x[1] == x[0] + 1:\n1452:                 del x[1]\n1453:             if x[0] == 0:\n1454:                 x[0] = ''\n1455:             return ':'.join(map(self._print, x))\n1456:         return (self._print(expr.parent) + r'\\left[' +\n1457:                 latexslice(expr.rowslice) + ', ' +\n1458:                 latexslice(expr.colslice) + r'\\right]')\n1459: \n1460:     def _print_BlockMatrix(self, expr):\n1461:         return self._print(expr.blocks)\n1462: \n1463:     def _print_Transpose(self, expr):\n1464:         mat = expr.arg\n1465:         from sympy.matrices import MatrixSymbol\n1466:         if not isinstance(mat, MatrixSymbol):\n1467:             return r\"\\left(%s\\right)^T\" % self._print(mat)\n1468:         else:\n1469:             return \"%s^T\" % self._print(mat)\n1470: \n1471:     def _print_Adjoint(self, expr):\n1472:         mat = expr.arg\n1473:         from sympy.matrices import MatrixSymbol\n1474:         if not isinstance(mat, MatrixSymbol):\n1475:             return r\"\\left(%s\\right)^\\dagger\" % self._print(mat)\n1476:         else:\n1477:             return r\"%s^\\dagger\" % self._print(mat)\n1478: \n1479:     def _print_MatAdd(self, expr):\n1480:         terms = list(expr.args)\n1481:         tex = \" + \".join(map(self._print, terms))\n1482:         return tex\n1483: \n1484:     def _print_MatMul(self, expr):\n1485:         from sympy import Add, MatAdd, HadamardProduct\n1486: \n1487:         def parens(x):\n1488:             if isinstance(x, (Add, MatAdd, HadamardProduct)):\n1489:                 return r\"\\left(%s\\right)\" % self._print(x)\n1490:             return self._print(x)\n1491:         return ' '.join(map(parens, expr.args))\n1492: \n... Code Truncated ...\n\n[start of sympy/printing/pretty/pretty.py]\n1: from __future__ import print_function, division\n2: \n3: import itertools\n4: \n5: from sympy.core import S\n6: from sympy.core.containers import Tuple\n7: from sympy.core.function import _coeff_isneg\n8: from sympy.core.mod import Mod\n9: from sympy.core.mul import Mul\n10: from sympy.core.numbers import Rational\n11: from sympy.core.power import Pow\n12: from sympy.core.relational import Equality\n13: from sympy.core.symbol import Symbol\n14: from sympy.printing.precedence import PRECEDENCE, precedence, precedence_traditional\n15: from sympy.utilities import group\n16: from sympy.utilities.iterables import has_variety\n17: from sympy.core.sympify import SympifyError\n18: from sympy.core.compatibility import range\n19: from sympy.core.add import Add\n20: \n21: from sympy.printing.printer import Printer\n22: from sympy.printing.str import sstr\n23: from sympy.printing.conventions import requires_partial\n24: \n25: from .stringpict import prettyForm, stringPict\n26: from .pretty_symbology import xstr, hobj, vobj, xobj, xsym, pretty_symbol, \\\n27:     pretty_atom, pretty_use_unicode, pretty_try_use_unicode, greek_unicode, U, \\\n28:     annotated\n29: \n30: from sympy.utilities import default_sort_key\n31: \n32: # rename for usage from outside\n33: pprint_use_unicode = pretty_use_unicode\n34: pprint_try_use_unicode = pretty_try_use_unicode\n35: \n36: \n37: class PrettyPrinter(Printer):\n38:     \"\"\"Printer, which converts an expression into 2D ASCII-art figure.\"\"\"\n39:     printmethod = \"_pretty\"\n40: \n41:     _default_settings = {\n42:         \"order\": None,\n43:         \"full_prec\": \"auto\",\n44:         \"use_unicode\": None,\n45:         \"wrap_line\": True,\n46:         \"num_columns\": None,\n47:         \"use_unicode_sqrt_char\": True,\n48:     }\n49: \n50:     def __init__(self, settings=None):\n51:         Printer.__init__(self, settings)\n52:         self.emptyPrinter = lambda x: prettyForm(xstr(x))\n53: \n54:     @property\n55:     def _use_unicode(self):\n56:         if self._settings['use_unicode']:\n57:             return True\n58:         else:\n59:             return pretty_use_unicode()\n60: \n61:     def doprint(self, expr):\n62:         return self._print(expr).render(**self._settings)\n63: \n64:     # empty op so _print(stringPict) returns the same\n65:     def _print_stringPict(self, e):\n66:         return e\n67: \n68:     def _print_basestring(self, e):\n69:         return prettyForm(e)\n70: \n71:     def _print_atan2(self, e):\n72:         pform = prettyForm(*self._print_seq(e.args).parens())\n73:         pform = prettyForm(*pform.left('atan2'))\n74:         return pform\n75: \n76:     def _print_Symbol(self, e):\n77:         symb = pretty_symbol(e.name)\n78:         return prettyForm(symb)\n79:     _print_RandomSymbol = _print_Symbol\n80: \n81:     def _print_Float(self, e):\n82:         # we will use StrPrinter's Float printer, but we need to handle the\n83:         # full_prec ourselves, according to the self._print_level\n84:         full_prec = self._settings[\"full_prec\"]\n85:         if full_prec == \"auto\":\n86:             full_prec = self._print_level == 1\n87:         return prettyForm(sstr(e, full_prec=full_prec))\n88: \n89:     def _print_Cross(self, e):\n90:         vec1 = e._expr1\n91:         vec2 = e._expr2\n92:         pform = self._print(vec2)\n93:         pform = prettyForm(*pform.left('('))\n94:         pform = prettyForm(*pform.right(')'))\n95:         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))\n96:         pform = prettyForm(*pform.left(')'))\n97:         pform = prettyForm(*pform.left(self._print(vec1)))\n98:         pform = prettyForm(*pform.left('('))\n99:         return pform\n100: \n101:     def _print_Curl(self, e):\n102:         vec = e._expr\n103:         pform = self._print(vec)\n104:         pform = prettyForm(*pform.left('('))\n105:         pform = prettyForm(*pform.right(')'))\n106:         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))\n107:         pform = prettyForm(*pform.left(self._print(U('NABLA'))))\n108:         return pform\n109: \n110:     def _print_Divergence(self, e):\n111:         vec = e._expr\n112:         pform = self._print(vec)\n113:         pform = prettyForm(*pform.left('('))\n114:         pform = prettyForm(*pform.right(')'))\n115:         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))\n116:         pform = prettyForm(*pform.left(self._print(U('NABLA'))))\n117:         return pform\n118: \n119:     def _print_Dot(self, e):\n120:         vec1 = e._expr1\n121:         vec2 = e._expr2\n122:         pform = self._print(vec2)\n123:         pform = prettyForm(*pform.left('('))\n124:         pform = prettyForm(*pform.right(')'))\n125:         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))\n126:         pform = prettyForm(*pform.left(')'))\n127:         pform = prettyForm(*pform.left(self._print(vec1)))\n128:         pform = prettyForm(*pform.left('('))\n129:         return pform\n130: \n131:     def _print_Gradient(self, e):\n132:         func = e._expr\n133:         pform = self._print(func)\n134:         pform = prettyForm(*pform.left('('))\n135:         pform = prettyForm(*pform.right(')'))\n136:         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))\n137:         pform = prettyForm(*pform.left(self._print(U('NABLA'))))\n138:         return pform\n139: \n140:     def _print_Atom(self, e):\n141:         try:\n142:             # print atoms like Exp1 or Pi\n143:             return prettyForm(pretty_atom(e.__class__.__name__))\n144:         except KeyError:\n145:             return self.emptyPrinter(e)\n146: \n147:     # Infinity inherits from Number, so we have to override _print_XXX order\n148:     _print_Infinity = _print_Atom\n149:     _print_NegativeInfinity = _print_Atom\n150:     _print_EmptySet = _print_Atom\n151:     _print_Naturals = _print_Atom\n152:     _print_Naturals0 = _print_Atom\n153:     _print_Integers = _print_Atom\n154:     _print_Complexes = _print_Atom\n155: \n156:     def _print_Reals(self, e):\n157:         if self._use_unicode:\n158:             return self._print_Atom(e)\n159:         else:\n160:             inf_list = ['-oo', 'oo']\n161:             return self._print_seq(inf_list, '(', ')')\n162: \n163:     def _print_subfactorial(self, e):\n164:         x = e.args[0]\n165:         pform = self._print(x)\n166:         # Add parentheses if needed\n167:         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):\n168:             pform = prettyForm(*pform.parens())\n169:         pform = prettyForm(*pform.left('!'))\n170:         return pform\n171: \n172:     def _print_factorial(self, e):\n173:         x = e.args[0]\n174:         pform = self._print(x)\n175:         # Add parentheses if needed\n176:         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):\n177:             pform = prettyForm(*pform.parens())\n178:         pform = prettyForm(*pform.right('!'))\n179:         return pform\n180: \n181:     def _print_factorial2(self, e):\n182:         x = e.args[0]\n183:         pform = self._print(x)\n184:         # Add parentheses if needed\n185:         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):\n186:             pform = prettyForm(*pform.parens())\n187:         pform = prettyForm(*pform.right('!!'))\n188:         return pform\n189: \n190:     def _print_binomial(self, e):\n191:         n, k = e.args\n192: \n193:         n_pform = self._print(n)\n194:         k_pform = self._print(k)\n195: \n196:         bar = ' '*max(n_pform.width(), k_pform.width())\n197: \n198:         pform = prettyForm(*k_pform.above(bar))\n199:         pform = prettyForm(*pform.above(n_pform))\n200:         pform = prettyForm(*pform.parens('(', ')'))\n201: \n202:         pform.baseline = (pform.baseline + 1)//2\n203: \n204:         return pform\n205: \n206:     def _print_Relational(self, e):\n207:         op = prettyForm(' ' + xsym(e.rel_op) + ' ')\n208: \n209:         l = self._print(e.lhs)\n210:         r = self._print(e.rhs)\n211:         pform = prettyForm(*stringPict.next(l, op, r))\n212:         return pform\n213: \n214:     def _print_Not(self, e):\n215:         from sympy import Equivalent, Implies\n216:         if self._use_unicode:\n217:             arg = e.args[0]\n218:             pform = self._print(arg)\n219:             if isinstance(arg, Equivalent):\n220:                 return self._print_Equivalent(arg, altchar=u\"\\N{LEFT RIGHT DOUBLE ARROW WITH STROKE}\")\n221:             if isinstance(arg, Implies):\n222:                 return self._print_Implies(arg, altchar=u\"\\N{RIGHTWARDS ARROW WITH STROKE}\")\n223: \n224:             if arg.is_Boolean and not arg.is_Not:\n225:                 pform = prettyForm(*pform.parens())\n226: \n227:             return prettyForm(*pform.left(u\"\\N{NOT SIGN}\"))\n228:         else:\n229:             return self._print_Function(e)\n230: \n231:     def __print_Boolean(self, e, char, sort=True):\n232:         args = e.args\n233:         if sort:\n234:             args = sorted(e.args, key=default_sort_key)\n235:         arg = args[0]\n236:         pform = self._print(arg)\n237: \n238:         if arg.is_Boolean and not arg.is_Not:\n239:             pform = prettyForm(*pform.parens())\n240: \n241:         for arg in args[1:]:\n242:             pform_arg = self._print(arg)\n243: \n244:             if arg.is_Boolean and not arg.is_Not:\n245:                 pform_arg = prettyForm(*pform_arg.parens())\n246: \n247:             pform = prettyForm(*pform.right(u' %s ' % char))\n248:             pform = prettyForm(*pform.right(pform_arg))\n249: \n250:         return pform\n251: \n252:     def _print_And(self, e):\n253:         if self._use_unicode:\n254:             return self.__print_Boolean(e, u\"\\N{LOGICAL AND}\")\n255:         else:\n256:             return self._print_Function(e, sort=True)\n257: \n258:     def _print_Or(self, e):\n259:         if self._use_unicode:\n260:             return self.__print_Boolean(e, u\"\\N{LOGICAL OR}\")\n261:         else:\n262:             return self._print_Function(e, sort=True)\n263: \n264:     def _print_Xor(self, e):\n265:         if self._use_unicode:\n266:             return self.__print_Boolean(e, u\"\\N{XOR}\")\n267:         else:\n268:             return self._print_Function(e, sort=True)\n269: \n270:     def _print_Nand(self, e):\n271:         if self._use_unicode:\n272:             return self.__print_Boolean(e, u\"\\N{NAND}\")\n273:         else:\n274:             return self._print_Function(e, sort=True)\n275: \n276:     def _print_Nor(self, e):\n277:         if self._use_unicode:\n278:             return self.__print_Boolean(e, u\"\\N{NOR}\")\n279:         else:\n280:             return self._print_Function(e, sort=True)\n281: \n282:     def _print_Implies(self, e, altchar=None):\n283:         if self._use_unicode:\n284:             return self.__print_Boolean(e, altchar or u\"\\N{RIGHTWARDS ARROW}\", sort=False)\n285:         else:\n286:             return self._print_Function(e)\n287: \n288:     def _print_Equivalent(self, e, altchar=None):\n289:         if self._use_unicode:\n290:             return self.__print_Boolean(e, altchar or u\"\\N{LEFT RIGHT DOUBLE ARROW}\")\n291:         else:\n292:             return self._print_Function(e, sort=True)\n293: \n294:     def _print_conjugate(self, e):\n295:         pform = self._print(e.args[0])\n296:         return prettyForm( *pform.above( hobj('_', pform.width())) )\n297: \n298:     def _print_Abs(self, e):\n299:         pform = self._print(e.args[0])\n300:         pform = prettyForm(*pform.parens('|', '|'))\n301:         return pform\n302:     _print_Determinant = _print_Abs\n303: \n304:     def _print_floor(self, e):\n305:         if self._use_unicode:\n306:             pform = self._print(e.args[0])\n307:             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))\n308:             return pform\n309:         else:\n310:             return self._print_Function(e)\n311: \n312:     def _print_ceiling(self, e):\n313:         if self._use_unicode:\n314:             pform = self._print(e.args[0])\n315:             pform = prettyForm(*pform.parens('lceil', 'rceil'))\n316:             return pform\n317:         else:\n318:             return self._print_Function(e)\n319: \n320:     def _print_Derivative(self, deriv):\n321:         if requires_partial(deriv) and self._use_unicode:\n322:             deriv_symbol = U('PARTIAL DIFFERENTIAL')\n323:         else:\n324:             deriv_symbol = r'd'\n325:         x = None\n326:         count_total_deriv = 0\n327: \n328:         for sym, num in reversed(deriv.variable_count):\n329:             s = self._print(sym)\n330:             ds = prettyForm(*s.left(deriv_symbol))\n331:             count_total_deriv += num\n332: \n333:             if (not num.is_Integer) or (num > 1):\n334:                 ds = ds**prettyForm(str(num))\n335: \n336:             if x is None:\n337:                 x = ds\n338:             else:\n339:                 x = prettyForm(*x.right(' '))\n340:                 x = prettyForm(*x.right(ds))\n341: \n342:         f = prettyForm(\n343:             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())\n344: \n345:         pform = prettyForm(deriv_symbol)\n346: \n347:         if (count_total_deriv > 1) != False:\n348:             pform = pform**prettyForm(str(count_total_deriv))\n349: \n350:         pform = prettyForm(*pform.below(stringPict.LINE, x))\n351:         pform.baseline = pform.baseline + 1\n352:         pform = prettyForm(*stringPict.next(pform, f))\n353:         pform.binding = prettyForm.MUL\n354: \n355:         return pform\n356: \n357:     def _print_Cycle(self, dc):\n358:         from sympy.combinatorics.permutations import Permutation, Cycle\n359:         # for Empty Cycle\n360:         if dc == Cycle():\n361:             cyc = stringPict('')\n362:             return prettyForm(*cyc.parens())\n363: \n364:         dc_list = Permutation(dc.list()).cyclic_form\n365:         # for Identity Cycle\n366:         if dc_list == []:\n367:             cyc = self._print(dc.size - 1)\n368:             return prettyForm(*cyc.parens())\n369: \n370:         cyc = stringPict('')\n371:         for i in dc_list:\n372:             l = self._print(str(tuple(i)).replace(',', ''))\n373:             cyc = prettyForm(*cyc.right(l))\n374:         return cyc\n375: \n376:     def _print_PDF(self, pdf):\n377:         lim = self._print(pdf.pdf.args[0])\n378:         lim = prettyForm(*lim.right(', '))\n379:         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))\n380:         lim = prettyForm(*lim.right(', '))\n381:         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))\n382:         lim = prettyForm(*lim.parens())\n383: \n384:         f = self._print(pdf.pdf.args[1])\n385:         f = prettyForm(*f.right(', '))\n386:         f = prettyForm(*f.right(lim))\n387:         f = prettyForm(*f.parens())\n388: \n389:         pform = prettyForm('PDF')\n390:         pform = prettyForm(*pform.right(f))\n391:         return pform\n392: \n393:     def _print_Integral(self, integral):\n394:         f = integral.function\n395: \n396:         # Add parentheses if arg involves addition of terms and\n397:         # create a pretty form for the argument\n398:         prettyF = self._print(f)\n399:         # XXX generalize parens\n400:         if f.is_Add:\n401:             prettyF = prettyForm(*prettyF.parens())\n402: \n403:         # dx dy dz ...\n404:         arg = prettyF\n405:         for x in integral.limits:\n406:             prettyArg = self._print(x[0])\n407:             # XXX qparens (parens if needs-parens)\n408:             if prettyArg.width() > 1:\n409:                 prettyArg = prettyForm(*prettyArg.parens())\n410: \n411:             arg = prettyForm(*arg.right(' d', prettyArg))\n412: \n413:         # \\int \\int \\int ...\n414:         firstterm = True\n415:         s = None\n416:         for lim in integral.limits:\n417:             x = lim[0]\n418:             # Create bar based on the height of the argument\n419:             h = arg.height()\n420:             H = h + 2\n421: \n422:             # XXX hack!\n423:             ascii_mode = not self._use_unicode\n424:             if ascii_mode:\n425:                 H += 2\n426: \n427:             vint = vobj('int', H)\n428: \n429:             # Construct the pretty form with the integral sign and the argument\n430:             pform = prettyForm(vint)\n431:             pform.baseline = arg.baseline + (\n432:                 H - h)//2    # covering the whole argument\n433: \n434:             if len(lim) > 1:\n435:                 # Create pretty forms for endpoints, if definite integral.\n436:                 # Do not print empty endpoints.\n437:                 if len(lim) == 2:\n438:                     prettyA = prettyForm(\"\")\n439:                     prettyB = self._print(lim[1])\n440:                 if len(lim) == 3:\n441:                     prettyA = self._print(lim[1])\n442:                     prettyB = self._print(lim[2])\n443: \n444:                 if ascii_mode:  # XXX hack\n445:                     # Add spacing so that endpoint can more easily be\n446:                     # identified with the correct integral sign\n447:                     spc = max(1, 3 - prettyB.width())\n448:                     prettyB = prettyForm(*prettyB.left(' ' * spc))\n449: \n450:                     spc = max(1, 4 - prettyA.width())\n451:                     prettyA = prettyForm(*prettyA.right(' ' * spc))\n452: \n453:                 pform = prettyForm(*pform.above(prettyB))\n454:                 pform = prettyForm(*pform.below(prettyA))\n455: \n456:             if not ascii_mode:  # XXX hack\n457:                 pform = prettyForm(*pform.right(' '))\n458: \n459:             if firstterm:\n460:                 s = pform   # first term\n461:                 firstterm = False\n462:             else:\n463:                 s = prettyForm(*s.left(pform))\n464: \n465:         pform = prettyForm(*arg.left(s))\n466:         pform.binding = prettyForm.MUL\n467:         return pform\n468: \n469:     def _print_Product(self, expr):\n470:         func = expr.term\n471:         pretty_func = self._print(func)\n472: \n473:         horizontal_chr = xobj('_', 1)\n474:         corner_chr = xobj('_', 1)\n475:         vertical_chr = xobj('|', 1)\n476: \n477:         if self._use_unicode:\n478:             # use unicode corners\n479:             horizontal_chr = xobj('-', 1)\n480:             corner_chr = u'\\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'\n481: \n482:         func_height = pretty_func.height()\n483: \n484:         first = True\n485:         max_upper = 0\n486:         sign_height = 0\n487: \n488:         for lim in expr.limits:\n489:             width = (func_height + 2) * 5 // 3 - 2\n490:             sign_lines = []\n491:             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)\n492:             for i in range(func_height + 1):\n493:                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)\n494: \n495:             pretty_sign = stringPict('')\n496:             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))\n497: \n498:             pretty_upper = self._print(lim[2])\n499:             pretty_lower = self._print(Equality(lim[0], lim[1]))\n500: \n501:             max_upper = max(max_upper, pretty_upper.height())\n502: \n503:             if first:\n504:                 sign_height = pretty_sign.height()\n505: \n506:             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))\n507:             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))\n508: \n509:             if first:\n510:                 pretty_func.baseline = 0\n511:                 first = False\n512: \n513:             height = pretty_sign.height()\n514:             padding = stringPict('')\n515:             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))\n516:             pretty_sign = prettyForm(*pretty_sign.right(padding))\n517: \n518:             pretty_func = prettyForm(*pretty_sign.right(pretty_func))\n519: \n520:         pretty_func.baseline = max_upper + sign_height//2\n521:         pretty_func.binding = prettyForm.MUL\n522:         return pretty_func\n523: \n524:     def _print_Sum(self, expr):\n525:         ascii_mode = not self._use_unicode\n526: \n527:         def asum(hrequired, lower, upper, use_ascii):\n528:             def adjust(s, wid=None, how='<^>'):\n529:                 if not wid or len(s) > wid:\n530:                     return s\n531:                 need = wid - len(s)\n532:                 if how == '<^>' or how == \"<\" or how not in list('<^>'):\n533:                     return s + ' '*need\n534:                 half = need//2\n535:                 lead = ' '*half\n536:                 if how == \">\":\n537:                     return \" \"*need + s\n538:                 return lead + s + ' '*(need - len(lead))\n539: \n540:             h = max(hrequired, 2)\n541:             d = h//2\n542:             w = d + 1\n543:             more = hrequired % 2\n544: \n545:             lines = []\n546:             if use_ascii:\n547:                 lines.append(\"_\"*(w) + ' ')\n548:                 lines.append(r\"\\%s`\" % (' '*(w - 1)))\n549:                 for i in range(1, d):\n550:                     lines.append('%s\\\\%s' % (' '*i, ' '*(w - i)))\n551:                 if more:\n552:                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))\n553:                 for i in reversed(range(1, d)):\n554:                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))\n555:                 lines.append(\"/\" + \"_\"*(w - 1) + ',')\n556:                 return d, h + more, lines, 0\n557:             else:\n558:                 w = w + more\n559:                 d = d + more\n560:                 vsum = vobj('sum', 4)\n561:                 lines.append(\"_\"*(w))\n562:                 for i in range(0, d):\n563:                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))\n564:                 for i in reversed(range(0, d)):\n565:                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))\n566:                 lines.append(vsum[8]*(w))\n567:                 return d, h + 2*more, lines, more\n568: \n569:         f = expr.function\n570: \n571:         prettyF = self._print(f)\n572: \n573:         if f.is_Add:  # add parens\n574:             prettyF = prettyForm(*prettyF.parens())\n575: \n576:         H = prettyF.height() + 2\n577: \n578:         # \\sum \\sum \\sum ...\n579:         first = True\n580:         max_upper = 0\n581:         sign_height = 0\n582: \n583:         for lim in expr.limits:\n584:             if len(lim) == 3:\n585:                 prettyUpper = self._print(lim[2])\n586:                 prettyLower = self._print(Equality(lim[0], lim[1]))\n587:             elif len(lim) == 2:\n588:                 prettyUpper = self._print(\"\")\n589:                 prettyLower = self._print(Equality(lim[0], lim[1]))\n590:             elif len(lim) == 1:\n591:                 prettyUpper = self._print(\"\")\n592:                 prettyLower = self._print(lim[0])\n593: \n594:             max_upper = max(max_upper, prettyUpper.height())\n595: \n596:             # Create sum sign based on the height of the argument\n597:             d, h, slines, adjustment = asum(\n598:                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)\n599:             prettySign = stringPict('')\n600:             prettySign = prettyForm(*prettySign.stack(*slines))\n601: \n602:             if first:\n603:                 sign_height = prettySign.height()\n604: \n605:             prettySign = prettyForm(*prettySign.above(prettyUpper))\n606:             prettySign = prettyForm(*prettySign.below(prettyLower))\n607: \n608:             if first:\n609:                 # change F baseline so it centers on the sign\n610:                 prettyF.baseline -= d - (prettyF.height()//2 -\n611:                                          prettyF.baseline) - adjustment\n612:                 first = False\n613: \n614:             # put padding to the right\n615:             pad = stringPict('')\n616:             pad = prettyForm(*pad.stack(*[' ']*h))\n617:             prettySign = prettyForm(*prettySign.right(pad))\n618:             # put the present prettyF to the right\n619:             prettyF = prettyForm(*prettySign.right(prettyF))\n620: \n621:         prettyF.baseline = max_upper + sign_height//2\n622:         prettyF.binding = prettyForm.MUL\n623:         return prettyF\n624: \n625:     def _print_Limit(self, l):\n626:         e, z, z0, dir = l.args\n627: \n628:         E = self._print(e)\n629:         if precedence(e) <= PRECEDENCE[\"Mul\"]:\n630:             E = prettyForm(*E.parens('(', ')'))\n631:         Lim = prettyForm('lim')\n632: \n633:         LimArg = self._print(z)\n634:         if self._use_unicode:\n635:             LimArg = prettyForm(*LimArg.right(u'\\N{BOX DRAWINGS LIGHT HORIZONTAL}\\N{RIGHTWARDS ARROW}'))\n636:         else:\n637:             LimArg = prettyForm(*LimArg.right('->'))\n638:         LimArg = prettyForm(*LimArg.right(self._print(z0)))\n639: \n640:         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n641:             dir = \"\"\n642:         else:\n643:             if self._use_unicode:\n644:                 dir = u'\\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == \"+\" else u'\\N{SUPERSCRIPT MINUS}'\n645: \n646:         LimArg = prettyForm(*LimArg.right(self._print(dir)))\n647: \n648:         Lim = prettyForm(*Lim.below(LimArg))\n649:         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)\n650: \n651:         return Lim\n652: \n653:     def _print_matrix_contents(self, e):\n654:         \"\"\"\n655:         This method factors out what is essentially grid printing.\n656:         \"\"\"\n657:         M = e   # matrix\n658:         Ms = {}  # i,j -> pretty(M[i,j])\n659:         for i in range(M.rows):\n660:             for j in range(M.cols):\n661:                 Ms[i, j] = self._print(M[i, j])\n662: \n663:         # h- and v- spacers\n664:         hsep = 2\n665:         vsep = 1\n666: \n667:         # max width for columns\n668:         maxw = [-1] * M.cols\n669: \n670:         for j in range(M.cols):\n671:             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])\n672: \n673:         # drawing result\n674:         D = None\n675: \n676:         for i in range(M.rows):\n677: \n678:             D_row = None\n679:             for j in range(M.cols):\n680:                 s = Ms[i, j]\n681: \n682:                 # reshape s to maxw\n683:                 # XXX this should be generalized, and go to stringPict.reshape ?\n684:                 assert s.width() <= maxw[j]\n685: \n686:                 # hcenter it, +0.5 to the right                        2\n687:                 # ( it's better to align formula starts for say 0 and r )\n688:                 # XXX this is not good in all cases -- maybe introduce vbaseline?\n689:                 wdelta = maxw[j] - s.width()\n690:                 wleft = wdelta // 2\n691:                 wright = wdelta - wleft\n692: \n693:                 s = prettyForm(*s.right(' '*wright))\n694:                 s = prettyForm(*s.left(' '*wleft))\n695: \n696:                 # we don't need vcenter cells -- this is automatically done in\n697:                 # a pretty way because when their baselines are taking into\n698:                 # account in .right()\n699: \n700:                 if D_row is None:\n701:                     D_row = s   # first box in a row\n702:                     continue\n703: \n704:                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer\n705:                 D_row = prettyForm(*D_row.right(s))\n706: \n707:             if D is None:\n708:                 D = D_row       # first row in a picture\n709:                 continue\n710: \n711:             # v-spacer\n712:             for _ in range(vsep):\n713:                 D = prettyForm(*D.below(' '))\n714: \n715:             D = prettyForm(*D.below(D_row))\n716: \n717:         if D is None:\n718:             D = prettyForm('')  # Empty Matrix\n719: \n720:         return D\n721: \n722:     def _print_MatrixBase(self, e):\n723:         D = self._print_matrix_contents(e)\n724:         D.baseline = D.height()//2\n725:         D = prettyForm(*D.parens('[', ']'))\n726:         return D\n727:     _print_ImmutableMatrix = _print_MatrixBase\n728:     _print_Matrix = _print_MatrixBase\n729: \n730:     def _print_TensorProduct(self, expr):\n731:         # This should somehow share the code with _print_WedgeProduct:\n732:         circled_times = \"\\u2297\"\n733:         return self._print_seq(expr.args, None, None, circled_times,\n734:             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE[\"Mul\"])\n735: \n736:     def _print_WedgeProduct(self, expr):\n737:         # This should somehow share the code with _print_TensorProduct:\n738:         wedge_symbol = u\"\\u2227\"\n739:         return self._print_seq(expr.args, None, None, wedge_symbol,\n740:             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE[\"Mul\"])\n741: \n742:     def _print_Trace(self, e):\n743:         D = self._print(e.arg)\n744:         D = prettyForm(*D.parens('(',')'))\n745:         D.baseline = D.height()//2\n746:         D = prettyForm(*D.left('\\n'*(0) + 'tr'))\n747:         return D\n748: \n749: \n750:     def _print_MatrixElement(self, expr):\n751:         from sympy.matrices import MatrixSymbol\n752:         from sympy import Symbol\n753:         if (isinstance(expr.parent, MatrixSymbol)\n754:                 and expr.i.is_number and expr.j.is_number):\n755:             return self._print(\n756:                     Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))\n757:         else:\n758:             prettyFunc = self._print(expr.parent)\n759:             prettyFunc = prettyForm(*prettyFunc.parens())\n760:             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '\n761:                     ).parens(left='[', right=']')[0]\n762:             pform = prettyForm(binding=prettyForm.FUNC,\n763:                     *stringPict.next(prettyFunc, prettyIndices))\n764: \n765:             # store pform parts so it can be reassembled e.g. when powered\n766:             pform.prettyFunc = prettyFunc\n767:             pform.prettyArgs = prettyIndices\n768: \n769:             return pform\n770: \n771: \n772:     def _print_MatrixSlice(self, m):\n773:         # XXX works only for applied functions\n774:         prettyFunc = self._print(m.parent)\n775:         def ppslice(x):\n776:             x = list(x)\n777:             if x[2] == 1:\n778:                 del x[2]\n779:             if x[1] == x[0] + 1:\n780:                 del x[1]\n781:             if x[0] == 0:\n782:                 x[0] = ''\n783:             return prettyForm(*self._print_seq(x, delimiter=':'))\n784:         prettyArgs = self._print_seq((ppslice(m.rowslice),\n785:             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]\n786: \n787:         pform = prettyForm(\n788:             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))\n789: \n790:         # store pform parts so it can be reassembled e.g. when powered\n791:         pform.prettyFunc = prettyFunc\n792:         pform.prettyArgs = prettyArgs\n793: \n794:         return pform\n795: \n796:     def _print_Transpose(self, expr):\n797:         pform = self._print(expr.arg)\n798:         from sympy.matrices import MatrixSymbol\n799:         if not isinstance(expr.arg, MatrixSymbol):\n800:             pform = prettyForm(*pform.parens())\n801:         pform = pform**(prettyForm('T'))\n802:         return pform\n803: \n804:     def _print_Adjoint(self, expr):\n805:         pform = self._print(expr.arg)\n806:         if self._use_unicode:\n807:             dag = prettyForm(u'\\N{DAGGER}')\n808:         else:\n809:             dag = prettyForm('+')\n810:         from sympy.matrices import MatrixSymbol\n811:         if not isinstance(expr.arg, MatrixSymbol):\n812:             pform = prettyForm(*pform.parens())\n813:         pform = pform**dag\n814:         return pform\n815: \n816:     def _print_BlockMatrix(self, B):\n817:         if B.blocks.shape == (1, 1):\n818:             return self._print(B.blocks[0, 0])\n819:         return self._print(B.blocks)\n820: \n821:     def _print_MatAdd(self, expr):\n822:         return self._print_seq(expr.args, None, None, ' + ')\n823: \n... Code Truncated ...\n\n[start of sympy/printing/str.py]\n1: \"\"\"\n2: A Printer for generating readable representation of most sympy classes.\n3: \"\"\"\n4: \n5: from __future__ import print_function, division\n6: \n7: from sympy.core import S, Rational, Pow, Basic, Mul\n8: from sympy.core.mul import _keep_coeff\n9: from .printer import Printer\n10: from sympy.printing.precedence import precedence, PRECEDENCE\n11: \n12: import mpmath.libmp as mlib\n13: from mpmath.libmp import prec_to_dps\n14: \n15: from sympy.utilities import default_sort_key\n16: \n17: \n18: class StrPrinter(Printer):\n19:     printmethod = \"_sympystr\"\n20:     _default_settings = {\n21:         \"order\": None,\n22:         \"full_prec\": \"auto\",\n23:         \"sympy_integers\": False,\n24:         \"abbrev\": False,\n25:     }\n26: \n27:     _relationals = dict()\n28: \n29:     def parenthesize(self, item, level, strict=False):\n30:         if (precedence(item) < level) or ((not strict) and precedence(item) <= level):\n31:             return \"(%s)\" % self._print(item)\n32:         else:\n33:             return self._print(item)\n34: \n35:     def stringify(self, args, sep, level=0):\n36:         return sep.join([self.parenthesize(item, level) for item in args])\n37: \n38:     def emptyPrinter(self, expr):\n39:         if isinstance(expr, str):\n40:             return expr\n41:         elif isinstance(expr, Basic):\n42:             if hasattr(expr, \"args\"):\n43:                 return repr(expr)\n44:             else:\n45:                 raise\n46:         else:\n47:             return str(expr)\n48: \n49:     def _print_Add(self, expr, order=None):\n50:         if self.order == 'none':\n51:             terms = list(expr.args)\n52:         else:\n53:             terms = self._as_ordered_terms(expr, order=order)\n54: \n55:         PREC = precedence(expr)\n56:         l = []\n57:         for term in terms:\n58:             t = self._print(term)\n59:             if t.startswith('-'):\n60:                 sign = \"-\"\n61:                 t = t[1:]\n62:             else:\n63:                 sign = \"+\"\n64:             if precedence(term) < PREC:\n65:                 l.extend([sign, \"(%s)\" % t])\n66:             else:\n67:                 l.extend([sign, t])\n68:         sign = l.pop(0)\n69:         if sign == '+':\n70:             sign = \"\"\n71:         return sign + ' '.join(l)\n72: \n73:     def _print_BooleanTrue(self, expr):\n74:         return \"True\"\n75: \n76:     def _print_BooleanFalse(self, expr):\n77:         return \"False\"\n78: \n79:     def _print_Not(self, expr):\n80:         return '~%s' %(self.parenthesize(expr.args[0],PRECEDENCE[\"Not\"]))\n81: \n82:     def _print_And(self, expr):\n83:         return self.stringify(expr.args, \" & \", PRECEDENCE[\"BitwiseAnd\"])\n84: \n85:     def _print_Or(self, expr):\n86:         return self.stringify(expr.args, \" | \", PRECEDENCE[\"BitwiseOr\"])\n87: \n88:     def _print_AppliedPredicate(self, expr):\n89:         return '%s(%s)' % (expr.func, expr.arg)\n90: \n91:     def _print_Basic(self, expr):\n92:         l = [self._print(o) for o in expr.args]\n93:         return expr.__class__.__name__ + \"(%s)\" % \", \".join(l)\n94: \n95:     def _print_BlockMatrix(self, B):\n96:         if B.blocks.shape == (1, 1):\n97:             self._print(B.blocks[0, 0])\n98:         return self._print(B.blocks)\n99: \n100:     def _print_Catalan(self, expr):\n101:         return 'Catalan'\n102: \n103:     def _print_ComplexInfinity(self, expr):\n104:         return 'zoo'\n105: \n106:     def _print_Derivative(self, expr):\n107:         dexpr = expr.expr\n108:         dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]\n109:         return 'Derivative(%s)' % \", \".join(map(self._print, [dexpr] + dvars))\n110: \n111:     def _print_dict(self, d):\n112:         keys = sorted(d.keys(), key=default_sort_key)\n113:         items = []\n114: \n115:         for key in keys:\n116:             item = \"%s: %s\" % (self._print(key), self._print(d[key]))\n117:             items.append(item)\n118: \n119:         return \"{%s}\" % \", \".join(items)\n120: \n121:     def _print_Dict(self, expr):\n122:         return self._print_dict(expr)\n123: \n124: \n125:     def _print_RandomDomain(self, d):\n126:         if hasattr(d, 'as_boolean'):\n127:             return 'Domain: ' + self._print(d.as_boolean())\n128:         elif hasattr(d, 'set'):\n129:             return ('Domain: ' + self._print(d.symbols) + ' in ' +\n130:                     self._print(d.set))\n131:         else:\n132:             return 'Domain on ' + self._print(d.symbols)\n133: \n134:     def _print_Dummy(self, expr):\n135:         return '_' + expr.name\n136: \n137:     def _print_EulerGamma(self, expr):\n138:         return 'EulerGamma'\n139: \n140:     def _print_Exp1(self, expr):\n141:         return 'E'\n142: \n143:     def _print_ExprCondPair(self, expr):\n144:         return '(%s, %s)' % (expr.expr, expr.cond)\n145: \n146:     def _print_FiniteSet(self, s):\n147:         s = sorted(s, key=default_sort_key)\n148:         if len(s) > 10:\n149:             printset = s[:3] + ['...'] + s[-3:]\n150:         else:\n151:             printset = s\n152:         return '{' + ', '.join(self._print(el) for el in printset) + '}'\n153: \n154:     def _print_Function(self, expr):\n155:         return expr.func.__name__ + \"(%s)\" % self.stringify(expr.args, \", \")\n156: \n157:     def _print_GeometryEntity(self, expr):\n158:         # GeometryEntity is special -- it's base is tuple\n159:         return str(expr)\n160: \n161:     def _print_GoldenRatio(self, expr):\n162:         return 'GoldenRatio'\n163: \n164:     def _print_ImaginaryUnit(self, expr):\n165:         return 'I'\n166: \n167:     def _print_Infinity(self, expr):\n168:         return 'oo'\n169: \n170:     def _print_Integral(self, expr):\n171:         def _xab_tostr(xab):\n172:             if len(xab) == 1:\n173:                 return self._print(xab[0])\n174:             else:\n175:                 return self._print((xab[0],) + tuple(xab[1:]))\n176:         L = ', '.join([_xab_tostr(l) for l in expr.limits])\n177:         return 'Integral(%s, %s)' % (self._print(expr.function), L)\n178: \n179:     def _print_Interval(self, i):\n180:         fin =  'Interval{m}({a}, {b})'\n181:         a, b, l, r = i.args\n182:         if a.is_infinite and b.is_infinite:\n183:             m = ''\n184:         elif a.is_infinite and not r:\n185:             m = ''\n186:         elif b.is_infinite and not l:\n187:             m = ''\n188:         elif not l and not r:\n189:             m = ''\n190:         elif l and r:\n191:             m = '.open'\n192:         elif l:\n193:             m = '.Lopen'\n194:         else:\n195:             m = '.Ropen'\n196:         return fin.format(**{'a': a, 'b': b, 'm': m})\n197: \n198:     def _print_AccumulationBounds(self, i):\n199:         return \"AccumBounds(%s, %s)\" % (self._print(i.min), self._print(i.max))\n200: \n201:     def _print_Inverse(self, I):\n202:         return \"%s^-1\" % self.parenthesize(I.arg, PRECEDENCE[\"Pow\"])\n203: \n204:     def _print_Lambda(self, obj):\n205:         args, expr = obj.args\n206:         if len(args) == 1:\n207:             return \"Lambda(%s, %s)\" % (args.args[0], expr)\n208:         else:\n209:             arg_string = \", \".join(self._print(arg) for arg in args)\n210:             return \"Lambda((%s), %s)\" % (arg_string, expr)\n211: \n212:     def _print_LatticeOp(self, expr):\n213:         args = sorted(expr.args, key=default_sort_key)\n214:         return expr.func.__name__ + \"(%s)\" % \", \".join(self._print(arg) for arg in args)\n215: \n216:     def _print_Limit(self, expr):\n217:         e, z, z0, dir = expr.args\n218:         if str(dir) == \"+\":\n219:             return \"Limit(%s, %s, %s)\" % (e, z, z0)\n220:         else:\n221:             return \"Limit(%s, %s, %s, dir='%s')\" % (e, z, z0, dir)\n222: \n223:     def _print_list(self, expr):\n224:         return \"[%s]\" % self.stringify(expr, \", \")\n225: \n226:     def _print_MatrixBase(self, expr):\n227:         return expr._format_str(self)\n228:     _print_SparseMatrix = \\\n229:         _print_MutableSparseMatrix = \\\n230:         _print_ImmutableSparseMatrix = \\\n231:         _print_Matrix = \\\n232:         _print_DenseMatrix = \\\n233:         _print_MutableDenseMatrix = \\\n234:         _print_ImmutableMatrix = \\\n235:         _print_ImmutableDenseMatrix = \\\n236:         _print_MatrixBase\n237: \n238:     def _print_MatrixElement(self, expr):\n239:         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n240:             + '[%s, %s]' % (expr.i, expr.j)\n241: \n242:     def _print_MatrixSlice(self, expr):\n243:         def strslice(x):\n244:             x = list(x)\n245:             if x[2] == 1:\n246:                 del x[2]\n247:             if x[1] == x[0] + 1:\n248:                 del x[1]\n249:             if x[0] == 0:\n250:                 x[0] = ''\n251:             return ':'.join(map(self._print, x))\n252:         return (self._print(expr.parent) + '[' +\n253:                 strslice(expr.rowslice) + ', ' +\n254:                 strslice(expr.colslice) + ']')\n255: \n256:     def _print_DeferredVector(self, expr):\n257:         return expr.name\n258: \n259:     def _print_Mul(self, expr):\n260: \n261:         prec = precedence(expr)\n262: \n263:         c, e = expr.as_coeff_Mul()\n264:         if c < 0:\n265:             expr = _keep_coeff(-c, e)\n266:             sign = \"-\"\n267:         else:\n268:             sign = \"\"\n269: \n270:         a = []  # items in the numerator\n271:         b = []  # items that are in the denominator (if any)\n272: \n273:         if self.order not in ('old', 'none'):\n274:             args = expr.as_ordered_factors()\n275:         else:\n276:             # use make_args in case expr was something like -x -> x\n277:             args = Mul.make_args(expr)\n278: \n279:         # Gather args for numerator/denominator\n280:         for item in args:\n281:             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n282:                 if item.exp != -1:\n283:                     b.append(Pow(item.base, -item.exp, evaluate=False))\n284:                 else:\n285:                     b.append(Pow(item.base, -item.exp))\n286:             elif item.is_Rational and item is not S.Infinity:\n287:                 if item.p != 1:\n288:                     a.append(Rational(item.p))\n289:                 if item.q != 1:\n290:                     b.append(Rational(item.q))\n291:             else:\n292:                 a.append(item)\n293: \n294:         a = a or [S.One]\n295: \n296:         a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n297:         b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n298: \n299:         if len(b) == 0:\n300:             return sign + '*'.join(a_str)\n301:         elif len(b) == 1:\n302:             return sign + '*'.join(a_str) + \"/\" + b_str[0]\n303:         else:\n304:             return sign + '*'.join(a_str) + \"/(%s)\" % '*'.join(b_str)\n305: \n306:     def _print_MatMul(self, expr):\n307:         return '*'.join([self.parenthesize(arg, precedence(expr))\n308:             for arg in expr.args])\n309: \n310:     def _print_HadamardProduct(self, expr):\n311:         return '.*'.join([self.parenthesize(arg, precedence(expr))\n312:             for arg in expr.args])\n313: \n314:     def _print_MatAdd(self, expr):\n315:         return ' + '.join([self.parenthesize(arg, precedence(expr))\n316:             for arg in expr.args])\n317: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/printing/latex.py",
      "suspect_lines": [
        1480,
        1481,
        1482,
        1485,
        1491
      ]
    },
    {
      "filename": "/sympy/printing/pretty/pretty.py",
      "suspect_lines": [
        822
      ]
    },
    {
      "filename": "/sympy/printing/str.py",
      "suspect_lines": [
        307,
        315,
        316
      ]
    }
  ]
}