{
  "instance_id": "django__django-16136",
  "problem_statement": "object HttpResponseNotAllowed can't be used in 'await' expression\nDescription\n\t\nWhen defining a simple View subclass with only an async \"post\" method, GET requests to this view cause the following exception:\n[29/Sep/2022 07:50:48] \"GET /demo HTTP/1.1\" 500 81134\nMethod Not Allowed (GET): /demo\nInternal Server Error: /demo\nTraceback (most recent call last):\n File \"/home/alorence/.cache/pypoetry/virtualenvs/dj-bug-demo-FlhD0jMY-py3.10/lib/python3.10/site-packages/django/core/handlers/exception.py\", line 55, in inner\n\tresponse = get_response(request)\n File \"/home/alorence/.cache/pypoetry/virtualenvs/dj-bug-demo-FlhD0jMY-py3.10/lib/python3.10/site-packages/django/core/handlers/base.py\", line 197, in _get_response\n\tresponse = wrapped_callback(request, *callback_args, **callback_kwargs)\n File \"/home/alorence/.cache/pypoetry/virtualenvs/dj-bug-demo-FlhD0jMY-py3.10/lib/python3.10/site-packages/asgiref/sync.py\", line 218, in __call__\n\treturn call_result.result()\n File \"/usr/lib/python3.10/concurrent/futures/_base.py\", line 451, in result\n\treturn self.__get_result()\n File \"/usr/lib/python3.10/concurrent/futures/_base.py\", line 403, in __get_result\n\traise self._exception\n File \"/home/alorence/.cache/pypoetry/virtualenvs/dj-bug-demo-FlhD0jMY-py3.10/lib/python3.10/site-packages/asgiref/sync.py\", line 284, in main_wrap\n\tresult = await self.awaitable(*args, **kwargs)\nTypeError: object HttpResponseNotAllowed can't be used in 'await' expression\nThis can be easily reproduced with an empty project (no external dependencies) started with Django 4.1.1 and python 3.10.6.\nBasic view to reproduce the bug:\nfrom django.views import View\nfrom django.http import HttpResponse\nclass Demo(View):\n\t\"\"\"This basic view supports only POST requests\"\"\"\n\tasync def post(self, request):\n\t\treturn HttpResponse(\"ok\")\nURL pattern to access it:\nfrom django.urls import path\nfrom views import Demo\nurlpatterns = [\n\tpath(\"demo\", Demo.as_view()),\n]\nStart the local dev server (manage.py runserver) and open â€‹http://127.0.0.1:8000/demo in the browser.\nServer crash with 500 error with the given traceback.\n",
  "localized_code": "[start of django/views/generic/base.py]\n1: import asyncio\n2: import logging\n3: \n4: from django.core.exceptions import ImproperlyConfigured\n5: from django.http import (\n6:     HttpResponse,\n7:     HttpResponseGone,\n8:     HttpResponseNotAllowed,\n9:     HttpResponsePermanentRedirect,\n10:     HttpResponseRedirect,\n11: )\n12: from django.template.response import TemplateResponse\n13: from django.urls import reverse\n14: from django.utils.decorators import classonlymethod\n15: from django.utils.functional import classproperty\n16: \n17: logger = logging.getLogger(\"django.request\")\n18: \n19: \n20: class ContextMixin:\n21:     \"\"\"\n22:     A default context mixin that passes the keyword arguments received by\n23:     get_context_data() as the template context.\n24:     \"\"\"\n25: \n26:     extra_context = None\n27: \n28:     def get_context_data(self, **kwargs):\n29:         kwargs.setdefault(\"view\", self)\n30:         if self.extra_context is not None:\n31:             kwargs.update(self.extra_context)\n32:         return kwargs\n33: \n34: \n35: class View:\n36:     \"\"\"\n37:     Intentionally simple parent class for all views. Only implements\n38:     dispatch-by-method and simple sanity checking.\n39:     \"\"\"\n40: \n41:     http_method_names = [\n42:         \"get\",\n43:         \"post\",\n44:         \"put\",\n45:         \"patch\",\n46:         \"delete\",\n47:         \"head\",\n48:         \"options\",\n49:         \"trace\",\n50:     ]\n51: \n52:     def __init__(self, **kwargs):\n53:         \"\"\"\n54:         Constructor. Called in the URLconf; can contain helpful extra\n55:         keyword arguments, and other things.\n56:         \"\"\"\n57:         # Go through keyword arguments, and either save their values to our\n58:         # instance, or raise an error.\n59:         for key, value in kwargs.items():\n60:             setattr(self, key, value)\n61: \n62:     @classproperty\n63:     def view_is_async(cls):\n64:         handlers = [\n65:             getattr(cls, method)\n66:             for method in cls.http_method_names\n67:             if (method != \"options\" and hasattr(cls, method))\n68:         ]\n69:         if not handlers:\n70:             return False\n71:         is_async = asyncio.iscoroutinefunction(handlers[0])\n72:         if not all(asyncio.iscoroutinefunction(h) == is_async for h in handlers[1:]):\n73:             raise ImproperlyConfigured(\n74:                 f\"{cls.__qualname__} HTTP handlers must either be all sync or all \"\n75:                 \"async.\"\n76:             )\n77:         return is_async\n78: \n79:     @classonlymethod\n80:     def as_view(cls, **initkwargs):\n81:         \"\"\"Main entry point for a request-response process.\"\"\"\n82:         for key in initkwargs:\n83:             if key in cls.http_method_names:\n84:                 raise TypeError(\n85:                     \"The method name %s is not accepted as a keyword argument \"\n86:                     \"to %s().\" % (key, cls.__name__)\n87:                 )\n88:             if not hasattr(cls, key):\n89:                 raise TypeError(\n90:                     \"%s() received an invalid keyword %r. as_view \"\n91:                     \"only accepts arguments that are already \"\n92:                     \"attributes of the class.\" % (cls.__name__, key)\n93:                 )\n94: \n95:         def view(request, *args, **kwargs):\n96:             self = cls(**initkwargs)\n97:             self.setup(request, *args, **kwargs)\n98:             if not hasattr(self, \"request\"):\n99:                 raise AttributeError(\n100:                     \"%s instance has no 'request' attribute. Did you override \"\n101:                     \"setup() and forget to call super()?\" % cls.__name__\n102:                 )\n103:             return self.dispatch(request, *args, **kwargs)\n104: \n105:         view.view_class = cls\n106:         view.view_initkwargs = initkwargs\n107: \n108:         # __name__ and __qualname__ are intentionally left unchanged as\n109:         # view_class should be used to robustly determine the name of the view\n110:         # instead.\n111:         view.__doc__ = cls.__doc__\n112:         view.__module__ = cls.__module__\n113:         view.__annotations__ = cls.dispatch.__annotations__\n114:         # Copy possible attributes set by decorators, e.g. @csrf_exempt, from\n115:         # the dispatch method.\n116:         view.__dict__.update(cls.dispatch.__dict__)\n117: \n118:         # Mark the callback if the view class is async.\n119:         if cls.view_is_async:\n120:             view._is_coroutine = asyncio.coroutines._is_coroutine\n121: \n122:         return view\n123: \n124:     def setup(self, request, *args, **kwargs):\n125:         \"\"\"Initialize attributes shared by all view methods.\"\"\"\n126:         if hasattr(self, \"get\") and not hasattr(self, \"head\"):\n127:             self.head = self.get\n128:         self.request = request\n129:         self.args = args\n130:         self.kwargs = kwargs\n131: \n132:     def dispatch(self, request, *args, **kwargs):\n133:         # Try to dispatch to the right method; if a method doesn't exist,\n134:         # defer to the error handler. Also defer to the error handler if the\n135:         # request method isn't on the approved list.\n136:         if request.method.lower() in self.http_method_names:\n137:             handler = getattr(\n138:                 self, request.method.lower(), self.http_method_not_allowed\n139:             )\n140:         else:\n141:             handler = self.http_method_not_allowed\n142:         return handler(request, *args, **kwargs)\n143: \n144:     def http_method_not_allowed(self, request, *args, **kwargs):\n145:         logger.warning(\n146:             \"Method Not Allowed (%s): %s\",\n147:             request.method,\n148:             request.path,\n149:             extra={\"status_code\": 405, \"request\": request},\n150:         )\n151:         return HttpResponseNotAllowed(self._allowed_methods())\n152: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/views/generic/base.py",
      "suspect_lines": [
        151
      ]
    }
  ]
}