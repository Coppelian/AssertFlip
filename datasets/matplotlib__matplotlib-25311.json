{
  "instance_id": "matplotlib__matplotlib-25311",
  "problem_statement": "[Bug]: Unable to pickle figure with draggable legend\n### Bug summary\r\n\r\nI am unable to pickle figure with draggable legend. Same error comes for draggable annotations.\r\n\r\n\r\n\r\n\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport pickle\r\n\r\nfig = plt.figure()\r\nax = fig.add_subplot(111)\r\n\r\ntime=[0,1,2,3,4]\r\nspeed=[40,43,45,47,48]\r\n\r\nax.plot(time,speed,label=\"speed\")\r\n\r\nleg=ax.legend()\r\nleg.set_draggable(True) #pickling works after removing this line \r\n\r\npickle.dumps(fig)\r\nplt.show()\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n`TypeError: cannot pickle 'FigureCanvasQTAgg' object`\r\n\r\n### Expected outcome\r\n\r\nPickling successful\r\n\r\n### Additional information\r\n\r\n_No response_\r\n\r\n### Operating system\r\n\r\nWindows 10\r\n\r\n### Matplotlib Version\r\n\r\n3.7.0\r\n\r\n### Matplotlib Backend\r\n\r\n_No response_\r\n\r\n### Python version\r\n\r\n3.10\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\npip\n",
  "localized_code": "[start of lib/matplotlib/offsetbox.py]\n1: r\"\"\"\n2: Container classes for `.Artist`\\s.\n3: \n4: `OffsetBox`\n5:     The base of all container artists defined in this module.\n6: \n7: `AnchoredOffsetbox`, `AnchoredText`\n8:     Anchor and align an arbitrary `.Artist` or a text relative to the parent\n9:     axes or a specific anchor point.\n10: \n11: `DrawingArea`\n12:     A container with fixed width and height. Children have a fixed position\n13:     inside the container and may be clipped.\n14: \n15: `HPacker`, `VPacker`\n16:     Containers for layouting their children vertically or horizontally.\n17: \n18: `PaddedBox`\n19:     A container to add a padding around an `.Artist`.\n20: \n21: `TextArea`\n22:     Contains a single `.Text` instance.\n23: \"\"\"\n24: \n25: import functools\n26: \n27: import numpy as np\n28: \n29: import matplotlib as mpl\n30: from matplotlib import _api, _docstring\n31: import matplotlib.artist as martist\n32: import matplotlib.path as mpath\n33: import matplotlib.text as mtext\n34: import matplotlib.transforms as mtransforms\n35: from matplotlib.font_manager import FontProperties\n36: from matplotlib.image import BboxImage\n37: from matplotlib.patches import (\n38:     FancyBboxPatch, FancyArrowPatch, bbox_artist as mbbox_artist)\n39: from matplotlib.transforms import Bbox, BboxBase, TransformedBbox\n40: \n41: \n42: DEBUG = False\n43: \n44: \n45: def _compat_get_offset(meth):\n46:     \"\"\"\n47:     Decorator for the get_offset method of OffsetBox and subclasses, that\n48:     allows supporting both the new signature (self, bbox, renderer) and the old\n49:     signature (self, width, height, xdescent, ydescent, renderer).\n50:     \"\"\"\n51:     sigs = [lambda self, width, height, xdescent, ydescent, renderer: locals(),\n52:             lambda self, bbox, renderer: locals()]\n53: \n54:     @functools.wraps(meth)\n55:     def get_offset(self, *args, **kwargs):\n56:         params = _api.select_matching_signature(sigs, self, *args, **kwargs)\n57:         bbox = (params[\"bbox\"] if \"bbox\" in params else\n58:                 Bbox.from_bounds(-params[\"xdescent\"], -params[\"ydescent\"],\n59:                                  params[\"width\"], params[\"height\"]))\n60:         return meth(params[\"self\"], bbox, params[\"renderer\"])\n61:     return get_offset\n62: \n63: \n64: @_api.deprecated(\"3.7\", alternative='patches.bbox_artist')\n65: def bbox_artist(*args, **kwargs):\nCode replaced for brevity.\n67: \n68: \n69: \n70: # for debugging use\n71: def _bbox_artist(*args, **kwargs):\nCode replaced for brevity.\n73: \n74: \n75: \n76: def _get_packed_offsets(widths, total, sep, mode=\"fixed\"):\nCode replaced for brevity.\n154: \n155: \n156: \n157: def _get_aligned_offsets(yspans, height, align=\"baseline\"):\nCode replaced for brevity.\n205: \n206: \n207: \n208: class OffsetBox(martist.Artist):\nCode replaced for brevity.\n418: \n419: \n420: \n421: class PackerBase(OffsetBox):\nCode replaced for brevity.\n465: \n466: \n467: \n468: class VPacker(PackerBase):\nCode replaced for brevity.\n497: \n498: \n499: \n500: class HPacker(PackerBase):\nCode replaced for brevity.\n525: \n526: \n527: \n528: class PaddedBox(OffsetBox):\nCode replaced for brevity.\n594: \n595: \n596: \n597: class DrawingArea(OffsetBox):\nCode replaced for brevity.\n706: \n707: \n708: \n709: class TextArea(OffsetBox):\nCode replaced for brevity.\n823: \n824: \n825: \n826: class AuxTransformBox(OffsetBox):\nCode replaced for brevity.\n905: \n906: \n907: \n908: class AnchoredOffsetbox(OffsetBox):\nCode replaced for brevity.\n1086: \n1087: \n1088: \n1089: def _get_anchored_bbox(loc, bbox, parentbbox, borderpad):\nCode replaced for brevity.\n1098: \n1099: \n1100: \n1101: class AnchoredText(AnchoredOffsetbox):\nCode replaced for brevity.\n1142: \n1143: \n1144: \n1145: class OffsetImage(OffsetBox):\nCode replaced for brevity.\n1214: \n1215: \n1216: \n1217: class AnnotationBbox(martist.Artist, mtext._AnnotationBase):\nCode replaced for brevity.\n1471: \n1472: \n1473: \n1474: class DraggableBase:\n1475:     \"\"\"\n1476:     Helper base class for a draggable artist (legend, offsetbox).\n1477: \n1478:     Derived classes must override the following methods::\n1479: \n1480:         def save_offset(self):\n1481:             '''\n1482:             Called when the object is picked for dragging; should save the\n1483:             reference position of the artist.\n1484:             '''\n1485: \n1486:         def update_offset(self, dx, dy):\n1487:             '''\n1488:             Called during the dragging; (*dx*, *dy*) is the pixel offset from\n1489:             the point where the mouse drag started.\n1490:             '''\n1491: \n1492:     Optionally, you may override the following method::\n1493: \n1494:         def finalize_offset(self):\n1495:             '''Called when the mouse is released.'''\n1496: \n1497:     In the current implementation of `.DraggableLegend` and\n1498:     `DraggableAnnotation`, `update_offset` places the artists in display\n1499:     coordinates, and `finalize_offset` recalculates their position in axes\n1500:     coordinate and set a relevant attribute.\n1501:     \"\"\"\n1502: \n1503:     def __init__(self, ref_artist, use_blit=False):\n1504:         self.ref_artist = ref_artist\n1505:         if not ref_artist.pickable():\n1506:             ref_artist.set_picker(True)\n1507:         self.got_artist = False\n1508:         self.canvas = self.ref_artist.figure.canvas\n1509:         self._use_blit = use_blit and self.canvas.supports_blit\n1510:         self.cids = [\n1511:             self.canvas.callbacks._connect_picklable(\n1512:                 'pick_event', self.on_pick),\n1513:             self.canvas.callbacks._connect_picklable(\n1514:                 'button_release_event', self.on_release),\n1515:         ]\n1516: \n1517:     def on_motion(self, evt):\n1518:         if self._check_still_parented() and self.got_artist:\n1519:             dx = evt.x - self.mouse_x\n1520:             dy = evt.y - self.mouse_y\n1521:             self.update_offset(dx, dy)\n1522:             if self._use_blit:\n1523:                 self.canvas.restore_region(self.background)\n1524:                 self.ref_artist.draw(\n1525:                     self.ref_artist.figure._get_renderer())\n1526:                 self.canvas.blit()\n1527:             else:\n1528:                 self.canvas.draw()\n1529: \n1530:     def on_pick(self, evt):\n1531:         if self._check_still_parented() and evt.artist == self.ref_artist:\n1532:             self.mouse_x = evt.mouseevent.x\n1533:             self.mouse_y = evt.mouseevent.y\n1534:             self.got_artist = True\n1535:             if self._use_blit:\n1536:                 self.ref_artist.set_animated(True)\n1537:                 self.canvas.draw()\n1538:                 self.background = \\\n1539:                     self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)\n1540:                 self.ref_artist.draw(\n1541:                     self.ref_artist.figure._get_renderer())\n1542:                 self.canvas.blit()\n1543:             self._c1 = self.canvas.callbacks._connect_picklable(\n1544:                 \"motion_notify_event\", self.on_motion)\n1545:             self.save_offset()\n1546: \n1547:     def on_release(self, event):\n1548:         if self._check_still_parented() and self.got_artist:\n1549:             self.finalize_offset()\n1550:             self.got_artist = False\n1551:             self.canvas.mpl_disconnect(self._c1)\n1552: \n1553:             if self._use_blit:\n1554:                 self.ref_artist.set_animated(False)\n1555: \n1556:     def _check_still_parented(self):\n1557:         if self.ref_artist.figure is None:\n1558:             self.disconnect()\n1559:             return False\n1560:         else:\n1561:             return True\n1562: \n1563:     def disconnect(self):\n1564:         \"\"\"Disconnect the callbacks.\"\"\"\n1565:         for cid in self.cids:\n1566:             self.canvas.mpl_disconnect(cid)\n1567:         try:\n1568:             c1 = self._c1\n1569:         except AttributeError:\n1570:             pass\n1571:         else:\n1572:             self.canvas.mpl_disconnect(c1)\n1573: \n1574:     def save_offset(self):\n1575:         pass\n1576: \n1577:     def update_offset(self, dx, dy):\n1578:         pass\n1579: \n1580:     def finalize_offset(self):\n1581:         pass\n1582: \n1583: \n1584: class DraggableOffsetBox(DraggableBase):\nCode replaced for brevity.\n1606: \n1607: \n1608: \n1609: class DraggableAnnotation(DraggableBase):\nCode replaced for brevity.\n1621: \n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/offsetbox.py",
      "suspect_lines": [
        1508
      ]
    }
  ]
}