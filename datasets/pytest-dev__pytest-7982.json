{
  "instance_id": "pytest-dev__pytest-7982",
  "problem_statement": "Symlinked directories not collected since pytest 6.1.0\nWhen there is a symlink to a directory in a test directory, is is just skipped over, but it should be followed and collected as usual.\r\n\r\nThis regressed in b473e515bc57ff1133fe650f1e7e6d7e22e5d841 (included in 6.1.0). For some reason I added a `follow_symlinks=False` in there, I don't remember why, but it does not match the previous behavior and should be removed.\r\n\r\nPR for this is coming up.\n",
  "localized_code": "[start of src/_pytest/pathlib.py]\n1: import atexit\n2: import contextlib\n3: import fnmatch\n4: import importlib.util\n5: import itertools\n6: import os\n7: import shutil\n8: import sys\n9: import uuid\n10: import warnings\n11: from enum import Enum\n12: from functools import partial\n13: from os.path import expanduser\n14: from os.path import expandvars\n15: from os.path import isabs\n16: from os.path import sep\n17: from pathlib import Path\n18: from pathlib import PurePath\n19: from posixpath import sep as posix_sep\n20: from types import ModuleType\n21: from typing import Callable\n22: from typing import Iterable\n23: from typing import Iterator\n24: from typing import Optional\n25: from typing import Set\n26: from typing import TypeVar\n27: from typing import Union\n28: \n29: import py\n30: \n31: from _pytest.compat import assert_never\n32: from _pytest.outcomes import skip\n33: from _pytest.warning_types import PytestWarning\n34: \n35: LOCK_TIMEOUT = 60 * 60 * 24 * 3\n36: \n37: \n38: _AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n39: \n40: \n41: def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:\n42:     return path.joinpath(\".lock\")\n43: \n44: \n45: def ensure_reset_dir(path: Path) -> None:\n46:     \"\"\"Ensure the given path is an empty directory.\"\"\"\n47:     if path.exists():\n48:         rm_rf(path)\n49:     path.mkdir()\n50: \n51: \n52: def on_rm_rf_error(func, path: str, exc, *, start_path: Path) -> bool:\nCode replaced for brevity.\n100: \n101: \n102: \n103: def ensure_extended_length_path(path: Path) -> Path:\nCode replaced for brevity.\n118: \n119: \n120: \n121: def get_extended_length_path_str(path: str) -> str:\nCode replaced for brevity.\n130: \n131: \n132: \n133: def rm_rf(path: Path) -> None:\nCode replaced for brevity.\n138: \n139: \n140: \n141: def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\nCode replaced for brevity.\n146: \n147: \n148: \n149: def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\nCode replaced for brevity.\n157: \n158: \n159: \n160: def find_suffixes(root: Path, prefix: str) -> Iterator[str]:\nCode replaced for brevity.\n162: \n163: \n164: \n165: def parse_num(maybe_num) -> int:\nCode replaced for brevity.\n170: \n171: \n172: \n173: ) -> None:\nCode replaced for brevity.\n192: \n193: \n194: \n195: def make_numbered_dir(root: Path, prefix: str) -> Path:\nCode replaced for brevity.\n213: \n214: \n215: \n216: def create_cleanup_lock(p: Path) -> Path:\nCode replaced for brevity.\n230: \n231: \n232: \n233: def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):\nCode replaced for brevity.\n247: \n248: \n249: \n250: def maybe_delete_a_numbered_dir(path: Path) -> None:\nCode replaced for brevity.\n275: \n276: \n277: \n278: def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:\nCode replaced for brevity.\n303: \n304: \n305: \n306: def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:\nCode replaced for brevity.\n309: \n310: \n311: \n312: def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\nCode replaced for brevity.\n321: \n322: \n323: \n324: ) -> None:\nCode replaced for brevity.\n331: \n332: \n333: \n334: ) -> Path:\nCode replaced for brevity.\n358: \n359: \n360: \n361: def resolve_from_str(input: str, rootpath: Path) -> Path:\nCode replaced for brevity.\n367: \n368: \n369: \n370: def fnmatch_ex(pattern: str, path) -> bool:\nCode replaced for brevity.\n403: \n404: \n405: \n406: def parts(s: str) -> Set[str]:\nCode replaced for brevity.\n408: \n409: \n410: \n411: def symlink_or_skip(src, dst, **kwargs):\nCode replaced for brevity.\n416: \n417: \n418: \n419: class ImportMode(Enum):\nCode replaced for brevity.\n424: \n425: \n426: \n427: class ImportPathMismatchError(ImportError):\nCode replaced for brevity.\n433: \n434: \n435: \n436: ) -> ModuleType:\nCode replaced for brevity.\n531: \n532: \n533: \n534: def resolve_package_path(path: Path) -> Optional[Path]:\nCode replaced for brevity.\n548: \n549: \n550: \n551: def visit(\n552:     path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n553: ) -> Iterator[\"os.DirEntry[str]\"]:\n554:     \"\"\"Walk a directory recursively, in breadth-first order.\n555: \n556:     Entries at each directory level are sorted.\n557:     \"\"\"\n558:     entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n559:     yield from entries\n560:     for entry in entries:\n561:         if entry.is_dir(follow_symlinks=False) and recurse(entry):\n562:             yield from visit(entry.path, recurse)\n563: \n564: \n565: def absolutepath(path: Union[Path, str]) -> Path:\nCode replaced for brevity.\n571: \n572: \n573: \n574: def commonpath(path1: Path, path2: Path) -> Optional[Path]:\nCode replaced for brevity.\n583: \n584: \n585: \n586: def bestrelpath(directory: Path, dest: Path) -> str:\nCode replaced for brevity.\n610: \n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/pathlib.py",
      "suspect_lines": [
        561
      ]
    }
  ]
}