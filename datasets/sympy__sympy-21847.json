{
  "instance_id": "sympy__sympy-21847",
  "problem_statement": "itermonomials returns incorrect monomials when using min_degrees argument\n`itermonomials` returns incorrect monomials when using optional `min_degrees` argument\r\n\r\nFor example, the following code introduces three symbolic variables and generates monomials with max and min degree of 3:\r\n\r\n\r\n```\r\nimport sympy as sp\r\nfrom sympy.polys.orderings import monomial_key\r\n\r\nx1, x2, x3 = sp.symbols('x1, x2, x3')\r\nstates = [x1, x2, x3]\r\nmax_degrees = 3\r\nmin_degrees = 3\r\nmonomials = sorted(sp.itermonomials(states, max_degrees, min_degrees=min_degrees), \r\n                   key=monomial_key('grlex', states))\r\nprint(monomials)\r\n```\r\nThe code returns `[x3**3, x2**3, x1**3]`, when it _should_ also return monomials such as `x1*x2**2, x2*x3**2, etc...` that also have total degree of 3. This behaviour is inconsistent with the documentation that states that \r\n\r\n> A generator of all monomials `monom` is returned, such that either `min_degree <= total_degree(monom) <= max_degree`...\r\n\r\nThe monomials are also missing when `max_degrees` is increased above `min_degrees`.\n",
  "localized_code": "[start of sympy/polys/monomials.py]\n1: \"\"\"Tools and arithmetics for monomials of distributed polynomials. \"\"\"\n2: \n3: \n4: from itertools import combinations_with_replacement, product\n5: from textwrap import dedent\n6: \n7: from sympy.core import Mul, S, Tuple, sympify\n8: from sympy.core.compatibility import iterable\n9: from sympy.polys.polyerrors import ExactQuotientFailed\n10: from sympy.polys.polyutils import PicklableWithSlots, dict_from_expr\n11: from sympy.utilities import public\n12: from sympy.core.compatibility import is_sequence\n13: \n14: @public\n15: def itermonomials(variables, max_degrees, min_degrees=None):\n16:     r\"\"\"\n17:     ``max_degrees`` and ``min_degrees`` are either both integers or both lists.\n18:     Unless otherwise specified, ``min_degrees`` is either ``0`` or\n19:     ``[0, ..., 0]``.\n20: \n21:     A generator of all monomials ``monom`` is returned, such that\n22:     either\n23:     ``min_degree <= total_degree(monom) <= max_degree``,\n24:     or\n25:     ``min_degrees[i] <= degree_list(monom)[i] <= max_degrees[i]``,\n26:     for all ``i``.\n27: \n28:     Case I. ``max_degrees`` and ``min_degrees`` are both integers\n29:     =============================================================\n30: \n31:     Given a set of variables $V$ and a min_degree $N$ and a max_degree $M$\n32:     generate a set of monomials of degree less than or equal to $N$ and greater\n33:     than or equal to $M$. The total number of monomials in commutative\n34:     variables is huge and is given by the following formula if $M = 0$:\n35: \n36:         .. math::\n37:             \\frac{(\\#V + N)!}{\\#V! N!}\n38: \n39:     For example if we would like to generate a dense polynomial of\n40:     a total degree $N = 50$ and $M = 0$, which is the worst case, in 5\n41:     variables, assuming that exponents and all of coefficients are 32-bit long\n42:     and stored in an array we would need almost 80 GiB of memory! Fortunately\n43:     most polynomials, that we will encounter, are sparse.\n44: \n45:     Consider monomials in commutative variables $x$ and $y$\n46:     and non-commutative variables $a$ and $b$::\n47: \n48:         >>> from sympy import symbols\n49:         >>> from sympy.polys.monomials import itermonomials\n50:         >>> from sympy.polys.orderings import monomial_key\n51:         >>> from sympy.abc import x, y\n52: \n53:         >>> sorted(itermonomials([x, y], 2), key=monomial_key('grlex', [y, x]))\n54:         [1, x, y, x**2, x*y, y**2]\n55: \n56:         >>> sorted(itermonomials([x, y], 3), key=monomial_key('grlex', [y, x]))\n57:         [1, x, y, x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3]\n58: \n59:         >>> a, b = symbols('a, b', commutative=False)\n60:         >>> set(itermonomials([a, b, x], 2))\n61:         {1, a, a**2, b, b**2, x, x**2, a*b, b*a, x*a, x*b}\n62: \n63:         >>> sorted(itermonomials([x, y], 2, 1), key=monomial_key('grlex', [y, x]))\n64:         [x, y, x**2, x*y, y**2]\n65: \n66:     Case II. ``max_degrees`` and ``min_degrees`` are both lists\n67:     ===========================================================\n68: \n69:     If ``max_degrees = [d_1, ..., d_n]`` and\n70:     ``min_degrees = [e_1, ..., e_n]``, the number of monomials generated\n71:     is:\n72: \n73:     .. math::\n74:         (d_1 - e_1 + 1) (d_2 - e_2 + 1) \\cdots (d_n - e_n + 1)\n75: \n76:     Let us generate all monomials ``monom`` in variables $x$ and $y$\n77:     such that ``[1, 2][i] <= degree_list(monom)[i] <= [2, 4][i]``,\n78:     ``i = 0, 1`` ::\n79: \n80:         >>> from sympy import symbols\n81:         >>> from sympy.polys.monomials import itermonomials\n82:         >>> from sympy.polys.orderings import monomial_key\n83:         >>> from sympy.abc import x, y\n84: \n85:         >>> sorted(itermonomials([x, y], [2, 4], [1, 2]), reverse=True, key=monomial_key('lex', [x, y]))\n86:         [x**2*y**4, x**2*y**3, x**2*y**2, x*y**4, x*y**3, x*y**2]\n87:     \"\"\"\n88:     n = len(variables)\n89:     if is_sequence(max_degrees):\n90:         if len(max_degrees) != n:\n91:             raise ValueError('Argument sizes do not match')\n92:         if min_degrees is None:\n93:             min_degrees = [0]*n\n94:         elif not is_sequence(min_degrees):\n95:             raise ValueError('min_degrees is not a list')\n96:         else:\n97:             if len(min_degrees) != n:\n98:                 raise ValueError('Argument sizes do not match')\n99:             if any(i < 0 for i in min_degrees):\n100:                 raise ValueError(\"min_degrees can't contain negative numbers\")\n101:         total_degree = False\n102:     else:\n103:         max_degree = max_degrees\n104:         if max_degree < 0:\n105:             raise ValueError(\"max_degrees can't be negative\")\n106:         if min_degrees is None:\n107:             min_degree = 0\n108:         else:\n109:             if min_degrees < 0:\n110:                 raise ValueError(\"min_degrees can't be negative\")\n111:             min_degree = min_degrees\n112:         total_degree = True\n113:     if total_degree:\n114:         if min_degree > max_degree:\n115:             return\n116:         if not variables or max_degree == 0:\n117:             yield S.One\n118:             return\n119:         # Force to list in case of passed tuple or other incompatible collection\n120:         variables = list(variables) + [S.One]\n121:         if all(variable.is_commutative for variable in variables):\n122:             monomials_list_comm = []\n123:             for item in combinations_with_replacement(variables, max_degree):\n124:                 powers = dict()\n125:                 for variable in variables:\n126:                     powers[variable] = 0\n127:                 for variable in item:\n128:                     if variable != 1:\n129:                         powers[variable] += 1\n130:                 if max(powers.values()) >= min_degree:\n131:                     monomials_list_comm.append(Mul(*item))\n132:             yield from set(monomials_list_comm)\n133:         else:\n134:             monomials_list_non_comm = []\n135:             for item in product(variables, repeat=max_degree):\n136:                 powers = dict()\n137:                 for variable in variables:\n138:                     powers[variable] = 0\n139:                 for variable in item:\n140:                     if variable != 1:\n141:                         powers[variable] += 1\n142:                 if max(powers.values()) >= min_degree:\n143:                     monomials_list_non_comm.append(Mul(*item))\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/polys/monomials.py",
      "suspect_lines": [
        130,
        142
      ]
    }
  ]
}