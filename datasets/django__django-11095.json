{
  "instance_id": "django__django-11095",
  "problem_statement": "add ModelAdmin.get_inlines() hook to allow set inlines based on the request or model instance.\nDescription\n\t\nadd ModelAdmin.get_inlines() hook to allow set inlines based on the request or model instance.\nCurrently, We can override the method get_inline_instances to do such a thing, but a for loop should be copied to my code. So I wished add a hook get_inlines(request, obj=None)\n",
  "localized_code": "[start of django/contrib/admin/options.py]\n1: import copy\n2: import json\n3: import operator\n4: import re\n5: from functools import partial, reduce, update_wrapper\n6: from urllib.parse import quote as urlquote\n7: \n8: from django import forms\n9: from django.conf import settings\n10: from django.contrib import messages\n11: from django.contrib.admin import helpers, widgets\n12: from django.contrib.admin.checks import (\n13:     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,\n14: )\n15: from django.contrib.admin.exceptions import DisallowedModelAdminToField\n16: from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n17: from django.contrib.admin.utils import (\n18:     NestedObjects, construct_change_message, flatten_fieldsets,\n19:     get_deleted_objects, lookup_needs_distinct, model_format_dict,\n20:     model_ngettext, quote, unquote,\n21: )\n22: from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n23: from django.contrib.admin.widgets import (\n24:     AutocompleteSelect, AutocompleteSelectMultiple,\n25: )\n26: from django.contrib.auth import get_permission_codename\n27: from django.core.exceptions import (\n28:     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,\n29: )\n30: from django.core.paginator import Paginator\n31: from django.db import models, router, transaction\n32: from django.db.models.constants import LOOKUP_SEP\n33: from django.db.models.fields import BLANK_CHOICE_DASH\n34: from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n35: from django.forms.models import (\n36:     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,\n37:     modelform_factory, modelformset_factory,\n38: )\n39: from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n40: from django.http import HttpResponseRedirect\n41: from django.http.response import HttpResponseBase\n42: from django.template.response import SimpleTemplateResponse, TemplateResponse\n43: from django.urls import reverse\n44: from django.utils.decorators import method_decorator\n45: from django.utils.html import format_html\n46: from django.utils.http import urlencode\n47: from django.utils.safestring import mark_safe\n48: from django.utils.text import capfirst, format_lazy, get_text_list\n49: from django.utils.translation import gettext as _, ngettext\n50: from django.views.decorators.csrf import csrf_protect\n51: from django.views.generic import RedirectView\n52: \n53: IS_POPUP_VAR = '_popup'\n54: TO_FIELD_VAR = '_to_field'\n55: \n56: \n57: HORIZONTAL, VERTICAL = 1, 2\n58: \n59: \n60:     # it cannot import models from other applications at the module level.\nCode replaced for brevity.\n64: \n65: \n66: \n67: def get_ul_class(radio_style):\nCode replaced for brevity.\n68: \n69: \n70: \n71: class IncorrectLookupParameters(Exception):\n72:     pass\n73: \n74: \n75: # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n76: # by adding to ModelAdmin.formfield_overrides.\n77: \n78: FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n79:     models.DateTimeField: {\n80:         'form_class': forms.SplitDateTimeField,\n81:         'widget': widgets.AdminSplitDateTime\n82:     },\n83:     models.DateField: {'widget': widgets.AdminDateWidget},\n84:     models.TimeField: {'widget': widgets.AdminTimeWidget},\n85:     models.TextField: {'widget': widgets.AdminTextareaWidget},\n86:     models.URLField: {'widget': widgets.AdminURLFieldWidget},\n87:     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},\n88:     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},\n89:     models.CharField: {'widget': widgets.AdminTextInputWidget},\n90:     models.ImageField: {'widget': widgets.AdminFileWidget},\n91:     models.FileField: {'widget': widgets.AdminFileWidget},\n92:     models.EmailField: {'widget': widgets.AdminEmailInputWidget},\n93:     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},\n94: }\n95: \n96: csrf_protect_m = method_decorator(csrf_protect)\n97: \n98: \n99: class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\nCode replaced for brevity.\n535: \n536: \n537: \n538: class ModelAdmin(BaseModelAdmin):\n539:     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n540: \n541:     list_display = ('__str__',)\n542:     list_display_links = ()\n543:     list_filter = ()\n544:     list_select_related = False\n545:     list_per_page = 100\n546:     list_max_show_all = 200\n547:     list_editable = ()\n548:     search_fields = ()\n549:     date_hierarchy = None\n550:     save_as = False\n551:     save_as_continue = True\n552:     save_on_top = False\n553:     paginator = Paginator\n554:     preserve_filters = True\n555:     inlines = []\n556: \n557:     # Custom templates (designed to be over-ridden in subclasses)\n558:     add_form_template = None\n559:     change_form_template = None\n560:     change_list_template = None\n561:     delete_confirmation_template = None\n562:     delete_selected_confirmation_template = None\n563:     object_history_template = None\n564:     popup_response_template = None\n565: \n566:     # Actions\n567:     actions = []\n568:     action_form = helpers.ActionForm\n569:     actions_on_top = True\n570:     actions_on_bottom = False\n571:     actions_selection_counter = True\n572:     checks_class = ModelAdminChecks\n573: \n574:     def __init__(self, model, admin_site):\n575:         self.model = model\n576:         self.opts = model._meta\n577:         self.admin_site = admin_site\n578:         super().__init__()\n579: \n580:     def __str__(self):\n581:         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n582: \n583:     def get_inline_instances(self, request, obj=None):\n584:         inline_instances = []\n585:         for inline_class in self.inlines:\n586:             inline = inline_class(self.model, self.admin_site)\n587:             if request:\n588:                 if not (inline.has_view_or_change_permission(request, obj) or\n589:                         inline.has_add_permission(request, obj) or\n590:                         inline.has_delete_permission(request, obj)):\n591:                     continue\n592:                 if not inline.has_add_permission(request, obj):\n593:                     inline.max_num = 0\n594:             inline_instances.append(inline)\n595: \n596:         return inline_instances\n597: \n598:     def get_urls(self):\n599:         from django.urls import path\n600: \n601:         def wrap(view):\n602:             def wrapper(*args, **kwargs):\n603:                 return self.admin_site.admin_view(view)(*args, **kwargs)\n604:             wrapper.model_admin = self\n605:             return update_wrapper(wrapper, view)\n606: \n607:         info = self.model._meta.app_label, self.model._meta.model_name\n608: \n609:         urlpatterns = [\n610:             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),\n611:             path('add/', wrap(self.add_view), name='%s_%s_add' % info),\n612:             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),\n613:             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),\n614:             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),\n615:             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),\n616:             # For backwards compatibility (was the change url before 1.9)\n617:             path('<path:object_id>/', wrap(RedirectView.as_view(\n618:                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)\n619:             ))),\n620:         ]\n621:         return urlpatterns\n622: \n623:     @property\n624:     def urls(self):\n625:         return self.get_urls()\n626: \n627:     @property\n628:     def media(self):\n629:         extra = '' if settings.DEBUG else '.min'\n630:         js = [\n631:             'vendor/jquery/jquery%s.js' % extra,\n632:             'jquery.init.js',\n633:             'core.js',\n634:             'admin/RelatedObjectLookups.js',\n635:             'actions%s.js' % extra,\n636:             'urlify.js',\n637:             'prepopulate%s.js' % extra,\n638:             'vendor/xregexp/xregexp%s.js' % extra,\n639:         ]\n640:         return forms.Media(js=['admin/js/%s' % url for url in js])\n641: \n642:     def get_model_perms(self, request):\n643:         \"\"\"\n644:         Return a dict of all perms for this model. This dict has the keys\n645:         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n646:         for each of those actions.\n647:         \"\"\"\n648:         return {\n649:             'add': self.has_add_permission(request),\n650:             'change': self.has_change_permission(request),\n651:             'delete': self.has_delete_permission(request),\n652:             'view': self.has_view_permission(request),\n653:         }\n654: \n655:     def _get_form_for_get_fields(self, request, obj):\n656:         return self.get_form(request, obj, fields=None)\n657: \n658:     def get_form(self, request, obj=None, change=False, **kwargs):\n659:         \"\"\"\n660:         Return a Form class for use in the admin add view. This is used by\n661:         add_view and change_view.\n662:         \"\"\"\n663:         if 'fields' in kwargs:\n664:             fields = kwargs.pop('fields')\n665:         else:\n666:             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n667:         excluded = self.get_exclude(request, obj)\n668:         exclude = [] if excluded is None else list(excluded)\n669:         readonly_fields = self.get_readonly_fields(request, obj)\n670:         exclude.extend(readonly_fields)\n671:         # Exclude all fields if it's a change form and the user doesn't have\n672:         # the change permission.\n673:         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):\n674:             exclude.extend(fields)\n675:         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n676:             # Take the custom ModelForm's Meta.exclude into account only if the\n677:             # ModelAdmin doesn't define its own.\n678:             exclude.extend(self.form._meta.exclude)\n679:         # if exclude is an empty list we pass None to be consistent with the\n680:         # default on modelform_factory\n681:         exclude = exclude or None\n682: \n683:         # Remove declared form fields which are in readonly_fields.\n684:         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)\n685:         form = type(self.form.__name__, (self.form,), new_attrs)\n686: \n687:         defaults = {\n688:             'form': form,\n689:             'fields': fields,\n690:             'exclude': exclude,\n691:             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n692:             **kwargs,\n693:         }\n694: \n695:         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n696:             defaults['fields'] = forms.ALL_FIELDS\n697: \n698:         try:\n699:             return modelform_factory(self.model, **defaults)\n700:         except FieldError as e:\n701:             raise FieldError(\n702:                 '%s. Check fields/fieldsets/exclude attributes of class %s.'\n703:                 % (e, self.__class__.__name__)\n704:             )\n705: \n706:     def get_changelist(self, request, **kwargs):\n707:         \"\"\"\n708:         Return the ChangeList class for use on the changelist page.\n709:         \"\"\"\n710:         from django.contrib.admin.views.main import ChangeList\n711:         return ChangeList\n712: \n713:     def get_changelist_instance(self, request):\n714:         \"\"\"\n715:         Return a `ChangeList` instance based on `request`. May raise\n716:         `IncorrectLookupParameters`.\n717:         \"\"\"\n718:         list_display = self.get_list_display(request)\n719:         list_display_links = self.get_list_display_links(request, list_display)\n720:         # Add the action checkboxes if any actions are available.\n721:         if self.get_actions(request):\n722:             list_display = ['action_checkbox', *list_display]\n723:         sortable_by = self.get_sortable_by(request)\n724:         ChangeList = self.get_changelist(request)\n725:         return ChangeList(\n726:             request,\n727:             self.model,\n728:             list_display,\n729:             list_display_links,\n730:             self.get_list_filter(request),\n731:             self.date_hierarchy,\n732:             self.get_search_fields(request),\n733:             self.get_list_select_related(request),\n734:             self.list_per_page,\n735:             self.list_max_show_all,\n736:             self.list_editable,\n737:             self,\n738:             sortable_by,\n739:         )\n740: \n741:     def get_object(self, request, object_id, from_field=None):\n742:         \"\"\"\n743:         Return an instance matching the field and value provided, the primary\n744:         key is used if no field is provided. Return ``None`` if no match is\n745:         found or the object_id fails validation.\n746:         \"\"\"\n747:         queryset = self.get_queryset(request)\n748:         model = queryset.model\n749:         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)\n750:         try:\n751:             object_id = field.to_python(object_id)\n752:             return queryset.get(**{field.name: object_id})\n753:         except (model.DoesNotExist, ValidationError, ValueError):\n754:             return None\n755: \n756:     def get_changelist_form(self, request, **kwargs):\n757:         \"\"\"\n758:         Return a Form class for use in the Formset on the changelist page.\n759:         \"\"\"\n760:         defaults = {\n761:             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n762:             **kwargs,\n763:         }\n764:         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):\n765:             defaults['fields'] = forms.ALL_FIELDS\n766: \n767:         return modelform_factory(self.model, **defaults)\n768: \n769:     def get_changelist_formset(self, request, **kwargs):\n770:         \"\"\"\n771:         Return a FormSet class for use on the changelist page if list_editable\n772:         is used.\n773:         \"\"\"\n774:         defaults = {\n775:             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n776:             **kwargs,\n777:         }\n778:         return modelformset_factory(\n779:             self.model, self.get_changelist_form(request), extra=0,\n780:             fields=self.list_editable, **defaults\n781:         )\n782: \n783:     def get_formsets_with_inlines(self, request, obj=None):\n784:         \"\"\"\n785:         Yield formsets and the corresponding inlines.\n786:         \"\"\"\n787:         for inline in self.get_inline_instances(request, obj):\n788:             yield inline.get_formset(request, obj), inline\n789: \n790:     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):\n791:         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n792: \n793:     def log_addition(self, request, object, message):\n794:         \"\"\"\n795:         Log that an object has been successfully added.\n796: \n797:         The default implementation creates an admin LogEntry object.\n798:         \"\"\"\n799:         from django.contrib.admin.models import LogEntry, ADDITION\n800:         return LogEntry.objects.log_action(\n801:             user_id=request.user.pk,\n802:             content_type_id=get_content_type_for_model(object).pk,\n803:             object_id=object.pk,\n804:             object_repr=str(object),\n805:             action_flag=ADDITION,\n806:             change_message=message,\n807:         )\n808: \n809:     def log_change(self, request, object, message):\n810:         \"\"\"\n811:         Log that an object has been successfully changed.\n812: \n813:         The default implementation creates an admin LogEntry object.\n814:         \"\"\"\n815:         from django.contrib.admin.models import LogEntry, CHANGE\n816:         return LogEntry.objects.log_action(\n817:             user_id=request.user.pk,\n818:             content_type_id=get_content_type_for_model(object).pk,\n819:             object_id=object.pk,\n820:             object_repr=str(object),\n821:             action_flag=CHANGE,\n822:             change_message=message,\n823:         )\n824: \n825:     def log_deletion(self, request, object, object_repr):\n826:         \"\"\"\n827:         Log that an object will be deleted. Note that this method must be\n828:         called before the deletion.\n829: \n830:         The default implementation creates an admin LogEntry object.\n831:         \"\"\"\n832:         from django.contrib.admin.models import LogEntry, DELETION\n833:         return LogEntry.objects.log_action(\n834:             user_id=request.user.pk,\n835:             content_type_id=get_content_type_for_model(object).pk,\n836:             object_id=object.pk,\n837:             object_repr=object_repr,\n838:             action_flag=DELETION,\n839:         )\n840: \n841:     def action_checkbox(self, obj):\n842:         \"\"\"\n843:         A list_display column containing a checkbox widget.\n844:         \"\"\"\n845:         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n846:     action_checkbox.short_description = mark_safe('<input type=\"checkbox\" id=\"action-toggle\">')\n847: \n848:     def _get_base_actions(self):\n849:         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n850:         actions = []\n851: \n852:         # Gather actions from the admin site first\n853:         for (name, func) in self.admin_site.actions:\n854:             description = getattr(func, 'short_description', name.replace('_', ' '))\n855:             actions.append((func, name, description))\n856:         # Add actions from this ModelAdmin.\n857:         actions.extend(self.get_action(action) for action in self.actions or [])\n858:         # get_action might have returned None, so filter any of those out.\n859:         return filter(None, actions)\n860: \n861:     def _filter_actions_by_permissions(self, request, actions):\n862:         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n863:         filtered_actions = []\n864:         for action in actions:\n865:             callable = action[0]\n866:             if not hasattr(callable, 'allowed_permissions'):\n867:                 filtered_actions.append(action)\n868:                 continue\n869:             permission_checks = (\n870:                 getattr(self, 'has_%s_permission' % permission)\n871:                 for permission in callable.allowed_permissions\n872:             )\n873:             if any(has_permission(request) for has_permission in permission_checks):\n874:                 filtered_actions.append(action)\n875:         return filtered_actions\n876: \n877:     def get_actions(self, request):\n878:         \"\"\"\n879:         Return a dictionary mapping the names of all actions for this\n880:         ModelAdmin to a tuple of (callable, name, description) for each action.\n881:         \"\"\"\n882:         # If self.actions is set to None that means actions are disabled on\n883:         # this page.\n884:         if self.actions is None or IS_POPUP_VAR in request.GET:\n885:             return {}\n886:         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n887:         return {name: (func, name, desc) for func, name, desc in actions}\n888: \n889:     def get_action_choices(self, request, default_choices=BLANK_CHOICE_DASH):\n890:         \"\"\"\n891:         Return a list of choices for use in a form object.  Each choice is a\n892:         tuple (name, description).\n893:         \"\"\"\n894:         choices = [] + default_choices\n895:         for func, name, description in self.get_actions(request).values():\n896:             choice = (name, description % model_format_dict(self.opts))\n897:             choices.append(choice)\n898:         return choices\n899: \n900:     def get_action(self, action):\n901:         \"\"\"\n902:         Return a given action from a parameter, which can either be a callable,\n903:         or the name of a method on the ModelAdmin.  Return is a tuple of\n904:         (callable, name, description).\n905:         \"\"\"\n906:         # If the action is a callable, just use it.\n907:         if callable(action):\n908:             func = action\n909:             action = action.__name__\n910: \n911:         # Next, look for a method. Grab it off self.__class__ to get an unbound\n912:         # method instead of a bound one; this ensures that the calling\n913:         # conventions are the same for functions and methods.\n914:         elif hasattr(self.__class__, action):\n915:             func = getattr(self.__class__, action)\n916: \n917:         # Finally, look for a named method on the admin site\n918:         else:\n919:             try:\n920:                 func = self.admin_site.get_action(action)\n921:             except KeyError:\n922:                 return None\n923: \n924:         if hasattr(func, 'short_description'):\n925:             description = func.short_description\n926:         else:\n927:             description = capfirst(action.replace('_', ' '))\n928:         return func, action, description\n929: \n930:     def get_list_display(self, request):\n931:         \"\"\"\n932:         Return a sequence containing the fields to be displayed on the\n933:         changelist.\n934:         \"\"\"\n935:         return self.list_display\n936: \n937:     def get_list_display_links(self, request, list_display):\n938:         \"\"\"\n939:         Return a sequence containing the fields to be displayed as links\n940:         on the changelist. The list_display parameter is the list of fields\n941:         returned by get_list_display().\n942:         \"\"\"\n943:         if self.list_display_links or self.list_display_links is None or not list_display:\n944:             return self.list_display_links\n945:         else:\n946:             # Use only the first item in list_display as link\n947:             return list(list_display)[:1]\n948: \n949:     def get_list_filter(self, request):\n950:         \"\"\"\n951:         Return a sequence containing the fields to be displayed as filters in\n952:         the right sidebar of the changelist page.\n953:         \"\"\"\n954:         return self.list_filter\n955: \n956:     def get_list_select_related(self, request):\n957:         \"\"\"\n958:         Return a list of fields to add to the select_related() part of the\n959:         changelist items query.\n960:         \"\"\"\n961:         return self.list_select_related\n962: \n963:     def get_search_fields(self, request):\n964:         \"\"\"\n965:         Return a sequence containing the fields to be searched whenever\n966:         somebody submits a search query.\n967:         \"\"\"\n968:         return self.search_fields\n969: \n970:     def get_search_results(self, request, queryset, search_term):\n971:         \"\"\"\n972:         Return a tuple containing a queryset to implement the search\n973:         and a boolean indicating if the results may contain duplicates.\n974:         \"\"\"\n975:         # Apply keyword searches.\n976:         def construct_search(field_name):\n977:             if field_name.startswith('^'):\n978:                 return \"%s__istartswith\" % field_name[1:]\n979:             elif field_name.startswith('='):\n980:                 return \"%s__iexact\" % field_name[1:]\n981:             elif field_name.startswith('@'):\n982:                 return \"%s__search\" % field_name[1:]\n983:             # Use field_name if it includes a lookup.\n984:             opts = queryset.model._meta\n985:             lookup_fields = field_name.split(LOOKUP_SEP)\n986:             # Go through the fields, following all relations.\n987:             prev_field = None\n988:             for path_part in lookup_fields:\n989:                 if path_part == 'pk':\n990:                     path_part = opts.pk.name\n991:                 try:\n992:                     field = opts.get_field(path_part)\n993:                 except FieldDoesNotExist:\n994:                     # Use valid query lookups.\n995:                     if prev_field and prev_field.get_lookup(path_part):\n996:                         return field_name\n997:                 else:\n998:                     prev_field = field\n999:                     if hasattr(field, 'get_path_info'):\n1000:                         # Update opts to follow the relation.\n1001:                         opts = field.get_path_info()[-1].to_opts\n1002:             # Otherwise, use the field with icontains.\n1003:             return \"%s__icontains\" % field_name\n1004: \n1005:         use_distinct = False\n1006:         search_fields = self.get_search_fields(request)\n1007:         if search_fields and search_term:\n1008:             orm_lookups = [construct_search(str(search_field))\n1009:                            for search_field in search_fields]\n1010:             for bit in search_term.split():\n1011:                 or_queries = [models.Q(**{orm_lookup: bit})\n1012:                               for orm_lookup in orm_lookups]\n1013:                 queryset = queryset.filter(reduce(operator.or_, or_queries))\n1014:             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)\n1015: \n1016:         return queryset, use_distinct\n1017: \n1018:     def get_preserved_filters(self, request):\n1019:         \"\"\"\n1020:         Return the preserved filters querystring.\n1021:         \"\"\"\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/options.py",
      "suspect_lines": [
        585
      ]
    }
  ]
}