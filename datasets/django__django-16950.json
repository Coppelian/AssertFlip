{
  "instance_id": "django__django-16950",
  "problem_statement": "Django Admin with Inlines not using UUIDField default value\nDescription\n\t \n\t\t(last modified by Joseph Metzinger)\n\t \nHello,\nI am a long time django user, first time bug reporter, so please let me know if I need to do anything else to help get this bug fixed :)\nI am using Django 3.1.3 and python 3.8.5 and have cerated a toy project to illustrate the bug. I have the following models:\nclass UUIDModel(models.Model):\n\tpkid = models.BigAutoField(primary_key=True, editable=False)\n\tid = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)\n\tclass Meta:\n\t\tabstract = True\nclass Thing(UUIDModel):\n\tname = models.CharField(max_length=191)\nclass SubThing(models.Model):\n\tname = models.CharField(max_length=191)\n\tthing = models.ForeignKey(\n\t\t'bugapp.Thing',\n\t\tto_field='id',\n\t\ton_delete = models.CASCADE,\n\t\trelated_name='subthings',\n\t)\nAnd the following admin.py file:\nclass SubThingInline(admin.StackedInline):\n\tmodel = SubThing\n@admin.register(Thing)\nclass ThingAdmin(admin.ModelAdmin):\n\tlist_display = ('name',)\n\tordering = ('pkid',)\n\tinlines = (SubThingInline,)\nWhen logging into the admin, if you delete all of the entries for \"subthings\", add a name, and save the model, it will work. As soon as you try to add a subthing alongside the main Thing, it fails with the following exception:\nâ€‹https://dpaste.com/8EU4FF6RW\nIt shows that the value of \"id\" in the Thing model is being set to null.\nI believe this is a bug in django.\nThanks!\n",
  "localized_code": "[start of django/forms/models.py]\n1: \"\"\"\n2: Helper functions for creating Form classes from Django models\n3: and database field objects.\n4: \"\"\"\n5: from itertools import chain\n6: \n7: from django.core.exceptions import (\n8:     NON_FIELD_ERRORS,\n9:     FieldError,\n10:     ImproperlyConfigured,\n11:     ValidationError,\n12: )\n13: from django.db.models.utils import AltersData\n14: from django.forms.fields import ChoiceField, Field\n15: from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n16: from django.forms.formsets import BaseFormSet, formset_factory\n17: from django.forms.utils import ErrorList\n18: from django.forms.widgets import (\n19:     HiddenInput,\n20:     MultipleHiddenInput,\n21:     RadioSelect,\n22:     SelectMultiple,\n23: )\n24: from django.utils.text import capfirst, get_text_list\n25: from django.utils.translation import gettext\n26: from django.utils.translation import gettext_lazy as _\n27: \n28: __all__ = (\n29:     \"ModelForm\",\n30:     \"BaseModelForm\",\n31:     \"model_to_dict\",\n32:     \"fields_for_model\",\n33:     \"ModelChoiceField\",\n34:     \"ModelMultipleChoiceField\",\n35:     \"ALL_FIELDS\",\n36:     \"BaseModelFormSet\",\n37:     \"modelformset_factory\",\n38:     \"BaseInlineFormSet\",\n39:     \"inlineformset_factory\",\n40:     \"modelform_factory\",\n41: )\n42: \n43: ALL_FIELDS = \"__all__\"\n44: \n45: \n46: def construct_instance(form, instance, fields=None, exclude=None):\n47:     \"\"\"\n48:     Construct and return a model instance from the bound ``form``'s\n49:     ``cleaned_data``, but do not save the returned instance to the database.\n50:     \"\"\"\n51:     from django.db import models\n52: \n53:     opts = instance._meta\n54: \n55:     cleaned_data = form.cleaned_data\n56:     file_field_list = []\n57:     for f in opts.fields:\n58:         if (\n59:             not f.editable\n60:             or isinstance(f, models.AutoField)\n61:             or f.name not in cleaned_data\n62:         ):\n63:             continue\n64:         if fields is not None and f.name not in fields:\n65:             continue\n66:         if exclude and f.name in exclude:\n67:             continue\n68:         # Leave defaults for fields that aren't in POST data, except for\n69:         # checkbox inputs because they don't appear in POST data if not checked.\n70:         if (\n71:             f.has_default()\n72:             and form[f.name].field.widget.value_omitted_from_data(\n73:                 form.data, form.files, form.add_prefix(f.name)\n74:             )\n75:             and cleaned_data.get(f.name) in form[f.name].field.empty_values\n76:         ):\n77:             continue\n78:         # Defer saving file-type fields until after the other fields, so a\n79:         # callable upload_to can use the values from other fields.\n80:         if isinstance(f, models.FileField):\n81:             file_field_list.append(f)\n82:         else:\n83:             f.save_form_data(instance, cleaned_data[f.name])\n84: \n85:     for f in file_field_list:\n86:         f.save_form_data(instance, cleaned_data[f.name])\n87: \n88:     return instance\n89: \n90: \n91: # ModelForms #################################################################\n92: \n93: \n94: def model_to_dict(instance, fields=None, exclude=None):\nCode replaced for brevity.\n116: \n117: \n118: \n119: def apply_limit_choices_to_to_formfield(formfield):\nCode replaced for brevity.\n133: \n134: \n135: \n136: ):\nCode replaced for brevity.\n251: \n252: \n253: \n254: class ModelFormOptions:\nCode replaced for brevity.\n265: \n266: \n267: \n268: class ModelFormMetaclass(DeclarativeFieldsMetaclass):\nCode replaced for brevity.\n338: \n339: \n340: \n341: class BaseModelForm(BaseForm, AltersData):\nCode replaced for brevity.\n558: \n559: \n560: \n561: class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n562:     pass\n563: \n564: \n565: ):\nCode replaced for brevity.\n650: \n651: \n652: \n653: # ModelFormSets ##############################################################\n654: \n655: \n656: class BaseModelFormSet(BaseFormSet, AltersData):\nCode replaced for brevity.\n1005: \n1006: \n1007: \n1008: ):\nCode replaced for brevity.\n1073: \n1074: \n1075: \n1076: # InlineFormSets #############################################################\n1077: \n1078: \n1079: class BaseInlineFormSet(BaseModelFormSet):\n1080:     \"\"\"A formset for child objects related to a parent.\"\"\"\n1081: \n1082:     def __init__(\n1083:         self,\n1084:         data=None,\n1085:         files=None,\n1086:         instance=None,\n1087:         save_as_new=False,\n1088:         prefix=None,\n1089:         queryset=None,\n1090:         **kwargs,\n1091:     ):\n1092:         if instance is None:\n1093:             self.instance = self.fk.remote_field.model()\n1094:         else:\n1095:             self.instance = instance\n1096:         self.save_as_new = save_as_new\n1097:         if queryset is None:\n1098:             queryset = self.model._default_manager\n1099:         if self.instance.pk is not None:\n1100:             qs = queryset.filter(**{self.fk.name: self.instance})\n1101:         else:\n1102:             qs = queryset.none()\n1103:         self.unique_fields = {self.fk.name}\n1104:         super().__init__(data, files, prefix=prefix, queryset=qs, **kwargs)\n1105: \n1106:         # Add the generated field to form._meta.fields if it's defined to make\n1107:         # sure validation isn't skipped on that field.\n1108:         if self.form._meta.fields and self.fk.name not in self.form._meta.fields:\n1109:             if isinstance(self.form._meta.fields, tuple):\n1110:                 self.form._meta.fields = list(self.form._meta.fields)\n1111:             self.form._meta.fields.append(self.fk.name)\n1112: \n1113:     def initial_form_count(self):\n1114:         if self.save_as_new:\n1115:             return 0\n1116:         return super().initial_form_count()\n1117: \n1118:     def _construct_form(self, i, **kwargs):\n1119:         form = super()._construct_form(i, **kwargs)\n1120:         if self.save_as_new:\n1121:             mutable = getattr(form.data, \"_mutable\", None)\n1122:             # Allow modifying an immutable QueryDict.\n1123:             if mutable is not None:\n1124:                 form.data._mutable = True\n1125:             # Remove the primary key from the form's data, we are only\n1126:             # creating new instances\n1127:             form.data[form.add_prefix(self._pk_field.name)] = None\n1128:             # Remove the foreign key from the form's data\n1129:             form.data[form.add_prefix(self.fk.name)] = None\n1130:             if mutable is not None:\n1131:                 form.data._mutable = mutable\n1132: \n1133:         # Set the fk value here so that the form can do its validation.\n1134:         fk_value = self.instance.pk\n1135:         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n1136:             fk_value = getattr(self.instance, self.fk.remote_field.field_name)\n1137:             fk_value = getattr(fk_value, \"pk\", fk_value)\n1138:         setattr(form.instance, self.fk.get_attname(), fk_value)\n1139:         return form\n1140: \n1141:     @classmethod\n1142:     def get_default_prefix(cls):\n1143:         return cls.fk.remote_field.get_accessor_name(model=cls.model).replace(\"+\", \"\")\n1144: \n1145:     def save_new(self, form, commit=True):\n1146:         # Ensure the latest copy of the related instance is present on each\n1147:         # form (it may have been saved after the formset was originally\n1148:         # instantiated).\n1149:         setattr(form.instance, self.fk.name, self.instance)\n1150:         return super().save_new(form, commit=commit)\n1151: \n1152:     def add_fields(self, form, index):\n1153:         super().add_fields(form, index)\n1154:         if self._pk_field == self.fk:\n1155:             name = self._pk_field.name\n1156:             kwargs = {\"pk_field\": True}\n1157:         else:\n1158:             # The foreign key field might not be on the form, so we poke at the\n1159:             # Model field to get the label, since we need that for error messages.\n1160:             name = self.fk.name\n1161:             kwargs = {\n1162:                 \"label\": getattr(\n1163:                     form.fields.get(name), \"label\", capfirst(self.fk.verbose_name)\n1164:                 )\n1165:             }\n1166: \n1167:         # The InlineForeignKeyField assumes that the foreign key relation is\n1168:         # based on the parent model's pk. If this isn't the case, set to_field\n1169:         # to correctly resolve the initial form value.\n1170:         if self.fk.remote_field.field_name != self.fk.remote_field.model._meta.pk.name:\n1171:             kwargs[\"to_field\"] = self.fk.remote_field.field_name\n1172: \n1173:         # If we're adding a new object, ignore a parent's auto-generated key\n1174:         # as it will be regenerated on the save request.\n1175:         if self.instance._state.adding:\n1176:             if kwargs.get(\"to_field\") is not None:\n1177:                 to_field = self.instance._meta.get_field(kwargs[\"to_field\"])\n1178:             else:\n1179:                 to_field = self.instance._meta.pk\n1180:             if to_field.has_default():\n1181:                 setattr(self.instance, to_field.attname, None)\n1182: \n1183:         form.fields[name] = InlineForeignKeyField(self.instance, **kwargs)\n1184: \n1185:     def get_unique_error_message(self, unique_check):\n1186:         unique_check = [field for field in unique_check if field != self.fk.name]\n1187:         return super().get_unique_error_message(unique_check)\n1188: \n1189: \n1190: def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\nCode replaced for brevity.\n1266: \n1267: \n1268: \n1269: ):\nCode replaced for brevity.\n1332: \n1333: \n1334: \n1335: # Fields #####################################################################\n1336: \n1337: \n1338: class InlineForeignKeyField(Field):\nCode replaced for brevity.\n1379: \n1380: \n1381: \n1382: class ModelChoiceIteratorValue:\nCode replaced for brevity.\n1396: \n1397: \n1398: \n1399: class ModelChoiceIterator:\nCode replaced for brevity.\n1427: \n1428: \n1429: \n1430: class ModelChoiceField(ChoiceField):\nCode replaced for brevity.\n1563: \n1564: \n1565: \n1566: class ModelMultipleChoiceField(ModelChoiceField):\nCode replaced for brevity.\n1662: \n1663: \n1664: \n1665:     retu\nCode replaced for brevity.\n1668: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/forms/models.py",
      "suspect_lines": [
        1180
      ]
    }
  ]
}