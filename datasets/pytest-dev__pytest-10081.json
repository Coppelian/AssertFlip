{
  "instance_id": "pytest-dev__pytest-10081",
  "problem_statement": "unittest.TestCase.tearDown executed for classes marked with `unittest.skip` when running --pdb\n<!--\r\nThanks for submitting an issue!\r\n\r\nQuick check-list while reporting bugs:\r\n-->\r\n\r\n- [x] a detailed description of the bug or problem you are having\r\n- [x] output of `pip list` from the virtual environment you are using\r\n- [x] pytest and operating system versions\r\n- [x] minimal example if possible\r\n\r\nRunning `pytest --pdb` will run the `tearDown()` of `unittest.TestCase` classes that are decorated with `unittest.skip` on the class level.\r\n\r\nIdentical to #7215 , but with the `skip()` on the class level rather than on the function level.\r\n\r\nMinimal test (adapted from #7215), `test_repro_skip_class.py`:\r\n```python\r\nimport unittest\r\n\r\n@unittest.skip(\"hello\")\r\nclass MyTestCase(unittest.TestCase):\r\n    def setUp(self):\r\n        xxx\r\n    def test_one(self):\r\n        pass\r\n    def tearDown(self):\r\n        xxx\r\n```\r\nSome versions (full below):\r\n```\r\n$ python --version\r\nPython 3.10.5\r\n$Â pytest --version\r\npytest 7.1.2\r\n$ cat /etc/issue\r\nUbuntu 20.04.4 LTS \\n \\l\r\n```\r\nTest is properly skipped normally:\r\n```\r\n$ pytest test_repro_skip_class.py\r\n===================================== test session starts ======================================\r\nplatform linux -- Python 3.10.5, pytest-7.1.2, pluggy-1.0.0\r\nrootdir: [...]\r\ncollected 1 item                                                                               \r\n\r\ntest_repro_skip_class.py s                                                               [100%]\r\n\r\n====================================== 1 skipped in 0.01s ======================================\r\n```\r\nbut when running with `--pdb`, the teardown seems executed:\r\n```\r\n$ pytest --pdb test_repro_skip_class.py\r\n===================================== test session starts ======================================\r\nplatform linux -- Python 3.10.5, pytest-7.1.2, pluggy-1.0.0\r\nrootdir: [..]\r\ncollected 1 item                                                                               \r\n\r\ntest_repro_skip_class.py sE\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> traceback >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n\r\nself = <test_repro_skip_class.MyTestCase testMethod=test_one>\r\n\r\n    def tearDown(self):\r\n>       xxx\r\nE       NameError: name 'xxx' is not defined\r\n\r\ntest_repro_skip_class.py:10: NameError\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> entering PDB >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n\r\n>>>>>>>>>>>>>>>>>>>>>>>>>> PDB post_mortem (IO-capturing turned off) >>>>>>>>>>>>>>>>>>>>>>>>>>>\r\n> /mnt/raid/hugo/research/micado/wise/t/test_repro_skip_class.py(10)tearDown()\r\n-> xxx\r\n(Pdb) \r\n```\r\n\r\nFull versions:\r\n```\r\n$ pip list\r\nPackage    Version\r\n---------- -------\r\nattrs      21.4.0\r\niniconfig  1.1.1\r\npackaging  21.3\r\npip        22.1.2\r\npluggy     1.0.0\r\npy         1.11.0\r\npyparsing  3.0.9\r\npytest     7.1.2\r\nsetuptools 62.6.0\r\ntomli      2.0.1\r\nwheel      0.37.1\r\n```\r\n\n",
  "localized_code": "[start of src/_pytest/unittest.py]\n1: \"\"\"Discover and run std-library \"unittest\" style tests.\"\"\"\n2: import sys\n3: import traceback\n4: import types\n5: from typing import Any\n6: from typing import Callable\n7: from typing import Generator\n8: from typing import Iterable\n9: from typing import List\n10: from typing import Optional\n11: from typing import Tuple\n12: from typing import Type\n13: from typing import TYPE_CHECKING\n14: from typing import Union\n15: \n16: import _pytest._code\n17: import pytest\n18: from _pytest.compat import getimfunc\n19: from _pytest.compat import is_async_function\n20: from _pytest.config import hookimpl\n21: from _pytest.fixtures import FixtureRequest\n22: from _pytest.nodes import Collector\n23: from _pytest.nodes import Item\n24: from _pytest.outcomes import exit\n25: from _pytest.outcomes import fail\n26: from _pytest.outcomes import skip\n27: from _pytest.outcomes import xfail\n28: from _pytest.python import Class\n29: from _pytest.python import Function\n30: from _pytest.python import Module\n31: from _pytest.runner import CallInfo\n32: from _pytest.scope import Scope\n33: \n34: if TYPE_CHECKING:\n35:     import unittest\n36:     import twisted.trial.unittest\n37: \n38:     _SysExcInfoType = Union[\n39:         Tuple[Type[BaseException], BaseException, types.TracebackType],\n40:         Tuple[None, None, None],\n41:     ]\n42: \n43: \n44: def pytest_pycollect_makeitem(\n45:     collector: Union[Module, Class], name: str, obj: object\n46: ) -> Optional[\"UnitTestCase\"]:\n47:     # Has unittest been imported and is obj a subclass of its TestCase?\n48:     try:\n49:         ut = sys.modules[\"unittest\"]\n50:         # Type ignored because `ut` is an opaque module.\n51:         if not issubclass(obj, ut.TestCase):  # type: ignore\n52:             return None\n53:     except Exception:\n54:         return None\n55:     # Yes, so let's collect it.\n56:     item: UnitTestCase = UnitTestCase.from_parent(collector, name=name, obj=obj)\n57:     return item\n58: \n59: \n60:     # to declare that our children do not support funcargs.\nCode replaced for brevity.\n119: \n120: \n121: \n122: ):\nCode replaced for brevity.\n180: \n181: \n182: \n183: class TestCaseFunction(Function):\n184:     nofuncargs = True\n185:     _excinfo: Optional[List[_pytest._code.ExceptionInfo[BaseException]]] = None\n186:     _testcase: Optional[\"unittest.TestCase\"] = None\n187: \n188:     def _getobj(self):\n189:         assert self.parent is not None\n190:         # Unlike a regular Function in a Class, where `item.obj` returns\n191:         # a *bound* method (attached to an instance), TestCaseFunction's\n192:         # `obj` returns an *unbound* method (not attached to an instance).\n193:         # This inconsistency is probably not desirable, but needs some\n194:         # consideration before changing.\n195:         return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n196: \n197:     def setup(self) -> None:\n198:         # A bound method to be called during teardown() if set (see 'runtest()').\n199:         self._explicit_tearDown: Optional[Callable[[], None]] = None\n200:         assert self.parent is not None\n201:         self._testcase = self.parent.obj(self.name)  # type: ignore[attr-defined]\n202:         self._obj = getattr(self._testcase, self.name)\n203:         if hasattr(self, \"_request\"):\n204:             self._request._fillfixtures()\n205: \n206:     def teardown(self) -> None:\n207:         if self._explicit_tearDown is not None:\n208:             self._explicit_tearDown()\n209:             self._explicit_tearDown = None\n210:         self._testcase = None\n211:         self._obj = None\n212: \n213:     def startTest(self, testcase: \"unittest.TestCase\") -> None:\n214:         pass\n215: \n216:     def _addexcinfo(self, rawexcinfo: \"_SysExcInfoType\") -> None:\n217:         # Unwrap potential exception info (see twisted trial support below).\n218:         rawexcinfo = getattr(rawexcinfo, \"_rawexcinfo\", rawexcinfo)\n219:         try:\n220:             excinfo = _pytest._code.ExceptionInfo[BaseException].from_exc_info(rawexcinfo)  # type: ignore[arg-type]\n221:             # Invoke the attributes to trigger storing the traceback\n222:             # trial causes some issue there.\n223:             excinfo.value\n224:             excinfo.traceback\n225:         except TypeError:\n226:             try:\n227:                 try:\n228:                     values = traceback.format_exception(*rawexcinfo)\n229:                     values.insert(\n230:                         0,\n231:                         \"NOTE: Incompatible Exception Representation, \"\n232:                         \"displaying natively:\\n\\n\",\n233:                     )\n234:                     fail(\"\".join(values), pytrace=False)\n235:                 except (fail.Exception, KeyboardInterrupt):\n236:                     raise\n237:                 except BaseException:\n238:                     fail(\n239:                         \"ERROR: Unknown Incompatible Exception \"\n240:                         \"representation:\\n%r\" % (rawexcinfo,),\n241:                         pytrace=False,\n242:                     )\n243:             except KeyboardInterrupt:\n244:                 raise\n245:             except fail.Exception:\n246:                 excinfo = _pytest._code.ExceptionInfo.from_current()\n247:         self.__dict__.setdefault(\"_excinfo\", []).append(excinfo)\n248: \n249:     def addError(\n250:         self, testcase: \"unittest.TestCase\", rawexcinfo: \"_SysExcInfoType\"\n251:     ) -> None:\n252:         try:\n253:             if isinstance(rawexcinfo[1], exit.Exception):\n254:                 exit(rawexcinfo[1].msg)\n255:         except TypeError:\n256:             pass\n257:         self._addexcinfo(rawexcinfo)\n258: \n259:     def addFailure(\n260:         self, testcase: \"unittest.TestCase\", rawexcinfo: \"_SysExcInfoType\"\n261:     ) -> None:\n262:         self._addexcinfo(rawexcinfo)\n263: \n264:     def addSkip(self, testcase: \"unittest.TestCase\", reason: str) -> None:\n265:         try:\n266:             raise pytest.skip.Exception(reason, _use_item_location=True)\n267:         except skip.Exception:\n268:             self._addexcinfo(sys.exc_info())\n269: \n270:     def addExpectedFailure(\n271:         self,\n272:         testcase: \"unittest.TestCase\",\n273:         rawexcinfo: \"_SysExcInfoType\",\n274:         reason: str = \"\",\n275:     ) -> None:\n276:         try:\n277:             xfail(str(reason))\n278:         except xfail.Exception:\n279:             self._addexcinfo(sys.exc_info())\n280: \n281:     def addUnexpectedSuccess(\n282:         self,\n283:         testcase: \"unittest.TestCase\",\n284:         reason: Optional[\"twisted.trial.unittest.Todo\"] = None,\n285:     ) -> None:\n286:         msg = \"Unexpected success\"\n287:         if reason:\n288:             msg += f\": {reason.reason}\"\n289:         # Preserve unittest behaviour - fail the test. Explicitly not an XPASS.\n290:         try:\n291:             fail(msg, pytrace=False)\n292:         except fail.Exception:\n293:             self._addexcinfo(sys.exc_info())\n294: \n295:     def addSuccess(self, testcase: \"unittest.TestCase\") -> None:\n296:         pass\n297: \n298:     def stopTest(self, testcase: \"unittest.TestCase\") -> None:\n299:         pass\n300: \n301:     def runtest(self) -> None:\n302:         from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n303: \n304:         assert self._testcase is not None\n305: \n306:         maybe_wrap_pytest_function_for_tracing(self)\n307: \n308:         # Let the unittest framework handle async functions.\n309:         if is_async_function(self.obj):\n310:             # Type ignored because self acts as the TestResult, but is not actually one.\n311:             self._testcase(result=self)  # type: ignore[arg-type]\n312:         else:\n313:             # When --pdb is given, we want to postpone calling tearDown() otherwise\n314:             # when entering the pdb prompt, tearDown() would have probably cleaned up\n315:             # instance variables, which makes it difficult to debug.\n316:             # Arguably we could always postpone tearDown(), but this changes the moment where the\n317:             # TestCase instance interacts with the results object, so better to only do it\n318:             # when absolutely needed.\n319:             if self.config.getoption(\"usepdb\") and not _is_skipped(self.obj):\n320:                 self._explicit_tearDown = self._testcase.tearDown\n321:                 setattr(self._testcase, \"tearDown\", lambda *args: None)\n322: \n323:             # We need to update the actual bound method with self.obj, because\n324:             # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.\n325:             setattr(self._testcase, self.name, self.obj)\n326:             try:\n327:                 self._testcase(result=self)  # type: ignore[arg-type]\n328:             finally:\n329:                 delattr(self._testcase, self.name)\n330: \n331:     def _prunetraceback(\n332:         self, excinfo: _pytest._code.ExceptionInfo[BaseException]\n333:     ) -> None:\n334:         super()._prunetraceback(excinfo)\n335:         traceback = excinfo.traceback.filter(\n336:             lambda x: not x.frame.f_globals.get(\"__unittest\")\n337:         )\n338:         if traceback:\n339:             excinfo.traceback = traceback\n340: \n341: \n342: @hookimpl(tryfirst=True)\n343: def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> None:\nCode replaced for brevity.\n366: \n367: \n368: \n369: # Twisted trial support.\n370: \n371: \n372: @hookimpl(hookwrapper=True)\n373: def pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\nCode replaced for brevity.\n399: \n400: \n401: \n402: def check_testcase_implements_trial_reporter(done: List[int] = []) -> None:\nCode replaced for brevity.\n409: \n410: \n411: \n412: def _is_skipped(obj) -> bool:\nCode replaced for brevity.\n414: \n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/unittest.py",
      "suspect_lines": [
        319
      ]
    }
  ]
}