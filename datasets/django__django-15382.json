{
  "instance_id": "django__django-15382",
  "problem_statement": "filter on exists-subquery with empty queryset removes whole WHERE block\nDescription\n\t \n\t\t(last modified by Tobias Bengfort)\n\t \n>>> qs = MyModel.objects.filter(~models.Exists(MyModel.objects.none()), name='test')\n>>> qs\n<QuerySet []>\n>>> print(qs.query)\nEmptyResultSet\nWith django-debug-toolbar I can still see the query, but there WHERE block is missing completely.\nThis seems to be very similar to #33018.\n",
  "localized_code": "[start of django/db/models/expressions.py]\n1: import copy\n2: import datetime\n3: import functools\n4: import inspect\n5: from decimal import Decimal\n6: from uuid import UUID\n7: \n8: from django.core.exceptions import EmptyResultSet, FieldError\n9: from django.db import DatabaseError, NotSupportedError, connection\n10: from django.db.models import fields\n11: from django.db.models.constants import LOOKUP_SEP\n12: from django.db.models.query_utils import Q\n13: from django.utils.deconstruct import deconstructible\n14: from django.utils.functional import cached_property\n15: from django.utils.hashable import make_hashable\n16: \n17: \n18: class SQLiteNumericMixin:\n19:     \"\"\"\n20:     Some expressions with output_field=DecimalField() must be cast to\n21:     numeric to be properly filtered.\n22:     \"\"\"\n23:     def as_sqlite(self, compiler, connection, **extra_context):\n24:         sql, params = self.as_sql(compiler, connection, **extra_context)\n25:         try:\n26:             if self.output_field.get_internal_type() == 'DecimalField':\n27:                 sql = 'CAST(%s AS NUMERIC)' % sql\n28:         except FieldError:\n29:             pass\n30:         return sql, params\n31: \n32: \n33: class Combinable:\n34:     \"\"\"\n35:     Provide the ability to combine one or two objects with\n36:     some connector. For example F('foo') + F('bar').\n37:     \"\"\"\n38: \n39:     # Arithmetic connectors\n40:     ADD = '+'\n41:     SUB = '-'\n42:     MUL = '*'\n43:     DIV = '/'\n44:     POW = '^'\n45:     # The following is a quoted % operator - it is quoted because it can be\n46:     # used in strings that also have parameter substitution.\n47:     MOD = '%%'\n48: \n49:     # Bitwise operators - note that these are generated by .bitand()\n50:     # and .bitor(), the '&' and '|' are reserved for boolean operator\n51:     # usage.\n52:     BITAND = '&'\n53:     BITOR = '|'\n54:     BITLEFTSHIFT = '<<'\n55:     BITRIGHTSHIFT = '>>'\n56:     BITXOR = '#'\n57: \n58:     def _combine(self, other, connector, reversed):\n59:         if not hasattr(other, 'resolve_expression'):\n60:             # everything must be resolvable to an expression\n61:             other = Value(other)\n62: \n63:         if reversed:\n64:             return CombinedExpression(other, connector, self)\n65:         return CombinedExpression(self, connector, other)\n66: \n67:     #############\n68:     # OPERATORS #\n69:     #############\n70: \n71:     def __neg__(self):\n72:         return self._combine(-1, self.MUL, False)\n73: \n74:     def __add__(self, other):\n75:         return self._combine(other, self.ADD, False)\n76: \n77:     def __sub__(self, other):\n78:         return self._combine(other, self.SUB, False)\n79: \n80:     def __mul__(self, other):\n81:         return self._combine(other, self.MUL, False)\n82: \n83:     def __truediv__(self, other):\n84:         return self._combine(other, self.DIV, False)\n85: \n86:     def __mod__(self, other):\n87:         return self._combine(other, self.MOD, False)\n88: \n89:     def __pow__(self, other):\n90:         return self._combine(other, self.POW, False)\n91: \n92:     def __and__(self, other):\n93:         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n94:             return Q(self) & Q(other)\n95:         raise NotImplementedError(\n96:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n97:         )\n98: \n99:     def bitand(self, other):\n100:         return self._combine(other, self.BITAND, False)\n101: \n102:     def bitleftshift(self, other):\n103:         return self._combine(other, self.BITLEFTSHIFT, False)\n104: \n105:     def bitrightshift(self, other):\n106:         return self._combine(other, self.BITRIGHTSHIFT, False)\n107: \n108:     def bitxor(self, other):\n109:         return self._combine(other, self.BITXOR, False)\n110: \n111:     def __or__(self, other):\n112:         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n113:             return Q(self) | Q(other)\n114:         raise NotImplementedError(\n115:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n116:         )\n117: \n118:     def bitor(self, other):\n119:         return self._combine(other, self.BITOR, False)\n120: \n121:     def __radd__(self, other):\n122:         return self._combine(other, self.ADD, True)\n123: \n124:     def __rsub__(self, other):\n125:         return self._combine(other, self.SUB, True)\n126: \n127:     def __rmul__(self, other):\n128:         return self._combine(other, self.MUL, True)\n129: \n130:     def __rtruediv__(self, other):\n131:         return self._combine(other, self.DIV, True)\n132: \n133:     def __rmod__(self, other):\n134:         return self._combine(other, self.MOD, True)\n135: \n136:     def __rpow__(self, other):\n137:         return self._combine(other, self.POW, True)\n138: \n139:     def __rand__(self, other):\n140:         raise NotImplementedError(\n141:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n142:         )\n143: \n144:     def __ror__(self, other):\n145:         raise NotImplementedError(\n146:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n147:         )\n148: \n149: \n150: class BaseExpression:\nCode replaced for brevity.\n390: \n391: \n392: \n393: @deconstructible\n394: class Expression(BaseExpression, Combinable):\nCode replaced for brevity.\n422: \n423: \n424: \n425: _connector_combinators = {\n426:     connector: [\n427:         (fields.IntegerField, fields.IntegerField, fields.IntegerField),\n428:         (fields.IntegerField, fields.DecimalField, fields.DecimalField),\n429:         (fields.DecimalField, fields.IntegerField, fields.DecimalField),\n430:         (fields.IntegerField, fields.FloatField, fields.FloatField),\n431:         (fields.FloatField, fields.IntegerField, fields.FloatField),\n432:     ]\n433:     for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)\n434: }\n435: \n436: \n437: @functools.lru_cache(maxsize=128)\n438: def _resolve_combined_type(connector, lhs_type, rhs_type):\nCode replaced for brevity.\n442: \n443: \n444: \n445: class CombinedExpression(SQLiteNumericMixin, Expression):\nCode replaced for brevity.\n517: \n518: \n519: \n520: class DurationExpression(CombinedExpression):\nCode replaced for brevity.\n565: \n566: \n567: \n568: class TemporalSubtraction(CombinedExpression):\nCode replaced for brevity.\n578: \n579: \n580: \n581: @deconstructible(path='django.db.models.F')\n582: class F(Combinable):\nCode replaced for brevity.\n609: \n610: \n611: \n612: class ResolvedOuterRef(F):\nCode replaced for brevity.\n639: \n640: \n641: \n642:     c\nCode replaced for brevity.\n651: \n652: \n653: \n654: @deconstructible(path='django.db.models.Func')\n655:     \"\nCode replaced for brevity.\n732: \n733: \n734: \n735: @deconstructible(path='django.db.models.Value')\n736:     \"\nCode replaced for brevity.\n809: \n810: \n811: \n812:     d\nCode replaced for brevity.\n836: \n837: \n838: \n839:     d\nCode replaced for brevity.\n844: \n845: \n846: \n847:     c\nCode replaced for brevity.\n881: \n882: \n883: \n884:     \"\nCode replaced for brevity.\n914: \n915: \n916: \n917:     \"\nCode replaced for brevity.\n935: \n936: \n937: \n938:     t\nCode replaced for brevity.\n955: \n956: \n957: \n958: @deconstructible(path='django.db.models.ExpressionWrapper')\n959:     \"\nCode replaced for brevity.\n988: \n989: \n990: \n991: @deconstructible(path='django.db.models.When')\n992:     t\nCode replaced for brevity.\n1056: \n1057: \n1058: \n1059: @deconstructible(path='django.db.models.Case')\n1060:     \"\nCode replaced for brevity.\n1138: \n1139: \n1140: \n1141:     \"\nCode replaced for brevity.\n1196: \n1197: \n1198: \n1199: class Exists(Subquery):\n1200:     template = 'EXISTS(%(subquery)s)'\n1201:     output_field = fields.BooleanField()\n1202: \n1203:     def __init__(self, queryset, negated=False, **kwargs):\n1204:         self.negated = negated\n1205:         super().__init__(queryset, **kwargs)\n1206: \n1207:     def __invert__(self):\n1208:         clone = self.copy()\n1209:         clone.negated = not self.negated\n1210:         return clone\n1211: \n1212:     def as_sql(self, compiler, connection, template=None, **extra_context):\n1213:         query = self.query.exists(using=connection.alias)\n1214:         sql, params = super().as_sql(\n1215:             compiler,\n1216:             connection,\n1217:             template=template,\n1218:             query=query,\n1219:             **extra_context,\n1220:         )\n1221:         if self.negated:\n1222:             sql = 'NOT {}'.format(sql)\n1223:         return sql, params\n1224: \n1225:     def select_format(self, compiler, sql, params):\n1226:         # Wrap EXISTS() with a CASE WHEN expression if a database backend\n1227:         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP\n1228:         # BY list.\n1229:         if not compiler.connection.features.supports_boolean_expr_in_select_clause:\n1230:             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n1231:         return sql, params\n1232: \n1233: \n1234: @deconstructible(path='django.db.models.OrderBy')\n1235:     t\nCode replaced for brevity.\n1314: \n1315: \n1316: \n1317:     t\nCode replaced for brevity.\n1419: \n1420: \n1421: \n1422:     \"\nCode replaced for brevity.\n1478: \n1479: \n1480: \n1481:     f\nCode replaced for brevity.\n1485: \n1486: \n1487: \n1488:     f\nCode replaced for brevity.\n1492: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/expressions.py",
      "suspect_lines": [
        1214,
        1215,
        1216,
        1217,
        1218,
        1219,
        1220
      ]
    }
  ]
}