{
  "instance_id": "matplotlib__matplotlib-14623",
  "problem_statement": "Inverting an axis using its limits does not work for log scale\n### Bug report\r\n\r\n**Bug summary**\r\nStarting in matplotlib 3.1.0 it is no longer possible to invert a log axis using its limits.\r\n\r\n**Code for reproduction**\r\n```python\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\ny = np.linspace(1000e2, 1, 100)\r\nx = np.exp(-np.linspace(0, 1, y.size))\r\n\r\nfor yscale in ('linear', 'log'):\r\n    fig, ax = plt.subplots()\r\n    ax.plot(x, y)\r\n    ax.set_yscale(yscale)\r\n    ax.set_ylim(y.max(), y.min())\r\n```\r\n\r\n**Actual outcome**\r\nThe yaxis is only inverted for the ``\"linear\"`` scale.\r\n\r\n![linear](https://user-images.githubusercontent.com/9482218/60081191-99245e80-9731-11e9-9e4a-eadb3ef58666.png)\r\n\r\n![log](https://user-images.githubusercontent.com/9482218/60081203-9e81a900-9731-11e9-8bae-0be1c9762b16.png)\r\n\r\n**Expected outcome**\r\nI would expect the yaxis to be inverted for both the ``\"linear\"`` and the ``\"log\"`` scale.\r\n\r\n**Matplotlib version**\r\n  * Operating system: Linux and MacOS\r\n  * Matplotlib version: 3.1.0 \r\n  * Python version: 3.7.3\r\n \r\nPython and matplotlib have been installed using conda.\r\n\n",
  "localized_code": "[start of lib/matplotlib/axes/_base.py]\n1: from collections import OrderedDict\n2: import itertools\n3: import logging\n4: import math\n5: from numbers import Real\n6: from operator import attrgetter\n7: import types\n8: \n9: import numpy as np\n10: \n11: import matplotlib as mpl\n12: from matplotlib import cbook, rcParams\n13: from matplotlib.cbook import _OrderedSet, _check_1d, index_of, get_label\n14: from matplotlib import docstring\n15: import matplotlib.colors as mcolors\n16: import matplotlib.lines as mlines\n17: import matplotlib.patches as mpatches\n18: import matplotlib.artist as martist\n19: import matplotlib.transforms as mtransforms\n20: import matplotlib.ticker as mticker\n21: import matplotlib.axis as maxis\n22: import matplotlib.scale as mscale\n23: import matplotlib.spines as mspines\n24: import matplotlib.font_manager as font_manager\n25: import matplotlib.text as mtext\n26: import matplotlib.image as mimage\n27: from matplotlib.rcsetup import cycler, validate_axisbelow\n28: \n29: _log = logging.getLogger(__name__)\n30: \n31: \n32: def _process_plot_format(fmt):\n33:     \"\"\"\n34:     Convert a MATLAB style color/line style format string to a (*linestyle*,\n35:     *marker*, *color*) tuple.\n36: \n37:     Example format strings include:\n38: \n39:     * 'ko': black circles\n40:     * '.b': blue dots\n41:     * 'r--': red dashed lines\n42:     * 'C2--': the third color in the color cycle, dashed lines\n43: \n44:     See Also\n45:     --------\n46:     matplotlib.Line2D.lineStyles, matplotlib.colors.cnames\n47:         All possible styles and color format strings.\n48:     \"\"\"\n49: \n50:     linestyle = None\n51:     marker = None\n... Code Truncated ...\n\n[start of lib/matplotlib/ticker.py]\n1: \"\"\"\n2: Tick locating and formatting\n3: ============================\n4: \n5: This module contains classes to support completely configurable tick\n6: locating and formatting. Although the locators know nothing about major\n7: or minor ticks, they are used by the Axis class to support major and\n8: minor tick locating and formatting. Generic tick locators and\n9: formatters are provided, as well as domain specific custom ones.\n10: \n11: Default Formatter\n12: -----------------\n13: \n14: The default formatter identifies when the x-data being plotted is a\n15: small range on top of a large offset. To reduce the chances that the\n16: ticklabels overlap, the ticks are labeled as deltas from a fixed offset.\n17: For example::\n18: \n19:    ax.plot(np.arange(2000, 2010), range(10))\n20: \n21: will have tick of 0-9 with an offset of +2e3. If this is not desired\n22: turn off the use of the offset on the default formatter::\n23: \n24:    ax.get_xaxis().get_major_formatter().set_useOffset(False)\n25: \n26: set the rcParam ``axes.formatter.useoffset=False`` to turn it off\n27: globally, or set a different formatter.\n28: \n29: Tick locating\n30: -------------\n31: \n32: The Locator class is the base class for all tick locators. The locators\n33: handle autoscaling of the view limits based on the data limits, and the\n34: choosing of tick locations. A useful semi-automatic tick locator is\n35: `MultipleLocator`. It is initialized with a base, e.g., 10, and it picks\n36: axis limits and ticks that are multiples of that base.\n37: \n38: The Locator subclasses defined here are\n39: \n40: :class:`AutoLocator`\n41:     `MaxNLocator` with simple defaults.  This is the default tick locator for\n42:     most plotting.\n43: \n44: :class:`MaxNLocator`\n45:     Finds up to a max number of intervals with ticks at nice locations.\n46: \n47: :class:`LinearLocator`\n48:     Space ticks evenly from min to max.\n49: \n50: :class:`LogLocator`\n51:     Space ticks logarithmically from min to max.\n52: \n53: :class:`MultipleLocator`\n54:     Ticks and range are a multiple of base; either integer or float.\n55: \n56: :class:`FixedLocator`\n57:     Tick locations are fixed.\n58: \n59: :class:`IndexLocator`\n60:     Locator for index plots (e.g., where ``x = range(len(y))``).\n61: \n62: :class:`NullLocator`\n63:     No ticks.\n64: \n65: :class:`SymmetricalLogLocator`\n66:     Locator for use with with the symlog norm; works like `LogLocator` for the\n67:     part outside of the threshold and adds 0 if inside the limits.\n68: \n69: :class:`LogitLocator`\n70:     Locator for logit scaling.\n71: \n72: :class:`OldAutoLocator`\n73:     Choose a `MultipleLocator` and dynamically reassign it for intelligent\n74:     ticking during navigation.\n75: \n76: :class:`AutoMinorLocator`\n77:     Locator for minor ticks when the axis is linear and the\n78:     major ticks are uniformly spaced.  Subdivides the major\n79:     tick interval into a specified number of minor intervals,\n80:     defaulting to 4 or 5 depending on the major interval.\n81: \n82: \n83: There are a number of locators specialized for date locations - see\n84: the `dates` module.\n85: \n86: You can define your own locator by deriving from Locator. You must\n87: override the ``__call__`` method, which returns a sequence of locations,\n88: and you will probably want to override the autoscale method to set the\n89: view limits from the data limits.\n90: \n91: If you want to override the default locator, use one of the above or a custom\n92: locator and pass it to the x or y axis instance. The relevant methods are::\n93: \n94:   ax.xaxis.set_major_locator(xmajor_locator)\n95:   ax.xaxis.set_minor_locator(xminor_locator)\n96:   ax.yaxis.set_major_locator(ymajor_locator)\n97:   ax.yaxis.set_minor_locator(yminor_locator)\n98: \n99: The default minor locator is `NullLocator`, i.e., no minor ticks on by default.\n100: \n101: Tick formatting\n102: ---------------\n103: \n104: Tick formatting is controlled by classes derived from Formatter. The formatter\n105: operates on a single tick value and returns a string to the axis.\n106: \n107: :class:`NullFormatter`\n108:     No labels on the ticks.\n109: \n110: :class:`IndexFormatter`\n111:     Set the strings from a list of labels.\n112: \n113: :class:`FixedFormatter`\n114:     Set the strings manually for the labels.\n115: \n116: :class:`FuncFormatter`\n117:     User defined function sets the labels.\n118: \n119: :class:`StrMethodFormatter`\n120:     Use string `format` method.\n121: \n122: :class:`FormatStrFormatter`\n123:     Use an old-style sprintf format string.\n124: \n125: :class:`ScalarFormatter`\n126:     Default formatter for scalars: autopick the format string.\n127: \n128: :class:`LogFormatter`\n129:     Formatter for log axes.\n130: \n131: :class:`LogFormatterExponent`\n132:     Format values for log axis using ``exponent = log_base(value)``.\n133: \n134: :class:`LogFormatterMathtext`\n135:     Format values for log axis using ``exponent = log_base(value)``\n136:     using Math text.\n137: \n138: :class:`LogFormatterSciNotation`\n139:     Format values for log axis using scientific notation.\n140: \n141: :class:`LogitFormatter`\n142:     Probability formatter.\n143: \n144: :class:`EngFormatter`\n145:     Format labels in engineering notation\n146: \n147: :class:`PercentFormatter`\n148:     Format labels as a percentage\n149: \n150: You can derive your own formatter from the Formatter base class by\n151: simply overriding the ``__call__`` method. The formatter class has\n152: access to the axis view and data limits.\n153: \n154: To control the major and minor tick label formats, use one of the\n155: following methods::\n156: \n157:   ax.xaxis.set_major_formatter(xmajor_formatter)\n158:   ax.xaxis.set_minor_formatter(xminor_formatter)\n159:   ax.yaxis.set_major_formatter(ymajor_formatter)\n160:   ax.yaxis.set_minor_formatter(yminor_formatter)\n161: \n162: See :doc:`/gallery/ticks_and_spines/major_minor_demo` for an\n163: example of setting major and minor ticks. See the :mod:`matplotlib.dates`\n164: module for more information and examples of using date locators and formatters.\n165: \"\"\"\n166: \n167: import itertools\n168: import logging\n169: import locale\n170: import math\n171: import numpy as np\n172: from matplotlib import rcParams\n173: from matplotlib import cbook\n174: from matplotlib import transforms as mtransforms\n175: \n176: _log = logging.getLogger(__name__)\n177: \n178: __all__ = ('TickHelper', 'Formatter', 'FixedFormatter',\n179:            'NullFormatter', 'FuncFormatter', 'FormatStrFormatter',\n180:            'StrMethodFormatter', 'ScalarFormatter', 'LogFormatter',\n181:            'LogFormatterExponent', 'LogFormatterMathtext',\n182:            'IndexFormatter', 'LogFormatterSciNotation',\n183:            'LogitFormatter', 'EngFormatter', 'PercentFormatter',\n184:            'Locator', 'IndexLocator', 'FixedLocator', 'NullLocator',\n185:            'LinearLocator', 'LogLocator', 'AutoLocator',\n186:            'MultipleLocator', 'MaxNLocator', 'AutoMinorLocator',\n187:            'SymmetricalLogLocator', 'LogitLocator')\n188: \n189: \n190: def _mathdefault(s):\n191:     return '\\\\mathdefault{%s}' % s\n192: \n193: \n194: class _DummyAxis(object):\nCode replaced for brevity.\n217: \n218: \n219: \n220: class TickHelper(object):\nCode replaced for brevity.\n238: \n239: \n240: \n241: class Formatter(TickHelper):\nCode replaced for brevity.\n300: \n301: \n302: \n303: class IndexFormatter(Formatter):\nCode replaced for brevity.\n328: \n329: \n330: \n331: class NullFormatter(Formatter):\nCode replaced for brevity.\n339: \n340: \n341: \n342: class FixedFormatter(Formatter):\nCode replaced for brevity.\n371: \n372: \n373: \n374: class FuncFormatter(Formatter):\nCode replaced for brevity.\n391: \n392: \n393: \n394: class FormatStrFormatter(Formatter):\nCode replaced for brevity.\n410: \n411: \n412: \n413: class StrMethodFormatter(Formatter):\nCode replaced for brevity.\n431: \n432: \n433: \n434: class OldScalarFormatter(Formatter):\nCode replaced for brevity.\n496: \n497: \n498: \n499: class ScalarFormatter(Formatter):\nCode replaced for brevity.\n836: \n837: \n838: \n839: class LogFormatter(Formatter):\nCode replaced for brevity.\n1065: \n1066: \n1067: \n1068: class LogFormatterExponent(LogFormatter):\nCode replaced for brevity.\n1081: \n1082: \n1083: \n1084: class LogFormatterMathtext(LogFormatter):\nCode replaced for brevity.\n1146: \n1147: \n1148: \n1149: class LogFormatterSciNotation(LogFormatterMathtext):\nCode replaced for brevity.\n1166: \n1167: \n1168: \n1169: class LogitFormatter(Formatter):\nCode replaced for brevity.\n1191: \n1192: \n1193: \n1194: class EngFormatter(Formatter):\nCode replaced for brevity.\n1348: \n1349: \n1350: \n1351: class PercentFormatter(Formatter):\nCode replaced for brevity.\n1464: \n1465: \n1466: \n1467: class Locator(TickHelper):\n1468:     \"\"\"\n1469:     Determine the tick locations;\n1470: \n1471:     Note that the same locator should not be used across multiple\n1472:     `~matplotlib.axis.Axis` because the locator stores references to the Axis\n1473:     data and view limits.\n1474:     \"\"\"\n1475: \n1476:     # Some automatic tick locators can generate so many ticks they\n1477:     # kill the machine when you try and render them.\n1478:     # This parameter is set to cause locators to raise an error if too\n1479:     # many ticks are generated.\n1480:     MAXTICKS = 1000\n1481: \n1482:     def tick_values(self, vmin, vmax):\n1483:         \"\"\"\n1484:         Return the values of the located ticks given **vmin** and **vmax**.\n1485: \n1486:         .. note::\n1487:             To get tick locations with the vmin and vmax values defined\n1488:             automatically for the associated :attr:`axis` simply call\n1489:             the Locator instance::\n1490: \n1491:                 >>> print(type(loc))\n1492:                 <type 'Locator'>\n1493:                 >>> print(loc())\n1494:                 [1, 2, 3, 4]\n1495: \n1496:         \"\"\"\n1497:         raise NotImplementedError('Derived must override')\n1498: \n1499:     def set_params(self, **kwargs):\n1500:         \"\"\"\n1501:         Do nothing, and raise a warning. Any locator class not supporting the\n1502:         set_params() function will call this.\n1503:         \"\"\"\n1504:         cbook._warn_external(\n1505:             \"'set_params()' not defined for locator of type \" +\n1506:             str(type(self)))\n1507: \n1508:     def __call__(self):\n1509:         \"\"\"Return the locations of the ticks\"\"\"\n1510:         # note: some locators return data limits, other return view limits,\n1511:         # hence there is no *one* interface to call self.tick_values.\n1512:         raise NotImplementedError('Derived must override')\n1513: \n1514:     def raise_if_exceeds(self, locs):\n1515:         \"\"\"raise a RuntimeError if Locator attempts to create more than\n1516:            MAXTICKS locs\"\"\"\n1517:         if len(locs) >= self.MAXTICKS:\n1518:             raise RuntimeError(\"Locator attempting to generate {} ticks from \"\n1519:                                \"{} to {}: exceeds Locator.MAXTICKS\".format(\n1520:                                    len(locs), locs[0], locs[-1]))\n1521:         return locs\n1522: \n1523:     def nonsingular(self, v0, v1):\n1524:         \"\"\"Modify the endpoints of a range as needed to avoid singularities.\"\"\"\n1525:         return mtransforms.nonsingular(v0, v1, increasing=False, expander=.05)\n1526: \n1527:     def view_limits(self, vmin, vmax):\n1528:         \"\"\"\n1529:         Select a scale for the range from vmin to vmax.\n1530: \n1531:         Subclasses should override this method to change locator behaviour.\n1532:         \"\"\"\n1533:         return mtransforms.nonsingular(vmin, vmax)\n1534: \n1535:     def autoscale(self):\n1536:         \"\"\"autoscale the view limits\"\"\"\n1537:         return self.view_limits(*self.axis.get_view_interval())\n1538: \n1539:     def pan(self, numsteps):\n1540:         \"\"\"Pan numticks (can be positive or negative)\"\"\"\n1541:         ticks = self()\n1542:         numticks = len(ticks)\n1543: \n1544:         vmin, vmax = self.axis.get_view_interval()\n1545:         vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n1546:         if numticks > 2:\n1547:             step = numsteps * abs(ticks[0] - ticks[1])\n1548:         else:\n1549:             d = abs(vmax - vmin)\n1550:             step = numsteps * d / 6.\n1551: \n1552:         vmin += step\n1553:         vmax += step\n1554:         self.axis.set_view_interval(vmin, vmax, ignore=True)\n1555: \n1556:     def zoom(self, direction):\n1557:         \"Zoom in/out on axis; if direction is >0 zoom in, else zoom out\"\n1558: \n1559:         vmin, vmax = self.axis.get_view_interval()\n1560:         vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=0.05)\n1561:         interval = abs(vmax - vmin)\n1562:         step = 0.1 * interval * direction\n1563:         self.axis.set_view_interval(vmin + step, vmax - step, ignore=True)\n1564: \n1565:     def refresh(self):\n1566:         \"\"\"refresh internal information based on current lim\"\"\"\n1567:         pass\n1568: \n1569: \n1570: class IndexLocator(Locator):\nCode replaced for brevity.\n1596: \n1597: \n1598: \n1599: class FixedLocator(Locator):\nCode replaced for brevity.\n1640: \n1641: \n1642: \n1643: class NullLocator(Locator):\nCode replaced for brevity.\n1660: \n1661: \n1662: \n1663: class LinearLocator(Locator):\nCode replaced for brevity.\n1733: \n1734: \n1735: \n1736: @cbook.deprecated(\"3.0\")\n1737: def closeto(x, y):\n1738:     return abs(x - y) < 1e-10\n1739: \n1740: \n1741: @cbook.deprecated(\"3.0\")\n1742: class Base(object):\nCode replaced for brevity.\n1780: \n1781: \n1782: \n1783: class MultipleLocator(Locator):\nCode replaced for brevity.\n1825: \n1826: \n1827: \n1828: def scale_range(vmin, vmax, n=1, threshold=100):\nCode replaced for brevity.\n1836: \n1837: \n1838: \n1839: class _Edge_integer:\nCode replaced for brevity.\n1879: \n1880: \n1881: \n1882: class MaxNLocator(Locator):\nCode replaced for brevity.\n2108: \n2109: \n2110: \n2111: @cbook.deprecated(\"3.1\")\n2112: def decade_down(x, base=10):\nCode replaced for brevity.\n2117: \n2118: \n2119: \n2120: @cbook.deprecated(\"3.1\")\n2121: def decade_up(x, base=10):\nCode replaced for brevity.\n2126: \n2127: \n2128: \n2129: def nearest_long(x):\nCode replaced for brevity.\n2134: \n2135: \n2136: \n2137: def is_decade(x, base=10):\nCode replaced for brevity.\n2143: \n2144: \n2145: \n2146: def _decade_less_equal(x, base):\nCode replaced for brevity.\n2154: \n2155: \n2156: \n2157: def _decade_greater_equal(x, base):\nCode replaced for brevity.\n2165: \n2166: \n2167: \n2168: def _decade_less(x, base):\nCode replaced for brevity.\n2179: \n2180: \n2181: \n2182: def _decade_greater(x, base):\nCode replaced for brevity.\n2193: \n2194: \n2195: \n2196: def is_close_to_int(x):\n2197:     return abs(x - np.round(x)) < 1e-10\n2198: \n2199: \n2200: class LogLocator(Locator):\nCode replaced for brevity.\n2398: \n2399: \n2400: \n2401: class SymmetricalLogLocator(Locator):\nCode replaced for brevity.\n2558: \n2559: \n2560: \n2561: class LogitLocator(Locator):\nCode replaced for brevity.\n2650: \n2651: \n2652: \n2653: class AutoLocator(MaxNLocator):\nCode replaced for brevity.\n2670: \n2671: \n2672: \n2673: class AutoMinorLocator(Locator):\nCode replaced for brevity.\n2731: \n2732: \n2733: \n2734: class OldAutoLocator(Locator):\nCode replaced for brevity.\n2792: \n\n[start of lib/mpl_toolkits/mplot3d/axes3d.py]\n1: \"\"\"\n2: axes3d.py, original mplot3d version by John Porter\n3: Created: 23 Sep 2005\n4: \n5: Parts fixed by Reinier Heeres <reinier@heeres.eu>\n6: Minor additions by Ben Axelrod <baxelrod@coroware.com>\n7: Significant updates and revisions by Ben Root <ben.v.root@gmail.com>\n8: \n9: Module containing Axes3D, an object which can plot 3D objects on a\n10: 2D matplotlib figure.\n11: \"\"\"\n12: from collections import defaultdict\n13: from functools import reduce\n14: import math\n15: \n16: import numpy as np\n17: \n18: from matplotlib import artist\n19: import matplotlib.axes as maxes\n20: import matplotlib.cbook as cbook\n21: import matplotlib.collections as mcoll\n22: import matplotlib.colors as mcolors\n23: import matplotlib.docstring as docstring\n24: import matplotlib.projections as proj\n25: import matplotlib.scale as mscale\n26: import matplotlib.transforms as mtransforms\n27: from matplotlib.axes import Axes, rcParams\n28: from matplotlib.colors import Normalize, LightSource\n29: from matplotlib.transforms import Bbox\n30: from matplotlib.tri.triangulation import Triangulation\n31: \n32: from . import art3d\n33: from . import proj3d\n34: from . import axis3d\n35: \n36: \n37: def unit_bbox():\n38:     box = Bbox(np.array([[0, 0], [1, 1]]))\n39:     return box\n40: \n41: \n42: class Axes3D(Axes):\n43:     \"\"\"\n44:     3D axes object.\n45:     \"\"\"\n46:     name = '3d'\n47:     _shared_z_axes = cbook.Grouper()\n48: \n49:     @docstring.dedent_interpd\n50:     def __init__(\n51:             self, fig, rect=None, *args,\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/axes/_base.py",
      "suspect_lines": []
    },
    {
      "filename": "/lib/matplotlib/ticker.py",
      "suspect_lines": [
        1524,
        1525
      ]
    },
    {
      "filename": "/lib/mpl_toolkits/mplot3d/axes3d.py",
      "suspect_lines": []
    }
  ]
}