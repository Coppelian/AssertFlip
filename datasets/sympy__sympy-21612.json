{
  "instance_id": "sympy__sympy-21612",
  "problem_statement": "Latex parsing of fractions yields wrong expression due to missing brackets\nProblematic latex expression: `\"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\"`\r\n\r\nis parsed to: `((a**3 + b)/c)/1/(c**2)`.\r\n\r\nExpected is: `((a**3 + b)/c)/(1/(c**2))`. \r\n\r\nThe missing brackets in the denominator result in a wrong expression.\r\n\r\n## Tested on\r\n\r\n- 1.8\r\n- 1.6.2\r\n\r\n## Reproduce:\r\n\r\n```\r\nroot@d31ef1c26093:/# python3\r\nPython 3.6.9 (default, Jan 26 2021, 15:33:00)\r\n[GCC 8.4.0] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> from sympy.parsing.latex import parse_latex\r\n>>> parse_latex(\"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\")\r\n((a**3 + b)/c)/1/(c**2)\r\n\r\n\n",
  "localized_code": "[start of sympy/printing/str.py]\n1: \"\"\"\n2: A Printer for generating readable representation of most sympy classes.\n3: \"\"\"\n4: \n5: from typing import Any, Dict\n6: \n7: from sympy.core import S, Rational, Pow, Basic, Mul, Number\n8: from sympy.core.mul import _keep_coeff\n9: from sympy.core.function import _coeff_isneg\n10: from .printer import Printer, print_function\n11: from sympy.printing.precedence import precedence, PRECEDENCE\n12: \n13: from mpmath.libmp import prec_to_dps, to_str as mlib_to_str\n14: \n15: from sympy.utilities import default_sort_key, sift\n16: \n17: \n18: class StrPrinter(Printer):\n19:     printmethod = \"_sympystr\"\n20:     _default_settings = {\n21:         \"order\": None,\n22:         \"full_prec\": \"auto\",\n23:         \"sympy_integers\": False,\n24:         \"abbrev\": False,\n25:         \"perm_cyclic\": True,\n26:         \"min\": None,\n27:         \"max\": None,\n28:     }  # type: Dict[str, Any]\n29: \n30:     _relationals = dict()  # type: Dict[str, str]\n31: \n32:     def parenthesize(self, item, level, strict=False):\n33:         if (precedence(item) < level) or ((not strict) and precedence(item) <= level):\n34:             return \"(%s)\" % self._print(item)\n35:         else:\n36:             return self._print(item)\n37: \n38:     def stringify(self, args, sep, level=0):\n39:         return sep.join([self.parenthesize(item, level) for item in args])\n40: \n41:     def emptyPrinter(self, expr):\n42:         if isinstance(expr, str):\n43:             return expr\n44:         elif isinstance(expr, Basic):\n45:             return repr(expr)\n46:         else:\n47:             return str(expr)\n48: \n49:     def _print_Add(self, expr, order=None):\n50:         terms = self._as_ordered_terms(expr, order=order)\n51: \n52:         PREC = precedence(expr)\n53:         l = []\n54:         for term in terms:\n55:             t = self._print(term)\n56:             if t.startswith('-'):\n57:                 sign = \"-\"\n58:                 t = t[1:]\n59:             else:\n60:                 sign = \"+\"\n61:             if precedence(term) < PREC:\n62:                 l.extend([sign, \"(%s)\" % t])\n63:             else:\n64:                 l.extend([sign, t])\n65:         sign = l.pop(0)\n66:         if sign == '+':\n67:             sign = \"\"\n68:         return sign + ' '.join(l)\n69: \n70:     def _print_BooleanTrue(self, expr):\n71:         return \"True\"\n72: \n73:     def _print_BooleanFalse(self, expr):\n74:         return \"False\"\n75: \n76:     def _print_Not(self, expr):\n77:         return '~%s' %(self.parenthesize(expr.args[0],PRECEDENCE[\"Not\"]))\n78: \n79:     def _print_And(self, expr):\n80:         return self.stringify(expr.args, \" & \", PRECEDENCE[\"BitwiseAnd\"])\n81: \n82:     def _print_Or(self, expr):\n83:         return self.stringify(expr.args, \" | \", PRECEDENCE[\"BitwiseOr\"])\n84: \n85:     def _print_Xor(self, expr):\n86:         return self.stringify(expr.args, \" ^ \", PRECEDENCE[\"BitwiseXor\"])\n87: \n88:     def _print_AppliedPredicate(self, expr):\n89:         return '%s(%s)' % (\n90:             self._print(expr.function), self.stringify(expr.arguments, \", \"))\n91: \n92:     def _print_Basic(self, expr):\n93:         l = [self._print(o) for o in expr.args]\n94:         return expr.__class__.__name__ + \"(%s)\" % \", \".join(l)\n95: \n96:     def _print_BlockMatrix(self, B):\n97:         if B.blocks.shape == (1, 1):\n98:             self._print(B.blocks[0, 0])\n99:         return self._print(B.blocks)\n100: \n101:     def _print_Catalan(self, expr):\n102:         return 'Catalan'\n103: \n104:     def _print_ComplexInfinity(self, expr):\n105:         return 'zoo'\n106: \n107:     def _print_ConditionSet(self, s):\n108:         args = tuple([self._print(i) for i in (s.sym, s.condition)])\n109:         if s.base_set is S.UniversalSet:\n110:             return 'ConditionSet(%s, %s)' % args\n111:         args += (self._print(s.base_set),)\n112:         return 'ConditionSet(%s, %s, %s)' % args\n113: \n114:     def _print_Derivative(self, expr):\n115:         dexpr = expr.expr\n116:         dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]\n117:         return 'Derivative(%s)' % \", \".join(map(lambda arg: self._print(arg), [dexpr] + dvars))\n118: \n119:     def _print_dict(self, d):\n120:         keys = sorted(d.keys(), key=default_sort_key)\n121:         items = []\n122: \n123:         for key in keys:\n124:             item = \"%s: %s\" % (self._print(key), self._print(d[key]))\n125:             items.append(item)\n126: \n127:         return \"{%s}\" % \", \".join(items)\n128: \n129:     def _print_Dict(self, expr):\n130:         return self._print_dict(expr)\n131: \n132:     def _print_RandomDomain(self, d):\n133:         if hasattr(d, 'as_boolean'):\n134:             return 'Domain: ' + self._print(d.as_boolean())\n135:         elif hasattr(d, 'set'):\n136:             return ('Domain: ' + self._print(d.symbols) + ' in ' +\n137:                     self._print(d.set))\n138:         else:\n139:             return 'Domain on ' + self._print(d.symbols)\n140: \n141:     def _print_Dummy(self, expr):\n142:         return '_' + expr.name\n143: \n144:     def _print_EulerGamma(self, expr):\n145:         return 'EulerGamma'\n146: \n147:     def _print_Exp1(self, expr):\n148:         return 'E'\n149: \n150:     def _print_ExprCondPair(self, expr):\n151:         return '(%s, %s)' % (self._print(expr.expr), self._print(expr.cond))\n152: \n153:     def _print_Function(self, expr):\n154:         return expr.func.__name__ + \"(%s)\" % self.stringify(expr.args, \", \")\n155: \n156:     def _print_GoldenRatio(self, expr):\n157:         return 'GoldenRatio'\n158: \n159:     def _print_TribonacciConstant(self, expr):\n160:         return 'TribonacciConstant'\n161: \n162:     def _print_ImaginaryUnit(self, expr):\n163:         return 'I'\n164: \n165:     def _print_Infinity(self, expr):\n166:         return 'oo'\n167: \n168:     def _print_Integral(self, expr):\n169:         def _xab_tostr(xab):\n170:             if len(xab) == 1:\n171:                 return self._print(xab[0])\n172:             else:\n173:                 return self._print((xab[0],) + tuple(xab[1:]))\n174:         L = ', '.join([_xab_tostr(l) for l in expr.limits])\n175:         return 'Integral(%s, %s)' % (self._print(expr.function), L)\n176: \n177:     def _print_Interval(self, i):\n178:         fin =  'Interval{m}({a}, {b})'\n179:         a, b, l, r = i.args\n180:         if a.is_infinite and b.is_infinite:\n181:             m = ''\n182:         elif a.is_infinite and not r:\n183:             m = ''\n184:         elif b.is_infinite and not l:\n185:             m = ''\n186:         elif not l and not r:\n187:             m = ''\n188:         elif l and r:\n189:             m = '.open'\n190:         elif l:\n191:             m = '.Lopen'\n192:         else:\n193:             m = '.Ropen'\n194:         return fin.format(**{'a': a, 'b': b, 'm': m})\n195: \n196:     def _print_AccumulationBounds(self, i):\n197:         return \"AccumBounds(%s, %s)\" % (self._print(i.min),\n198:                                         self._print(i.max))\n199: \n200:     def _print_Inverse(self, I):\n201:         return \"%s**(-1)\" % self.parenthesize(I.arg, PRECEDENCE[\"Pow\"])\n202: \n203:     def _print_Lambda(self, obj):\n204:         expr = obj.expr\n205:         sig = obj.signature\n206:         if len(sig) == 1 and sig[0].is_symbol:\n207:             sig = sig[0]\n208:         return \"Lambda(%s, %s)\" % (self._print(sig), self._print(expr))\n209: \n210:     def _print_LatticeOp(self, expr):\n211:         args = sorted(expr.args, key=default_sort_key)\n212:         return expr.func.__name__ + \"(%s)\" % \", \".join(self._print(arg) for arg in args)\n213: \n214:     def _print_Limit(self, expr):\n215:         e, z, z0, dir = expr.args\n216:         if str(dir) == \"+\":\n217:             return \"Limit(%s, %s, %s)\" % tuple(map(self._print, (e, z, z0)))\n218:         else:\n219:             return \"Limit(%s, %s, %s, dir='%s')\" % tuple(map(self._print,\n220:                                                             (e, z, z0, dir)))\n221: \n222:     def _print_list(self, expr):\n223:         return \"[%s]\" % self.stringify(expr, \", \")\n224: \n225:     def _print_MatrixBase(self, expr):\n226:         return expr._format_str(self)\n227: \n228:     def _print_MatrixElement(self, expr):\n229:         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) \\\n230:             + '[%s, %s]' % (self._print(expr.i), self._print(expr.j))\n231: \n232:     def _print_MatrixSlice(self, expr):\n233:         def strslice(x, dim):\n234:             x = list(x)\n235:             if x[2] == 1:\n236:                 del x[2]\n237:             if x[0] == 0:\n238:                 x[0] = ''\n239:             if x[1] == dim:\n240:                 x[1] = ''\n241:             return ':'.join(map(lambda arg: self._print(arg), x))\n242:         return (self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True) + '[' +\n243:                 strslice(expr.rowslice, expr.parent.rows) + ', ' +\n244:                 strslice(expr.colslice, expr.parent.cols) + ']')\n245: \n246:     def _print_DeferredVector(self, expr):\n247:         return expr.name\n248: \n249:     def _print_Mul(self, expr):\n250: \n251:         prec = precedence(expr)\n252: \n253:         # Check for unevaluated Mul. In this case we need to make sure the\n254:         # identities are visible, multiple Rational factors are not combined\n255:         # etc so we display in a straight-forward form that fully preserves all\n256:         # args and their order.\n257:         args = expr.args\n258:         if args[0] is S.One or any(\n259:                 isinstance(a, Number) or\n260:                 a.is_Pow and all(ai.is_Integer for ai in a.args)\n261:                 for a in args[1:]):\n262:             d, n = sift(args, lambda x:\n263:                 isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0),\n264:                 binary=True)\n265:             for i, di in enumerate(d):\n266:                 if di.exp.is_Number:\n267:                     e = -di.exp\n268:                 else:\n269:                     dargs = list(di.exp.args)\n270:                     dargs[0] = -dargs[0]\n271:                     e = Mul._from_args(dargs)\n272:                 d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base\n273: \n274:             # don't parenthesize first factor if negative\n275:             if _coeff_isneg(n[0]):\n276:                 pre = [str(n.pop(0))]\n277:             else:\n278:                 pre = []\n279:             nfactors = pre + [self.parenthesize(a, prec, strict=False)\n280:                 for a in n]\n281: \n282:             # don't parenthesize first of denominator unless singleton\n283:             if len(d) > 1 and _coeff_isneg(d[0]):\n284:                 pre = [str(d.pop(0))]\n285:             else:\n286:                 pre = []\n287:             dfactors = pre + [self.parenthesize(a, prec, strict=False)\n288:                 for a in d]\n289: \n290:             n = '*'.join(nfactors)\n291:             d = '*'.join(dfactors)\n292:             if len(dfactors) > 1:\n293:                 return '%s/(%s)' % (n, d)\n294:             elif dfactors:\n295:                 return '%s/%s' % (n, d)\n296:             return n\n297: \n298:         c, e = expr.as_coeff_Mul()\n299:         if c < 0:\n300:             expr = _keep_coeff(-c, e)\n301:             sign = \"-\"\n302:         else:\n303:             sign = \"\"\n304: \n305:         a = []  # items in the numerator\n306:         b = []  # items that are in the denominator (if any)\n307: \n308:         pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n309: \n310:         if self.order not in ('old', 'none'):\n311:             args = expr.as_ordered_factors()\n312:         else:\n313:             # use make_args in case expr was something like -x -> x\n314:             args = Mul.make_args(expr)\n315: \n316:         # Gather args for numerator/denominator\n317:         def apow(i):\n318:             b, e = i.as_base_exp()\n319:             eargs = list(Mul.make_args(e))\n320:             if eargs[0] is S.NegativeOne:\n321:                 eargs = eargs[1:]\n322:             else:\n323:                 eargs[0] = -eargs[0]\n324:             e = Mul._from_args(eargs)\n325:             if isinstance(i, Pow):\n326:                 return i.func(b, e, evaluate=False)\n327:             return i.func(e, evaluate=False)\n328:         for item in args:\n329:             if (item.is_commutative and\n330:                     isinstance(item, Pow) and\n331:                     bool(item.exp.as_coeff_Mul()[0] < 0)):\n332:                 if item.exp is not S.NegativeOne:\n333:                     b.append(apow(item))\n334:                 else:\n335:                     if (len(item.args[0].args) != 1 and\n336:                             isinstance(item.base, Mul)):\n337:                         # To avoid situations like #14160\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/printing/str.py",
      "suspect_lines": [
        336
      ]
    }
  ]
}