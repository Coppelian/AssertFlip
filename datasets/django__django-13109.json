{
  "instance_id": "django__django-13109",
  "problem_statement": "ForeignKey.validate() should validate using the base manager.\nDescription\n\t\nForeignKey.validate() should validate using the base manager instead of the default manager.\nConsider the models:\nclass ArticleManager(models.Manage):\n\tdef get_queryset(self):\n\t\tqs = super().get_queryset()\n\t\treturn qs.filter(archived=False)\nclass Article(models.Model):\n\ttitle = models.CharField(max_length=100)\n\tarchived = models.BooleanField(default=False)\n\t# Don't include archived articles by default.\n\tobjects = ArticleManager()\nclass FavoriteAricles(models.Model):\n\tarticle = models.ForeignKey(Article, on_delete=models.CASCADE)\nIn the example, now consider a form that allows users to pick a favorite article including archived articles.\nclass FavoriteAriclesForm(forms.ModelForm):\n\tclass Meta:\n\t\tmodel = FavoriteArticle\n\t\tfields = '__all__'\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper().__init__(*args, **kwargs)\n\t\t# Use the base manager instead of the default manager to allow archived articles.\n\t\tself.fields['article'].queryset = Article._base_manager.all()\nThe above form will never validate as True when a user selects an archived article. This is because the ForeignKey validation always uses _default_manager instead of _base_manager. The user facing error message is \"article instance with id 123 does not exist.\" (quite confusing to typical users). The code for this validation is here:\nâ€‹https://github.com/django/django/blob/94f63b926fd32d7a7b6e2591ef72aa8f040f25cc/django/db/models/fields/related.py#L917-L919\nThe FavoriteAriclesForm is specifically designed to use a different manager, but the ForeignKey validation makes this difficult.\nIn this example scenario, it is not acceptable to change the model's default manager as the default should avoid archived articles in other typical scenarios.\nSuggested solution: the ForeignKey validation should use the _base_manager instead which does not include the default filters.\n",
  "localized_code": "[start of django/db/models/fields/related.py]\n1: import functools\n2: import inspect\n3: from functools import partial\n4: \n5: from django import forms\n6: from django.apps import apps\n7: from django.conf import SettingsReference, settings\n8: from django.core import checks, exceptions\n9: from django.db import connection, router\n10: from django.db.backends import utils\n11: from django.db.models import Q\n12: from django.db.models.constants import LOOKUP_SEP\n13: from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14: from django.db.models.query_utils import PathInfo\n15: from django.db.models.utils import make_model_tuple\n16: from django.utils.functional import cached_property\n17: from django.utils.translation import gettext_lazy as _\n18: \n19: from . import Field\n20: from .mixins import FieldCacheMixin\n21: from .related_descriptors import (\n22:     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,\n23:     ForwardOneToOneDescriptor, ManyToManyDescriptor,\n24:     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,\n25: )\n26: from .related_lookups import (\n27:     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,\n28:     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,\n29: )\n30: from .reverse_related import (\n31:     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,\n32: )\n33: \n34: RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n35: \n36: \n37: def resolve_relation(scope_model, relation):\n38:     \"\"\"\n39:     Transform relation into a model or fully-qualified model string of the form\n40:     \"app_label.ModelName\", relative to scope_model.\n41: \n42:     The relation argument can be:\n43:       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n44:         the model argument will be returned.\n45:       * A bare model name without an app_label, in which case scope_model's\n46:         app_label will be prepended.\n47:       * An \"app_label.ModelName\" string.\n48:       * A model class, which will be returned unchanged.\n49:     \"\"\"\n50:     # Check for recursive relations\n51:     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n52:         relation = scope_model\n53: \n54:     # Look for an \"app.Model\" relation\n55:     if isinstance(relation, str):\n56:         if \".\" not in relation:\n57:             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n58: \n59:     return relation\n60: \n61: \n62: def lazy_related_operation(function, model, *related_models, **kwargs):\nCode replaced for brevity.\n80: \n81: \n82: \n83: class RelatedField(FieldCacheMixin, Field):\nCode replaced for brevity.\n441: \n442: \n443: \n444: class ForeignObject(RelatedField):\nCode replaced for brevity.\n755: \n756: \n757: \n758: ForeignObject.register_lookup(RelatedIn)\n759: ForeignObject.register_lookup(RelatedExact)\n760: ForeignObject.register_lookup(RelatedLessThan)\n761: ForeignObject.register_lookup(RelatedGreaterThan)\n762: ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n763: ForeignObject.register_lookup(RelatedLessThanOrEqual)\n764: ForeignObject.register_lookup(RelatedIsNull)\n765: \n766: \n767: class ForeignKey(ForeignObject):\n768:     \"\"\"\n769:     Provide a many-to-one relation by adding a column to the local model\n770:     to hold the remote value.\n771: \n772:     By default ForeignKey will target the pk of the remote model but this\n773:     behavior can be changed by using the ``to_field`` argument.\n774:     \"\"\"\n775:     descriptor_class = ForeignKeyDeferredAttribute\n776:     # Field flags\n777:     many_to_many = False\n778:     many_to_one = True\n779:     one_to_many = False\n780:     one_to_one = False\n781: \n782:     rel_class = ManyToOneRel\n783: \n784:     empty_strings_allowed = False\n785:     default_error_messages = {\n786:         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n787:     }\n788:     description = _(\"Foreign Key (type determined by related field)\")\n789: \n790:     def __init__(self, to, on_delete, related_name=None, related_query_name=None,\n791:                  limit_choices_to=None, parent_link=False, to_field=None,\n792:                  db_constraint=True, **kwargs):\n793:         try:\n794:             to._meta.model_name\n795:         except AttributeError:\n796:             assert isinstance(to, str), (\n797:                 \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n798:                 \"either a model, a model name, or the string %r\" % (\n799:                     self.__class__.__name__, to,\n800:                     RECURSIVE_RELATIONSHIP_CONSTANT,\n801:                 )\n802:             )\n803:         else:\n804:             # For backwards compatibility purposes, we need to *try* and set\n805:             # the to_field during FK construction. It won't be guaranteed to\n806:             # be correct until contribute_to_class is called. Refs #12190.\n807:             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n808:         if not callable(on_delete):\n809:             raise TypeError('on_delete must be callable.')\n810: \n811:         kwargs['rel'] = self.rel_class(\n812:             self, to, to_field,\n813:             related_name=related_name,\n814:             related_query_name=related_query_name,\n815:             limit_choices_to=limit_choices_to,\n816:             parent_link=parent_link,\n817:             on_delete=on_delete,\n818:         )\n819:         kwargs.setdefault('db_index', True)\n820: \n821:         super().__init__(\n822:             to,\n823:             on_delete,\n824:             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n825:             to_fields=[to_field],\n826:             **kwargs,\n827:         )\n828:         self.db_constraint = db_constraint\n829: \n830:     def check(self, **kwargs):\n831:         return [\n832:             *super().check(**kwargs),\n833:             *self._check_on_delete(),\n834:             *self._check_unique(),\n835:         ]\n836: \n837:     def _check_on_delete(self):\n838:         on_delete = getattr(self.remote_field, 'on_delete', None)\n839:         if on_delete == SET_NULL and not self.null:\n840:             return [\n841:                 checks.Error(\n842:                     'Field specifies on_delete=SET_NULL, but cannot be null.',\n843:                     hint='Set null=True argument on the field, or change the on_delete rule.',\n844:                     obj=self,\n845:                     id='fields.E320',\n846:                 )\n847:             ]\n848:         elif on_delete == SET_DEFAULT and not self.has_default():\n849:             return [\n850:                 checks.Error(\n851:                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',\n852:                     hint='Set a default value, or change the on_delete rule.',\n853:                     obj=self,\n854:                     id='fields.E321',\n855:                 )\n856:             ]\n857:         else:\n858:             return []\n859: \n860:     def _check_unique(self, **kwargs):\n861:         return [\n862:             checks.Warning(\n863:                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',\n864:                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',\n865:                 obj=self,\n866:                 id='fields.W342',\n867:             )\n868:         ] if self.unique else []\n869: \n870:     def deconstruct(self):\n871:         name, path, args, kwargs = super().deconstruct()\n872:         del kwargs['to_fields']\n873:         del kwargs['from_fields']\n874:         # Handle the simpler arguments\n875:         if self.db_index:\n876:             del kwargs['db_index']\n877:         else:\n878:             kwargs['db_index'] = False\n879:         if self.db_constraint is not True:\n880:             kwargs['db_constraint'] = self.db_constraint\n881:         # Rel needs more work.\n882:         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n883:         if self.remote_field.field_name and (\n884:                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):\n885:             kwargs['to_field'] = self.remote_field.field_name\n886:         return name, path, args, kwargs\n887: \n888:     def to_python(self, value):\n889:         return self.target_field.to_python(value)\n890: \n891:     @property\n892:     def target_field(self):\n893:         return self.foreign_related_fields[0]\n894: \n895:     def get_reverse_path_info(self, filtered_relation=None):\n896:         \"\"\"Get path from the related model to this field's model.\"\"\"\n897:         opts = self.model._meta\n898:         from_opts = self.remote_field.model._meta\n899:         return [PathInfo(\n900:             from_opts=from_opts,\n901:             to_opts=opts,\n902:             target_fields=(opts.pk,),\n903:             join_field=self.remote_field,\n904:             m2m=not self.unique,\n905:             direct=False,\n906:             filtered_relation=filtered_relation,\n907:         )]\n908: \n909:     def validate(self, value, model_instance):\n910:         if self.remote_field.parent_link:\n911:             return\n912:         super().validate(value, model_instance)\n913:         if value is None:\n914:             return\n915: \n916:         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n917:         qs = self.remote_field.model._default_manager.using(using).filter(\n918:             **{self.remote_field.field_name: value}\n919:         )\n920:         qs = qs.complex_filter(self.get_limit_choices_to())\n921:         if not qs.exists():\n922:             raise exceptions.ValidationError(\n923:                 self.error_messages['invalid'],\n924:                 code='invalid',\n925:                 params={\n926:                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,\n927:                     'field': self.remote_field.field_name, 'value': value,\n928:                 },  # 'pk' is included for backwards compatibility\n929:             )\n930: \n931:     def resolve_related_fields(self):\n932:         related_fields = super().resolve_related_fields()\n933:         for from_field, to_field in related_fields:\n934:             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:\n935:                 raise exceptions.FieldError(\n936:                     \"'%s.%s' refers to field '%s' which is not local to model \"\n937:                     \"'%s'.\" % (\n938:                         self.model._meta.label,\n939:                         self.name,\n940:                         to_field.name,\n941:                         self.remote_field.model._meta.concrete_model._meta.label,\n942:                     )\n943:                 )\n944:         return related_fields\n945: \n946:     def get_attname(self):\n947:         return '%s_id' % self.name\n948: \n949:     def get_attname_column(self):\n950:         attname = self.get_attname()\n951:         column = self.db_column or attname\n952:         return attname, column\n953: \n954:     def get_default(self):\n955:         \"\"\"Return the to_field if the default value is an object.\"\"\"\n956:         field_default = super().get_default()\n957:         if isinstance(field_default, self.remote_field.model):\n958:             return getattr(field_default, self.target_field.attname)\n959:         return field_default\n960: \n961:     def get_db_prep_save(self, value, connection):\n962:         if value is None or (value == '' and\n963:                              (not self.target_field.empty_strings_allowed or\n964:                               connection.features.interprets_empty_strings_as_nulls)):\n965:             return None\n966:         else:\n967:             return self.target_field.get_db_prep_save(value, connection=connection)\n968: \n969:     def get_db_prep_value(self, value, connection, prepared=False):\n970:         return self.target_field.get_db_prep_value(value, connection, prepared)\n971: \n972:     def get_prep_value(self, value):\n973:         return self.target_field.get_prep_value(value)\n974: \n975:     def contribute_to_related_class(self, cls, related):\n976:         super().contribute_to_related_class(cls, related)\n977:         if self.remote_field.field_name is None:\n978:             self.remote_field.field_name = cls._meta.pk.name\n979: \n980:     def formfield(self, *, using=None, **kwargs):\n981:         if isinstance(self.remote_field.model, str):\n982:             raise ValueError(\"Cannot create form field for %r yet, because \"\n983:                              \"its related model %r has not been loaded yet\" %\n984:                              (self.name, self.remote_field.model))\n985:         return super().formfield(**{\n986:             'form_class': forms.ModelChoiceField,\n987:             'queryset': self.remote_field.model._default_manager.using(using),\n988:             'to_field_name': self.remote_field.field_name,\n989:             **kwargs,\n990:             'blank': self.blank,\n991:         })\n992: \n993:     def db_check(self, connection):\n994:         return []\n995: \n996:     def db_type(self, connection):\n997:         return self.target_field.rel_db_type(connection=connection)\n998: \n999:     def db_parameters(self, connection):\n1000:         return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}\n1001: \n1002:     def convert_empty_strings(self, value, expression, connection):\n1003:         if (not value) and isinstance(value, str):\n1004:             return None\n1005:         return value\n1006: \n1007:     def get_db_converters(self, connection):\n1008:         converters = super().get_db_converters(connection)\n1009:         if connection.features.interprets_empty_strings_as_nulls:\n1010:             converters += [self.convert_empty_strings]\n1011:         return converters\n1012: \n1013:     def get_col(self, alias, output_field=None):\n1014:         if output_field is None:\n1015:             output_field = self.target_field\n1016:             while isinstance(output_field, ForeignKey):\n1017:                 output_field = output_field.target_field\n1018:                 if output_field is self:\n1019:                     raise ValueError('Cannot resolve output_field.')\n1020:         return super().get_col(alias, output_field)\n1021: \n1022: \n1023: class OneToOneField(ForeignKey):\nCode replaced for brevity.\n1070: \n1071: \n1072: \n1073: def create_many_to_many_intermediary_model(field, klass):\nCode replaced for brevity.\n1117: \n1118: \n1119: \n1120: class ManyToManyField(RelatedField):\nCode replaced for brevity.\n1692: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/related.py",
      "suspect_lines": [
        917
      ]
    }
  ]
}