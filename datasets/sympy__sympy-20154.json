{
  "instance_id": "sympy__sympy-20154",
  "problem_statement": "partitions() reusing the output dictionaries\nThe partitions() iterator in sympy.utilities.iterables reuses the output dictionaries. There is a caveat about it in the docstring. \r\n\r\nI'm wondering if it's really that important for it to do this. It shouldn't be that much of a performance loss to copy the dictionary before yielding it. This behavior is very confusing. It means that something as simple as list(partitions()) will give an apparently wrong result. And it can lead to much more subtle bugs if the partitions are used in a nontrivial way. \n",
  "localized_code": "[start of sympy/utilities/iterables.py]\n1: from collections import defaultdict, OrderedDict\n2: from itertools import (\n3:     combinations, combinations_with_replacement, permutations,\n4:     product, product as cartes\n5: )\n6: import random\n7: from operator import gt\n8: \n9: from sympy.core import Basic\n10: \n11: # this is the logical location of these functions\n12: from sympy.core.compatibility import (\n13:     as_int, default_sort_key, is_sequence, iterable, ordered\n14: )\n15: \n16: from sympy.utilities.enumerative import (\n17:     multiset_partitions_taocp, list_visitor, MultisetPartitionTraverser)\n18: \n19: \n20: def is_palindromic(s, i=0, j=None):\n21:     \"\"\"return True if the sequence is the same from left to right as it\n22:     is from right to left in the whole sequence (default) or in the\n23:     Python slice ``s[i: j]``; else False.\n24: \n25:     Examples\n26:     ========\n27: \n28:     >>> from sympy.utilities.iterables import is_palindromic\n29:     >>> is_palindromic([1, 0, 1])\n30:     True\n31:     >>> is_palindromic('abcbb')\n32:     False\n33:     >>> is_palindromic('abcbb', 1)\n34:     False\n35: \n36:     Normal Python slicing is performed in place so there is no need to\n37:     create a slice of the sequence for testing:\n38: \n39:     >>> is_palindromic('abcbb', 1, -1)\n40:     True\n41:     >>> is_palindromic('abcbb', -4, -1)\n42:     True\n43: \n44:     See Also\n45:     ========\n46: \n47:     sympy.ntheory.digits.is_palindromic: tests integers\n48: \n49:     \"\"\"\n50:     i, j, _ = slice(i, j).indices(len(s))\n51:     m = (j - i)//2\n52:     # if length is odd, middle element will be ignored\n53:     return all(s[i + k] == s[j - 1 - k] for k in range(m))\n54: \n55: \n56: def flatten(iterable, levels=None, cls=None):\nCode replaced for brevity.\n117: \n118: \n119: \n120: def unflatten(iter, n=2):\nCode replaced for brevity.\n126: \n127: \n128: \n129: def reshape(seq, how):\nCode replaced for brevity.\n186: \n187: \n188: \n189: def group(seq, multiple=True):\nCode replaced for brevity.\n231: \n232: \n233: \n234: def _iproduct2(iterable1, iterable2):\nCode replaced for brevity.\n258: \n259: \n260: \n261: def iproduct(*iterables):\nCode replaced for brevity.\n299: \n300: \n301: \n302: def multiset(seq):\nCode replaced for brevity.\n322: \n323: \n324: \n325: def postorder_traversal(node, keys=None):\nCode replaced for brevity.\n379: \n380: \n381: \n382: def interactive_traversal(expr):\nCode replaced for brevity.\n472: \n473: \n474: \n475: def ibin(n, bits=None, str=False):\nCode replaced for brevity.\n544: \n545: \n546: \n547: def variations(seq, n, repetition=False):\nCode replaced for brevity.\n589: \n590: \n591: \n592: def subsets(seq, k=None, repetition=False):\nCode replaced for brevity.\n639: \n640: \n641: \n642: def filter_symbols(iterator, exclude):\nCode replaced for brevity.\n664: \n665: \n666: def numbered_symbols(prefix='x', cls=None, start=0, exclude=[], *args, **assumptions):\nCode replaced for brevity.\n702: \n703: \n704: \n705: def capture(func):\nCode replaced for brevity.\n732: \n733: \n734: \n735: def sift(seq, keyfunc, binary=False):\nCode replaced for brevity.\n819: \n820: \n821: \n822: def take(iter, n):\nCode replaced for brevity.\n824: \n825: \n826: \n827: def dict_merge(*dicts):\nCode replaced for brevity.\n834: \n835: \n836: \n837: def common_prefix(*seqs):\nCode replaced for brevity.\n860: \n861: \n862: \n863: def common_suffix(*seqs):\nCode replaced for brevity.\n890: \n891: \n892: \n893: def prefixes(seq):\nCode replaced for brevity.\n909: \n910: \n911: \n912: def postfixes(seq):\nCode replaced for brevity.\n928: \n929: \n930: \n931: def topological_sort(graph, key=None):\nCode replaced for brevity.\n1042: \n1043: \n1044: \n1045: def strongly_connected_components(G):\nCode replaced for brevity.\n1165: \n1166: \n1167: \n1168: def connected_components(G):\nCode replaced for brevity.\n1236: \n1237: \n1238: \n1239: def rotate_left(x, y):\nCode replaced for brevity.\n1255: \n1256: \n1257: \n1258: def rotate_right(x, y):\nCode replaced for brevity.\n1274: \n1275: \n1276: \n1277: def least_rotation(x):\nCode replaced for brevity.\n1314: \n1315: \n1316: \n1317: def multiset_combinations(m, n, g=None):\nCode replaced for brevity.\n1370: \n1371: \n1372: \n1373: def multiset_permutations(m, size=None, g=None):\nCode replaced for brevity.\n1419: \n1420: \n1421: \n1422: def _partition(seq, vector, m=None):\nCode replaced for brevity.\n1457: \n1458: \n1459: \n1460: def _set_partitions(n):\nCode replaced for brevity.\n1536: \n1537: \n1538: \n1539: def multiset_partitions(multiset, m=None):\nCode replaced for brevity.\n1693: \n1694: \n1695: \n1696: def partitions(n, m=None, k=None, size=False):\n1697:     \"\"\"Generate all partitions of positive integer, n.\n1698: \n1699:     Parameters\n1700:     ==========\n1701: \n1702:     m : integer (default gives partitions of all sizes)\n1703:         limits number of parts in partition (mnemonic: m, maximum parts)\n1704:     k : integer (default gives partitions number from 1 through n)\n1705:         limits the numbers that are kept in the partition (mnemonic: k, keys)\n1706:     size : bool (default False, only partition is returned)\n1707:         when ``True`` then (M, P) is returned where M is the sum of the\n1708:         multiplicities and P is the generated partition.\n1709: \n1710:     Each partition is represented as a dictionary, mapping an integer\n1711:     to the number of copies of that integer in the partition.  For example,\n1712:     the first partition of 4 returned is {4: 1}, \"4: one of them\".\n1713: \n1714:     Examples\n1715:     ========\n1716: \n1717:     >>> from sympy.utilities.iterables import partitions\n1718: \n1719:     The numbers appearing in the partition (the key of the returned dict)\n1720:     are limited with k:\n1721: \n1722:     >>> for p in partitions(6, k=2):  # doctest: +SKIP\n1723:     ...     print(p)\n1724:     {2: 3}\n1725:     {1: 2, 2: 2}\n1726:     {1: 4, 2: 1}\n1727:     {1: 6}\n1728: \n1729:     The maximum number of parts in the partition (the sum of the values in\n1730:     the returned dict) are limited with m (default value, None, gives\n1731:     partitions from 1 through n):\n1732: \n1733:     >>> for p in partitions(6, m=2):  # doctest: +SKIP\n1734:     ...     print(p)\n1735:     ...\n1736:     {6: 1}\n1737:     {1: 1, 5: 1}\n1738:     {2: 1, 4: 1}\n1739:     {3: 2}\n1740: \n1741:     Note that the _same_ dictionary object is returned each time.\n1742:     This is for speed:  generating each partition goes quickly,\n1743:     taking constant time, independent of n.\n1744: \n1745:     >>> [p for p in partitions(6, k=2)]\n1746:     [{1: 6}, {1: 6}, {1: 6}, {1: 6}]\n1747: \n1748:     If you want to build a list of the returned dictionaries then\n1749:     make a copy of them:\n1750: \n1751:     >>> [p.copy() for p in partitions(6, k=2)]  # doctest: +SKIP\n1752:     [{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]\n1753:     >>> [(M, p.copy()) for M, p in partitions(6, k=2, size=True)]  # doctest: +SKIP\n1754:     [(3, {2: 3}), (4, {1: 2, 2: 2}), (5, {1: 4, 2: 1}), (6, {1: 6})]\n1755: \n1756:     References\n1757:     ==========\n1758: \n1759:     .. [1] modified from Tim Peter's version to allow for k and m values:\n1760:            http://code.activestate.com/recipes/218332-generator-for-integer-partitions/\n1761: \n1762:     See Also\n1763:     ========\n1764: \n1765:     sympy.combinatorics.partitions.Partition\n1766:     sympy.combinatorics.partitions.IntegerPartition\n1767: \n1768:     \"\"\"\n1769:     if (n <= 0 or\n1770:         m is not None and m < 1 or\n1771:         k is not None and k < 1 or\n1772:         m and k and m*k < n):\n1773:         # the empty set is the only way to handle these inputs\n1774:         # and returning {} to represent it is consistent with\n1775:         # the counting convention, e.g. nT(0) == 1.\n1776:         if size:\n1777:             yield 0, {}\n1778:         else:\n1779:             yield {}\n1780:         return\n1781: \n1782:     if m is None:\n1783:         m = n\n1784:     else:\n1785:         m = min(m, n)\n1786: \n1787:     if n == 0:\n1788:         if size:\n1789:             yield 1, {0: 1}\n1790:         else:\n1791:             yield {0: 1}\n1792:         return\n1793: \n1794:     k = min(k or n, n)\n1795: \n1796:     n, m, k = as_int(n), as_int(m), as_int(k)\n1797:     q, r = divmod(n, k)\n1798:     ms = {k: q}\n1799:     keys = [k]  # ms.keys(), from largest to smallest\n1800:     if r:\n1801:         ms[r] = 1\n1802:         keys.append(r)\n1803:     room = m - q - bool(r)\n1804:     if size:\n1805:         yield sum(ms.values()), ms\n1806:     else:\n1807:         yield ms\n1808: \n1809:     while keys != [1]:\n1810:         # Reuse any 1's.\n1811:         if keys[-1] == 1:\n1812:             del keys[-1]\n1813:             reuse = ms.pop(1)\n1814:             room += reuse\n1815:         else:\n1816:             reuse = 0\n1817: \n1818:         while 1:\n1819:             # Let i be the smallest key larger than 1.  Reuse one\n1820:             # instance of i.\n1821:             i = keys[-1]\n1822:             newcount = ms[i] = ms[i] - 1\n1823:             reuse += i\n1824:             if newcount == 0:\n1825:                 del keys[-1], ms[i]\n1826:             room += 1\n1827: \n1828:             # Break the remainder into pieces of size i-1.\n1829:             i -= 1\n1830:             q, r = divmod(reuse, i)\n1831:             need = q + bool(r)\n1832:             if need > room:\n1833:                 if not keys:\n1834:                     return\n1835:                 continue\n1836: \n1837:             ms[i] = q\n1838:             keys.append(i)\n1839:             if r:\n1840:                 ms[r] = 1\n1841:                 keys.append(r)\n1842:             break\n1843:         room -= need\n1844:         if size:\n1845:             yield sum(ms.values()), ms\n1846:         else:\n1847:             yield ms\n1848: \n1849: \n1850: def ordered_partitions(n, m=None, sort=True):\nCode replaced for brevity.\n1983: \n1984: \n1985: \n1986: def binary_partitions(n):\nCode replaced for brevity.\n2041: \n2042: \n2043: \n2044: def has_dups(seq):\nCode replaced for brevity.\n2065: \n2066: \n2067: \n2068: def has_variety(seq):\nCode replaced for brevity.\n2087: \n2088: \n2089: \n2090: def uniq(seq, result=None):\nCode replaced for brevity.\n2141: \n2142: \n2143: \n2144: def generate_bell(n):\nCode replaced for brevity.\n2248: \n2249: \n2250: \n2251: def generate_involutions(n):\nCode replaced for brevity.\n2285: \n2286: \n2287: \n2288: def generate_derangements(perm):\nCode replaced for brevity.\n2317: \n2318: \n2319: \n2320: def necklaces(n, k, free=False):\nCode replaced for brevity.\n2362: \n2363: \n2364: \n2365: def bracelets(n, k):\nCode replaced for brevity.\n2367: \n2368: \n2369: \n2370: def generate_oriented_forest(n):\nCode replaced for brevity.\n2413: \n2414: \n2415: \n2416: def minlex(seq, directed=True, is_set=False, small=None):\nCode replaced for brevity.\n2491: \n2492: \n2493: \n2494: def runs(seq, op=gt):\nCode replaced for brevity.\n2528: \n2529: \n2530: \n2531: def kbins(l, k, ordered=None):\nCode replaced for brevity.\n2654: \n2655: \n2656: \n2657: def permute_signs(t):\nCode replaced for brevity.\n2670: \n2671: \n2672: \n2673: def signed_permutations(t):\nCode replaced for brevity.\n2689: \n2690: \n2691: \n2692: def rotations(s, dir=1):\nCode replaced for brevity.\n2709: \n2710: \n2711: \n2712: def roundrobin(*iterables):\nCode replaced for brevity.\n2731: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/utilities/iterables.py",
      "suspect_lines": [
        1741,
        1742,
        1743,
        1744,
        1745,
        1746,
        1747,
        1748,
        1749,
        1750,
        1751,
        1752,
        1753,
        1754,
        1755,
        1805,
        1807,
        1845,
        1847
      ]
    }
  ]
}