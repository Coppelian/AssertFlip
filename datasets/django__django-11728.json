{
  "instance_id": "django__django-11728",
  "problem_statement": "simplify_regexp() doesn't replace trailing groups.\nDescription\n\t\nreplace_named_groups() fails to replace the final named group if the urlpattern passed in is missing a trailing '/'.\nFor example, with input r'entries/(?P<pk>[^/.]+)/relationships/(?P<related_field>\\w+)' the \"related_field\" does not get properly replaced. A workaround is to tack on a '/' at the end and then it works.\nCode that reproduces this is attached. \nThis function is used downstream in Django REST Framework. See issue â€‹6888\n",
  "localized_code": "[start of django/contrib/admindocs/utils.py]\n1: \"Misc. utility functions/classes for admin documentation generator.\"\n2: \n3: import re\n4: from email.errors import HeaderParseError\n5: from email.parser import HeaderParser\n6: \n7: from django.urls import reverse\n8: from django.utils.safestring import mark_safe\n9: \n10: try:\n11:     import docutils.core\n12:     import docutils.nodes\n13:     import docutils.parsers.rst.roles\n14: except ImportError:\n15:     docutils_is_available = False\n16: else:\n17:     docutils_is_available = True\n18: \n19: \n20: def get_view_name(view_func):\n21:     mod_name = view_func.__module__\n22:     view_name = getattr(view_func, '__qualname__', view_func.__class__.__name__)\n23:     return mod_name + '.' + view_name\n24: \n25: \n26: def trim_docstring(docstring):\n27:     \"\"\"\n28:     Uniformly trim leading/trailing whitespace from docstrings.\n29: \n30:     Based on https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation\n31:     \"\"\"\n32:     if not docstring or not docstring.strip():\n33:         return ''\n34:     # Convert tabs to spaces and split into lines\n35:     lines = docstring.expandtabs().splitlines()\n36:     indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n37:     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n38:     return \"\\n\".join(trimmed).strip()\n39: \n40: \n41: def parse_docstring(docstring):\n42:     \"\"\"\n43:     Parse out the parts of a docstring.  Return (title, body, metadata).\n44:     \"\"\"\n45:     docstring = trim_docstring(docstring)\n46:     parts = re.split(r'\\n{2,}', docstring)\n47:     title = parts[0]\n48:     if len(parts) == 1:\n49:         body = ''\n50:         metadata = {}\n51:     else:\n52:         parser = HeaderParser()\n53:         try:\n54:             metadata = parser.parsestr(parts[-1])\n55:         except HeaderParseError:\n56:             metadata = {}\n57:             body = \"\\n\\n\".join(parts[1:])\n58:         else:\n59:             metadata = dict(metadata.items())\n60:             if metadata:\n61:                 body = \"\\n\\n\".join(parts[1:-1])\n62:             else:\n63:                 body = \"\\n\\n\".join(parts[1:])\n64:     return title, body, metadata\n65: \n66: \n67: def parse_rst(text, default_reference_context, thing_being_parsed=None):\nCode replaced for brevity.\n94: \n95: \n96: \n97: #\n98: # reST roles\n99: #\n100: ROLES = {\n101:     'model': '%s/models/%s/',\n102:     'view': '%s/views/%s/',\n103:     'template': '%s/templates/%s/',\n104:     'filter': '%s/filters/#%s',\n105:     'tag': '%s/tags/#%s',\n106: }\n107: \n108: \n109: def create_reference_role(rolename, urlbase):\nCode replaced for brevity.\n123: \n124: \n125: \n126: def default_reference_role(name, rawtext, text, lineno, inliner, options=None, content=None):\nCode replaced for brevity.\n139: \n140: \n141: \n142: if docutils_is_available:\n143:     docutils.parsers.rst.roles.register_canonical_role('cmsreference', default_reference_role)\n144: \n145:     for name, urlbase in ROLES.items():\n146:         create_reference_role(name, urlbase)\n147: \n148: # Match the beginning of a named or unnamed group.\n149: named_group_matcher = re.compile(r'\\(\\?P(<\\w+>)')\n150: unnamed_group_matcher = re.compile(r'\\(')\n151: \n152: \n153: def replace_named_groups(pattern):\n154:     r\"\"\"\n155:     Find named groups in `pattern` and replace them with the group name. E.g.,\n156:     1. ^(?P<a>\\w+)/b/(\\w+)$ ==> ^<a>/b/(\\w+)$\n157:     2. ^(?P<a>\\w+)/b/(?P<c>\\w+)/$ ==> ^<a>/b/<c>/$\n158:     \"\"\"\n159:     named_group_indices = [\n160:         (m.start(0), m.end(0), m.group(1))\n161:         for m in named_group_matcher.finditer(pattern)\n162:     ]\n163:     # Tuples of (named capture group pattern, group name).\n164:     group_pattern_and_name = []\n165:     # Loop over the groups and their start and end indices.\n166:     for start, end, group_name in named_group_indices:\n167:         # Handle nested parentheses, e.g. '^(?P<a>(x|y))/b'.\n168:         unmatched_open_brackets, prev_char = 1, None\n169:         for idx, val in enumerate(pattern[end:]):\n170:             # If brackets are balanced, the end of the string for the current\n171:             # named capture group pattern has been reached.\n172:             if unmatched_open_brackets == 0:\n173:                 group_pattern_and_name.append((pattern[start:end + idx], group_name))\n174:                 break\n175: \n176:             # Check for unescaped `(` and `)`. They mark the start and end of a\n177:             # nested group.\n178:             if val == '(' and prev_char != '\\\\':\n179:                 unmatched_open_brackets += 1\n180:             elif val == ')' and prev_char != '\\\\':\n181:                 unmatched_open_brackets -= 1\n182:             prev_char = val\n183: \n184:     # Replace the string for named capture groups with their group names.\n185:     for group_pattern, group_name in group_pattern_and_name:\n186:         pattern = pattern.replace(group_pattern, group_name)\n187:     return pattern\n188: \n189: \n190: def replace_unnamed_groups(pattern):\n191:     r\"\"\"\n192:     Find unnamed groups in `pattern` and replace them with '<var>'. E.g.,\n193:     1. ^(?P<a>\\w+)/b/(\\w+)$ ==> ^(?P<a>\\w+)/b/<var>$\n194:     2. ^(?P<a>\\w+)/b/((x|y)\\w+)$ ==> ^(?P<a>\\w+)/b/<var>$\n195:     \"\"\"\n196:     unnamed_group_indices = [m.start(0) for m in unnamed_group_matcher.finditer(pattern)]\n197:     # Indices of the start of unnamed capture groups.\n198:     group_indices = []\n199:     # Loop over the start indices of the groups.\n200:     for start in unnamed_group_indices:\n201:         # Handle nested parentheses, e.g. '^b/((x|y)\\w+)$'.\n202:         unmatched_open_brackets, prev_char = 1, None\n203:         for idx, val in enumerate(pattern[start + 1:]):\n204:             if unmatched_open_brackets == 0:\n205:                 group_indices.append((start, start + 1 + idx))\n206:                 break\n207: \n208:             # Check for unescaped `(` and `)`. They mark the start and end of\n209:             # a nested group.\n210:             if val == '(' and prev_char != '\\\\':\n211:                 unmatched_open_brackets += 1\n212:             elif val == ')' and prev_char != '\\\\':\n213:                 unmatched_open_brackets -= 1\n214:             prev_char = val\n215: \n216:     # Remove unnamed group matches inside other unnamed capture groups.\n217:     group_start_end_indices = []\n218:     prev_end = None\n219:     for start, end in group_indices:\n220:         if prev_end and start > prev_end or not prev_end:\n221:             group_start_end_indices.append((start, end))\n222:         prev_end = end\n223: \n224:     if group_start_end_indices:\n225:         # Replace unnamed groups with <var>. Handle the fact that replacing the\n226:         # string between indices will change string length and thus indices\n227:         # will point to the wrong substring if not corrected.\n228:         final_pattern, prev_end = [], None\n229:         for start, end in group_start_end_indices:\n230:             if prev_end:\n231:                 final_pattern.append(pattern[prev_end:start])\n232:             final_pattern.append(pattern[:start] + '<var>')\n233:             prev_end = end\n234:         final_pattern.append(pattern[prev_end:])\n235:         return ''.join(final_pattern)\n236:     else:\n237:         return pattern\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admindocs/utils.py",
      "suspect_lines": [
        170,
        171,
        172,
        173,
        174,
        175,
        204,
        205,
        206,
        207
      ]
    }
  ]
}