{
  "instance_id": "pytest-dev__pytest-10356",
  "problem_statement": "Consider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nConsider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nFix missing marks when inheritance from multiple classes\n\r\n<!--\r\nThanks for submitting a PR, your contribution is really appreciated!\r\n\r\nHere is a quick checklist that should be present in PRs.\r\n\r\n- [] Include documentation when adding new features.\r\n- [ ] Include new tests or update existing tests when applicable.\r\n- [X] Allow maintainers to push and squash when merging my commits. Please uncheck this if you prefer to squash the commits yourself.\r\n\r\nIf this change fixes an issue, please:\r\n\r\n- [x] Add text like ``closes #XYZW`` to the PR description and/or commits (where ``XYZW`` is the issue number). See the [github docs](https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) for more information.\r\n\r\nUnless your change is trivial or a small documentation fix (e.g., a typo or reword of a small section) please:\r\n\r\n- [x] Create a new changelog file in the `changelog` folder, with a name like `<ISSUE NUMBER>.<TYPE>.rst`. See [changelog/README.rst](https://github.com/pytest-dev/pytest/blob/main/changelog/README.rst) for details.\r\n\r\n  Write sentences in the **past or present tense**, examples:\r\n\r\n  * *Improved verbose diff output with sequences.*\r\n  * *Terminal summary statistics now use multiple colors.*\r\n\r\n  Also make sure to end the sentence with a `.`.\r\n\r\n- [x] Add yourself to `AUTHORS` in alphabetical order.\r\n-->\r\n\n",
  "localized_code": "[start of src/_pytest/mark/structures.py]\n1: import collections.abc\n2: import inspect\n3: import warnings\n4: from typing import Any\n5: from typing import Callable\n6: from typing import Collection\n7: from typing import Iterable\n8: from typing import Iterator\n9: from typing import List\n10: from typing import Mapping\n11: from typing import MutableMapping\n12: from typing import NamedTuple\n13: from typing import Optional\n14: from typing import overload\n15: from typing import Sequence\n16: from typing import Set\n17: from typing import Tuple\n18: from typing import Type\n19: from typing import TYPE_CHECKING\n20: from typing import TypeVar\n21: from typing import Union\n22: \n23: import attr\n24: \n25: from .._code import getfslineno\n26: from ..compat import ascii_escaped\n27: from ..compat import final\n28: from ..compat import NOTSET\n29: from ..compat import NotSetType\n30: from _pytest.config import Config\n31: from _pytest.deprecated import check_ispytest\n32: from _pytest.outcomes import fail\n33: from _pytest.warning_types import PytestUnknownMarkWarning\n34: \n35: if TYPE_CHECKING:\n36:     from ..nodes import Node\n37: \n38: \n39: EMPTY_PARAMETERSET_OPTION = \"empty_parameter_set_mark\"\n40: \n41: \n42: def istestfunc(func) -> bool:\n43:     return callable(func) and getattr(func, \"__name__\", \"<lambda>\") != \"<lambda>\"\n44: \n45: \n46: def get_empty_parameterset_mark(\n47:     config: Config, argnames: Sequence[str], func\n48: ) -> \"MarkDecorator\":\n49:     from ..nodes import Collector\n50: \n51:     fs, lineno = getfslineno(func)\n52:     reason = \"got empty parameter set %r, function %s at %s:%d\" % (\n53:         argnames,\n54:         func.__name__,\n55:         fs,\n56:         lineno,\n57:     )\n58: \n59:     requested_mark = config.getini(EMPTY_PARAMETERSET_OPTION)\n60:     if requested_mark in (\"\", None, \"skip\"):\n61:         mark = MARK_GEN.skip(reason=reason)\n62:     elif requested_mark == \"xfail\":\n63:         mark = MARK_GEN.xfail(reason=reason, run=False)\n64:     elif requested_mark == \"fail_at_collect\":\n65:         f_name = func.__name__\n66:         _, lineno = getfslineno(func)\n67:         raise Collector.CollectError(\n68:             \"Empty parameter set in '%s' at line %d\" % (f_name, lineno + 1)\n69:         )\n70:     else:\n71:         raise LookupError(requested_mark)\n72:     return mark\n73: \n74: \n75: class ParameterSet(NamedTuple):\nCode replaced for brevity.\n190: \n191: \n192: \n193: @final\n194: @attr.s(frozen=True, init=False, auto_attribs=True)\n195:     #: Name of the mark.\nCode replaced for brevity.\n255: \n256: \n257: \n258: # A generic parameter designating an object to which a Mark may\n259: # be applied -- a test function (callable) or class.\n260: # Note: a lambda is not allowed, but this can't be represented.\n261: Markable = TypeVar(\"Markable\", bound=Union[Callable[..., object], type])\n262: \n263: \n264: @attr.s(init=False, auto_attribs=True)\n265: class MarkDecorator:\nCode replaced for brevity.\n355: \n356: \n357: \n358: def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n359:     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n360:     mark_list = getattr(obj, \"pytestmark\", [])\n361:     if not isinstance(mark_list, list):\n362:         mark_list = [mark_list]\n363:     return normalize_mark_list(mark_list)\n364: \n365: \n366: ) -> Iterable[Mark]:\nCode replaced for brevity.\n380: \n381: \n382: \n383: def store_mark(obj, mark: Mark) -> None:\n384:     \"\"\"Store a Mark on an object.\n385: \n386:     This is used to implement the Mark declarations/decorators correctly.\n387:     \"\"\"\n388:     assert isinstance(mark, Mark), mark\n389:     # Always reassign name to avoid updating pytestmark in a reference that\n390:     # was only borrowed.\n391:     obj.pytestmark = [*get_unpacked_marks(obj), mark]\n392: \n393: \n394: # Typing for builtin pytest marks. This is cheating; it gives builtin marks\n395: # special privilege, and breaks modularity. But practicality beats purity...\n396: if TYPE_CHECKING:\n397:     from _pytest.scope import _ScopeName\n398: \n399:     class _SkipMarkDecorator(MarkDecorator):\nCode replaced for brevity.\n406: \n407: \n408:     class _SkipifMarkDecorator(MarkDecorator):\nCode replaced for brevity.\n415: \n416: \n417:     class _XfailMarkDecorator(MarkDecorator):\nCode replaced for brevity.\n432: \n433: \n434:     class _ParametrizeMarkDecorator(MarkDecorator):\nCode replaced for brevity.\n449: \n450: \n451:     class _UsefixturesMarkDecorator(MarkDecorator):\nCode replaced for brevity.\n453: \n454: \n455:     class _FilterwarningsMarkDecorator(MarkDecorator):\nCode replaced for brevity.\n457: \n458: \n459: \n460: @final\n461: class MarkGenerator:\nCode replaced for brevity.\n529: \n530: \n531: \n532: MARK_GEN = MarkGenerator(_ispytest=True)\n533: \n534: \n535: @final\n536: class NodeKeywords(MutableMapping[str, Any]):\nCode replaced for brevity.\n590: \n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/mark/structures.py",
      "suspect_lines": [
        358,
        359,
        360,
        361,
        362,
        363,
        391
      ]
    }
  ]
}