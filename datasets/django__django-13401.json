{
  "instance_id": "django__django-13401",
  "problem_statement": "Abstract model field should not be equal across models\nDescription\n\t\nConsider the following models:\nclass A(models.Model):\n\tclass Meta:\n\t\tabstract = True\n\tmyfield = IntegerField()\nclass B(A):\n\tpass\nclass C(A):\n\tpass\nIf I pull the fields of B and C into a shared set, one will be de-duplicated away, because they compare as equal. I found this surprising, though in practice using a list was sufficient for my need. The root of the issue is that they compare equal, as fields only consider self.creation_counter when comparing for equality.\nlen({B._meta.get_field('myfield'), C._meta.get_field('myfield')}) == 1\nB._meta.get_field('myfield') == C._meta.get_field('myfield')\nWe should adjust __eq__ so that if the field.model is different, they will compare unequal. Similarly, it is probably wise to adjust __hash__ and __lt__ to match.\nWhen adjusting __lt__, it may be wise to order first by self.creation_counter so that cases not affected by this equality collision won't be re-ordered. In my experimental branch, there was one test that broke if I ordered them by model first.\nI brought this up on IRC django-dev to check my intuitions, and those conversing with me there seemed to agree that the current behavior is not intuitive.\n",
  "localized_code": "[start of django/db/models/fields/__init__.py]\n1: import collections.abc\n2: import copy\n3: import datetime\n4: import decimal\n5: import operator\n6: import uuid\n7: import warnings\n8: from base64 import b64decode, b64encode\n9: from functools import partialmethod, total_ordering\n10: \n11: from django import forms\n12: from django.apps import apps\n13: from django.conf import settings\n14: from django.core import checks, exceptions, validators\n15: from django.db import connection, connections, router\n16: from django.db.models.constants import LOOKUP_SEP\n17: from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin\n18: from django.utils import timezone\n19: from django.utils.datastructures import DictWrapper\n20: from django.utils.dateparse import (\n21:     parse_date, parse_datetime, parse_duration, parse_time,\n22: )\n23: from django.utils.duration import duration_microseconds, duration_string\n24: from django.utils.functional import Promise, cached_property\n25: from django.utils.ipv6 import clean_ipv6_address\n26: from django.utils.itercompat import is_iterable\n27: from django.utils.text import capfirst\n28: from django.utils.translation import gettext_lazy as _\n29: \n30: __all__ = [\n31:     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',\n32:     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',\n33:     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',\n34:     'EmailField', 'Empty', 'Field', 'FilePathField', 'FloatField',\n35:     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',\n36:     'NullBooleanField', 'PositiveBigIntegerField', 'PositiveIntegerField',\n37:     'PositiveSmallIntegerField', 'SlugField', 'SmallAutoField',\n38:     'SmallIntegerField', 'TextField', 'TimeField', 'URLField', 'UUIDField',\n39: ]\n40: \n41: \n42: class Empty:\n43:     pass\n44: \n45: \n46: class NOT_PROVIDED:\n47:     pass\n48: \n49: \n50: # The values to use for \"blank\" in SelectFields. Will be appended to the start\n51: # of most \"choices\" lists.\n52: BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n53: \n54: \n55: def _load_field(app_label, model_name, field_name):\nCode replaced for brevity.\n56: \n57: \n58: \n59: # A guide to Field parameters:\n60: #\n61: #   * name:      The name of the field specified in the model.\n62: #   * attname:   The attribute to use on the model object. This is the same as\n63: #                \"name\", except in the case of ForeignKeys, where \"_id\" is\n64: #                appended.\n65: #   * db_column: The db_column specified in the model (or None).\n66: #   * column:    The database column for this field. This is the same as\n67: #                \"attname\", except if db_column is specified.\n68: #\n69: # Code that introspects values, or does other dynamic things, should use\n70: # attname. For example, this gets the primary key value of object \"obj\":\n71: #\n72: #     getattr(obj, opts.pk.attname)\n73: \n74: def _empty(of_cls):\n75:     new = Empty()\n76:     new.__class__ = of_cls\n77:     return new\n78: \n79: \n80: def return_None():\n81:     return None\n82: \n83: \n84: @total_ordering\n85: class Field(RegisterLookupMixin):\n86:     \"\"\"Base class for all field types\"\"\"\n87: \n88:     # Designates whether empty strings fundamentally are allowed at the\n89:     # database level.\n90:     empty_strings_allowed = True\n91:     empty_values = list(validators.EMPTY_VALUES)\n92: \n93:     # These track each time a Field instance is created. Used to retain order.\n94:     # The auto_creation_counter is used for fields that Django implicitly\n95:     # creates, creation_counter is used for all user-specified fields.\n96:     creation_counter = 0\n97:     auto_creation_counter = -1\n98:     default_validators = []  # Default set of validators\n99:     default_error_messages = {\n100:         'invalid_choice': _('Value %(value)r is not a valid choice.'),\n101:         'null': _('This field cannot be null.'),\n102:         'blank': _('This field cannot be blank.'),\n103:         'unique': _('%(model_name)s with this %(field_label)s '\n104:                     'already exists.'),\n105:         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n106:         # Eg: \"Title must be unique for pub_date year\"\n107:         'unique_for_date': _(\"%(field_label)s must be unique for \"\n108:                              \"%(date_field_label)s %(lookup_type)s.\"),\n109:     }\n110:     system_check_deprecated_details = None\n111:     system_check_removed_details = None\n112: \n113:     # Field flags\n114:     hidden = False\n115: \n116:     many_to_many = None\n117:     many_to_one = None\n118:     one_to_many = None\n119:     one_to_one = None\n120:     related_model = None\n121: \n122:     descriptor_class = DeferredAttribute\n123: \n124:     # Generic field type description, usually overridden by subclasses\n125:     def _description(self):\n126:         return _('Field of type: %(field_type)s') % {\n127:             'field_type': self.__class__.__name__\n128:         }\n129:     description = property(_description)\n130: \n131:     def __init__(self, verbose_name=None, name=None, primary_key=False,\n132:                  max_length=None, unique=False, blank=False, null=False,\n133:                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n134:                  serialize=True, unique_for_date=None, unique_for_month=None,\n135:                  unique_for_year=None, choices=None, help_text='', db_column=None,\n136:                  db_tablespace=None, auto_created=False, validators=(),\n137:                  error_messages=None):\n138:         self.name = name\n139:         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n140:         self._verbose_name = verbose_name  # Store original for deconstruction\n141:         self.primary_key = primary_key\n142:         self.max_length, self._unique = max_length, unique\n143:         self.blank, self.null = blank, null\n144:         self.remote_field = rel\n145:         self.is_relation = self.remote_field is not None\n146:         self.default = default\n147:         self.editable = editable\n148:         self.serialize = serialize\n149:         self.unique_for_date = unique_for_date\n150:         self.unique_for_month = unique_for_month\n151:         self.unique_for_year = unique_for_year\n152:         if isinstance(choices, collections.abc.Iterator):\n153:             choices = list(choices)\n154:         self.choices = choices\n155:         self.help_text = help_text\n156:         self.db_index = db_index\n157:         self.db_column = db_column\n158:         self._db_tablespace = db_tablespace\n159:         self.auto_created = auto_created\n160: \n161:         # Adjust the appropriate creation counter, and save our local copy.\n162:         if auto_created:\n163:             self.creation_counter = Field.auto_creation_counter\n164:             Field.auto_creation_counter -= 1\n165:         else:\n166:             self.creation_counter = Field.creation_counter\n167:             Field.creation_counter += 1\n168: \n169:         self._validators = list(validators)  # Store for deconstruction later\n170: \n171:         messages = {}\n172:         for c in reversed(self.__class__.__mro__):\n173:             messages.update(getattr(c, 'default_error_messages', {}))\n174:         messages.update(error_messages or {})\n175:         self._error_messages = error_messages  # Store for deconstruction later\n176:         self.error_messages = messages\n177: \n178:     def __str__(self):\n179:         \"\"\"\n180:         Return \"app_label.model_label.field_name\" for fields attached to\n181:         models.\n182:         \"\"\"\n183:         if not hasattr(self, 'model'):\n184:             return super().__str__()\n185:         model = self.model\n186:         app = model._meta.app_label\n187:         return '%s.%s.%s' % (app, model._meta.object_name, self.name)\n188: \n189:     def __repr__(self):\n190:         \"\"\"Display the module, class, and name of the field.\"\"\"\n191:         path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)\n192:         name = getattr(self, 'name', None)\n193:         if name is not None:\n194:             return '<%s: %s>' % (path, name)\n195:         return '<%s>' % path\n196: \n197:     def check(self, **kwargs):\n198:         return [\n199:             *self._check_field_name(),\n200:             *self._check_choices(),\n201:             *self._check_db_index(),\n202:             *self._check_null_allowed_for_primary_keys(),\n203:             *self._check_backend_specific_checks(**kwargs),\n204:             *self._check_validators(),\n205:             *self._check_deprecation_details(),\n206:         ]\n207: \n208:     def _check_field_name(self):\n209:         \"\"\"\n210:         Check if field name is valid, i.e. 1) does not end with an\n211:         underscore, 2) does not contain \"__\" and 3) is not \"pk\".\n212:         \"\"\"\n213:         if self.name.endswith('_'):\n214:             return [\n215:                 checks.Error(\n216:                     'Field names must not end with an underscore.',\n217:                     obj=self,\n218:                     id='fields.E001',\n219:                 )\n220:             ]\n221:         elif LOOKUP_SEP in self.name:\n222:             return [\n223:                 checks.Error(\n224:                     'Field names must not contain \"%s\".' % LOOKUP_SEP,\n225:                     obj=self,\n226:                     id='fields.E002',\n227:                 )\n228:             ]\n229:         elif self.name == 'pk':\n230:             return [\n231:                 checks.Error(\n232:                     \"'pk' is a reserved word that cannot be used as a field name.\",\n233:                     obj=self,\n234:                     id='fields.E003',\n235:                 )\n236:             ]\n237:         else:\n238:             return []\n239: \n240:     @classmethod\n241:     def _choices_is_value(cls, value):\n242:         return isinstance(value, (str, Promise)) or not is_iterable(value)\n243: \n244:     def _check_choices(self):\n245:         if not self.choices:\n246:             return []\n247: \n248:         if not is_iterable(self.choices) or isinstance(self.choices, str):\n249:             return [\n250:                 checks.Error(\n251:                     \"'choices' must be an iterable (e.g., a list or tuple).\",\n252:                     obj=self,\n253:                     id='fields.E004',\n254:                 )\n255:             ]\n256: \n257:         choice_max_length = 0\n258:         # Expect [group_name, [value, display]]\n259:         for choices_group in self.choices:\n260:             try:\n261:                 group_name, group_choices = choices_group\n262:             except (TypeError, ValueError):\n263:                 # Containing non-pairs\n264:                 break\n265:             try:\n266:                 if not all(\n267:                     self._choices_is_value(value) and self._choices_is_value(human_name)\n268:                     for value, human_name in group_choices\n269:                 ):\n270:                     break\n271:                 if self.max_length is not None and group_choices:\n272:                     choice_max_length = max([\n273:                         choice_max_length,\n274:                         *(len(value) for value, _ in group_choices if isinstance(value, str)),\n275:                     ])\n276:             except (TypeError, ValueError):\n277:                 # No groups, choices in the form [value, display]\n278:                 value, human_name = group_name, group_choices\n279:                 if not self._choices_is_value(value) or not self._choices_is_value(human_name):\n280:                     break\n281:                 if self.max_length is not None and isinstance(value, str):\n282:                     choice_max_length = max(choice_max_length, len(value))\n283: \n284:             # Special case: choices=['ab']\n285:             if isinstance(choices_group, str):\n286:                 break\n287:         else:\n288:             if self.max_length is not None and choice_max_length > self.max_length:\n289:                 return [\n290:                     checks.Error(\n291:                         \"'max_length' is too small to fit the longest value \"\n292:                         \"in 'choices' (%d characters).\" % choice_max_length,\n293:                         obj=self,\n294:                         id='fields.E009',\n295:                     ),\n296:                 ]\n297:             return []\n298: \n299:         return [\n300:             checks.Error(\n301:                 \"'choices' must be an iterable containing \"\n302:                 \"(actual value, human readable name) tuples.\",\n303:                 obj=self,\n304:                 id='fields.E005',\n305:             )\n306:         ]\n307: \n308:     def _check_db_index(self):\n309:         if self.db_index not in (None, True, False):\n310:             return [\n311:                 checks.Error(\n312:                     \"'db_index' must be None, True or False.\",\n313:                     obj=self,\n314:                     id='fields.E006',\n315:                 )\n316:             ]\n317:         else:\n318:             return []\n319: \n320:     def _check_null_allowed_for_primary_keys(self):\n321:         if (self.primary_key and self.null and\n322:                 not connection.features.interprets_empty_strings_as_nulls):\n323:             # We cannot reliably check this for backends like Oracle which\n324:             # consider NULL and '' to be equal (and thus set up\n325:             # character-based fields a little differently).\n326:             return [\n327:                 checks.Error(\n328:                     'Primary keys must not have null=True.',\n329:                     hint=('Set null=False on the field, or '\n330:                           'remove primary_key=True argument.'),\n331:                     obj=self,\n332:                     id='fields.E007',\n333:                 )\n334:             ]\n335:         else:\n336:             return []\n337: \n338:     def _check_backend_specific_checks(self, databases=None, **kwargs):\n339:         if databases is None:\n340:             return []\n341:         app_label = self.model._meta.app_label\n342:         errors = []\n343:         for alias in databases:\n344:             if router.allow_migrate(alias, app_label, model_name=self.model._meta.model_name):\n345:                 errors.extend(connections[alias].validation.check_field(self, **kwargs))\n346:         return errors\n347: \n348:     def _check_validators(self):\n349:         errors = []\n350:         for i, validator in enumerate(self.validators):\n351:             if not callable(validator):\n352:                 errors.append(\n353:                     checks.Error(\n354:                         \"All 'validators' must be callable.\",\n355:                         hint=(\n356:                             \"validators[{i}] ({repr}) isn't a function or \"\n357:                             \"instance of a validator class.\".format(\n358:                                 i=i, repr=repr(validator),\n359:                             )\n360:                         ),\n361:                         obj=self,\n362:                         id='fields.E008',\n363:                     )\n364:                 )\n365:         return errors\n366: \n367:     def _check_deprecation_details(self):\n368:         if self.system_check_removed_details is not None:\n369:             return [\n370:                 checks.Error(\n371:                     self.system_check_removed_details.get(\n372:                         'msg',\n373:                         '%s has been removed except for support in historical '\n374:                         'migrations.' % self.__class__.__name__\n375:                     ),\n376:                     hint=self.system_check_removed_details.get('hint'),\n377:                     obj=self,\n378:                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),\n379:                 )\n380:             ]\n381:         elif self.system_check_deprecated_details is not None:\n382:             return [\n383:                 checks.Warning(\n384:                     self.system_check_deprecated_details.get(\n385:                         'msg',\n386:                         '%s has been deprecated.' % self.__class__.__name__\n387:                     ),\n388:                     hint=self.system_check_deprecated_details.get('hint'),\n389:                     obj=self,\n390:                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),\n391:                 )\n392:             ]\n393:         return []\n394: \n395:     def get_col(self, alias, output_field=None):\n396:         if output_field is None:\n397:             output_field = self\n398:         if alias != self.model._meta.db_table or output_field != self:\n399:             from django.db.models.expressions import Col\n400:             return Col(alias, self, output_field)\n401:         else:\n402:             return self.cached_col\n403: \n404:     @cached_property\n405:     def cached_col(self):\n406:         from django.db.models.expressions import Col\n407:         return Col(self.model._meta.db_table, self)\n408: \n409:     def select_format(self, compiler, sql, params):\n410:         \"\"\"\n411:         Custom format for select clauses. For example, GIS columns need to be\n412:         selected as AsText(table.col) on MySQL as the table.col data can't be\n413:         used by Django.\n414:         \"\"\"\n415:         return sql, params\n416: \n417:     def deconstruct(self):\n418:         \"\"\"\n419:         Return enough information to recreate the field as a 4-tuple:\n420: \n421:          * The name of the field on the model, if contribute_to_class() has\n422:            been run.\n423:          * The import path of the field, including the class:e.g.\n424:            django.db.models.IntegerField This should be the most portable\n425:            version, so less specific may be better.\n426:          * A list of positional arguments.\n427:          * A dict of keyword arguments.\n428: \n429:         Note that the positional or keyword arguments must contain values of\n430:         the following types (including inner values of collection types):\n431: \n432:          * None, bool, str, int, float, complex, set, frozenset, list, tuple,\n433:            dict\n434:          * UUID\n435:          * datetime.datetime (naive), datetime.date\n436:          * top-level classes, top-level functions - will be referenced by their\n437:            full import path\n438:          * Storage instances - these have their own deconstruct() method\n439: \n440:         This is because the values here must be serialized into a text format\n441:         (possibly new Python code, possibly JSON) and these are the only types\n442:         with encoding handlers defined.\n443: \n444:         There's no need to return the exact way the field was instantiated this\n445:         time, just ensure that the resulting field is the same - prefer keyword\n446:         arguments over positional ones, and omit parameters with their default\n447:         values.\n448:         \"\"\"\n449:         # Short-form way of fetching all the default parameters\n450:         keywords = {}\n451:         possibles = {\n452:             \"verbose_name\": None,\n453:             \"primary_key\": False,\n454:             \"max_length\": None,\n455:             \"unique\": False,\n456:             \"blank\": False,\n457:             \"null\": False,\n458:             \"db_index\": False,\n459:             \"default\": NOT_PROVIDED,\n460:             \"editable\": True,\n461:             \"serialize\": True,\n462:             \"unique_for_date\": None,\n463:             \"unique_for_month\": None,\n464:             \"unique_for_year\": None,\n465:             \"choices\": None,\n466:             \"help_text\": '',\n467:             \"db_column\": None,\n468:             \"db_tablespace\": None,\n469:             \"auto_created\": False,\n470:             \"validators\": [],\n471:             \"error_messages\": None,\n472:         }\n473:         attr_overrides = {\n474:             \"unique\": \"_unique\",\n475:             \"error_messages\": \"_error_messages\",\n476:             \"validators\": \"_validators\",\n477:             \"verbose_name\": \"_verbose_name\",\n478:             \"db_tablespace\": \"_db_tablespace\",\n479:         }\n480:         equals_comparison = {\"choices\", \"validators\"}\n481:         for name, default in possibles.items():\n482:             value = getattr(self, attr_overrides.get(name, name))\n483:             # Unroll anything iterable for choices into a concrete list\n484:             if name == \"choices\" and isinstance(value, collections.abc.Iterable):\n485:                 value = list(value)\n486:             # Do correct kind of comparison\n487:             if name in equals_comparison:\n488:                 if value != default:\n489:                     keywords[name] = value\n490:             else:\n491:                 if value is not default:\n492:                     keywords[name] = value\n493:         # Work out path - we shorten it for known Django core fields\n494:         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n495:         if path.startswith(\"django.db.models.fields.related\"):\n496:             path = path.replace(\"django.db.models.fields.related\", \"django.db.models\")\n497:         elif path.startswith(\"django.db.models.fields.files\"):\n498:             path = path.replace(\"django.db.models.fields.files\", \"django.db.models\")\n499:         elif path.startswith('django.db.models.fields.json'):\n500:             path = path.replace('django.db.models.fields.json', 'django.db.models')\n501:         elif path.startswith(\"django.db.models.fields.proxy\"):\n502:             path = path.replace(\"django.db.models.fields.proxy\", \"django.db.models\")\n503:         elif path.startswith(\"django.db.models.fields\"):\n504:             path = path.replace(\"django.db.models.fields\", \"django.db.models\")\n505:         # Return basic info - other fields should override this.\n506:         return (self.name, path, [], keywords)\n507: \n508:     def clone(self):\n509:         \"\"\"\n510:         Uses deconstruct() to clone a new copy of this Field.\n511:         Will not preserve any class attachments/attribute names.\n512:         \"\"\"\n513:         name, path, args, kwargs = self.deconstruct()\n514:         return self.__class__(*args, **kwargs)\n515: \n516:     def __eq__(self, other):\n517:         # Needed for @total_ordering\n518:         if isinstance(other, Field):\n519:             return self.creation_counter == other.creation_counter\n520:         return NotImplemented\n521: \n522:     def __lt__(self, other):\n523:         # This is needed because bisect does not take a comparison function.\n524:         if isinstance(other, Field):\n525:             return self.creation_counter < other.creation_counter\n526:         return NotImplemented\n527: \n528:     def __hash__(self):\n529:         return hash(self.creation_counter)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/__init__.py",
      "suspect_lines": [
        519,
        525,
        529
      ]
    }
  ]
}