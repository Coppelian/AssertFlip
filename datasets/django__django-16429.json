{
  "instance_id": "django__django-16429",
  "problem_statement": "timesince() raises TypeError with USE_TZ=True and >1 month interval.\nDescription\n\t \n\t\t(last modified by Sage Abdullah)\n\t \nAs of 8d67e16493c903adc9d049141028bc0fff43f8c8, calling timesince() with a datetime object that's one month (or more) in the past and the USE_TZ setting is set to True results in the following crash:\nTypeError: can't subtract offset-naive and offset-aware datetimes\nTest:\n...\nclass TimesinceTests(TestCase):\n\t...\n\t@requires_tz_support\n\t@override_settings(USE_TZ=True)\n\tdef test_long_interval_with_tz(self):\n\t\tnow = timezone.now()\n\t\td = now - datetime.timedelta(days=31)\n\t\tself.assertEqual(timesince(d), \"1\\xa0month\")\nI believe this is because the pivot instantiated here: â€‹https://github.com/django/django/blob/d2310f6473593d28c14b63a72253408b568e100a/django/utils/timesince.py#L93-L100 does not take into account the datetime object's tzinfo. Adding 0, d.tzinfo arguments to the datetime.datetime call seems to fix this.\nHappy to send a PR.\n",
  "localized_code": "[start of django/utils/timesince.py]\n1: import datetime\n2: \n3: from django.utils.html import avoid_wrapping\n4: from django.utils.timezone import is_aware\n5: from django.utils.translation import gettext, ngettext_lazy\n6: \n7: TIME_STRINGS = {\n8:     \"year\": ngettext_lazy(\"%(num)d year\", \"%(num)d years\", \"num\"),\n9:     \"month\": ngettext_lazy(\"%(num)d month\", \"%(num)d months\", \"num\"),\n10:     \"week\": ngettext_lazy(\"%(num)d week\", \"%(num)d weeks\", \"num\"),\n11:     \"day\": ngettext_lazy(\"%(num)d day\", \"%(num)d days\", \"num\"),\n12:     \"hour\": ngettext_lazy(\"%(num)d hour\", \"%(num)d hours\", \"num\"),\n13:     \"minute\": ngettext_lazy(\"%(num)d minute\", \"%(num)d minutes\", \"num\"),\n14: }\n15: \n16: TIME_STRINGS_KEYS = list(TIME_STRINGS.keys())\n17: \n18: TIME_CHUNKS = [\n19:     60 * 60 * 24 * 7,  # week\n20:     60 * 60 * 24,  # day\n21:     60 * 60,  # hour\n22:     60,  # minute\n23: ]\n24: \n25: MONTHS_DAYS = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n26: \n27: \n28: def timesince(d, now=None, reversed=False, time_strings=None, depth=2):\n29:     \"\"\"\n30:     Take two datetime objects and return the time between d and now as a nicely\n31:     formatted string, e.g. \"10 minutes\". If d occurs after now, return\n32:     \"0 minutes\".\n33: \n34:     Units used are years, months, weeks, days, hours, and minutes.\n35:     Seconds and microseconds are ignored.\n36: \n37:     The algorithm takes into account the varying duration of years and months.\n38:     There is exactly \"1 year, 1 month\" between 2013/02/10 and 2014/03/10,\n39:     but also between 2007/08/10 and 2008/09/10 despite the delta being 393 days\n40:     in the former case and 397 in the latter.\n41: \n42:     Up to `depth` adjacent units will be displayed.  For example,\n43:     \"2 weeks, 3 days\" and \"1 year, 3 months\" are possible outputs, but\n44:     \"2 weeks, 3 hours\" and \"1 year, 5 days\" are not.\n45: \n46:     `time_strings` is an optional dict of strings to replace the default\n47:     TIME_STRINGS dict.\n48: \n49:     `depth` is an optional integer to control the number of adjacent time\n50:     units returned.\n51: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/timesince.py",
      "suspect_lines": []
    }
  ]
}