{
  "instance_id": "django__django-16631",
  "problem_statement": "SECRET_KEY_FALLBACKS is not used for sessions\nDescription\n\t\nI recently rotated my secret key, made the old one available in SECRET_KEY_FALLBACKS and I'm pretty sure everyone on our site is logged out now.\nI think the docs for ​SECRET_KEY_FALLBACKS may be incorrect when stating the following:\nIn order to rotate your secret keys, set a new SECRET_KEY and move the previous value to the beginning of SECRET_KEY_FALLBACKS. Then remove the old values from the end of the SECRET_KEY_FALLBACKS when you are ready to expire the sessions, password reset tokens, and so on, that make use of them.\nWhen looking at the Django source code, I see that the ​salted_hmac function uses the SECRET_KEY by default and the ​AbstractBaseUser.get_session_auth_hash method does not call salted_hmac with a value for the secret keyword argument.\n",
  "localized_code": "[start of django/contrib/auth/__init__.py]\n1: import inspect\n2: import re\n3: \n4: from django.apps import apps as django_apps\n5: from django.conf import settings\n6: from django.core.exceptions import ImproperlyConfigured, PermissionDenied\n7: from django.middleware.csrf import rotate_token\n8: from django.utils.crypto import constant_time_compare\n9: from django.utils.module_loading import import_string\n10: from django.views.decorators.debug import sensitive_variables\n11: \n12: from .signals import user_logged_in, user_logged_out, user_login_failed\n13: \n14: SESSION_KEY = \"_auth_user_id\"\n15: BACKEND_SESSION_KEY = \"_auth_user_backend\"\n16: HASH_SESSION_KEY = \"_auth_user_hash\"\n17: REDIRECT_FIELD_NAME = \"next\"\n18: \n19: \n20: def load_backend(path):\n21:     return import_string(path)()\n22: \n23: \n24: def _get_backends(return_tuples=False):\n25:     backends = []\n26:     for backend_path in settings.AUTHENTICATION_BACKENDS:\n27:         backend = load_backend(backend_path)\n28:         backends.append((backend, backend_path) if return_tuples else backend)\n29:     if not backends:\n30:         raise ImproperlyConfigured(\n31:             \"No authentication backends have been defined. Does \"\n32:             \"AUTHENTICATION_BACKENDS contain anything?\"\n33:         )\n34:     return backends\n35: \n36: \n37: def get_backends():\n38:     return _get_backends(return_tuples=False)\n39: \n40: \n41: @sensitive_variables(\"credentials\")\n42: def _clean_credentials(credentials):\n43:     \"\"\"\n44:     Clean a dictionary of credentials of potentially sensitive info before\n45:     sending to less secure functions.\n46: \n47:     Not comprehensive - intended for user_login_failed signal\n48:     \"\"\"\n49:     SENSITIVE_CREDENTIALS = re.compile(\"api|token|key|secret|password|signature\", re.I)\n50:     CLEANSED_SUBSTITUTE = \"********************\"\n51:     for key in credentials:\n52:         if SENSITIVE_CREDENTIALS.search(key):\n53:             credentials[key] = CLEANSED_SUBSTITUTE\n54:     return credentials\n55: \n56: \n57:     # to convert it back to Python whenever we access it.\nCode replaced for brevity.\n60: \n61: \n62: \n63: @sensitive_variables(\"credentials\")\n64: def authenticate(request=None, **credentials):\nCode replaced for brevity.\n91: \n92: \n93: \n94: def login(request, user, backend=None):\nCode replaced for brevity.\n144: \n145: \n146: \n147: def logout(request):\nCode replaced for brevity.\n162: \n163: \n164: \n165: def get_user_model():\nCode replaced for brevity.\n179: \n180: \n181: \n182: def get_user(request):\n183:     \"\"\"\n184:     Return the user model instance associated with the given request session.\n185:     If no user is retrieved, return an instance of `AnonymousUser`.\n186:     \"\"\"\n187:     from .models import AnonymousUser\n188: \n189:     user = None\n190:     try:\n191:         user_id = _get_user_session_key(request)\n192:         backend_path = request.session[BACKEND_SESSION_KEY]\n193:     except KeyError:\n194:         pass\n195:     else:\n196:         if backend_path in settings.AUTHENTICATION_BACKENDS:\n197:             backend = load_backend(backend_path)\n198:             user = backend.get_user(user_id)\n199:             # Verify the session\n200:             if hasattr(user, \"get_session_auth_hash\"):\n201:                 session_hash = request.session.get(HASH_SESSION_KEY)\n202:                 session_hash_verified = session_hash and constant_time_compare(\n203:                     session_hash, user.get_session_auth_hash()\n204:                 )\n205:                 if not session_hash_verified:\n206:                     request.session.flush()\n207:                     user = None\n208: \n209:     return user or AnonymousUser()\n210: \n211: \n212: def get_permission_codename(action, opts):\nCode replaced for brevity.\n216: \n217: \n218: \n219: def update_session_auth_hash(request, user):\nCode replaced for brevity.\n230: \n\n[start of django/contrib/auth/base_user.py]\n1: \"\"\"\n2: This module allows importing AbstractBaseUser even when django.contrib.auth is\n3: not in INSTALLED_APPS.\n4: \"\"\"\n5: import unicodedata\n6: import warnings\n7: \n8: from django.contrib.auth import password_validation\n9: from django.contrib.auth.hashers import (\n10:     check_password,\n11:     is_password_usable,\n12:     make_password,\n13: )\n14: from django.db import models\n15: from django.utils.crypto import get_random_string, salted_hmac\n16: from django.utils.deprecation import RemovedInDjango51Warning\n17: from django.utils.translation import gettext_lazy as _\n18: \n19: \n20: class BaseUserManager(models.Manager):\n21:     @classmethod\n22:     def normalize_email(cls, email):\n23:         \"\"\"\n24:         Normalize the email address by lowercasing the domain part of it.\n25:         \"\"\"\n26:         email = email or \"\"\n27:         try:\n28:             email_name, domain_part = email.strip().rsplit(\"@\", 1)\n29:         except ValueError:\n30:             pass\n31:         else:\n32:             email = email_name + \"@\" + domain_part.lower()\n33:         return email\n34: \n35:     def make_random_password(\n36:         self,\n37:         length=10,\n38:         allowed_chars=\"abcdefghjkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789\",\n39:     ):\n40:         \"\"\"\n41:         Generate a random password with the given length and given\n42:         allowed_chars. The default value of allowed_chars does not have \"I\" or\n43:         \"O\" or letters and digits that look similar -- just to avoid confusion.\n44:         \"\"\"\n45:         warnings.warn(\n46:             \"BaseUserManager.make_random_password() is deprecated.\",\n47:             category=RemovedInDjango51Warning,\n48:             stacklevel=2,\n49:         )\n50:         return get_random_string(length, allowed_chars)\n51: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/auth/__init__.py",
      "suspect_lines": [
        202,
        203,
        204,
        206,
        207
      ]
    },
    {
      "filename": "/django/contrib/auth/base_user.py",
      "suspect_lines": []
    }
  ]
}