{
  "instance_id": "django__django-13128",
  "problem_statement": "make temporal subtraction work without ExpressionWrapper\nDescription\n\t\nclass Experiment(models.Model):\n\tstart = models.DateTimeField()\n\tend = models.DateTimeField()\nExperiment.objects.annotate(\n\tdelta=F('end') - F('start') + Value(datetime.timedelta(), output_field=DurationField())\n)\nThis gives:\ndjango.core.exceptions.FieldError: Expression contains mixed types: DateTimeField, DurationField. You must set output_field.\n",
  "localized_code": "[start of django/db/models/expressions.py]\n1: import copy\n2: import datetime\n3: import inspect\n4: from decimal import Decimal\n5: \n6: from django.core.exceptions import EmptyResultSet, FieldError\n7: from django.db import NotSupportedError, connection\n8: from django.db.models import fields\n9: from django.db.models.constants import LOOKUP_SEP\n10: from django.db.models.query_utils import Q\n11: from django.utils.deconstruct import deconstructible\n12: from django.utils.functional import cached_property\n13: from django.utils.hashable import make_hashable\n14: \n15: \n16: class SQLiteNumericMixin:\n17:     \"\"\"\n18:     Some expressions with output_field=DecimalField() must be cast to\n19:     numeric to be properly filtered.\n20:     \"\"\"\n21:     def as_sqlite(self, compiler, connection, **extra_context):\n22:         sql, params = self.as_sql(compiler, connection, **extra_context)\n23:         try:\n24:             if self.output_field.get_internal_type() == 'DecimalField':\n25:                 sql = 'CAST(%s AS NUMERIC)' % sql\n26:         except FieldError:\n27:             pass\n28:         return sql, params\n29: \n30: \n31: class Combinable:\n32:     \"\"\"\n33:     Provide the ability to combine one or two objects with\n34:     some connector. For example F('foo') + F('bar').\n35:     \"\"\"\n36: \n37:     # Arithmetic connectors\n38:     ADD = '+'\n39:     SUB = '-'\n40:     MUL = '*'\n41:     DIV = '/'\n42:     POW = '^'\n43:     # The following is a quoted % operator - it is quoted because it can be\n44:     # used in strings that also have parameter substitution.\n45:     MOD = '%%'\n46: \n47:     # Bitwise operators - note that these are generated by .bitand()\n48:     # and .bitor(), the '&' and '|' are reserved for boolean operator\n49:     # usage.\n50:     BITAND = '&'\n51:     BITOR = '|'\n52:     BITLEFTSHIFT = '<<'\n53:     BITRIGHTSHIFT = '>>'\n54:     BITXOR = '#'\n55: \n56:     def _combine(self, other, connector, reversed):\n57:         if not hasattr(other, 'resolve_expression'):\n58:             # everything must be resolvable to an expression\n59:             output_field = (\n60:                 fields.DurationField()\n61:                 if isinstance(other, datetime.timedelta) else\n62:                 None\n63:             )\n64:             other = Value(other, output_field=output_field)\n65: \n66:         if reversed:\n67:             return CombinedExpression(other, connector, self)\n68:         return CombinedExpression(self, connector, other)\n69: \n70:     #############\n71:     # OPERATORS #\n72:     #############\n73: \n74:     def __neg__(self):\n75:         return self._combine(-1, self.MUL, False)\n76: \n77:     def __add__(self, other):\n78:         return self._combine(other, self.ADD, False)\n79: \n80:     def __sub__(self, other):\n81:         return self._combine(other, self.SUB, False)\n82: \n83:     def __mul__(self, other):\n84:         return self._combine(other, self.MUL, False)\n85: \n86:     def __truediv__(self, other):\n87:         return self._combine(other, self.DIV, False)\n88: \n89:     def __mod__(self, other):\n90:         return self._combine(other, self.MOD, False)\n91: \n92:     def __pow__(self, other):\n93:         return self._combine(other, self.POW, False)\n94: \n95:     def __and__(self, other):\n96:         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n97:             return Q(self) & Q(other)\n98:         raise NotImplementedError(\n99:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n100:         )\n101: \n102:     def bitand(self, other):\n103:         return self._combine(other, self.BITAND, False)\n104: \n105:     def bitleftshift(self, other):\n106:         return self._combine(other, self.BITLEFTSHIFT, False)\n107: \n108:     def bitrightshift(self, other):\n109:         return self._combine(other, self.BITRIGHTSHIFT, False)\n110: \n111:     def bitxor(self, other):\n112:         return self._combine(other, self.BITXOR, False)\n113: \n114:     def __or__(self, other):\n115:         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n116:             return Q(self) | Q(other)\n117:         raise NotImplementedError(\n118:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n119:         )\n120: \n121:     def bitor(self, other):\n122:         return self._combine(other, self.BITOR, False)\n123: \n124:     def __radd__(self, other):\n125:         return self._combine(other, self.ADD, True)\n126: \n127:     def __rsub__(self, other):\n128:         return self._combine(other, self.SUB, True)\n129: \n130:     def __rmul__(self, other):\n131:         return self._combine(other, self.MUL, True)\n132: \n133:     def __rtruediv__(self, other):\n134:         return self._combine(other, self.DIV, True)\n135: \n136:     def __rmod__(self, other):\n137:         return self._combine(other, self.MOD, True)\n138: \n139:     def __rpow__(self, other):\n140:         return self._combine(other, self.POW, True)\n141: \n142:     def __rand__(self, other):\n143:         raise NotImplementedError(\n144:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n145:         )\n146: \n147:     def __ror__(self, other):\n148:         raise NotImplementedError(\n149:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n150:         )\n151: \n152: \n153: @deconstructible\n154: class BaseExpression:\nCode replaced for brevity.\n417: \n418: \n419: \n420: class Expression(BaseExpression, Combinable):\nCode replaced for brevity.\n422: \n423: \n424: \n425: class CombinedExpression(SQLiteNumericMixin, Expression):\n426: \n427:     def __init__(self, lhs, connector, rhs, output_field=None):\n428:         super().__init__(output_field=output_field)\n429:         self.connector = connector\n430:         self.lhs = lhs\n431:         self.rhs = rhs\n432: \n433:     def __repr__(self):\n434:         return \"<{}: {}>\".format(self.__class__.__name__, self)\n435: \n436:     def __str__(self):\n437:         return \"{} {} {}\".format(self.lhs, self.connector, self.rhs)\n438: \n439:     def get_source_expressions(self):\n440:         return [self.lhs, self.rhs]\n441: \n442:     def set_source_expressions(self, exprs):\n443:         self.lhs, self.rhs = exprs\n444: \n445:     def as_sql(self, compiler, connection):\n446:         try:\n447:             lhs_type = self.lhs.output_field.get_internal_type()\n448:         except FieldError:\n449:             lhs_type = None\n450:         try:\n451:             rhs_type = self.rhs.output_field.get_internal_type()\n452:         except FieldError:\n453:             rhs_type = None\n454:         if (\n455:             not connection.features.has_native_duration_field and\n456:             'DurationField' in {lhs_type, rhs_type} and\n457:             lhs_type != rhs_type\n458:         ):\n459:             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n460:         datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\n461:         if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n462:             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n463:         expressions = []\n464:         expression_params = []\n465:         sql, params = compiler.compile(self.lhs)\n466:         expressions.append(sql)\n467:         expression_params.extend(params)\n468:         sql, params = compiler.compile(self.rhs)\n469:         expressions.append(sql)\n470:         expression_params.extend(params)\n471:         # order of precedence\n472:         expression_wrapper = '(%s)'\n473:         sql = connection.ops.combine_expression(self.connector, expressions)\n474:         return expression_wrapper % sql, expression_params\n475: \n476:     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n477:         c = self.copy()\n478:         c.is_summary = summarize\n479:         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n480:         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n481:         return c\n482: \n483: \n484: class DurationExpression(CombinedExpression):\nCode replaced for brevity.\n509: \n510: \n511: \n512: class TemporalSubtraction(CombinedExpression):\nCode replaced for brevity.\n522: \n523: \n524: \n525: @deconstructible\n526: class F(Combinable):\nCode replaced for brevity.\n553: \n554: \n555: \n556: class ResolvedOuterRef(F):\nCode replaced for brevity.\n583: \n584: \n585: \n586:     c\nCode replaced for brevity.\n595: \n596: \n597: \n598:     \"\nCode replaced for brevity.\n669: \n670: \n671: \n672:     \"\nCode replaced for brevity.\n713: \n714: \n715: \n716:     d\nCode replaced for brevity.\n740: \n741: \n742: \n743:     d\nCode replaced for brevity.\n748: \n749: \n750: \n751:     o\nCode replaced for brevity.\n758: \n759: \n760: \n761:     c\nCode replaced for brevity.\n795: \n796: \n797: \n798:     \"\nCode replaced for brevity.\n828: \n829: \n830: \n831:     \"\nCode replaced for brevity.\n845: \n846: \n847: \n848:     \"\nCode replaced for brevity.\n874: \n875: \n876: \n877:     t\nCode replaced for brevity.\n941: \n942: \n943: \n944:     \"\nCode replaced for brevity.\n1017: \n1018: \n1019: \n1020:     \"\nCode replaced for brevity.\n1079: \n1080: \n1081: \n1082:     t\nCode replaced for brevity.\n1110: \n1111: \n1112: \n1113:     t\nCode replaced for brevity.\n1194: \n1195: \n1196: \n1197:     t\nCode replaced for brevity.\n1288: \n1289: \n1290: \n1291:     \"\nCode replaced for brevity.\n1347: \n1348: \n1349: \n1350:     f\nCode replaced for brevity.\n1354: \n1355: \n1356: \n1357:     f\nCode replaced for brevity.\n1361: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/expressions.py",
      "suspect_lines": [
        446,
        447,
        448,
        449,
        450,
        451,
        452,
        453,
        454,
        455,
        456,
        457,
        458,
        459,
        460,
        461,
        462,
        479,
        480
      ]
    }
  ]
}