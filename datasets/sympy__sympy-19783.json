{
  "instance_id": "sympy__sympy-19783",
  "problem_statement": "Dagger() * IdentityOperator() is not simplified\nAs discussed on the mailing list the following does not work.\r\n```\r\nfrom sympy.physics.quantum.dagger import Dagger\r\nfrom sympy.physics.quantum.operator import Operator\r\nfrom sympy.physics.quantum import IdentityOperator\r\nA = Operators('A')\r\nIdentity = IdentityOperator()\r\nA * Identity #This gives A, correctly\r\nB = Dagger(A)\r\nB * Identity #This returns A^\\dagger I \r\n```\r\n\n",
  "localized_code": "[start of sympy/physics/quantum/dagger.py]\n1: \"\"\"Hermitian conjugation.\"\"\"\n2: \n3: from __future__ import print_function, division\n4: \n5: from sympy.core import Expr\n6: from sympy.functions.elementary.complexes import adjoint\n7: \n8: __all__ = [\n9:     'Dagger'\n10: ]\n11: \n12: \n13: class Dagger(adjoint):\n14:     \"\"\"General Hermitian conjugate operation.\n15: \n16:     Take the Hermetian conjugate of an argument [1]_. For matrices this\n17:     operation is equivalent to transpose and complex conjugate [2]_.\n18: \n19:     Parameters\n20:     ==========\n21: \n22:     arg : Expr\n23:         The sympy expression that we want to take the dagger of.\n24: \n25:     Examples\n26:     ========\n27: \n28:     Daggering various quantum objects:\n29: \n30:         >>> from sympy.physics.quantum.dagger import Dagger\n31:         >>> from sympy.physics.quantum.state import Ket, Bra\n32:         >>> from sympy.physics.quantum.operator import Operator\n33:         >>> Dagger(Ket('psi'))\n34:         <psi|\n35:         >>> Dagger(Bra('phi'))\n36:         |phi>\n37:         >>> Dagger(Operator('A'))\n38:         Dagger(A)\n39: \n40:     Inner and outer products::\n41: \n42:         >>> from sympy.physics.quantum import InnerProduct, OuterProduct\n43:         >>> Dagger(InnerProduct(Bra('a'), Ket('b')))\n44:         <b|a>\n45:         >>> Dagger(OuterProduct(Ket('a'), Bra('b')))\n46:         |b><a|\n47: \n48:     Powers, sums and products::\n49: \n50:         >>> A = Operator('A')\n51:         >>> B = Operator('B')\n... Code Truncated ...\n\n[start of sympy/physics/quantum/operator.py]\n1: \"\"\"Quantum mechanical operators.\n2: \n3: TODO:\n4: \n5: * Fix early 0 in apply_operators.\n6: * Debug and test apply_operators.\n7: * Get cse working with classes in this file.\n8: * Doctests and documentation of special methods for InnerProduct, Commutator,\n9:   AntiCommutator, represent, apply_operators.\n10: \"\"\"\n11: \n12: from __future__ import print_function, division\n13: \n14: from sympy import Derivative, Expr, Integer, oo, Mul, expand, Add\n15: from sympy.printing.pretty.stringpict import prettyForm\n16: from sympy.physics.quantum.dagger import Dagger\n17: from sympy.physics.quantum.qexpr import QExpr, dispatch_method\n18: from sympy.matrices import eye\n19: \n20: __all__ = [\n21:     'Operator',\n22:     'HermitianOperator',\n23:     'UnitaryOperator',\n24:     'IdentityOperator',\n25:     'OuterProduct',\n26:     'DifferentialOperator'\n27: ]\n28: \n29: #-----------------------------------------------------------------------------\n30: # Operators and outer products\n31: #-----------------------------------------------------------------------------\n32: \n33: \n34: class Operator(QExpr):\n35:     \"\"\"Base class for non-commuting quantum operators.\n36: \n37:     An operator maps between quantum states [1]_. In quantum mechanics,\n38:     observables (including, but not limited to, measured physical values) are\n39:     represented as Hermitian operators [2]_.\n40: \n41:     Parameters\n42:     ==========\n43: \n44:     args : tuple\n45:         The list of numbers or parameters that uniquely specify the\n46:         operator. For time-dependent operators, this will include the time.\n47: \n48:     Examples\n49:     ========\n50: \n51:     Create an operator and examine its attributes::\n52: \n53:         >>> from sympy.physics.quantum import Operator\n54:         >>> from sympy import I\n55:         >>> A = Operator('A')\n56:         >>> A\n57:         A\n58:         >>> A.hilbert_space\n59:         H\n60:         >>> A.label\n61:         (A,)\n62:         >>> A.is_commutative\n63:         False\n64: \n65:     Create another operator and do some arithmetic operations::\n66: \n67:         >>> B = Operator('B')\n68:         >>> C = 2*A*A + I*B\n69:         >>> C\n70:         2*A**2 + I*B\n71: \n72:     Operators don't commute::\n73: \n74:         >>> A.is_commutative\n75:         False\n76:         >>> B.is_commutative\n77:         False\n78:         >>> A*B == B*A\n79:         False\n80: \n81:     Polymonials of operators respect the commutation properties::\n82: \n83:         >>> e = (A+B)**3\n84:         >>> e.expand()\n85:         A*B*A + A*B**2 + A**2*B + A**3 + B*A*B + B*A**2 + B**2*A + B**3\n86: \n87:     Operator inverses are handle symbolically::\n88: \n89:         >>> A.inv()\n90:         A**(-1)\n91:         >>> A*A.inv()\n92:         1\n93: \n94:     References\n95:     ==========\n96: \n97:     .. [1] https://en.wikipedia.org/wiki/Operator_%28physics%29\n98:     .. [2] https://en.wikipedia.org/wiki/Observable\n99:     \"\"\"\n100: \n101:     @classmethod\n102:     def default_args(self):\n103:         return (\"O\",)\n104: \n105:     #-------------------------------------------------------------------------\n106:     # Printing\n107:     #-------------------------------------------------------------------------\n108: \n109:     _label_separator = ','\n110: \n111:     def _print_operator_name(self, printer, *args):\n112:         return self.__class__.__name__\n113: \n114:     _print_operator_name_latex = _print_operator_name\n115: \n116:     def _print_operator_name_pretty(self, printer, *args):\n117:         return prettyForm(self.__class__.__name__)\n118: \n119:     def _print_contents(self, printer, *args):\n120:         if len(self.label) == 1:\n121:             return self._print_label(printer, *args)\n122:         else:\n123:             return '%s(%s)' % (\n124:                 self._print_operator_name(printer, *args),\n125:                 self._print_label(printer, *args)\n126:             )\n127: \n128:     def _print_contents_pretty(self, printer, *args):\n129:         if len(self.label) == 1:\n130:             return self._print_label_pretty(printer, *args)\n131:         else:\n132:             pform = self._print_operator_name_pretty(printer, *args)\n133:             label_pform = self._print_label_pretty(printer, *args)\n134:             label_pform = prettyForm(\n135:                 *label_pform.parens(left='(', right=')')\n136:             )\n137:             pform = prettyForm(*pform.right((label_pform)))\n138:             return pform\n139: \n140:     def _print_contents_latex(self, printer, *args):\n141:         if len(self.label) == 1:\n142:             return self._print_label_latex(printer, *args)\n143:         else:\n144:             return r'%s\\left(%s\\right)' % (\n145:                 self._print_operator_name_latex(printer, *args),\n146:                 self._print_label_latex(printer, *args)\n147:             )\n148: \n149:     #-------------------------------------------------------------------------\n150:     # _eval_* methods\n151:     #-------------------------------------------------------------------------\n152: \n153:     def _eval_commutator(self, other, **options):\n154:         \"\"\"Evaluate [self, other] if known, return None if not known.\"\"\"\n155:         return dispatch_method(self, '_eval_commutator', other, **options)\n156: \n157:     def _eval_anticommutator(self, other, **options):\n158:         \"\"\"Evaluate [self, other] if known.\"\"\"\n159:         return dispatch_method(self, '_eval_anticommutator', other, **options)\n160: \n161:     #-------------------------------------------------------------------------\n162:     # Operator application\n163:     #-------------------------------------------------------------------------\n164: \n165:     def _apply_operator(self, ket, **options):\n166:         return dispatch_method(self, '_apply_operator', ket, **options)\n167: \n168:     def matrix_element(self, *args):\n169:         raise NotImplementedError('matrix_elements is not defined')\n170: \n171:     def inverse(self):\n172:         return self._eval_inverse()\n173: \n174:     inv = inverse\n175: \n176:     def _eval_inverse(self):\n177:         return self**(-1)\n178: \n179:     def __mul__(self, other):\n180: \n181:         if isinstance(other, IdentityOperator):\n182:             return self\n183: \n184:         return Mul(self, other)\n185: \n186: \n187: class HermitianOperator(Operator):\nCode replaced for brevity.\n223: \n224: \n225: \n226: class UnitaryOperator(Operator):\nCode replaced for brevity.\n246: \n247: \n248: \n249: class IdentityOperator(Operator):\n250:     \"\"\"An identity operator I that satisfies op * I == I * op == op for any\n251:     operator op.\n252: \n253:     Parameters\n254:     ==========\n255: \n256:     N : Integer\n257:         Optional parameter that specifies the dimension of the Hilbert space\n258:         of operator. This is used when generating a matrix representation.\n259: \n260:     Examples\n261:     ========\n262: \n263:     >>> from sympy.physics.quantum import IdentityOperator\n264:     >>> IdentityOperator()\n265:     I\n266:     \"\"\"\n267:     @property\n268:     def dimension(self):\n269:         return self.N\n270: \n271:     @classmethod\n272:     def default_args(self):\n273:         return (oo,)\n274: \n275:     def __init__(self, *args, **hints):\n276:         if not len(args) in [0, 1]:\n277:             raise ValueError('0 or 1 parameters expected, got %s' % args)\n278: \n279:         self.N = args[0] if (len(args) == 1 and args[0]) else oo\n280: \n281:     def _eval_commutator(self, other, **hints):\n282:         return Integer(0)\n283: \n284:     def _eval_anticommutator(self, other, **hints):\n285:         return 2 * other\n286: \n287:     def _eval_inverse(self):\n288:         return self\n289: \n290:     def _eval_adjoint(self):\n291:         return self\n292: \n293:     def _apply_operator(self, ket, **options):\n294:         return ket\n295: \n296:     def _eval_power(self, exp):\n297:         return self\n298: \n299:     def _print_contents(self, printer, *args):\n300:         return 'I'\n301: \n302:     def _print_contents_pretty(self, printer, *args):\n303:         return prettyForm('I')\n304: \n305:     def _print_contents_latex(self, printer, *args):\n306:         return r'{\\mathcal{I}}'\n307: \n308:     def __mul__(self, other):\n309: \n310:         if isinstance(other, Operator):\n311:             return other\n312: \n313:         return Mul(self, other)\n314: \n315:     def _represent_default_basis(self, **options):\n316:         if not self.N or self.N == oo:\n317:             raise NotImplementedError('Cannot represent infinite dimensional' +\n318:                                       ' identity operator as a matrix')\n319: \n320:         format = options.get('format', 'sympy')\n321:         if format != 'sympy':\n322:             raise NotImplementedError('Representation in format ' +\n323:                                       '%s not implemented.' % format)\n324: \n325:         return eye(self.N)\n326: \n327: \n328: class OuterProduct(Operator):\nCode replaced for brevity.\n485: \n486: \n487: \n488: class DifferentialOperator(Operator):\nCode replaced for brevity.\n644: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/physics/quantum/dagger.py",
      "suspect_lines": [
        3,
        4,
        5
      ]
    },
    {
      "filename": "/sympy/physics/quantum/operator.py",
      "suspect_lines": [
        310
      ]
    }
  ]
}