{
  "instance_id": "sphinx-doc__sphinx-9591",
  "problem_statement": "Cross-references don't work in property's type annotations\n### Describe the bug\r\n\r\nA documented type in property's type annotation does not get cross-referenced:\r\n```py\r\nfrom typing import Optional\r\n\r\n\r\nclass Point:\r\n    \"\"\"\r\n    A class representing a point.\r\n\r\n    Attributes:\r\n        x: Position X.\r\n        y: Position Y.\r\n    \"\"\"\r\n    x: int\r\n    y: int\r\n\r\n\r\nclass Square:\r\n    \"\"\"A class representing a square figure.\"\"\"\r\n    #: Square's start position (top-left corner).\r\n    start: Point\r\n    #: Square width.\r\n    width: int\r\n    #: Square height.\r\n    height: int\r\n\r\n    @property\r\n    def end(self) -> Point:\r\n        \"\"\"Square's end position (bottom-right corner).\"\"\"\r\n        return Point(self.start.x + self.width, self.start.y + self.height)\r\n\r\n\r\nclass Rectangle:\r\n    \"\"\"\r\n    A class representing a square figure.\r\n\r\n    Attributes:\r\n        start: Rectangle's start position (top-left corner).\r\n        width: Rectangle width.\r\n        height: Rectangle width.\r\n    \"\"\"\r\n    start: Point\r\n    width: int\r\n    height: int\r\n\r\n    @property\r\n    def end(self) -> Point:\r\n        \"\"\"Rectangle's end position (bottom-right corner).\"\"\"\r\n        return Point(self.start.x + self.width, self.start.y + self.height)\r\n```\r\n\r\n### How to Reproduce\r\n\r\n```\r\n$ git clone https://github.com/jack1142/sphinx-issue-9585\r\n$ cd sphinx-issue-9585\r\n$ pip install sphinx\r\n$ cd docs\r\n$ make html\r\n$ # open _build/html/index.html and see the issue\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nI expected the documented type in property's type annotation to be cross-referenced.\r\n\r\n### Your project\r\n\r\nhttps://github.com/jack1142/sphinx-issue-9585\r\n\r\n### Screenshots\r\n\r\nHere's a link to the generated docs:\r\nhttps://sphinx-issue-9585.readthedocs.io/en/latest/\r\n\r\n### OS\r\n\r\nWindows 10, Ubuntu 18.04\r\n\r\n### Python version\r\n\r\n3.7, 3.8, 3.9\r\n\r\n### Sphinx version\r\n\r\n4.1.2\r\n\r\n### Sphinx extensions\r\n\r\nsphinx.ext.autodoc\r\n\r\n### Extra tools\r\n\r\n_No response_\r\n\r\n### Additional context\r\n\r\n_No response_\n",
  "localized_code": "[start of sphinx/domains/python.py]\n1: \"\"\"\n2:     sphinx.domains.python\n3:     ~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     The Python domain.\n6: \n7:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import builtins\n12: import inspect\n13: import re\n14: import sys\n15: import typing\n16: import warnings\n17: from inspect import Parameter\n18: from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Optional, Tuple, Type, cast\n19: \n20: from docutils import nodes\n21: from docutils.nodes import Element, Node\n22: from docutils.parsers.rst import directives\n23: from docutils.parsers.rst.states import Inliner\n24: \n25: from sphinx import addnodes\n26: from sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\n27: from sphinx.application import Sphinx\n28: from sphinx.builders import Builder\n29: from sphinx.deprecation import RemovedInSphinx50Warning\n30: from sphinx.directives import ObjectDescription\n31: from sphinx.domains import Domain, Index, IndexEntry, ObjType\n32: from sphinx.environment import BuildEnvironment\n33: from sphinx.locale import _, __\n34: from sphinx.pycode.ast import ast\n35: from sphinx.pycode.ast import parse as ast_parse\n36: from sphinx.roles import XRefRole\n37: from sphinx.util import logging\n38: from sphinx.util.docfields import Field, GroupedField, TypedField\n39: from sphinx.util.docutils import SphinxDirective\n40: from sphinx.util.inspect import signature_from_str\n41: from sphinx.util.nodes import find_pending_xref_condition, make_id, make_refnode\n42: from sphinx.util.typing import OptionSpec, TextlikeNode\n43: \n44: logger = logging.getLogger(__name__)\n45: \n46: \n47: # REs for Python signatures\n48: py_sig_re = re.compile(\n49:     r'''^ ([\\w.]*\\.)?            # class name(s)\n50:           (\\w+)  \\s*             # thing name\n51:           (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n52:            (?:\\s* -> \\s* (.*))?  #           return annotation\n53:           )? $                   # and nothing more\n54:           ''', re.VERBOSE)\n55: \n56: \n57: pairindextypes = {\n58:     'module':    _('module'),\n59:     'keyword':   _('keyword'),\n60:     'operator':  _('operator'),\n61:     'object':    _('object'),\n62:     'exception': _('exception'),\n63:     'statement': _('statement'),\n64:     'builtin':   _('built-in function'),\n65: }\n66: \n67: \n68: class ObjectEntry(NamedTuple):\nCode replaced for brevity.\n72: \n73: \n74: \n75: class ModuleEntry(NamedTuple):\nCode replaced for brevity.\n80: \n81: \n82: \n83: def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\nCode replaced for brevity.\n107: \n108: \n109: \n110: def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\nCode replaced for brevity.\n186: \n187: \n188: \n189: def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\nCode replaced for brevity.\n236: \n237: \n238: \n239: def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\nCode replaced for brevity.\n284: \n285: \n286: \n287: # This override allows our inline type specifiers to behave like :class: link\n288: # when it comes to handling \".\" and \"~\" prefixes.\n289: class PyXrefMixin:\nCode replaced for brevity.\n344: \n345: \n346: \n347: class PyField(PyXrefMixin, Field):\nCode replaced for brevity.\n357: \n358: \n359: \n360: class PyGroupedField(PyXrefMixin, GroupedField):\n361:     pass\n362: \n363: \n364: class PyTypedField(PyXrefMixin, TypedField):\nCode replaced for brevity.\n374: \n375: \n376: \n377: class PyObject(ObjectDescription[Tuple[str, str]]):\nCode replaced for brevity.\n593: \n594: \n595: \n596: class PyFunction(PyObject):\nCode replaced for brevity.\n630: \n631: \n632: \n633: class PyDecoratorFunction(PyFunction):\nCode replaced for brevity.\n647: \n648: \n649: \n650: class PyVariable(PyObject):\nCode replaced for brevity.\n678: \n679: \n680: \n681: class PyClasslike(PyObject):\nCode replaced for brevity.\n707: \n708: \n709: \n710: class PyMethod(PyObject):\nCode replaced for brevity.\n768: \n769: \n770: \n771: class PyClassMethod(PyMethod):\nCode replaced for brevity.\n780: \n781: \n782: \n783: class PyStaticMethod(PyMethod):\nCode replaced for brevity.\n792: \n793: \n794: \n795: class PyDecoratorMethod(PyMethod):\nCode replaced for brevity.\n808: \n809: \n810: \n811: class PyAttribute(PyObject):\nCode replaced for brevity.\n846: \n847: \n848: \n849: class PyProperty(PyObject):\n850:     \"\"\"Description of an attribute.\"\"\"\n851: \n852:     option_spec = PyObject.option_spec.copy()\n853:     option_spec.update({\n854:         'abstractmethod': directives.flag,\n855:         'classmethod': directives.flag,\n856:         'type': directives.unchanged,\n857:     })\n858: \n859:     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n860:         fullname, prefix = super().handle_signature(sig, signode)\n861: \n862:         typ = self.options.get('type')\n863:         if typ:\n864:             signode += addnodes.desc_annotation(typ, ': ' + typ)\n865: \n866:         return fullname, prefix\n867: \n868:     def get_signature_prefix(self, sig: str) -> str:\n869:         prefix = []\n870:         if 'abstractmethod' in self.options:\n871:             prefix.append('abstract')\n872:         if 'classmethod' in self.options:\n873:             prefix.append('class')\n874: \n875:         prefix.append('property')\n876:         return ' '.join(prefix) + ' '\n877: \n878:     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n879:         name, cls = name_cls\n880:         try:\n881:             clsname, attrname = name.rsplit('.', 1)\n882:             if modname and self.env.config.add_module_names:\n883:                 clsname = '.'.join([modname, clsname])\n884:         except ValueError:\n885:             if modname:\n886:                 return _('%s (in module %s)') % (name, modname)\n887:             else:\n888:                 return name\n889: \n890:         return _('%s (%s property)') % (attrname, clsname)\n891: \n892: \n893: class PyDecoratorMixin:\nCode replaced for brevity.\n913: \n914: \n915: \n916: class PyModule(SphinxDirective):\nCode replaced for brevity.\n976: \n977: \n978: \n979: class PyCurrentModule(SphinxDirective):\nCode replaced for brevity.\n997: \n998: \n999: \n1000: class PyXRefRole(XRefRole):\nCode replaced for brevity.\n1020: \n1021: \n1022: \n1023: def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\nCode replaced for brevity.\n1035: \n1036: \n1037: \n1038: class PythonModuleIndex(Index):\nCode replaced for brevity.\n1107: \n1108: \n1109: \n1110: class PythonDomain(Domain):\nCode replaced for brevity.\n1379: \n1380: \n1381: \n1382:                      node: pending_xref, contnode: Element) -> Element:\nCode replaced for brevity.\n1404: \n1405: \n1406: \n1407: def setup(app: Sphinx) -> Dict[str, Any]:\nCode replaced for brevity.\n1420: \n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/domains/python.py",
      "suspect_lines": [
        864
      ]
    }
  ]
}