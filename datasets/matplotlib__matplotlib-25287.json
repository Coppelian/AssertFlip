{
  "instance_id": "matplotlib__matplotlib-25287",
  "problem_statement": "[Bug]: offsetText is colored based on tick.color instead of tick.labelcolor\n### Bug summary\n\nIn version 3.6.3, when setting ytick.labelcolor / xtick.labelcolor in styles / rcParams, it does not change the color of the exponent label as well. It will be colored based on xtick.color / ytick.color.\n\n### Code for reproduction\n\n```python\nimport matplotlib.pyplot as plt\r\n\r\nplt.rcParams.update({'ytick.labelcolor': 'red'})\r\nfig = plt.figure()\r\nax = fig.add_subplot(1,1,1)\r\nax.plot([1.01e9,1.02e9,1.03e9])\n```\n\n\n### Actual outcome\n\n![wrong_color](https://user-images.githubusercontent.com/50588526/217083612-dddf85ba-ebfa-4bf0-8ae0-3dce36c17198.png)\r\n\n\n### Expected outcome\n\n![correct_color](https://user-images.githubusercontent.com/50588526/217083512-34b3b32f-5d3a-4242-8742-2269bb09c20c.png)\r\n\n\n### Additional information\n\nThe following patch seems to fix it for my simple usecases:\r\n\r\n```\r\ndiff --git a/axis.py b/axis.py\r\n--- a/axis.py\t\r\n+++ b/axis.py\t(date 1675716341305)\r\n@@ -2203,7 +2203,7 @@\r\n             transform=mtransforms.blended_transform_factory(\r\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\r\n             fontsize=mpl.rcParams['xtick.labelsize'],\r\n-            color=mpl.rcParams['xtick.color'],\r\n+            color=mpl.rcParams['xtick.color'] if mpl.rcParams['xtick.labelcolor']=='inherit' else mpl.rcParams['xtick.labelcolor'],\r\n         )\r\n         self.offset_text_position = 'bottom'\r\n \r\n@@ -2456,7 +2456,7 @@\r\n             transform=mtransforms.blended_transform_factory(\r\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\r\n             fontsize=mpl.rcParams['ytick.labelsize'],\r\n-            color=mpl.rcParams['ytick.color'],\r\n+            color=mpl.rcParams['ytick.color'] if mpl.rcParams['ytick.labelcolor']=='inherit' else mpl.rcParams['ytick.labelcolor'],\r\n         )\r\n         self.offset_text_position = 'left'\r\n \r\n```\n\n### Operating system\n\n_No response_\n\n### Matplotlib Version\n\n3.6.3\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n_No response_\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\nNone\n",
  "localized_code": "[start of lib/matplotlib/axis.py]\n1: \"\"\"\n2: Classes for the ticks and x- and y-axis.\n3: \"\"\"\n4: \n5: import datetime\n6: import functools\n7: import logging\n8: from numbers import Real\n9: \n10: import numpy as np\n11: \n12: import matplotlib as mpl\n13: from matplotlib import _api, cbook\n14: import matplotlib.artist as martist\n15: import matplotlib.colors as mcolors\n16: import matplotlib.lines as mlines\n17: import matplotlib.scale as mscale\n18: import matplotlib.text as mtext\n19: import matplotlib.ticker as mticker\n20: import matplotlib.transforms as mtransforms\n21: import matplotlib.units as munits\n22: \n23: _log = logging.getLogger(__name__)\n24: \n25: GRIDLINE_INTERPOLATION_STEPS = 180\n26: \n27: # This list is being used for compatibility with Axes.grid, which\n28: # allows all Line2D kwargs.\n29: _line_inspector = martist.ArtistInspector(mlines.Line2D)\n30: _line_param_names = _line_inspector.get_setters()\n31: _line_param_aliases = [list(d)[0] for d in _line_inspector.aliasd.values()]\n32: _gridline_param_names = ['grid_' + name\n33:                          for name in _line_param_names + _line_param_aliases]\n34: \n35: \n36: class Tick(martist.Artist):\n37:     \"\"\"\n38:     Abstract base class for the axis ticks, grid lines and labels.\n39: \n40:     Ticks mark a position on an Axis. They contain two lines as markers and\n41:     two labels; one each for the bottom and top positions (in case of an\n42:     `.XAxis`) or for the left and right positions (in case of a `.YAxis`).\n43: \n44:     Attributes\n45:     ----------\n46:     tick1line : `.Line2D`\n47:         The left/bottom tick marker.\n48:     tick2line : `.Line2D`\n49:         The right/top tick marker.\n50:     gridline : `.Line2D`\n51:         The grid line associated with the label position.\n52:     label1 : `.Text`\n53:         The left/bottom tick label.\n54:     label2 : `.Text`\n55:         The right/top tick label.\n56: \n57:     \"\"\"\n58:     def __init__(\n59:         self, axes, loc, *,\n60:         size=None,  # points\n61:         width=None,\n62:         color=None,\n63:         tickdir=None,\n64:         pad=None,\n65:         labelsize=None,\n66:         labelcolor=None,\n67:         zorder=None,\n68:         gridOn=None,  # defaults to axes.grid depending on axes.grid.which\n69:         tick1On=True,\n70:         tick2On=True,\n71:         label1On=True,\n72:         label2On=False,\n73:         major=True,\n74:         labelrotation=0,\n75:         grid_color=None,\n76:         grid_linestyle=None,\n77:         grid_linewidth=None,\n78:         grid_alpha=None,\n79:         **kwargs,  # Other Line2D kwargs applied to gridlines.\n80:     ):\n81:         \"\"\"\n82:         bbox is the Bound2D bounding box in display coords of the Axes\n83:         loc is the tick location in data coords\n84:         size is the tick size in points\n85:         \"\"\"\n86:         super().__init__()\n87: \n88:         if gridOn is None:\n89:             if major and (mpl.rcParams['axes.grid.which']\n90:                           in ('both', 'major')):\n91:                 gridOn = mpl.rcParams['axes.grid']\n92:             elif (not major) and (mpl.rcParams['axes.grid.which']\n93:                                   in ('both', 'minor')):\n94:                 gridOn = mpl.rcParams['axes.grid']\n95:             else:\n96:                 gridOn = False\n97: \n98:         self.set_figure(axes.figure)\n99:         self.axes = axes\n100: \n101:         self._loc = loc\n102:         self._major = major\n103: \n104:         name = self.__name__\n105:         major_minor = \"major\" if major else \"minor\"\n106: \n107:         if size is None:\n108:             size = mpl.rcParams[f\"{name}.{major_minor}.size\"]\n109:         self._size = size\n110: \n111:         if width is None:\n112:             width = mpl.rcParams[f\"{name}.{major_minor}.width\"]\n113:         self._width = width\n114: \n115:         if color is None:\n116:             color = mpl.rcParams[f\"{name}.color\"]\n117: \n118:         if pad is None:\n119:             pad = mpl.rcParams[f\"{name}.{major_minor}.pad\"]\n120:         self._base_pad = pad\n121: \n122:         if labelcolor is None:\n123:             labelcolor = mpl.rcParams[f\"{name}.labelcolor\"]\n124: \n125:         if labelcolor == 'inherit':\n126:             # inherit from tick color\n127:             labelcolor = mpl.rcParams[f\"{name}.color\"]\n128: \n129:         if labelsize is None:\n130:             labelsize = mpl.rcParams[f\"{name}.labelsize\"]\n131: \n132:         self._set_labelrotation(labelrotation)\n133: \n134:         if zorder is None:\n135:             if major:\n136:                 zorder = mlines.Line2D.zorder + 0.01\n137:             else:\n138:                 zorder = mlines.Line2D.zorder\n139:         self._zorder = zorder\n140: \n141:         if grid_color is None:\n142:             grid_color = mpl.rcParams[\"grid.color\"]\n143:         if grid_linestyle is None:\n144:             grid_linestyle = mpl.rcParams[\"grid.linestyle\"]\n145:         if grid_linewidth is None:\n146:             grid_linewidth = mpl.rcParams[\"grid.linewidth\"]\n147:         if grid_alpha is None and not mcolors._has_alpha_channel(grid_color):\n148:             # alpha precedence: kwarg > color alpha > rcParams['grid.alpha']\n149:             # Note: only resolve to rcParams if the color does not have alpha\n150:             # otherwise `grid(color=(1, 1, 1, 0.5))` would work like\n151:             #   grid(color=(1, 1, 1, 0.5), alpha=rcParams['grid.alpha'])\n152:             # so the that the rcParams default would override color alpha.\n153:             grid_alpha = mpl.rcParams[\"grid.alpha\"]\n154:         grid_kw = {k[5:]: v for k, v in kwargs.items()}\n155: \n156:         self.tick1line = mlines.Line2D(\n157:             [], [],\n158:             color=color, linestyle=\"none\", zorder=zorder, visible=tick1On,\n159:             markeredgecolor=color, markersize=size, markeredgewidth=width,\n160:         )\n161:         self.tick2line = mlines.Line2D(\n162:             [], [],\n163:             color=color, linestyle=\"none\", zorder=zorder, visible=tick2On,\n164:             markeredgecolor=color, markersize=size, markeredgewidth=width,\n165:         )\n166:         self.gridline = mlines.Line2D(\n167:             [], [],\n168:             color=grid_color, alpha=grid_alpha, visible=gridOn,\n169:             linestyle=grid_linestyle, linewidth=grid_linewidth, marker=\"\",\n170:             **grid_kw,\n171:         )\n172:         self.gridline.get_path()._interpolation_steps = \\\n173:             GRIDLINE_INTERPOLATION_STEPS\n174:         self.label1 = mtext.Text(\n175:             np.nan, np.nan,\n176:             fontsize=labelsize, color=labelcolor, visible=label1On,\n177:             rotation=self._labelrotation[1])\n178:         self.label2 = mtext.Text(\n179:             np.nan, np.nan,\n180:             fontsize=labelsize, color=labelcolor, visible=label2On,\n181:             rotation=self._labelrotation[1])\n182: \n183:         self._apply_tickdir(tickdir)\n184: \n185:         for artist in [self.tick1line, self.tick2line, self.gridline,\n186:                        self.label1, self.label2]:\n187:             self._set_artist_props(artist)\n188: \n189:         self.update_position(loc)\n190: \n191:     @property\n192:     @_api.deprecated(\"3.1\", alternative=\"Tick.label1\", removal=\"3.8\")\n193:     def label(self):\n194:         return self.label1\n195: \n196:     def _set_labelrotation(self, labelrotation):\n197:         if isinstance(labelrotation, str):\n198:             mode = labelrotation\n199:             angle = 0\n200:         elif isinstance(labelrotation, (tuple, list)):\n201:             mode, angle = labelrotation\n202:         else:\n203:             mode = 'default'\n204:             angle = labelrotation\n205:         _api.check_in_list(['auto', 'default'], labelrotation=mode)\n206:         self._labelrotation = (mode, angle)\n207: \n208:     def _apply_tickdir(self, tickdir):\n209:         \"\"\"Set tick direction.  Valid values are 'out', 'in', 'inout'.\"\"\"\n210:         # This method is responsible for updating `_pad`, and, in subclasses,\n211:         # for setting the tick{1,2}line markers as well.  From the user\n212:         # perspective this should always be called though _apply_params, which\n213:         # further updates ticklabel positions using the new pads.\n214:         if tickdir is None:\n215:             tickdir = mpl.rcParams[f'{self.__name__}.direction']\n216:         _api.check_in_list(['in', 'out', 'inout'], tickdir=tickdir)\n217:         self._tickdir = tickdir\n218:         self._pad = self._base_pad + self.get_tick_padding()\n219: \n220:     def get_tickdir(self):\n221:         return self._tickdir\n222: \n223:     def get_tick_padding(self):\n224:         \"\"\"Get the length of the tick outside of the Axes.\"\"\"\n225:         padding = {\n226:             'in': 0.0,\n227:             'inout': 0.5,\n228:             'out': 1.0\n229:         }\n230:         return self._size * padding[self._tickdir]\n231: \n232:     def get_children(self):\n233:         children = [self.tick1line, self.tick2line,\n234:                     self.gridline, self.label1, self.label2]\n235:         return children\n236: \n237:     def set_clip_path(self, clippath, transform=None):\n238:         # docstring inherited\n239:         super().set_clip_path(clippath, transform)\n240:         self.gridline.set_clip_path(clippath, transform)\n241:         self.stale = True\n242: \n243:     @_api.deprecated(\"3.6\")\n244:     def get_pad_pixels(self):\n245:         return self.figure.dpi * self._base_pad / 72\n246: \n247:     def contains(self, mouseevent):\n248:         \"\"\"\n249:         Test whether the mouse event occurred in the Tick marks.\n250: \n251:         This function always returns false.  It is more useful to test if the\n252:         axis as a whole contains the mouse rather than the set of tick marks.\n253:         \"\"\"\n254:         inside, info = self._default_contains(mouseevent)\n255:         if inside is not None:\n256:             return inside, info\n257:         return False, {}\n258: \n259:     def set_pad(self, val):\n260:         \"\"\"\n261:         Set the tick label pad in points\n262: \n263:         Parameters\n264:         ----------\n265:         val : float\n266:         \"\"\"\n267:         self._apply_params(pad=val)\n268:         self.stale = True\n269: \n270:     def get_pad(self):\n271:         \"\"\"Get the value of the tick label pad in points.\"\"\"\n272:         return self._base_pad\n273: \n274:     def _get_text1(self):\n275:         \"\"\"Get the default Text 1 instance.\"\"\"\n276: \n277:     def _get_text2(self):\n278:         \"\"\"Get the default Text 2 instance.\"\"\"\n279: \n280:     def _get_tick1line(self):\n281:         \"\"\"Get the default `.Line2D` instance for tick1.\"\"\"\n282: \n283:     def _get_tick2line(self):\n284:         \"\"\"Get the default `.Line2D` instance for tick2.\"\"\"\n285: \n286:     def _get_gridline(self):\n287:         \"\"\"Get the default grid `.Line2D` instance for this tick.\"\"\"\n288: \n289:     def get_loc(self):\n290:         \"\"\"Return the tick location (data coords) as a scalar.\"\"\"\n291:         return self._loc\n292: \n293:     @martist.allow_rasterization\n294:     def draw(self, renderer):\n295:         if not self.get_visible():\n296:             self.stale = False\n297:             return\n298:         renderer.open_group(self.__name__, gid=self.get_gid())\n299:         for artist in [self.gridline, self.tick1line, self.tick2line,\n300:                        self.label1, self.label2]:\n301:             artist.draw(renderer)\n302:         renderer.close_group(self.__name__)\n303:         self.stale = False\n304: \n305:     def set_label1(self, s):\n306:         \"\"\"\n307:         Set the label1 text.\n308: \n309:         Parameters\n310:         ----------\n311:         s : str\n312:         \"\"\"\n313:         self.label1.set_text(s)\n314:         self.stale = True\n315: \n316:     set_label = set_label1\n317: \n318:     def set_label2(self, s):\n319:         \"\"\"\n320:         Set the label2 text.\n321: \n322:         Parameters\n323:         ----------\n324:         s : str\n325:         \"\"\"\n326:         self.label2.set_text(s)\n327:         self.stale = True\n328: \n329:     def set_url(self, url):\n330:         \"\"\"\n331:         Set the url of label1 and label2.\n332: \n333:         Parameters\n334:         ----------\n335:         url : str\n336:         \"\"\"\n337:         super().set_url(url)\n338:         self.label1.set_url(url)\n339:         self.label2.set_url(url)\n340:         self.stale = True\n341: \n342:     def _set_artist_props(self, a):\n343:         a.set_figure(self.figure)\n344: \n345:     def get_view_interval(self):\n346:         \"\"\"\n347:         Return the view limits ``(min, max)`` of the axis the tick belongs to.\n348:         \"\"\"\n349:         raise NotImplementedError('Derived must override')\n350: \n351:     def _apply_params(self, **kwargs):\n352:         for name, target in [(\"gridOn\", self.gridline),\n353:                              (\"tick1On\", self.tick1line),\n354:                              (\"tick2On\", self.tick2line),\n355:                              (\"label1On\", self.label1),\n356:                              (\"label2On\", self.label2)]:\n357:             if name in kwargs:\n358:                 target.set_visible(kwargs.pop(name))\n359:         if any(k in kwargs for k in ['size', 'width', 'pad', 'tickdir']):\n360:             self._size = kwargs.pop('size', self._size)\n361:             # Width could be handled outside this block, but it is\n362:             # convenient to leave it here.\n363:             self._width = kwargs.pop('width', self._width)\n364:             self._base_pad = kwargs.pop('pad', self._base_pad)\n365:             # _apply_tickdir uses _size and _base_pad to make _pad, and also\n366:             # sets the ticklines markers.\n367:             self._apply_tickdir(kwargs.pop('tickdir', self._tickdir))\n368:             for line in (self.tick1line, self.tick2line):\n369:                 line.set_markersize(self._size)\n370:                 line.set_markeredgewidth(self._width)\n371:             # _get_text1_transform uses _pad from _apply_tickdir.\n372:             trans = self._get_text1_transform()[0]\n373:             self.label1.set_transform(trans)\n374:             trans = self._get_text2_transform()[0]\n375:             self.label2.set_transform(trans)\n376:         tick_kw = {k: v for k, v in kwargs.items() if k in ['color', 'zorder']}\n377:         if 'color' in kwargs:\n378:             tick_kw['markeredgecolor'] = kwargs['color']\n379:         self.tick1line.set(**tick_kw)\n380:         self.tick2line.set(**tick_kw)\n381:         for k, v in tick_kw.items():\n382:             setattr(self, '_' + k, v)\n383: \n384:         if 'labelrotation' in kwargs:\n385:             self._set_labelrotation(kwargs.pop('labelrotation'))\n386:             self.label1.set(rotation=self._labelrotation[1])\n387:             self.label2.set(rotation=self._labelrotation[1])\n388: \n389:         label_kw = {k[5:]: v for k, v in kwargs.items()\n390:                     if k in ['labelsize', 'labelcolor']}\n391:         self.label1.set(**label_kw)\n392:         self.label2.set(**label_kw)\n393: \n394:         grid_kw = {k[5:]: v for k, v in kwargs.items()\n395:                    if k in _gridline_param_names}\n396:         self.gridline.set(**grid_kw)\n397: \n398:     def update_position(self, loc):\n399:         \"\"\"Set the location of tick in data coords with scalar *loc*.\"\"\"\n400:         raise NotImplementedError('Derived must override')\n401: \n402:     def _get_text1_transform(self):\n403:         raise NotImplementedError('Derived must override')\n404: \n405:     def _get_text2_transform(self):\n406:         raise NotImplementedError('Derived must override')\n407: \n408: \n409: class XTick(Tick):\nCode replaced for brevity.\n467: \n468: \n469: \n470: class YTick(Tick):\nCode replaced for brevity.\n528: \n529: \n530: \n531: class Ticker:\nCode replaced for brevity.\n569: \n570: \n571: \n572: class _LazyTickList:\nCode replaced for brevity.\n601: \n602: \n603: \n604: class Axis(martist.Artist):\nCode replaced for brevity.\n2195: \n2196: \n2197: \n2198: def _make_getset_interval(method_name, lim_name, attr_name):\nCode replaced for brevity.\n2225: \n2226: \n2227: \n2228: class XAxis(Axis):\n2229:     __name__ = 'xaxis'\n2230:     axis_name = 'x'  #: Read-only name identifying the axis.\n2231:     _tick_class = XTick\n2232: \n2233:     def __init__(self, *args, **kwargs):\n2234:         super().__init__(*args, **kwargs)\n2235:         self._init()\n2236: \n2237:     def _init(self):\n2238:         \"\"\"\n2239:         Initialize the label and offsetText instance values and\n2240:         `label_position` / `offset_text_position`.\n2241:         \"\"\"\n2242:         # x in axes coords, y in display coords (to be updated at draw time by\n2243:         # _update_label_positions and _update_offset_text_position).\n2244:         self.label.set(\n2245:             x=0.5, y=0,\n2246:             verticalalignment='top', horizontalalignment='center',\n2247:             transform=mtransforms.blended_transform_factory(\n2248:                 self.axes.transAxes, mtransforms.IdentityTransform()),\n2249:         )\n2250:         self.label_position = 'bottom'\n2251: \n2252:         self.offsetText.set(\n2253:             x=1, y=0,\n2254:             verticalalignment='top', horizontalalignment='right',\n2255:             transform=mtransforms.blended_transform_factory(\n2256:                 self.axes.transAxes, mtransforms.IdentityTransform()),\n2257:             fontsize=mpl.rcParams['xtick.labelsize'],\n2258:             color=mpl.rcParams['xtick.color'],\n2259:         )\n2260:         self.offset_text_position = 'bottom'\n2261: \n2262:     def contains(self, mouseevent):\n2263:         \"\"\"Test whether the mouse event occurred in the x-axis.\"\"\"\n2264:         inside, info = self._default_contains(mouseevent)\n2265:         if inside is not None:\n2266:             return inside, info\n2267: \n2268:         x, y = mouseevent.x, mouseevent.y\n2269:         try:\n2270:             trans = self.axes.transAxes.inverted()\n2271:             xaxes, yaxes = trans.transform((x, y))\n2272:         except ValueError:\n2273:             return False, {}\n2274:         (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n2275:         inaxis = 0 <= xaxes <= 1 and (\n2276:             b - self._pickradius < y < b or\n2277:             t < y < t + self._pickradius)\n2278:         return inaxis, {}\n2279: \n2280:     def set_label_position(self, position):\n2281:         \"\"\"\n2282:         Set the label position (top or bottom)\n2283: \n2284:         Parameters\n2285:         ----------\n2286:         position : {'top', 'bottom'}\n2287:         \"\"\"\n2288:         self.label.set_verticalalignment(_api.check_getitem({\n2289:             'top': 'baseline', 'bottom': 'top',\n2290:         }, position=position))\n2291:         self.label_position = position\n2292:         self.stale = True\n2293: \n2294:     def _update_label_position(self, renderer):\n2295:         \"\"\"\n2296:         Update the label position based on the bounding box enclosing\n2297:         all the ticklabels and axis spine\n2298:         \"\"\"\n2299:         if not self._autolabelpos:\n2300:             return\n2301: \n2302:         # get bounding boxes for this axis and any siblings\n2303:         # that have been set by `fig.align_xlabels()`\n2304:         bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n2305: \n2306:         x, y = self.label.get_position()\n2307:         if self.label_position == 'bottom':\n2308:             try:\n2309:                 spine = self.axes.spines['bottom']\n2310:                 spinebbox = spine.get_window_extent()\n2311:             except KeyError:\n2312:                 # use Axes if spine doesn't exist\n2313:                 spinebbox = self.axes.bbox\n2314:             bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n2315:             bottom = bbox.y0\n2316: \n2317:             self.label.set_position(\n2318:                 (x, bottom - self.labelpad * self.figure.dpi / 72)\n2319:             )\n2320:         else:\n2321:             try:\n2322:                 spine = self.axes.spines['top']\n2323:                 spinebbox = spine.get_window_extent()\n2324:             except KeyError:\n2325:                 # use Axes if spine doesn't exist\n2326:                 spinebbox = self.axes.bbox\n2327:             bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n2328:             top = bbox.y1\n2329: \n2330:             self.label.set_position(\n2331:                 (x, top + self.labelpad * self.figure.dpi / 72)\n2332:             )\n2333: \n2334:     def _update_offset_text_position(self, bboxes, bboxes2):\n2335:         \"\"\"\n2336:         Update the offset_text position based on the sequence of bounding\n2337:         boxes of all the ticklabels\n2338:         \"\"\"\n2339:         x, y = self.offsetText.get_position()\n2340:         if not hasattr(self, '_tick_position'):\n2341:             self._tick_position = 'bottom'\n2342:         if self._tick_position == 'bottom':\n2343:             if not len(bboxes):\n2344:                 bottom = self.axes.bbox.ymin\n2345:             else:\n2346:                 bbox = mtransforms.Bbox.union(bboxes)\n2347:                 bottom = bbox.y0\n2348:             y = bottom - self.OFFSETTEXTPAD * self.figure.dpi / 72\n2349:         else:\n2350:             if not len(bboxes2):\n2351:                 top = self.axes.bbox.ymax\n2352:             else:\n2353:                 bbox = mtransforms.Bbox.union(bboxes2)\n2354:                 top = bbox.y1\n2355:             y = top + self.OFFSETTEXTPAD * self.figure.dpi / 72\n2356:         self.offsetText.set_position((x, y))\n2357: \n2358:     @_api.deprecated(\"3.6\")\n2359:     def get_text_heights(self, renderer):\n2360:         \"\"\"\n2361:         Return how much space should be reserved for text above and below the\n2362:         Axes, as a pair of floats.\n2363:         \"\"\"\n2364:         bbox, bbox2 = self.get_ticklabel_extents(renderer)\n2365:         # MGDTODO: Need a better way to get the pad\n2366:         pad_pixels = self.majorTicks[0].get_pad_pixels()\n2367: \n2368:         above = 0.0\n2369:         if bbox2.height:\n2370:             above += bbox2.height + pad_pixels\n2371:         below = 0.0\n2372:         if bbox.height:\n2373:             below += bbox.height + pad_pixels\n2374: \n2375:         if self.get_label_position() == 'top':\n2376:             above += self.label.get_window_extent(renderer).height + pad_pixels\n2377:         else:\n2378:             below += self.label.get_window_extent(renderer).height + pad_pixels\n2379:         return above, below\n2380: \n2381:     def set_ticks_position(self, position):\n2382:         \"\"\"\n2383:         Set the ticks position.\n2384: \n2385:         Parameters\n2386:         ----------\n2387:         position : {'top', 'bottom', 'both', 'default', 'none'}\n2388:             'both' sets the ticks to appear on both positions, but does not\n2389:             change the tick labels.  'default' resets the tick positions to\n2390:             the default: ticks on both positions, labels at bottom.  'none'\n2391:             can be used if you don't want any ticks. 'none' and 'both'\n2392:             affect only the ticks, not the labels.\n2393:         \"\"\"\n2394:         _api.check_in_list(['top', 'bottom', 'both', 'default', 'none'],\n2395:                            position=position)\n2396:         if position == 'top':\n2397:             self.set_tick_params(which='both', top=True, labeltop=True,\n2398:                                  bottom=False, labelbottom=False)\n2399:             self._tick_position = 'top'\n2400:             self.offsetText.set_verticalalignment('bottom')\n2401:         elif position == 'bottom':\n2402:             self.set_tick_params(which='both', top=False, labeltop=False,\n2403:                                  bottom=True, labelbottom=True)\n2404:             self._tick_position = 'bottom'\n2405:             self.offsetText.set_verticalalignment('top')\n2406:         elif position == 'both':\n2407:             self.set_tick_params(which='both', top=True,\n2408:                                  bottom=True)\n2409:         elif position == 'none':\n2410:             self.set_tick_params(which='both', top=False,\n2411:                                  bottom=False)\n2412:         elif position == 'default':\n2413:             self.set_tick_params(which='both', top=True, labeltop=False,\n2414:                                  bottom=True, labelbottom=True)\n2415:             self._tick_position = 'bottom'\n2416:             self.offsetText.set_verticalalignment('top')\n2417:         else:\n2418:             assert False, \"unhandled parameter not caught by _check_in_list\"\n2419:         self.stale = True\n2420: \n2421:     def tick_top(self):\n2422:         \"\"\"\n2423:         Move ticks and ticklabels (if present) to the top of the Axes.\n2424:         \"\"\"\n2425:         label = True\n2426:         if 'label1On' in self._major_tick_kw:\n2427:             label = (self._major_tick_kw['label1On']\n2428:                      or self._major_tick_kw['label2On'])\n2429:         self.set_ticks_position('top')\n2430:         # If labels were turned off before this was called, leave them off.\n2431:         self.set_tick_params(which='both', labeltop=label)\n2432: \n2433:     def tick_bottom(self):\n2434:         \"\"\"\n2435:         Move ticks and ticklabels (if present) to the bottom of the Axes.\n2436:         \"\"\"\n2437:         label = True\n2438:         if 'label1On' in self._major_tick_kw:\n2439:             label = (self._major_tick_kw['label1On']\n2440:                      or self._major_tick_kw['label2On'])\n2441:         self.set_ticks_position('bottom')\n2442:         # If labels were turned off before this was called, leave them off.\n2443:         self.set_tick_params(which='both', labelbottom=label)\n2444: \n2445:     def get_ticks_position(self):\n2446:         \"\"\"\n2447:         Return the ticks position (\"top\", \"bottom\", \"default\", or \"unknown\").\n2448:         \"\"\"\n2449:         return {1: \"bottom\", 2: \"top\",\n2450:                 \"default\": \"default\", \"unknown\": \"unknown\"}[\n2451:                     self._get_ticks_position()]\n2452: \n2453:     get_view_interval, set_view_interval = _make_getset_interval(\n2454:         \"view\", \"viewLim\", \"intervalx\")\n2455:     get_data_interval, set_data_interval = _make_getset_interval(\n2456:         \"data\", \"dataLim\", \"intervalx\")\n2457: \n2458:     def get_minpos(self):\n2459:         return self.axes.dataLim.minposx\n2460: \n2461:     def set_default_intervals(self):\n2462:         # docstring inherited\n2463:         # only change view if dataLim has not changed and user has\n2464:         # not changed the view:\n2465:         if (not self.axes.dataLim.mutatedx() and\n2466:                 not self.axes.viewLim.mutatedx()):\n2467:             if self.converter is not None:\n2468:                 info = self.converter.axisinfo(self.units, self)\n2469:                 if info.default_limits is not None:\n2470:                     xmin, xmax = self.convert_units(info.default_limits)\n2471:                     self.axes.viewLim.intervalx = xmin, xmax\n2472:         self.stale = True\n2473: \n2474:     def get_tick_space(self):\n2475:         ends = mtransforms.Bbox.unit().transformed(\n2476:             self.axes.transAxes - self.figure.dpi_scale_trans)\n2477:         length = ends.width * 72\n2478:         # There is a heuristic here that the aspect ratio of tick text\n2479:         # is no more than 3:1\n2480:         size = self._get_tick_label_size('x') * 3\n2481:         if size > 0:\n2482:             return int(np.floor(length / size))\n2483:         else:\n2484:             return 2**31 - 1\n2485: \n2486: \n2487: class YAxis(Axis):\n2488:     __name__ = 'yaxis'\n2489:     axis_name = 'y'  #: Read-only name identifying the axis.\n2490:     _tick_class = YTick\n2491: \n2492:     def __init__(self, *args, **kwargs):\n2493:         super().__init__(*args, **kwargs)\n2494:         self._init()\n2495: \n2496:     def _init(self):\n2497:         \"\"\"\n2498:         Initialize the label and offsetText instance values and\n2499:         `label_position` / `offset_text_position`.\n2500:         \"\"\"\n2501:         # x in display coords, y in axes coords (to be updated at draw time by\n2502:         # _update_label_positions and _update_offset_text_position).\n2503:         self.label.set(\n2504:             x=0, y=0.5,\n2505:             verticalalignment='bottom', horizontalalignment='center',\n2506:             rotation='vertical', rotation_mode='anchor',\n2507:             transform=mtransforms.blended_transform_factory(\n2508:                 mtransforms.IdentityTransform(), self.axes.transAxes),\n2509:         )\n2510:         self.label_position = 'left'\n2511:         # x in axes coords, y in display coords(!).\n2512:         self.offsetText.set(\n2513:             x=0, y=0.5,\n2514:             verticalalignment='baseline', horizontalalignment='left',\n2515:             transform=mtransforms.blended_transform_factory(\n2516:                 self.axes.transAxes, mtransforms.IdentityTransform()),\n2517:             fontsize=mpl.rcParams['ytick.labelsize'],\n2518:             color=mpl.rcParams['ytick.color'],\n2519:         )\n2520:         self.offset_text_position = 'left'\n2521: \n2522:     def contains(self, mouseevent):\n2523:         # docstring inherited\n2524:         inside, info = self._default_contains(mouseevent)\n2525:         if inside is not None:\n2526:             return inside, info\n2527: \n2528:         x, y = mouseevent.x, mouseevent.y\n2529:         try:\n2530:             trans = self.axes.transAxes.inverted()\n2531:             xaxes, yaxes = trans.transform((x, y))\n2532:         except ValueError:\n2533:             return False, {}\n2534:         (l, b), (r, t) = self.axes.transAxes.transform([(0, 0), (1, 1)])\n2535:         inaxis = 0 <= yaxes <= 1 and (\n2536:             l - self._pickradius < x < l or\n2537:             r < x < r + self._pickradius)\n2538:         return inaxis, {}\n2539: \n2540:     def set_label_position(self, position):\n2541:         \"\"\"\n2542:         Set the label position (left or right)\n2543: \n2544:         Parameters\n2545:         ----------\n2546:         position : {'left', 'right'}\n2547:         \"\"\"\n2548:         self.label.set_rotation_mode('anchor')\n2549:         self.label.set_verticalalignment(_api.check_getitem({\n2550:             'left': 'bottom', 'right': 'top',\n2551:         }, position=position))\n2552:         self.label_position = position\n2553:         self.stale = True\n2554: \n2555:     def _update_label_position(self, renderer):\n2556:         \"\"\"\n2557:         Update the label position based on the bounding box enclosing\n2558:         all the ticklabels and axis spine\n2559:         \"\"\"\n2560:         if not self._autolabelpos:\n2561:             return\n2562: \n2563:         # get bounding boxes for this axis and any siblings\n2564:         # that have been set by `fig.align_ylabels()`\n2565:         bboxes, bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)\n2566:         x, y = self.label.get_position()\n2567:         if self.label_position == 'left':\n2568:             try:\n2569:                 spine = self.axes.spines['left']\n2570:                 spinebbox = spine.get_window_extent()\n2571:             except KeyError:\n2572:                 # use Axes if spine doesn't exist\n2573:                 spinebbox = self.axes.bbox\n2574:             bbox = mtransforms.Bbox.union(bboxes + [spinebbox])\n2575:             left = bbox.x0\n2576:             self.label.set_position(\n2577:                 (left - self.labelpad * self.figure.dpi / 72, y)\n2578:             )\n2579: \n2580:         else:\n2581:             try:\n2582:                 spine = self.axes.spines['right']\n2583:                 spinebbox = spine.get_window_extent()\n2584:             except KeyError:\n2585:                 # use Axes if spine doesn't exist\n2586:                 spinebbox = self.axes.bbox\n2587: \n2588:             bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])\n2589:             right = bbox.x1\n2590:             self.label.set_position(\n2591:                 (right + self.labelpad * self.figure.dpi / 72, y)\n2592:             )\n2593: \n2594:     def _update_offset_text_position(self, bboxes, bboxes2):\n2595:         \"\"\"\n2596:         Update the offset_text position based on the sequence of bounding\n2597:         boxes of all the ticklabels\n2598:         \"\"\"\n2599:         x, _ = self.offsetText.get_position()\n2600:         if 'outline' in self.axes.spines:\n2601:             # Special case for colorbars:\n2602:             bbox = self.axes.spines['outline'].get_window_extent()\n2603:         else:\n2604:             bbox = self.axes.bbox\n2605:         top = bbox.ymax\n2606:         self.offsetText.set_position(\n2607:             (x, top + self.OFFSETTEXTPAD * self.figure.dpi / 72)\n2608:         )\n2609: \n2610:     def set_offset_position(self, position):\n2611:         \"\"\"\n2612:         Parameters\n2613:         ----------\n2614:         position : {'left', 'right'}\n2615:         \"\"\"\n2616:         x, y = self.offsetText.get_position()\n2617:         x = _api.check_getitem({'left': 0, 'right': 1}, position=position)\n2618: \n2619:         self.offsetText.set_ha(position)\n2620:         self.offsetText.set_position((x, y))\n2621:         self.stale = True\n2622: \n2623:     @_api.deprecated(\"3.6\")\n2624:     def get_text_widths(self, renderer):\n2625:         bbox, bbox2 = self.get_ticklabel_extents(renderer)\n2626:         # MGDTODO: Need a better way to get the pad\n2627:         pad_pixels = self.majorTicks[0].get_pad_pixels()\n2628: \n2629:         left = 0.0\n2630:         if bbox.width:\n2631:             left += bbox.width + pad_pixels\n2632:         right = 0.0\n2633:         if bbox2.width:\n2634:             right += bbox2.width + pad_pixels\n2635: \n2636:         if self.get_label_position() == 'left':\n2637:             left += self.label.get_window_extent(renderer).width + pad_pixels\n2638:         else:\n2639:             right += self.label.get_window_extent(renderer).width + pad_pixels\n2640:         return left, right\n2641: \n2642:     def set_ticks_position(self, position):\n2643:         \"\"\"\n2644:         Set the ticks position.\n2645: \n2646:         Parameters\n2647:         ----------\n2648:         position : {'left', 'right', 'both', 'default', 'none'}\n2649:             'both' sets the ticks to appear on both positions, but does not\n2650:             change the tick labels.  'default' resets the tick positions to\n2651:             the default: ticks on both positions, labels at left.  'none'\n2652:             can be used if you don't want any ticks. 'none' and 'both'\n2653:             affect only the ticks, not the labels.\n2654:         \"\"\"\n2655:         _api.check_in_list(['left', 'right', 'both', 'default', 'none'],\n2656:                            position=position)\n2657:         if position == 'right':\n2658:             self.set_tick_params(which='both', right=True, labelright=True,\n2659:                                  left=False, labelleft=False)\n2660:             self.set_offset_position(position)\n2661:         elif position == 'left':\n2662:             self.set_tick_params(which='both', right=False, labelright=False,\n2663:                                  left=True, labelleft=True)\n2664:             self.set_offset_position(position)\n2665:         elif position == 'both':\n2666:             self.set_tick_params(which='both', right=True,\n2667:                                  left=True)\n2668:         elif position == 'none':\n2669:             self.set_tick_params(which='both', right=False,\n2670:                                  left=False)\n2671:         elif position == 'default':\n2672:             self.set_tick_params(which='both', right=True, labelright=False,\n2673:                                  left=True, labelleft=True)\n2674:         else:\n2675:             assert False, \"unhandled parameter not caught by _check_in_list\"\n2676:         self.stale = True\n2677: \n2678:     def tick_right(self):\n2679:         \"\"\"\n2680:         Move ticks and ticklabels (if present) to the right of the Axes.\n2681:         \"\"\"\n2682:         label = True\n2683:         if 'label1On' in self._major_tick_kw:\n2684:             label = (self._major_tick_kw['label1On']\n2685:                      or self._major_tick_kw['label2On'])\n2686:         self.set_ticks_position('right')\n2687:         # if labels were turned off before this was called\n2688:         # leave them off\n2689:         self.set_tick_params(which='both', labelright=label)\n2690: \n2691:     def tick_left(self):\n2692:         \"\"\"\n2693:         Move ticks and ticklabels (if present) to the left of the Axes.\n2694:         \"\"\"\n2695:         label = True\n2696:         if 'label1On' in self._major_tick_kw:\n2697:             label = (self._major_tick_kw['label1On']\n2698:                      or self._major_tick_kw['label2On'])\n2699:         self.set_ticks_position('left')\n2700:         # if labels were turned off before this was called\n2701:         # leave them off\n2702:         self.set_tick_params(which='both', labelleft=label)\n2703: \n2704:     def get_ticks_position(self):\n2705:         \"\"\"\n2706:         Return the ticks position (\"left\", \"right\", \"default\", or \"unknown\").\n2707:         \"\"\"\n2708:         return {1: \"left\", 2: \"right\",\n2709:                 \"default\": \"default\", \"unknown\": \"unknown\"}[\n2710:                     self._get_ticks_position()]\n2711: \n2712:     get_view_interval, set_view_interval = _make_getset_interval(\n2713:         \"view\", \"viewLim\", \"intervaly\")\n2714:     get_data_interval, set_data_interval = _make_getset_interval(\n2715:         \"data\", \"dataLim\", \"intervaly\")\n2716: \n2717:     def get_minpos(self):\n2718:         return self.axes.dataLim.minposy\n2719: \n2720:     def set_default_intervals(self):\n2721:         # docstring inherited\n2722:         # only change view if dataLim has not changed and user has\n2723:         # not changed the view:\n2724:         if (not self.axes.dataLim.mutatedy() and\n2725:                 not self.axes.viewLim.mutatedy()):\n2726:             if self.converter is not None:\n2727:                 info = self.converter.axisinfo(self.units, self)\n2728:                 if info.default_limits is not None:\n2729:                     ymin, ymax = self.convert_units(info.default_limits)\n2730:                     self.axes.viewLim.intervaly = ymin, ymax\n2731:         self.stale = True\n2732: \n2733:     def get_tick_space(self):\n2734:         ends = mtransforms.Bbox.unit().transformed(\n2735:             self.axes.transAxes - self.figure.dpi_scale_trans)\n2736:         length = ends.height * 72\n2737:         # Having a spacing of at least 2 just looks good.\n2738:         size = self._get_tick_label_size('y') * 2\n2739:         if size > 0:\n2740:             return int(np.floor(length / size))\n2741:         else:\n2742:             return 2**31 - 1\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/axis.py",
      "suspect_lines": [
        2262,
        2522
      ]
    }
  ]
}