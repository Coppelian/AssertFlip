{
  "instance_id": "django__django-12276",
  "problem_statement": "FileInput shouldn't display required attribute when initial data exists.\nDescription\n\t \n\t\t(last modified by thenewguy)\n\t \nI think that ClearableFileInput.use_required_attribute() (â€‹https://github.com/django/django/blob/e703b93a656b78b9b444bb3a9980e305ed002a70/django/forms/widgets.py#L454) should be moved to FileInput.use_required_attribute() so that required is not output on the html input element that represents FileInput when a file is already set (e.g. already saved on a model instance that is being edited).\nMaybe I am overlooking a use case where this is not desirable? I can not think of one.\n",
  "localized_code": "[start of django/forms/widgets.py]\n1: \"\"\"\n2: HTML Widget classes\n3: \"\"\"\n4: \n5: import copy\n6: import datetime\n7: import warnings\n8: from collections import defaultdict\n9: from itertools import chain\n10: \n11: from django.conf import settings\n12: from django.forms.utils import to_current_timezone\n13: from django.templatetags.static import static\n14: from django.utils import datetime_safe, formats\n15: from django.utils.datastructures import OrderedSet\n16: from django.utils.dates import MONTHS\n17: from django.utils.formats import get_format\n18: from django.utils.html import format_html, html_safe\n19: from django.utils.regex_helper import _lazy_re_compile\n20: from django.utils.safestring import mark_safe\n21: from django.utils.topological_sort import (\n22:     CyclicDependencyError, stable_topological_sort,\n23: )\n24: from django.utils.translation import gettext_lazy as _\n25: \n26: from .renderers import get_default_renderer\n27: \n28: __all__ = (\n29:     'Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'NumberInput',\n30:     'EmailInput', 'URLInput', 'PasswordInput', 'HiddenInput',\n31:     'MultipleHiddenInput', 'FileInput', 'ClearableFileInput', 'Textarea',\n32:     'DateInput', 'DateTimeInput', 'TimeInput', 'CheckboxInput', 'Select',\n33:     'NullBooleanSelect', 'SelectMultiple', 'RadioSelect',\n34:     'CheckboxSelectMultiple', 'MultiWidget', 'SplitDateTimeWidget',\n35:     'SplitHiddenDateTimeWidget', 'SelectDateWidget',\n36: )\n37: \n38: MEDIA_TYPES = ('css', 'js')\n39: \n40: \n41: class MediaOrderConflictWarning(RuntimeWarning):\n42:     pass\n43: \n44: \n45: @html_safe\n46: class Media:\n47:     def __init__(self, media=None, css=None, js=None):\n48:         if media is not None:\n49:             css = getattr(media, 'css', {})\n50:             js = getattr(media, 'js', [])\n51:         else:\n52:             if css is None:\n53:                 css = {}\n54:             if js is None:\n55:                 js = []\n56:         self._css_lists = [css]\n57:         self._js_lists = [js]\n58: \n59:     def __repr__(self):\n60:         return 'Media(css=%r, js=%r)' % (self._css, self._js)\n61: \n62:     def __str__(self):\n63:         return self.render()\n64: \n65:     @property\n66:     def _css(self):\n67:         css = defaultdict(list)\n68:         for css_list in self._css_lists:\n69:             for medium, sublist in css_list.items():\n70:                 css[medium].append(sublist)\n71:         return {medium: self.merge(*lists) for medium, lists in css.items()}\n72: \n73:     @property\n74:     def _js(self):\n75:         return self.merge(*self._js_lists)\n76: \n77:     def render(self):\n78:         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n79: \n80:     def render_js(self):\n81:         return [\n82:             format_html(\n83:                 '<script src=\"{}\"></script>',\n84:                 self.absolute_path(path)\n85:             ) for path in self._js\n86:         ]\n87: \n88:     def render_css(self):\n89:         # To keep rendering order consistent, we can't just iterate over items().\n90:         # We need to sort the keys, and iterate over the sorted list.\n91:         media = sorted(self._css)\n92:         return chain.from_iterable([\n93:             format_html(\n94:                 '<link href=\"{}\" type=\"text/css\" media=\"{}\" rel=\"stylesheet\">',\n95:                 self.absolute_path(path), medium\n96:             ) for path in self._css[medium]\n97:         ] for medium in media)\n98: \n99:     def absolute_path(self, path):\n100:         \"\"\"\n101:         Given a relative or absolute path to a static asset, return an absolute\n102:         path. An absolute path will be returned unchanged while a relative path\n103:         will be passed to django.templatetags.static.static().\n104:         \"\"\"\n105:         if path.startswith(('http://', 'https://', '/')):\n106:             return path\n107:         return static(path)\n108: \n109:     def __getitem__(self, name):\n110:         \"\"\"Return a Media object that only contains media of the given type.\"\"\"\n111:         if name in MEDIA_TYPES:\n112:             return Media(**{str(name): getattr(self, '_' + name)})\n113:         raise KeyError('Unknown media type \"%s\"' % name)\n114: \n115:     @staticmethod\n116:     def merge(*lists):\n117:         \"\"\"\n118:         Merge lists while trying to keep the relative order of the elements.\n119:         Warn if the lists have the same elements in a different relative order.\n120: \n121:         For static assets it can be important to have them included in the DOM\n122:         in a certain order. In JavaScript you may not be able to reference a\n123:         global or in CSS you might want to override a style.\n124:         \"\"\"\n125:         dependency_graph = defaultdict(set)\n126:         all_items = OrderedSet()\n127:         for list_ in filter(None, lists):\n128:             head = list_[0]\n129:             # The first items depend on nothing but have to be part of the\n130:             # dependency graph to be included in the result.\n131:             dependency_graph.setdefault(head, set())\n132:             for item in list_:\n133:                 all_items.add(item)\n134:                 # No self dependencies\n135:                 if head != item:\n136:                     dependency_graph[item].add(head)\n137:                 head = item\n138:         try:\n139:             return stable_topological_sort(all_items, dependency_graph)\n140:         except CyclicDependencyError:\n141:             warnings.warn(\n142:                 'Detected duplicate Media files in an opposite order: {}'.format(\n143:                     ', '.join(repr(l) for l in lists)\n144:                 ), MediaOrderConflictWarning,\n145:             )\n146:             return list(all_items)\n147: \n148:     def __add__(self, other):\n149:         combined = Media()\n150:         combined._css_lists = self._css_lists + other._css_lists\n151:         combined._js_lists = self._js_lists + other._js_lists\n152:         return combined\n153: \n154: \n155: def media_property(cls):\nCode replaced for brevity.\n178: \n179: \n180: \n181: class MediaDefiningClass(type):\nCode replaced for brevity.\n191: \n192: \n193: \n194: class Widget(metaclass=MediaDefiningClass):\nCode replaced for brevity.\n276: \n277: \n278: \n279: class Input(Widget):\nCode replaced for brevity.\n295: \n296: \n297: \n298: class TextInput(Input):\nCode replaced for brevity.\n300: \n301: \n302: \n303: class NumberInput(Input):\nCode replaced for brevity.\n305: \n306: \n307: \n308: class EmailInput(Input):\nCode replaced for brevity.\n310: \n311: \n312: \n313: class URLInput(Input):\nCode replaced for brevity.\n315: \n316: \n317: \n318: class PasswordInput(Input):\nCode replaced for brevity.\n329: \n330: \n331: \n332: class HiddenInput(Input):\nCode replaced for brevity.\n334: \n335: \n336: \n337: class MultipleHiddenInput(HiddenInput):\nCode replaced for brevity.\n371: \n372: \n373: \n374: class FileInput(Input):\nCode replaced for brevity.\n388: \n389: \n390: \n391: FILE_INPUT_CONTRADICTION = object()\n392: \n393: \n394: class ClearableFileInput(FileInput):\n395:     clear_checkbox_label = _('Clear')\n396:     initial_text = _('Currently')\n397:     input_text = _('Change')\n398:     template_name = 'django/forms/widgets/clearable_file_input.html'\n399: \n400:     def clear_checkbox_name(self, name):\n401:         \"\"\"\n402:         Given the name of the file input, return the name of the clear checkbox\n403:         input.\n404:         \"\"\"\n405:         return name + '-clear'\n406: \n407:     def clear_checkbox_id(self, name):\n408:         \"\"\"\n409:         Given the name of the clear checkbox input, return the HTML id for it.\n410:         \"\"\"\n411:         return name + '_id'\n412: \n413:     def is_initial(self, value):\n414:         \"\"\"\n415:         Return whether value is considered to be initial value.\n416:         \"\"\"\n417:         return bool(value and getattr(value, 'url', False))\n418: \n419:     def format_value(self, value):\n420:         \"\"\"\n421:         Return the file object if it has a defined url attribute.\n422:         \"\"\"\n423:         if self.is_initial(value):\n424:             return value\n425: \n426:     def get_context(self, name, value, attrs):\n427:         context = super().get_context(name, value, attrs)\n428:         checkbox_name = self.clear_checkbox_name(name)\n429:         checkbox_id = self.clear_checkbox_id(checkbox_name)\n430:         context['widget'].update({\n431:             'checkbox_name': checkbox_name,\n432:             'checkbox_id': checkbox_id,\n433:             'is_initial': self.is_initial(value),\n434:             'input_text': self.input_text,\n435:             'initial_text': self.initial_text,\n436:             'clear_checkbox_label': self.clear_checkbox_label,\n437:         })\n438:         return context\n439: \n440:     def value_from_datadict(self, data, files, name):\n441:         upload = super().value_from_datadict(data, files, name)\n442:         if not self.is_required and CheckboxInput().value_from_datadict(\n443:                 data, files, self.clear_checkbox_name(name)):\n444: \n445:             if upload:\n446:                 # If the user contradicts themselves (uploads a new file AND\n447:                 # checks the \"clear\" checkbox), we return a unique marker\n448:                 # object that FileField will turn into a ValidationError.\n449:                 return FILE_INPUT_CONTRADICTION\n450:             # False signals to clear any existing value, as opposed to just None\n451:             return False\n452:         return upload\n453: \n454:     def use_required_attribute(self, initial):\n455:         return super().use_required_attribute(initial) and not initial\n456: \n457:     def value_omitted_from_data(self, data, files, name):\n458:         return (\n459:             super().value_omitted_from_data(data, files, name) and\n460:             self.clear_checkbox_name(name) not in data\n461:         )\n462: \n463: \n464: class Textarea(Widget):\nCode replaced for brevity.\n472: \n473: \n474: \n475: class DateTimeBaseInput(TextInput):\nCode replaced for brevity.\n484: \n485: \n486: \n487: class DateInput(DateTimeBaseInput):\nCode replaced for brevity.\n489: \n490: \n491: \n492: class DateTimeInput(DateTimeBaseInput):\nCode replaced for brevity.\n494: \n495: \n496: \n497: class TimeInput(DateTimeBaseInput):\nCode replaced for brevity.\n499: \n500: \n501: \n502: # Defined at module level so that CheckboxInput is picklable (#17976)\n503: def boolean_check(v):\n504:     return not (v is False or v is None or v == '')\n505: \n506: \n507: class CheckboxInput(Input):\nCode replaced for brevity.\n543: \n544: \n545: \n546: class ChoiceWidget(Widget):\nCode replaced for brevity.\n666: \n667: \n668: \n669: class Select(ChoiceWidget):\nCode replaced for brevity.\n700: \n701: \n702: \n703: class NullBooleanSelect(Select):\nCode replaced for brevity.\n738: \n739: \n740: \n741: class SelectMultiple(Select):\nCode replaced for brevity.\n754: \n755: \n756: \n757: class RadioSelect(ChoiceWidget):\nCode replaced for brevity.\n760: \n761: \n762: \n763: class CheckboxSelectMultiple(ChoiceWidget):\nCode replaced for brevity.\n786: \n787: \n788: \n789: class MultiWidget(Widget):\nCode replaced for brevity.\n880: \n881: \n882: \n883: class SplitDateTimeWidget(MultiWidget):\nCode replaced for brevity.\n907: \n908: \n909: \n910: class SplitHiddenDateTimeWidget(SplitDateTimeWidget):\nCode replaced for brevity.\n919: \n920: \n921: \n922: class SelectDateWidget(Widget):\nCode replaced for brevity.\n1074: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/forms/widgets.py",
      "suspect_lines": [
        454,
        455,
        456
      ]
    }
  ]
}