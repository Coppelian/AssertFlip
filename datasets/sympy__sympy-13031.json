{
  "instance_id": "sympy__sympy-13031",
  "problem_statement": "Behavior of Matrix hstack and vstack changed in sympy 1.1\nIn sympy 1.0:\r\n```\r\nimport sympy as sy\r\nM1 = sy.Matrix.zeros(0, 0)\r\nM2 = sy.Matrix.zeros(0, 1)\r\nM3 = sy.Matrix.zeros(0, 2)\r\nM4 = sy.Matrix.zeros(0, 3)\r\nsy.Matrix.hstack(M1, M2, M3, M4).shape\r\n```\r\nreturns \r\n`(0, 6)`\r\n\r\nNow, same in sympy 1.1:\r\n```\r\nimport sympy as sy\r\nM1 = sy.Matrix.zeros(0, 0)\r\nM2 = sy.Matrix.zeros(0, 1)\r\nM3 = sy.Matrix.zeros(0, 2)\r\nM4 = sy.Matrix.zeros(0, 3)\r\nsy.Matrix.hstack(M1, M2, M3, M4).shape\r\n```\r\nreturns\r\n`(0, 3)\r\n`\r\nwhereas:\r\n```\r\nimport sympy as sy\r\nM1 = sy.Matrix.zeros(1, 0)\r\nM2 = sy.Matrix.zeros(1, 1)\r\nM3 = sy.Matrix.zeros(1, 2)\r\nM4 = sy.Matrix.zeros(1, 3)\r\nsy.Matrix.hstack(M1, M2, M3, M4).shape\r\n```\r\nreturns\r\n`(1, 6)\r\n`\n",
  "localized_code": "[start of sympy/matrices/sparse.py]\n1: from __future__ import print_function, division\n2: \n3: import copy\n4: from collections import defaultdict\n5: \n6: from sympy.core.containers import Dict\n7: from sympy.core.expr import Expr\n8: from sympy.core.compatibility import is_sequence, as_int, range\n9: from sympy.core.logic import fuzzy_and\n10: from sympy.core.singleton import S\n11: from sympy.functions import Abs\n12: from sympy.functions.elementary.miscellaneous import sqrt\n13: from sympy.utilities.iterables import uniq\n14: \n15: from .matrices import MatrixBase, ShapeError, a2idx\n16: from .dense import Matrix\n17: import collections\n18: \n19: \n20: class SparseMatrix(MatrixBase):\n21:     \"\"\"\n22:     A sparse matrix (a matrix with a large number of zero elements).\n23: \n24:     Examples\n25:     ========\n26: \n27:     >>> from sympy.matrices import SparseMatrix\n28:     >>> SparseMatrix(2, 2, range(4))\n29:     Matrix([\n30:     [0, 1],\n31:     [2, 3]])\n32:     >>> SparseMatrix(2, 2, {(1, 1): 2})\n33:     Matrix([\n34:     [0, 0],\n35:     [0, 2]])\n36: \n37:     See Also\n38:     ========\n39:     sympy.matrices.dense.Matrix\n40:     \"\"\"\n41: \n42:     def __new__(cls, *args, **kwargs):\n43:         self = object.__new__(cls)\n44:         if len(args) == 1 and isinstance(args[0], SparseMatrix):\n45:             self.rows = args[0].rows\n46:             self.cols = args[0].cols\n47:             self._smat = dict(args[0]._smat)\n48:             return self\n49: \n50:         self._smat = {}\n51: \n52:         if len(args) == 3:\n53:             self.rows = as_int(args[0])\n54:             self.cols = as_int(args[1])\n55: \n56:             if isinstance(args[2], collections.Callable):\n57:                 op = args[2]\n58:                 for i in range(self.rows):\n59:                     for j in range(self.cols):\n60:                         value = self._sympify(\n61:                             op(self._sympify(i), self._sympify(j)))\n62:                         if value:\n63:                             self._smat[(i, j)] = value\n64:             elif isinstance(args[2], (dict, Dict)):\n65:                 # manual copy, copy.deepcopy() doesn't work\n66:                 for key in args[2].keys():\n67:                     v = args[2][key]\n68:                     if v:\n69:                         self._smat[key] = self._sympify(v)\n70:             elif is_sequence(args[2]):\n71:                 if len(args[2]) != self.rows*self.cols:\n72:                     raise ValueError(\n73:                         'List length (%s) != rows*columns (%s)' %\n74:                         (len(args[2]), self.rows*self.cols))\n75:                 flat_list = args[2]\n76:                 for i in range(self.rows):\n77:                     for j in range(self.cols):\n78:                         value = self._sympify(flat_list[i*self.cols + j])\n79:                         if value:\n80:                             self._smat[(i, j)] = value\n81:         else:\n82:             # handle full matrix forms with _handle_creation_inputs\n83:             r, c, _list = Matrix._handle_creation_inputs(*args)\n84:             self.rows = r\n85:             self.cols = c\n86:             for i in range(self.rows):\n87:                 for j in range(self.cols):\n88:                     value = _list[self.cols*i + j]\n89:                     if value:\n90:                         self._smat[(i, j)] = value\n91:         return self\n92: \n93:     def __eq__(self, other):\n94:         try:\n95:             if self.shape != other.shape:\n96:                 return False\n97:             if isinstance(other, SparseMatrix):\n98:                 return self._smat == other._smat\n99:             elif isinstance(other, MatrixBase):\n100:                 return self._smat == MutableSparseMatrix(other)._smat\n101:         except AttributeError:\n102:             return False\n103: \n104:     def __getitem__(self, key):\n105: \n106:         if isinstance(key, tuple):\n107:             i, j = key\n108:             try:\n109:                 i, j = self.key2ij(key)\n110:                 return self._smat.get((i, j), S.Zero)\n111:             except (TypeError, IndexError):\n112:                 if isinstance(i, slice):\n113:                     # XXX remove list() when PY2 support is dropped\n114:                     i = list(range(self.rows))[i]\n115:                 elif is_sequence(i):\n116:                     pass\n117:                 elif isinstance(i, Expr) and not i.is_number:\n118:                     from sympy.matrices.expressions.matexpr import MatrixElement\n119:                     return MatrixElement(self, i, j)\n120:                 else:\n121:                     if i >= self.rows:\n122:                         raise IndexError('Row index out of bounds')\n123:                     i = [i]\n124:                 if isinstance(j, slice):\n125:                     # XXX remove list() when PY2 support is dropped\n126:                     j = list(range(self.cols))[j]\n127:                 elif is_sequence(j):\n128:                     pass\n129:                 elif isinstance(j, Expr) and not j.is_number:\n130:                     from sympy.matrices.expressions.matexpr import MatrixElement\n131:                     return MatrixElement(self, i, j)\n132:                 else:\n133:                     if j >= self.cols:\n134:                         raise IndexError('Col index out of bounds')\n135:                     j = [j]\n136:                 return self.extract(i, j)\n137: \n138:         # check for single arg, like M[:] or M[3]\n139:         if isinstance(key, slice):\n140:             lo, hi = key.indices(len(self))[:2]\n141:             L = []\n142:             for i in range(lo, hi):\n143:                 m, n = divmod(i, self.cols)\n144:                 L.append(self._smat.get((m, n), S.Zero))\n145:             return L\n146: \n147:         i, j = divmod(a2idx(key, len(self)), self.cols)\n148:         return self._smat.get((i, j), S.Zero)\n149: \n150:     def __setitem__(self, key, value):\n151:         raise NotImplementedError()\n152: \n153:     def _cholesky_solve(self, rhs):\n154:         # for speed reasons, this is not uncommented, but if you are\n155:         # having difficulties, try uncommenting to make sure that the\n156:         # input matrix is symmetric\n157: \n158:         #assert self.is_symmetric()\n159:         L = self._cholesky_sparse()\n160:         Y = L._lower_triangular_solve(rhs)\n161:         rv = L.T._upper_triangular_solve(Y)\n162:         return rv\n163: \n164:     def _cholesky_sparse(self):\n165:         \"\"\"Algorithm for numeric Cholesky factorization of a sparse matrix.\"\"\"\n166:         Crowstruc = self.row_structure_symbolic_cholesky()\n167:         C = self.zeros(self.rows)\n168:         for i in range(len(Crowstruc)):\n169:             for j in Crowstruc[i]:\n170:                 if i != j:\n171:                     C[i, j] = self[i, j]\n172:                     summ = 0\n173:                     for p1 in Crowstruc[i]:\n174:                         if p1 < j:\n175:                             for p2 in Crowstruc[j]:\n176:                                 if p2 < j:\n177:                                     if p1 == p2:\n178:                                         summ += C[i, p1]*C[j, p1]\n179:                                 else:\n180:                                     break\n181:                             else:\n182:                                 break\n183:                     C[i, j] -= summ\n184:                     C[i, j] /= C[j, j]\n185:                 else:\n186:                     C[j, j] = self[j, j]\n187:                     summ = 0\n188:                     for k in Crowstruc[j]:\n189:                         if k < j:\n190:                             summ += C[j, k]**2\n191:                         else:\n192:                             break\n193:                     C[j, j] -= summ\n194:                     C[j, j] = sqrt(C[j, j])\n195: \n196:         return C\n197: \n198:     def _diagonal_solve(self, rhs):\n199:         \"Diagonal solve.\"\n200:         return self._new(self.rows, 1, lambda i, j: rhs[i, 0] / self[i, i])\n201: \n202:     def _eval_inverse(self, **kwargs):\n203:         \"\"\"Return the matrix inverse using Cholesky or LDL (default)\n204:         decomposition as selected with the ``method`` keyword: 'CH' or 'LDL',\n205:         respectively.\n206: \n207:         Examples\n208:         ========\n209: \n210:         >>> from sympy import SparseMatrix, Matrix\n211:         >>> A = SparseMatrix([\n212:         ... [ 2, -1,  0],\n213:         ... [-1,  2, -1],\n214:         ... [ 0,  0,  2]])\n215:         >>> A.inv('CH')\n216:         Matrix([\n217:         [2/3, 1/3, 1/6],\n218:         [1/3, 2/3, 1/3],\n219:         [  0,   0, 1/2]])\n220:         >>> A.inv(method='LDL') # use of 'method=' is optional\n221:         Matrix([\n222:         [2/3, 1/3, 1/6],\n223:         [1/3, 2/3, 1/3],\n224:         [  0,   0, 1/2]])\n225:         >>> A * _\n226:         Matrix([\n227:         [1, 0, 0],\n228:         [0, 1, 0],\n229:         [0, 0, 1]])\n230: \n231:         \"\"\"\n232:         sym = self.is_symmetric()\n233:         M = self.as_mutable()\n234:         I = M.eye(M.rows)\n235:         if not sym:\n236:             t = M.T\n237:             r1 = M[0, :]\n238:             M = t*M\n239:             I = t*I\n240:         method = kwargs.get('method', 'LDL')\n241:         if method in \"LDL\":\n242:             solve = M._LDL_solve\n243:         elif method == \"CH\":\n244:             solve = M._cholesky_solve\n245:         else:\n246:             raise NotImplementedError(\n247:                 'Method may be \"CH\" or \"LDL\", not %s.' % method)\n248:         rv = M.hstack(*[solve(I[:, i]) for i in range(I.cols)])\n249:         if not sym:\n250:             scale = (r1*rv[:, 0])[0, 0]\n251:             rv /= scale\n252:         return self._new(rv)\n253: \n254:     def _eval_Abs(self):\n255:         return self.applyfunc(lambda x: Abs(x))\n256: \n257:     def _eval_add(self, other):\n258:         \"\"\"If `other` is a SparseMatrix, add efficiently. Otherwise,\n259:         do standard addition.\"\"\"\n260:         if not isinstance(other, SparseMatrix):\n261:             return self + self._new(other)\n262: \n263:         smat = {}\n264:         zero = self._sympify(0)\n265:         for key in set().union(self._smat.keys(), other._smat.keys()):\n266:             sum = self._smat.get(key, zero) + other._smat.get(key, zero)\n267:             if sum != 0:\n268:                 smat[key] = sum\n269:         return self._new(self.rows, self.cols, smat)\n270: \n271:     def _eval_col_insert(self, icol, other):\n272:         if not isinstance(other, SparseMatrix):\n273:             other = SparseMatrix(other)\n274:         new_smat = {}\n275:         # make room for the new rows\n276:         for key, val in self._smat.items():\n277:             row, col = key\n278:             if col >= icol:\n279:                 col += other.cols\n280:             new_smat[(row, col)] = val\n281:         # add other's keys\n282:         for key, val in other._smat.items():\n283:             row, col = key\n284:             new_smat[(row, col + icol)] = val\n285:         return self._new(self.rows, self.cols + other.cols, new_smat)\n286: \n287:     def _eval_conjugate(self):\n288:         smat = {key: val.conjugate() for key,val in self._smat.items()}\n289:         return self._new(self.rows, self.cols, smat)\n290: \n291:     def _eval_extract(self, rowsList, colsList):\n292:         urow = list(uniq(rowsList))\n293:         ucol = list(uniq(colsList))\n294:         smat = {}\n295:         if len(urow)*len(ucol) < len(self._smat):\n296:             # there are fewer elements requested than there are elements in the matrix\n297:             for i, r in enumerate(urow):\n298:                 for j, c in enumerate(ucol):\n299:                     smat[i, j] = self._smat.get((r, c), 0)\n300:         else:\n301:             # most of the request will be zeros so check all of self's entries,\n302:             # keeping only the ones that are desired\n303:             for rk, ck in self._smat:\n304:                 if rk in urow and ck in ucol:\n305:                     smat[(urow.index(rk), ucol.index(ck))] = self._smat[(rk, ck)]\n306: \n307:         rv = self._new(len(urow), len(ucol), smat)\n308:         # rv is nominally correct but there might be rows/cols\n309:         # which require duplication\n310:         if len(rowsList) != len(urow):\n311:             for i, r in enumerate(rowsList):\n312:                 i_previous = rowsList.index(r)\n313:                 if i_previous != i:\n314:                     rv = rv.row_insert(i, rv.row(i_previous))\n315:         if len(colsList) != len(ucol):\n316:             for i, c in enumerate(colsList):\n317:                 i_previous = colsList.index(c)\n318:                 if i_previous != i:\n319:                     rv = rv.col_insert(i, rv.col(i_previous))\n320:         return rv\n321: \n322:     @classmethod\n323:     def _eval_eye(cls, rows, cols):\n324:         entries = {(i,i): S.One for i in range(min(rows, cols))}\n325:         return cls._new(rows, cols, entries)\n326: \n327:     def _eval_has(self, *patterns):\n328:         # if the matrix has any zeros, see if S.Zero\n329:         # has the pattern.  If _smat is full length,\n330:         # the matrix has no zeros.\n331:         zhas = S.Zero.has(*patterns)\n332:         if len(self._smat) == self.rows*self.cols:\n333:             zhas = False\n334:         return any(self[key].has(*patterns) for key in self._smat) or zhas\n335: \n336:     def _eval_is_Identity(self):\n337:         if not all(self[i, i] == 1 for i in range(self.rows)):\n338:             return False\n339:         return len(self._smat) == self.rows\n340: \n341:     def _eval_is_symmetric(self, simpfunc):\n342:         diff = (self - self.T).applyfunc(simpfunc)\n343:         return len(diff.values()) == 0\n344: \n345:     def _eval_matrix_mul(self, other):\n346:         \"\"\"Fast multiplication exploiting the sparsity of the matrix.\"\"\"\n347:         if not isinstance(other, SparseMatrix):\n348:             return self*self._new(other)\n349: \n350:         # if we made it here, we're both sparse matrices\n351:         # create quick lookups for rows and cols\n352:         row_lookup = defaultdict(dict)\n353:         for (i,j), val in self._smat.items():\n354:             row_lookup[i][j] = val\n355:         col_lookup = defaultdict(dict)\n356:         for (i,j), val in other._smat.items():\n357:             col_lookup[j][i] = val\n358: \n359:         smat = {}\n360:         for row in row_lookup.keys():\n361:             for col in col_lookup.keys():\n362:                 # find the common indices of non-zero entries.\n363:                 # these are the only things that need to be multiplied.\n364:                 indices = set(col_lookup[col].keys()) & set(row_lookup[row].keys())\n365:                 if indices:\n366:                     val = sum(row_lookup[row][k]*col_lookup[col][k] for k in indices)\n367:                     smat[(row, col)] = val\n368:         return self._new(self.rows, other.cols, smat)\n369: \n370:     def _eval_row_insert(self, irow, other):\n371:         if not isinstance(other, SparseMatrix):\n372:             other = SparseMatrix(other)\n373:         new_smat = {}\n374:         # make room for the new rows\n375:         for key, val in self._smat.items():\n376:             row, col = key\n377:             if row >= irow:\n378:                 row += other.rows\n379:             new_smat[(row, col)] = val\n380:         # add other's keys\n381:         for key, val in other._smat.items():\n382:             row, col = key\n383:             new_smat[(row + irow, col)] = val\n384:         return self._new(self.rows + other.rows, self.cols, new_smat)\n385: \n386:     def _eval_scalar_mul(self, other):\n387:         return self.applyfunc(lambda x: x*other)\n388: \n389:     def _eval_scalar_rmul(self, other):\n390:         return self.applyfunc(lambda x: other*x)\n391: \n392:     def _eval_transpose(self):\n393:         \"\"\"Returns the transposed SparseMatrix of this SparseMatrix.\n394: \n395:         Examples\n396:         ========\n397: \n398:         >>> from sympy.matrices import SparseMatrix\n399:         >>> a = SparseMatrix(((1, 2), (3, 4)))\n400:         >>> a\n401:         Matrix([\n402:         [1, 2],\n403:         [3, 4]])\n404:         >>> a.T\n405:         Matrix([\n406:         [1, 3],\n407:         [2, 4]])\n408:         \"\"\"\n409:         smat = {(j,i): val for (i,j),val in self._smat.items()}\n410:         return self._new(self.cols, self.rows, smat)\n411: \n412:     def _eval_values(self):\n413:         return [v for k,v in self._smat.items() if not v.is_zero]\n414: \n415:     @classmethod\n416:     def _eval_zeros(cls, rows, cols):\n417:         return cls._new(rows, cols, {})\n418: \n419:     def _LDL_solve(self, rhs):\n420:         # for speed reasons, this is not uncommented, but if you are\n421:         # having difficulties, try uncommenting to make sure that the\n422:         # input matrix is symmetric\n423: \n424:         #assert self.is_symmetric()\n425:         L, D = self._LDL_sparse()\n426:         Z = L._lower_triangular_solve(rhs)\n427:         Y = D._diagonal_solve(Z)\n428:         return L.T._upper_triangular_solve(Y)\n429: \n430:     def _LDL_sparse(self):\n431:         \"\"\"Algorithm for numeric LDL factization, exploiting sparse structure.\n432:         \"\"\"\n433:         Lrowstruc = self.row_structure_symbolic_cholesky()\n434:         L = self.eye(self.rows)\n435:         D = self.zeros(self.rows, self.cols)\n436: \n437:         for i in range(len(Lrowstruc)):\n438:             for j in Lrowstruc[i]:\n439:                 if i != j:\n440:                     L[i, j] = self[i, j]\n441:                     summ = 0\n442:                     for p1 in Lrowstruc[i]:\n443:                         if p1 < j:\n444:                             for p2 in Lrowstruc[j]:\n445:                                 if p2 < j:\n446:                                     if p1 == p2:\n447:                                         summ += L[i, p1]*L[j, p1]*D[p1, p1]\n448:                                 else:\n449:                                     break\n450:                         else:\n451:                             break\n452:                     L[i, j] -= summ\n453:                     L[i, j] /= D[j, j]\n454:                 elif i == j:\n455:                     D[i, i] = self[i, i]\n456:                     summ = 0\n457:                     for k in Lrowstruc[i]:\n458:                         if k < i:\n459:                             summ += L[i, k]**2*D[k, k]\n460:                         else:\n461:                             break\n462:                     D[i, i] -= summ\n463: \n464:         return L, D\n465: \n466:     def _lower_triangular_solve(self, rhs):\n467:         \"\"\"Fast algorithm for solving a lower-triangular system,\n468:         exploiting the sparsity of the given matrix.\n469:         \"\"\"\n470:         rows = [[] for i in range(self.rows)]\n471:         for i, j, v in self.row_list():\n472:             if i > j:\n473:                 rows[i].append((j, v))\n474:         X = rhs.copy()\n475:         for i in range(self.rows):\n476:             for j, v in rows[i]:\n477:                 X[i, 0] -= v*X[j, 0]\n478:             X[i, 0] /= self[i, i]\n479:         return self._new(X)\n480: \n481:     @property\n482:     def _mat(self):\n483:         \"\"\"Return a list of matrix elements.  Some routines\n484:         in DenseMatrix use `_mat` directly to speed up operations.\"\"\"\n485:         return list(self)\n486: \n487:     def _upper_triangular_solve(self, rhs):\n488:         \"\"\"Fast algorithm for solving an upper-triangular system,\n489:         exploiting the sparsity of the given matrix.\n490:         \"\"\"\n491:         rows = [[] for i in range(self.rows)]\n492:         for i, j, v in self.row_list():\n493:             if i < j:\n494:                 rows[i].append((j, v))\n495:         X = rhs.copy()\n496:         for i in range(self.rows - 1, -1, -1):\n497:             rows[i].reverse()\n498:             for j, v in rows[i]:\n499:                 X[i, 0] -= v*X[j, 0]\n500:             X[i, 0] /= self[i, i]\n501:         return self._new(X)\n502: \n503: \n504:     def applyfunc(self, f):\n505:         \"\"\"Apply a function to each element of the matrix.\n506: \n507:         Examples\n508:         ========\n509: \n510:         >>> from sympy.matrices import SparseMatrix\n511:         >>> m = SparseMatrix(2, 2, lambda i, j: i*2+j)\n512:         >>> m\n513:         Matrix([\n514:         [0, 1],\n515:         [2, 3]])\n516:         >>> m.applyfunc(lambda i: 2*i)\n517:         Matrix([\n518:         [0, 2],\n519:         [4, 6]])\n520: \n521:         \"\"\"\n522:         if not callable(f):\n523:             raise TypeError(\"`f` must be callable.\")\n524: \n525:         out = self.copy()\n526:         for k, v in self._smat.items():\n527:             fv = f(v)\n528:             if fv:\n529:                 out._smat[k] = fv\n530:             else:\n531:                 out._smat.pop(k, None)\n532:         return out\n533: \n534:     def as_immutable(self):\n535:         \"\"\"Returns an Immutable version of this Matrix.\"\"\"\n536:         from .immutable import ImmutableSparseMatrix\n537:         return ImmutableSparseMatrix(self)\n538: \n539:     def as_mutable(self):\n540:         \"\"\"Returns a mutable version of this matrix.\n541: \n542:         Examples\n543:         ========\n544: \n545:         >>> from sympy import ImmutableMatrix\n546:         >>> X = ImmutableMatrix([[1, 2], [3, 4]])\n547:         >>> Y = X.as_mutable()\n548:         >>> Y[1, 1] = 5 # Can set values in Y\n549:         >>> Y\n550:         Matrix([\n551:         [1, 2],\n552:         [3, 5]])\n553:         \"\"\"\n554:         return MutableSparseMatrix(self)\n555: \n556:     def cholesky(self):\n557:         \"\"\"\n558:         Returns the Cholesky decomposition L of a matrix A\n559:         such that L * L.T = A\n560: \n561:         A must be a square, symmetric, positive-definite\n562:         and non-singular matrix\n563: \n564:         Examples\n565:         ========\n566: \n567:         >>> from sympy.matrices import SparseMatrix\n568:         >>> A = SparseMatrix(((25,15,-5),(15,18,0),(-5,0,11)))\n569:         >>> A.cholesky()\n570:         Matrix([\n571:         [ 5, 0, 0],\n572:         [ 3, 3, 0],\n573:         [-1, 1, 3]])\n574:         >>> A.cholesky() * A.cholesky().T == A\n575:         True\n576:         \"\"\"\n577: \n578:         from sympy.core.numbers import nan, oo\n579:         if not self.is_symmetric():\n580:             raise ValueError('Cholesky decomposition applies only to '\n581:                 'symmetric matrices.')\n582:         M = self.as_mutable()._cholesky_sparse()\n583:         if M.has(nan) or M.has(oo):\n584:             raise ValueError('Cholesky decomposition applies only to '\n585:                 'positive-definite matrices')\n586:         return self._new(M)\n587: \n588:     def col_list(self):\n589:         \"\"\"Returns a column-sorted list of non-zero elements of the matrix.\n590: \n591:         Examples\n592:         ========\n593: \n594:         >>> from sympy.matrices import SparseMatrix\n595:         >>> a=SparseMatrix(((1, 2), (3, 4)))\n596:         >>> a\n597:         Matrix([\n598:         [1, 2],\n599:         [3, 4]])\n600:         >>> a.CL\n601:         [(0, 0, 1), (1, 0, 3), (0, 1, 2), (1, 1, 4)]\n602: \n603:         See Also\n604:         ========\n605:         col_op\n606:         row_list\n607:         \"\"\"\n608:         return [tuple(k + (self[k],)) for k in sorted(list(self._smat.keys()), key=lambda k: list(reversed(k)))]\n609: \n610:     def copy(self):\n611:         return self._new(self.rows, self.cols, self._smat)\n612: \n613:     def LDLdecomposition(self):\n614:         \"\"\"\n615:         Returns the LDL Decomposition (matrices ``L`` and ``D``) of matrix\n616:         ``A``, such that ``L * D * L.T == A``. ``A`` must be a square,\n617:         symmetric, positive-definite and non-singular.\n618: \n619:         This method eliminates the use of square root and ensures that all\n620:         the diagonal entries of L are 1.\n621: \n622:         Examples\n623:         ========\n624: \n625:         >>> from sympy.matrices import SparseMatrix\n626:         >>> A = SparseMatrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))\n627:         >>> L, D = A.LDLdecomposition()\n628:         >>> L\n629:         Matrix([\n630:         [   1,   0, 0],\n631:         [ 3/5,   1, 0],\n632:         [-1/5, 1/3, 1]])\n633:         >>> D\n634:         Matrix([\n635:         [25, 0, 0],\n636:         [ 0, 9, 0],\n637:         [ 0, 0, 9]])\n638:         >>> L * D * L.T == A\n639:         True\n640: \n641:         \"\"\"\n642:         from sympy.core.numbers import nan, oo\n643:         if not self.is_symmetric():\n644:             raise ValueError('LDL decomposition applies only to '\n645:                 'symmetric matrices.')\n646:         L, D = self.as_mutable()._LDL_sparse()\n647:         if L.has(nan) or L.has(oo) or D.has(nan) or D.has(oo):\n648:             raise ValueError('LDL decomposition applies only to '\n649:                 'positive-definite matrices')\n650: \n651:         return self._new(L), self._new(D)\n652: \n653:     def liupc(self):\n654:         \"\"\"Liu's algorithm, for pre-determination of the Elimination Tree of\n655:         the given matrix, used in row-based symbolic Cholesky factorization.\n656: \n657:         Examples\n658:         ========\n659: \n660:         >>> from sympy.matrices import SparseMatrix\n661:         >>> S = SparseMatrix([\n662:         ... [1, 0, 3, 2],\n663:         ... [0, 0, 1, 0],\n664:         ... [4, 0, 0, 5],\n665:         ... [0, 6, 7, 0]])\n666:         >>> S.liupc()\n667:         ([[0], [], [0], [1, 2]], [4, 3, 4, 4])\n668: \n669:         References\n670:         ==========\n671: \n672:         Symbolic Sparse Cholesky Factorization using Elimination Trees,\n673:         Jeroen Van Grondelle (1999)\n674:         http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7582\n675:         \"\"\"\n676:         # Algorithm 2.4, p 17 of reference\n677: \n678:         # get the indices of the elements that are non-zero on or below diag\n679:         R = [[] for r in range(self.rows)]\n680:         for r, c, _ in self.row_list():\n681:             if c <= r:\n682:                 R[r].append(c)\n683: \n684:         inf = len(R)  # nothing will be this large\n685:         parent = [inf]*self.rows\n686:         virtual = [inf]*self.rows\n687:         for r in range(self.rows):\n688:             for c in R[r][:-1]:\n689:                 while virtual[c] < r:\n690:                     t = virtual[c]\n691:                     virtual[c] = r\n692:                     c = t\n693:                 if virtual[c] == inf:\n694:                     parent[c] = virtual[c] = r\n695:         return R, parent\n696: \n697:     def nnz(self):\n698:         \"\"\"Returns the number of non-zero elements in Matrix.\"\"\"\n699:         return len(self._smat)\n700: \n701:     def row_list(self):\n702:         \"\"\"Returns a row-sorted list of non-zero elements of the matrix.\n703: \n704:         Examples\n705:         ========\n706: \n707:         >>> from sympy.matrices import SparseMatrix\n708:         >>> a = SparseMatrix(((1, 2), (3, 4)))\n709:         >>> a\n710:         Matrix([\n711:         [1, 2],\n712:         [3, 4]])\n713:         >>> a.RL\n714:         [(0, 0, 1), (0, 1, 2), (1, 0, 3), (1, 1, 4)]\n715: \n716:         See Also\n717:         ========\n718:         row_op\n719:         col_list\n720:         \"\"\"\n721:         return [tuple(k + (self[k],)) for k in\n722:             sorted(list(self._smat.keys()), key=lambda k: list(k))]\n723: \n724:     def row_structure_symbolic_cholesky(self):\n725:         \"\"\"Symbolic cholesky factorization, for pre-determination of the\n726:         non-zero structure of the Cholesky factororization.\n727: \n728:         Examples\n729:         ========\n730: \n731:         >>> from sympy.matrices import SparseMatrix\n732:         >>> S = SparseMatrix([\n733:         ... [1, 0, 3, 2],\n734:         ... [0, 0, 1, 0],\n735:         ... [4, 0, 0, 5],\n736:         ... [0, 6, 7, 0]])\n737:         >>> S.row_structure_symbolic_cholesky()\n738:         [[0], [], [0], [1, 2]]\n739: \n740:         References\n741:         ==========\n742: \n743:         Symbolic Sparse Cholesky Factorization using Elimination Trees,\n744:         Jeroen Van Grondelle (1999)\n745:         http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7582\n746:         \"\"\"\n747: \n748:         R, parent = self.liupc()\n749:         inf = len(R)  # this acts as infinity\n750:         Lrow = copy.deepcopy(R)\n751:         for k in range(self.rows):\n752:             for j in R[k]:\n753:                 while j != inf and j != k:\n754:                     Lrow[k].append(j)\n755:                     j = parent[j]\n756:             Lrow[k] = list(sorted(set(Lrow[k])))\n757:         return Lrow\n758: \n759:     def scalar_multiply(self, scalar):\n760:         \"Scalar element-wise multiplication\"\n761:         M = self.zeros(*self.shape)\n762:         if scalar:\n763:             for i in self._smat:\n764:                 v = scalar*self._smat[i]\n765:                 if v:\n766:                     M._smat[i] = v\n767:                 else:\n768:                     M._smat.pop(i, None)\n769:         return M\n770: \n771:     def solve_least_squares(self, rhs, method='LDL'):\n772:         \"\"\"Return the least-square fit to the data.\n773: \n774:         By default the cholesky_solve routine is used (method='CH'); other\n775:         methods of matrix inversion can be used. To find out which are\n776:         available, see the docstring of the .inv() method.\n777: \n778:         Examples\n779:         ========\n780: \n781:         >>> from sympy.matrices import SparseMatrix, Matrix, ones\n782:         >>> A = Matrix([1, 2, 3])\n783:         >>> B = Matrix([2, 3, 4])\n784:         >>> S = SparseMatrix(A.row_join(B))\n785:         >>> S\n786:         Matrix([\n787:         [1, 2],\n788:         [2, 3],\n789:         [3, 4]])\n790: \n791:         If each line of S represent coefficients of Ax + By\n792:         and x and y are [2, 3] then S*xy is:\n793: \n794:         >>> r = S*Matrix([2, 3]); r\n795:         Matrix([\n796:         [ 8],\n797:         [13],\n798:         [18]])\n799: \n800:         But let's add 1 to the middle value and then solve for the\n801:         least-squares value of xy:\n802: \n803:         >>> xy = S.solve_least_squares(Matrix([8, 14, 18])); xy\n804:         Matrix([\n805:         [ 5/3],\n806:         [10/3]])\n807: \n808:         The error is given by S*xy - r:\n809: \n810:         >>> S*xy - r\n811:         Matrix([\n812:         [1/3],\n813:         [1/3],\n814:         [1/3]])\n815:         >>> _.norm().n(2)\n816:         0.58\n817: \n818:         If a different xy is used, the norm will be higher:\n819: \n820:         >>> xy += ones(2, 1)/10\n821:         >>> (S*xy - r).norm().n(2)\n822:         1.5\n823: \n824:         \"\"\"\n825:         t = self.T\n826:         return (t*self).inv(method=method)*t*rhs\n827: \n828:     def solve(self, rhs, method='LDL'):\n829:         \"\"\"Return solution to self*soln = rhs using given inversion method.\n830: \n831:         For a list of possible inversion methods, see the .inv() docstring.\n832:         \"\"\"\n833:         if not self.is_square:\n834:             if self.rows < self.cols:\n835:                 raise ValueError('Under-determined system.')\n836:             elif self.rows > self.cols:\n837:                 raise ValueError('For over-determined system, M, having '\n838:                     'more rows than columns, try M.solve_least_squares(rhs).')\n839:         else:\n840:             return self.inv(method=method)*rhs\n841: \n842:     RL = property(row_list, None, None, \"Alternate faster representation\")\n843: \n844:     CL = property(col_list, None, None, \"Alternate faster representation\")\n845: \n846: \n847: class MutableSparseMatrix(SparseMatrix, MatrixBase):\n848:     @classmethod\n849:     def _new(cls, *args, **kwargs):\n850:         return cls(*args)\n851: \n852:     def __setitem__(self, key, value):\n853:         \"\"\"Assign value to position designated by key.\n854: \n855:         Examples\n856:         ========\n857: \n858:         >>> from sympy.matrices import SparseMatrix, ones\n859:         >>> M = SparseMatrix(2, 2, {})\n860:         >>> M[1] = 1; M\n861:         Matrix([\n862:         [0, 1],\n863:         [0, 0]])\n864:         >>> M[1, 1] = 2; M\n865:         Matrix([\n866:         [0, 1],\n867:         [0, 2]])\n868:         >>> M = SparseMatrix(2, 2, {})\n869:         >>> M[:, 1] = [1, 1]; M\n870:         Matrix([\n871:         [0, 1],\n872:         [0, 1]])\n873:         >>> M = SparseMatrix(2, 2, {})\n874:         >>> M[1, :] = [[1, 1]]; M\n875:         Matrix([\n876:         [0, 0],\n877:         [1, 1]])\n878: \n879: \n880:         To replace row r you assign to position r*m where m\n881:         is the number of columns:\n882: \n883:         >>> M = SparseMatrix(4, 4, {})\n884:         >>> m = M.cols\n885:         >>> M[3*m] = ones(1, m)*2; M\n886:         Matrix([\n887:         [0, 0, 0, 0],\n888:         [0, 0, 0, 0],\n889:         [0, 0, 0, 0],\n890:         [2, 2, 2, 2]])\n891: \n892:         And to replace column c you can assign to position c:\n893: \n894:         >>> M[2] = ones(m, 1)*4; M\n895:         Matrix([\n896:         [0, 0, 4, 0],\n897:         [0, 0, 4, 0],\n898:         [0, 0, 4, 0],\n899:         [2, 2, 4, 2]])\n900:         \"\"\"\n901:         rv = self._setitem(key, value)\n902:         if rv is not None:\n903:             i, j, value = rv\n904:             if value:\n905:                 self._smat[(i, j)] = value\n906:             elif (i, j) in self._smat:\n907:                 del self._smat[(i, j)]\n908: \n909:     def as_mutable(self):\n910:         return self.copy()\n911: \n912:     __hash__ = None\n913: \n914:     def col_del(self, k):\n915:         \"\"\"Delete the given column of the matrix.\n916: \n917:         Examples\n918:         ========\n919: \n920:         >>> from sympy.matrices import SparseMatrix\n921:         >>> M = SparseMatrix([[0, 0], [0, 1]])\n922:         >>> M\n923:         Matrix([\n924:         [0, 0],\n925:         [0, 1]])\n926:         >>> M.col_del(0)\n927:         >>> M\n928:         Matrix([\n929:         [0],\n930:         [1]])\n931: \n932:         See Also\n933:         ========\n934: \n935:         row_del\n936:         \"\"\"\n937:         newD = {}\n938:         k = a2idx(k, self.cols)\n939:         for (i, j) in self._smat:\n940:             if j == k:\n941:                 pass\n942:             elif j > k:\n943:                 newD[i, j - 1] = self._smat[i, j]\n944:             else:\n945:                 newD[i, j] = self._smat[i, j]\n946:         self._smat = newD\n947:         self.cols -= 1\n948: \n949:     def col_join(self, other):\n950:         \"\"\"Returns B augmented beneath A (row-wise joining)::\n951: \n952:             [A]\n953:             [B]\n954: \n955:         Examples\n956:         ========\n957: \n958:         >>> from sympy import SparseMatrix, Matrix, ones\n959:         >>> A = SparseMatrix(ones(3))\n960:         >>> A\n961:         Matrix([\n962:         [1, 1, 1],\n963:         [1, 1, 1],\n964:         [1, 1, 1]])\n965:         >>> B = SparseMatrix.eye(3)\n966:         >>> B\n967:         Matrix([\n968:         [1, 0, 0],\n969:         [0, 1, 0],\n970:         [0, 0, 1]])\n971:         >>> C = A.col_join(B); C\n972:         Matrix([\n973:         [1, 1, 1],\n974:         [1, 1, 1],\n975:         [1, 1, 1],\n976:         [1, 0, 0],\n977:         [0, 1, 0],\n978:         [0, 0, 1]])\n979:         >>> C == A.col_join(Matrix(B))\n980:         True\n981: \n982:         Joining along columns is the same as appending rows at the end\n983:         of the matrix:\n984: \n985:         >>> C == A.row_insert(A.rows, Matrix(B))\n986:         True\n987:         \"\"\"\n988:         if not self:\n989:             return type(self)(other)\n990:         A, B = self, other\n991:         if not A.cols == B.cols:\n992:             raise ShapeError()\n993:         A = A.copy()\n994:         if not isinstance(B, SparseMatrix):\n995:             k = 0\n996:             b = B._mat\n997:             for i in range(B.rows):\n998:                 for j in range(B.cols):\n999:                     v = b[k]\n1000:                     if v:\n1001:                         A._smat[(i + A.rows, j)] = v\n1002:                     k += 1\n1003:         else:\n1004:             for (i, j), v in B._smat.items():\n1005:                 A._smat[i + A.rows, j] = v\n1006:         A.rows += B.rows\n1007:         return A\n1008: \n1009:     def col_op(self, j, f):\n1010:         \"\"\"In-place operation on col j using two-arg functor whose args are\n1011:         interpreted as (self[i, j], i) for i in range(self.rows).\n1012: \n1013:         Examples\n1014:         ========\n1015: \n1016:         >>> from sympy.matrices import SparseMatrix\n1017:         >>> M = SparseMatrix.eye(3)*2\n1018:         >>> M[1, 0] = -1\n1019:         >>> M.col_op(1, lambda v, i: v + 2*M[i, 0]); M\n1020:         Matrix([\n1021:         [ 2, 4, 0],\n1022:         [-1, 0, 0],\n1023:         [ 0, 0, 2]])\n1024:         \"\"\"\n1025:         for i in range(self.rows):\n1026:             v = self._smat.get((i, j), S.Zero)\n1027:             fv = f(v, i)\n1028:             if fv:\n1029:                 self._smat[(i, j)] = fv\n1030:             elif v:\n1031:                 self._smat.pop((i, j))\n1032: \n1033:     def col_swap(self, i, j):\n1034:         \"\"\"Swap, in place, columns i and j.\n1035: \n1036:         Examples\n1037:         ========\n1038: \n1039:         >>> from sympy.matrices import SparseMatrix\n1040:         >>> S = SparseMatrix.eye(3); S[2, 1] = 2\n1041:         >>> S.col_swap(1, 0); S\n1042:         Matrix([\n1043:         [0, 1, 0],\n1044:         [1, 0, 0],\n1045:         [2, 0, 1]])\n1046:         \"\"\"\n1047:         if i > j:\n1048:             i, j = j, i\n1049:         rows = self.col_list()\n1050:         temp = []\n1051:         for ii, jj, v in rows:\n1052:             if jj == i:\n1053:                 self._smat.pop((ii, jj))\n1054:                 temp.append((ii, v))\n1055:             elif jj == j:\n1056:                 self._smat.pop((ii, jj))\n1057:                 self._smat[ii, i] = v\n1058:             elif jj > j:\n1059:                 break\n1060:         for k, v in temp:\n1061:             self._smat[k, j] = v\n1062: \n1063:     def copyin_list(self, key, value):\n1064:         if not is_sequence(value):\n1065:             raise TypeError(\"`value` must be of type list or tuple.\")\n1066:         self.copyin_matrix(key, Matrix(value))\n1067: \n1068:     def copyin_matrix(self, key, value):\n1069:         # include this here because it's not part of BaseMatrix\n1070:         rlo, rhi, clo, chi = self.key2bounds(key)\n1071:         shape = value.shape\n1072:         dr, dc = rhi - rlo, chi - clo\n1073:         if shape != (dr, dc):\n1074:             raise ShapeError(\n1075:                 \"The Matrix `value` doesn't have the same dimensions \"\n1076:                 \"as the in sub-Matrix given by `key`.\")\n1077:         if not isinstance(value, SparseMatrix):\n1078:             for i in range(value.rows):\n1079:                 for j in range(value.cols):\n1080:                     self[i + rlo, j + clo] = value[i, j]\n1081:         else:\n1082:             if (rhi - rlo)*(chi - clo) < len(self):\n1083:                 for i in range(rlo, rhi):\n1084:                     for j in range(clo, chi):\n1085:                         self._smat.pop((i, j), None)\n1086:             else:\n1087:                 for i, j, v in self.row_list():\n1088:                     if rlo <= i < rhi and clo <= j < chi:\n1089:                         self._smat.pop((i, j), None)\n1090:             for k, v in value._smat.items():\n1091:                 i, j = k\n1092:                 self[i + rlo, j + clo] = value[i, j]\n1093: \n1094:     def fill(self, value):\n1095:         \"\"\"Fill self with the given value.\n1096: \n1097:         Notes\n1098:         =====\n1099: \n1100:         Unless many values are going to be deleted (i.e. set to zero)\n1101:         this will create a matrix that is slower than a dense matrix in\n1102:         operations.\n1103: \n1104:         Examples\n1105:         ========\n1106: \n1107:         >>> from sympy.matrices import SparseMatrix\n1108:         >>> M = SparseMatrix.zeros(3); M\n1109:         Matrix([\n1110:         [0, 0, 0],\n1111:         [0, 0, 0],\n1112:         [0, 0, 0]])\n1113:         >>> M.fill(1); M\n1114:         Matrix([\n1115:         [1, 1, 1],\n1116:         [1, 1, 1],\n1117:         [1, 1, 1]])\n1118:         \"\"\"\n1119:         if not value:\n1120:             self._smat = {}\n1121:         else:\n1122:             v = self._sympify(value)\n1123:             self._smat = dict([((i, j), v)\n1124:                 for i in range(self.rows) for j in range(self.cols)])\n1125: \n1126:     def row_del(self, k):\n1127:         \"\"\"Delete the given row of the matrix.\n1128: \n1129:         Examples\n1130:         ========\n1131: \n1132:         >>> from sympy.matrices import SparseMatrix\n1133:         >>> M = SparseMatrix([[0, 0], [0, 1]])\n1134:         >>> M\n1135:         Matrix([\n1136:         [0, 0],\n1137:         [0, 1]])\n1138:         >>> M.row_del(0)\n1139:         >>> M\n1140:         Matrix([[0, 1]])\n1141: \n1142:         See Also\n1143:         ========\n1144: \n1145:         col_del\n1146:         \"\"\"\n1147:         newD = {}\n1148:         k = a2idx(k, self.rows)\n1149:         for (i, j) in self._smat:\n1150:             if i == k:\n1151:                 pass\n1152:             elif i > k:\n1153:                 newD[i - 1, j] = self._smat[i, j]\n1154:             else:\n1155:                 newD[i, j] = self._smat[i, j]\n1156:         self._smat = newD\n1157:         self.rows -= 1\n1158: \n1159:     def row_join(self, other):\n1160:         \"\"\"Returns B appended after A (column-wise augmenting)::\n1161: \n1162:             [A B]\n1163: \n1164:         Examples\n1165:         ========\n1166: \n1167:         >>> from sympy import SparseMatrix, Matrix\n1168:         >>> A = SparseMatrix(((1, 0, 1), (0, 1, 0), (1, 1, 0)))\n1169:         >>> A\n1170:         Matrix([\n1171:         [1, 0, 1],\n1172:         [0, 1, 0],\n1173:         [1, 1, 0]])\n1174:         >>> B = SparseMatrix(((1, 0, 0), (0, 1, 0), (0, 0, 1)))\n1175:         >>> B\n1176:         Matrix([\n1177:         [1, 0, 0],\n1178:         [0, 1, 0],\n1179:         [0, 0, 1]])\n1180:         >>> C = A.row_join(B); C\n1181:         Matrix([\n1182:         [1, 0, 1, 1, 0, 0],\n1183:         [0, 1, 0, 0, 1, 0],\n1184:         [1, 1, 0, 0, 0, 1]])\n1185:         >>> C == A.row_join(Matrix(B))\n1186:         True\n1187: \n1188:         Joining at row ends is the same as appending columns at the end\n1189:         of the matrix:\n1190: \n1191:         >>> C == A.col_insert(A.cols, B)\n1192:         True\n1193:         \"\"\"\n1194:         if not self:\n1195:             return type(self)(other)\n1196:         A, B = self, other\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/matrices/sparse.py",
      "suspect_lines": [
        988,
        989,
        1194,
        1195
      ]
    }
  ]
}