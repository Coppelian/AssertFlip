{
  "instance_id": "django__django-13158",
  "problem_statement": "QuerySet.none() on combined queries returns all results.\nDescription\n\t\nI came across this issue on Stack Overflow. I'm not 100% sure it's a bug, but it does seem strange. With this code (excuse the bizarre example filtering):\nclass Publication(models.Model):\n\tpass\nclass Article(models.Model):\n\tpublications = models.ManyToManyField(to=Publication, blank=True, null=True)\nclass ArticleForm(forms.ModelForm):\n\tpublications = forms.ModelMultipleChoiceField(\n\t\tPublication.objects.filter(id__lt=2) | Publication.objects.filter(id__gt=5),\n\t\trequired=False,\n\t)\n\tclass Meta:\n\t\tmodel = Article\n\t\tfields = [\"publications\"]\nclass ArticleAdmin(admin.ModelAdmin):\n\tform = ArticleForm\nThis works well. However, changing the ModelMultipleChoiceField queryset to use union() breaks things.\npublications = forms.ModelMultipleChoiceField(\n\tPublication.objects.filter(id__lt=2).union(\n\t\tPublication.objects.filter(id__gt=5)\n\t),\n\trequired=False,\n)\nThe form correctly shows only the matching objects. However, if you submit this form while empty (i.e. you didn't select any publications), ALL objects matching the queryset will be added. Using the OR query, NO objects are added, as I'd expect.\n",
  "localized_code": "[start of django/db/models/sql/query.py]\n1: \"\"\"\n2: Create SQL statements for QuerySets.\n3: \n4: The code in here encapsulates all of the SQL construction so that QuerySets\n5: themselves do not have to (and could be backed by things other than SQL\n6: databases). The abstraction barrier only works one way: this module has to know\n7: all about the internals of models in order to get the information it needs.\n8: \"\"\"\n9: import copy\n10: import difflib\n11: import functools\n12: import inspect\n13: import sys\n14: import warnings\n15: from collections import Counter, namedtuple\n16: from collections.abc import Iterator, Mapping\n17: from itertools import chain, count, product\n18: from string import ascii_uppercase\n19: \n20: from django.core.exceptions import (\n21:     EmptyResultSet, FieldDoesNotExist, FieldError,\n22: )\n23: from django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\n24: from django.db.models.aggregates import Count\n25: from django.db.models.constants import LOOKUP_SEP\n26: from django.db.models.expressions import BaseExpression, Col, F, OuterRef, Ref\n27: from django.db.models.fields import Field\n28: from django.db.models.fields.related_lookups import MultiColSource\n29: from django.db.models.lookups import Lookup\n30: from django.db.models.query_utils import (\n31:     Q, check_rel_lookup_compatibility, refs_expression,\n32: )\n33: from django.db.models.sql.constants import INNER, LOUTER, ORDER_DIR, SINGLE\n34: from django.db.models.sql.datastructures import (\n35:     BaseTable, Empty, Join, MultiJoin,\n36: )\n37: from django.db.models.sql.where import (\n38:     AND, OR, ExtraWhere, NothingNode, WhereNode,\n39: )\n40: from django.utils.deprecation import RemovedInDjango40Warning\n41: from django.utils.functional import cached_property\n42: from django.utils.tree import Node\n43: \n44: __all__ = ['Query', 'RawQuery']\n45: \n46: \n47: def get_field_names_from_opts(opts):\n48:     return set(chain.from_iterable(\n49:         (f.name, f.attname) if f.concrete else (f.name,)\n50:         for f in opts.get_fields()\n51:     ))\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/sql/query.py",
      "suspect_lines": []
    }
  ]
}