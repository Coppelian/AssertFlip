{
  "instance_id": "sympy__sympy-21930",
  "problem_statement": "Issues with Latex printing output in second quantization module\nThere are Latex rendering problems within the \"secondquant\" module, as it does not correctly interpret double superscripts containing the \"dagger\" command within Jupyter Notebook.\r\n\r\nLet's see a minimal example\r\n\r\n```\r\nIn [1]: import sympy as sp\r\n        from sympy.physics.secondquant import B, Bd, Commutator\r\n        sp.init_printing()\r\n\r\nIn [2]: a = sp.Symbol('0')\r\n\r\nIn [3]: Commutator(Bd(a)**2, B(a))\r\nOut[3]: \\displaystyle - \\left[b_{0},b^\\dagger_{0}^{2}\\right]\r\n```\r\nSo, it doesn't render correctly, and that's because the double superscript `\"b^\\dagger_{0}^{2}\"`. It should be correct by adding curly brackets `\"{b^\\dagger_{0}}^{2}\"`\n",
  "localized_code": "[start of sympy/physics/secondquant.py]\n1: \"\"\"\n2: Second quantization operators and states for bosons.\n3: \n4: This follow the formulation of Fetter and Welecka, \"Quantum Theory\n5: of Many-Particle Systems.\"\n6: \"\"\"\n7: from collections import defaultdict\n8: \n9: from sympy import (Add, Basic, cacheit, Dummy, Expr, Function, I,\n10:                    KroneckerDelta, Mul, Pow, S, sqrt, Symbol, sympify, Tuple,\n11:                    zeros)\n12: from sympy.printing.str import StrPrinter\n13: from sympy.utilities.iterables import has_dups\n14: from sympy.utilities import default_sort_key\n15: \n16: __all__ = [\n17:     'Dagger',\n18:     'KroneckerDelta',\n19:     'BosonicOperator',\n20:     'AnnihilateBoson',\n21:     'CreateBoson',\n22:     'AnnihilateFermion',\n23:     'CreateFermion',\n24:     'FockState',\n25:     'FockStateBra',\n26:     'FockStateKet',\n27:     'FockStateBosonKet',\n28:     'FockStateBosonBra',\n29:     'FockStateFermionKet',\n30:     'FockStateFermionBra',\n31:     'BBra',\n32:     'BKet',\n33:     'FBra',\n34:     'FKet',\n35:     'F',\n36:     'Fd',\n37:     'B',\n38:     'Bd',\n39:     'apply_operators',\n40:     'InnerProduct',\n41:     'BosonicBasis',\n42:     'VarBosonicBasis',\n43:     'FixedBosonicBasis',\n44:     'Commutator',\n45:     'matrix_rep',\n46:     'contraction',\n47:     'wicks',\n48:     'NO',\n49:     'evaluate_deltas',\n50:     'AntiSymmetricTensor',\n51:     'substitute_dummies',\n52:     'PermutationOperator',\n53:     'simplify_index_permutations',\n54: ]\n55: \n56: \n57: class SecondQuantizationError(Exception):\n58:     pass\n59: \n60: \n61: class AppliesOnlyToSymbolicIndex(SecondQuantizationError):\n62:     pass\n63: \n64: \n65: class ContractionAppliesOnlyToFermions(SecondQuantizationError):\n66:     pass\n67: \n68: \n69: class ViolationOfPauliPrinciple(SecondQuantizationError):\n70:     pass\n71: \n72: \n73: class SubstitutionOfAmbigousOperatorFailed(SecondQuantizationError):\n74:     pass\n75: \n76: \n77: class WicksTheoremDoesNotApply(SecondQuantizationError):\n78:     pass\n79: \n80: \n81: class Dagger(Expr):\nCode replaced for brevity.\n145: \n146: \n147: \n148: class TensorSymbol(Expr):\n149: \n150:     is_commutative = True\n151: \n152: \n153: class AntiSymmetricTensor(TensorSymbol):\n154:     \"\"\"Stores upper and lower indices in separate Tuple's.\n155: \n156:     Each group of indices is assumed to be antisymmetric.\n157: \n158:     Examples\n159:     ========\n160: \n161:     >>> from sympy import symbols\n162:     >>> from sympy.physics.secondquant import AntiSymmetricTensor\n163:     >>> i, j = symbols('i j', below_fermi=True)\n164:     >>> a, b = symbols('a b', above_fermi=True)\n165:     >>> AntiSymmetricTensor('v', (a, i), (b, j))\n166:     AntiSymmetricTensor(v, (a, i), (b, j))\n167:     >>> AntiSymmetricTensor('v', (i, a), (b, j))\n168:     -AntiSymmetricTensor(v, (a, i), (b, j))\n169: \n170:     As you can see, the indices are automatically sorted to a canonical form.\n171: \n172:     \"\"\"\n173: \n174:     def __new__(cls, symbol, upper, lower):\n175: \n176:         try:\n177:             upper, signu = _sort_anticommuting_fermions(\n178:                 upper, key=cls._sortkey)\n179:             lower, signl = _sort_anticommuting_fermions(\n180:                 lower, key=cls._sortkey)\n181: \n182:         except ViolationOfPauliPrinciple:\n183:             return S.Zero\n184: \n185:         symbol = sympify(symbol)\n186:         upper = Tuple(*upper)\n187:         lower = Tuple(*lower)\n188: \n189:         if (signu + signl) % 2:\n190:             return -TensorSymbol.__new__(cls, symbol, upper, lower)\n191:         else:\n192: \n193:             return TensorSymbol.__new__(cls, symbol, upper, lower)\n194: \n195:     @classmethod\n196:     def _sortkey(cls, index):\n197:         \"\"\"Key for sorting of indices.\n198: \n199:         particle < hole < general\n200: \n201:         FIXME: This is a bottle-neck, can we do it faster?\n202:         \"\"\"\n203:         h = hash(index)\n204:         label = str(index)\n205:         if isinstance(index, Dummy):\n206:             if index.assumptions0.get('above_fermi'):\n207:                 return (20, label, h)\n208:             elif index.assumptions0.get('below_fermi'):\n209:                 return (21, label, h)\n210:             else:\n211:                 return (22, label, h)\n212: \n213:         if index.assumptions0.get('above_fermi'):\n214:             return (10, label, h)\n215:         elif index.assumptions0.get('below_fermi'):\n216:             return (11, label, h)\n217:         else:\n218:             return (12, label, h)\n219: \n220:     def _latex(self, printer):\n221:         return \"%s^{%s}_{%s}\" % (\n222:             self.symbol,\n223:             \"\".join([ i.name for i in self.args[1]]),\n224:             \"\".join([ i.name for i in self.args[2]])\n225:         )\n226: \n227:     @property\n228:     def symbol(self):\n229:         \"\"\"\n230:         Returns the symbol of the tensor.\n231: \n232:         Examples\n233:         ========\n234: \n235:         >>> from sympy import symbols\n236:         >>> from sympy.physics.secondquant import AntiSymmetricTensor\n237:         >>> i, j = symbols('i,j', below_fermi=True)\n238:         >>> a, b = symbols('a,b', above_fermi=True)\n239:         >>> AntiSymmetricTensor('v', (a, i), (b, j))\n240:         AntiSymmetricTensor(v, (a, i), (b, j))\n241:         >>> AntiSymmetricTensor('v', (a, i), (b, j)).symbol\n242:         v\n243: \n244:         \"\"\"\n245:         return self.args[0]\n246: \n247:     @property\n248:     def upper(self):\n249:         \"\"\"\n250:         Returns the upper indices.\n251: \n252:         Examples\n253:         ========\n254: \n255:         >>> from sympy import symbols\n256:         >>> from sympy.physics.secondquant import AntiSymmetricTensor\n257:         >>> i, j = symbols('i,j', below_fermi=True)\n258:         >>> a, b = symbols('a,b', above_fermi=True)\n259:         >>> AntiSymmetricTensor('v', (a, i), (b, j))\n260:         AntiSymmetricTensor(v, (a, i), (b, j))\n261:         >>> AntiSymmetricTensor('v', (a, i), (b, j)).upper\n262:         (a, i)\n263: \n264: \n265:         \"\"\"\n266:         return self.args[1]\n267: \n268:     @property\n269:     def lower(self):\n270:         \"\"\"\n271:         Returns the lower indices.\n272: \n273:         Examples\n274:         ========\n275: \n276:         >>> from sympy import symbols\n277:         >>> from sympy.physics.secondquant import AntiSymmetricTensor\n278:         >>> i, j = symbols('i,j', below_fermi=True)\n279:         >>> a, b = symbols('a,b', above_fermi=True)\n280:         >>> AntiSymmetricTensor('v', (a, i), (b, j))\n281:         AntiSymmetricTensor(v, (a, i), (b, j))\n282:         >>> AntiSymmetricTensor('v', (a, i), (b, j)).lower\n283:         (b, j)\n284: \n285:         \"\"\"\n286:         return self.args[2]\n287: \n288:     def __str__(self):\n289:         return \"%s(%s,%s)\" % self.args\n290: \n291:     def doit(self, **kw_args):\n292:         \"\"\"\n293:         Returns self.\n294: \n295:         Examples\n296:         ========\n297: \n298:         >>> from sympy import symbols\n299:         >>> from sympy.physics.secondquant import AntiSymmetricTensor\n300:         >>> i, j = symbols('i,j', below_fermi=True)\n301:         >>> a, b = symbols('a,b', above_fermi=True)\n302:         >>> AntiSymmetricTensor('v', (a, i), (b, j)).doit()\n303:         AntiSymmetricTensor(v, (a, i), (b, j))\n304:         \"\"\"\n305:         return self\n306: \n307: \n308: class SqOperator(Expr):\nCode replaced for brevity.\n382: \n383: \n384: \n385: class BosonicOperator(SqOperator):\n386:     pass\n387: \n388: \n389: class Annihilator(SqOperator):\n390:     pass\n391: \n392: \n393: class Creator(SqOperator):\n394:     pass\n395: \n396: \n397: class AnnihilateBoson(BosonicOperator, Annihilator):\nCode replaced for brevity.\n442: \n443: \n444: \n445: class CreateBoson(BosonicOperator, Creator):\n446:     \"\"\"\n447:     Bosonic creation operator.\n448:     \"\"\"\n449: \n450:     op_symbol = 'b+'\n451: \n452:     def _dagger_(self):\n453:         return AnnihilateBoson(self.state)\n454: \n455:     def apply_operator(self, state):\n456:         \"\"\"\n457:         Apply state to self if self is not symbolic and state is a FockStateKet, else\n458:         multiply self by state.\n459: \n460:         Examples\n461:         ========\n462: \n463:         >>> from sympy.physics.secondquant import B, Dagger, BKet\n464:         >>> from sympy.abc import x, y, n\n465:         >>> Dagger(B(x)).apply_operator(y)\n466:         y*CreateBoson(x)\n467:         >>> B(0).apply_operator(BKet((n,)))\n468:         sqrt(n)*FockStateBosonKet((n - 1,))\n469:         \"\"\"\n470:         if not self.is_symbolic and isinstance(state, FockStateKet):\n471:             element = self.state\n472:             amp = sqrt(state[element] + 1)\n473:             return amp*state.up(element)\n474:         else:\n475:             return Mul(self, state)\n476: \n477:     def __repr__(self):\n478:         return \"CreateBoson(%s)\" % self.state\n479: \n480:     def _latex(self, printer):\n481:         return \"b^\\\\dagger_{%s}\" % self.state.name\n482: \n483: B = AnnihilateBoson\n484: Bd = CreateBoson\n485: \n486: \n487: class FermionicOperator(SqOperator):\nCode replaced for brevity.\n647: \n648: \n649: \n650: class AnnihilateFermion(FermionicOperator, Annihilator):\nCode replaced for brevity.\n796: \n797: \n798: \n799: class CreateFermion(FermionicOperator, Creator):\n800:     \"\"\"\n801:     Fermionic creation operator.\n802:     \"\"\"\n803: \n804:     op_symbol = 'f+'\n805: \n806:     def _dagger_(self):\n807:         return AnnihilateFermion(self.state)\n808: \n809:     def apply_operator(self, state):\n810:         \"\"\"\n811:         Apply state to self if self is not symbolic and state is a FockStateKet, else\n812:         multiply self by state.\n813: \n814:         Examples\n815:         ========\n816: \n817:         >>> from sympy.physics.secondquant import B, Dagger, BKet\n818:         >>> from sympy.abc import x, y, n\n819:         >>> Dagger(B(x)).apply_operator(y)\n820:         y*CreateBoson(x)\n821:         >>> B(0).apply_operator(BKet((n,)))\n822:         sqrt(n)*FockStateBosonKet((n - 1,))\n823:         \"\"\"\n824:         if isinstance(state, FockStateFermionKet):\n825:             element = self.state\n826:             return state.up(element)\n827: \n828:         elif isinstance(state, Mul):\n829:             c_part, nc_part = state.args_cnc()\n830:             if isinstance(nc_part[0], FockStateFermionKet):\n831:                 element = self.state\n832:                 return Mul(*(c_part + [nc_part[0].up(element)] + nc_part[1:]))\n833: \n834:         return Mul(self, state)\n835: \n836:     @property\n837:     def is_q_creator(self):\n838:         \"\"\"\n839:         Can we create a quasi-particle?  (create hole or create particle)\n840:         If so, would that be above or below the fermi surface?\n841: \n842:         Examples\n843:         ========\n844: \n845:         >>> from sympy import Symbol\n846:         >>> from sympy.physics.secondquant import Fd\n847:         >>> a = Symbol('a', above_fermi=True)\n848:         >>> i = Symbol('i', below_fermi=True)\n849:         >>> p = Symbol('p')\n850: \n851:         >>> Fd(a).is_q_creator\n852:         1\n853:         >>> Fd(i).is_q_creator\n854:         0\n855:         >>> Fd(p).is_q_creator\n856:         1\n857: \n858:         \"\"\"\n859:         if self.is_above_fermi:\n860:             return 1\n861:         return 0\n862: \n863:     @property\n864:     def is_q_annihilator(self):\n865:         \"\"\"\n866:         Can we destroy a quasi-particle?  (annihilate hole or annihilate particle)\n867:         If so, would that be above or below the fermi surface?\n868: \n869:         Examples\n870:         ========\n871: \n872:         >>> from sympy import Symbol\n873:         >>> from sympy.physics.secondquant import Fd\n874:         >>> a = Symbol('a', above_fermi=1)\n875:         >>> i = Symbol('i', below_fermi=1)\n876:         >>> p = Symbol('p')\n877: \n878:         >>> Fd(a).is_q_annihilator\n879:         0\n880:         >>> Fd(i).is_q_annihilator\n881:         -1\n882:         >>> Fd(p).is_q_annihilator\n883:         -1\n884: \n885:         \"\"\"\n886:         if self.is_below_fermi:\n887:             return -1\n888:         return 0\n889: \n890:     @property\n891:     def is_only_q_creator(self):\n892:         \"\"\"\n893:         Always create a quasi-particle?  (create hole or create particle)\n894: \n895:         Examples\n896:         ========\n897: \n898:         >>> from sympy import Symbol\n899:         >>> from sympy.physics.secondquant import Fd\n900:         >>> a = Symbol('a', above_fermi=True)\n901:         >>> i = Symbol('i', below_fermi=True)\n902:         >>> p = Symbol('p')\n903: \n904:         >>> Fd(a).is_only_q_creator\n905:         True\n906:         >>> Fd(i).is_only_q_creator\n907:         False\n908:         >>> Fd(p).is_only_q_creator\n909:         False\n910: \n911:         \"\"\"\n912:         return self.is_only_above_fermi\n913: \n914:     @property\n915:     def is_only_q_annihilator(self):\n916:         \"\"\"\n917:         Always destroy a quasi-particle?  (annihilate hole or annihilate particle)\n918: \n919:         Examples\n920:         ========\n921: \n922:         >>> from sympy import Symbol\n923:         >>> from sympy.physics.secondquant import Fd\n924:         >>> a = Symbol('a', above_fermi=True)\n925:         >>> i = Symbol('i', below_fermi=True)\n926:         >>> p = Symbol('p')\n927: \n928:         >>> Fd(a).is_only_q_annihilator\n929:         False\n930:         >>> Fd(i).is_only_q_annihilator\n931:         True\n932:         >>> Fd(p).is_only_q_annihilator\n933:         False\n934: \n935:         \"\"\"\n936:         return self.is_only_below_fermi\n937: \n938:     def __repr__(self):\n939:         return \"CreateFermion(%s)\" % self.state\n940: \n941:     def _latex(self, printer):\n942:         return \"a^\\\\dagger_{%s}\" % self.state.name\n943: \n944: Fd = CreateFermion\n945: F = AnnihilateFermion\n946: \n947: \n948: class FockState(Expr):\nCode replaced for brevity.\n988: \n989: \n990: \n991: class BosonState(FockState):\nCode replaced for brevity.\n1035: \n1036: \n1037: \n1038: class FermionState(FockState):\nCode replaced for brevity.\n1236: \n1237: \n1238: \n1239: class FockStateKet(FockState):\nCode replaced for brevity.\n1244: \n1245: \n1246: \n1247: class FockStateBra(FockState):\nCode replaced for brevity.\n1258: \n1259: \n1260: \n1261: class FockStateBosonKet(BosonState, FockStateKet):\nCode replaced for brevity.\n1275: \n1276: \n1277: \n1278: class FockStateBosonBra(BosonState, FockStateBra):\nCode replaced for brevity.\n1290: \n1291: \n1292: \n1293: class FockStateFermionKet(FermionState, FockStateKet):\nCode replaced for brevity.\n1317: \n1318: \n1319: \n1320: class FockStateFermionBra(FermionState, FockStateBra):\nCode replaced for brevity.\n1335: \n1336: \n1337: BBra = FockStateBosonBra\n1338: BKet = FockStateBosonKet\n1339: FBra = FockStateFermionBra\n1340: FKet = FockStateFermionKet\n1341: \n1342: \n1343: def _apply_Mul(m):\nCode replaced for brevity.\n1405: \n1406: \n1407: \n1408: def apply_operators(e):\nCode replaced for brevity.\n1423: \n1424: \n1425: \n1426: class InnerProduct(Basic):\nCode replaced for brevity.\n1473: \n1474: \n1475: \n1476: def matrix_rep(op, basis):\nCode replaced for brevity.\n1498: \n1499: \n1500: \n1501: class BosonicBasis:\nCode replaced for brevity.\n1505: \n1506: \n1507: \n1508: class VarBosonicBasis:\nCode replaced for brevity.\n1572: \n1573: \n1574: \n1575: class FixedBosonicBasis(BosonicBasis):\nCode replaced for brevity.\n1654: \n1655: \n1656: \n1657: class Commutator(Function):\nCode replaced for brevity.\n1802: \n1803: \n1804: \n1805: class NO(Expr):\nCode replaced for brevity.\n2143: \n2144: \n2145: \n2146: def contraction(a, b):\nCode replaced for brevity.\n2215: \n2216: \n2217: \n2218: def _sqkey(sq_operator):\nCode replaced for brevity.\n2220: \n2221: \n2222: \n2223: def _sort_anticommuting_fermions(string1, key=_sqkey):\nCode replaced for brevity.\n2276: \n2277: \n2278: \n2279: def evaluate_deltas(e):\nCode replaced for brevity.\n2387: \n2388: \n2389: \n2390: def substitute_dummies(expr, new_indices=False, pretty_indices={}):\nCode replaced for brevity.\n2555: \n2556: \n2557: \n2558: class KeyPrinter(StrPrinter):\nCode replaced for brevity.\n2561: \n2562: \n2563: \n2564: def __kprint(expr):\n2565:     p = KeyPrinter()\n2566:     return p.doprint(expr)\n2567: \n2568: \n2569: def _get_ordered_dummies(mul, verbose=False):\nCode replaced for brevity.\n2713: \n2714: \n2715: \n2716:     # break recursion if there are no ordered dummies\nCode replaced for brevity.\n2770: \n2771: \n2772: \n2773: class _SymbolFactory:\nCode replaced for brevity.\n2797: _symbol_factory = _SymbolFactory('_]\"]_')  # most certainly a unique label\n2798: _symbol_factory = _SymbolFactory('_]\"]_')  # most certainly a unique label\n2799: \n2800: \n2801: @cacheit\n2802: def _get_contractions(string1, keep_only_fully_contracted=False):\nCode replaced for brevity.\n2859: \n2860: \n2861: \n2862: def wicks(e, **kw_args):\nCode replaced for brevity.\n2970: \n2971: \n2972: \n2973: class PermutationOperator(Expr):\nCode replaced for brevity.\n3013: \n3014: \n3015: \n3016: def simplify_index_permutations(expr, permutation_operators):\nCode replaced for brevity.\n3106: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/physics/secondquant.py",
      "suspect_lines": [
        221,
        481,
        942
      ]
    }
  ]
}