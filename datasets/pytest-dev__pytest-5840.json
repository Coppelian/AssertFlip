{
  "instance_id": "pytest-dev__pytest-5840",
  "problem_statement": "5.1.2 ImportError while loading conftest (windows import folder casing issues)\n5.1.1 works fine. after upgrade to 5.1.2, the path was converted to lower case\r\n```\r\nInstalling collected packages: pytest\r\n  Found existing installation: pytest 5.1.1\r\n    Uninstalling pytest-5.1.1:\r\n      Successfully uninstalled pytest-5.1.1\r\nSuccessfully installed pytest-5.1.2\r\nPS C:\\Azure\\KMS\\ComponentTest\\Python> pytest --collect-only .\\PIsys -m smoke\r\nImportError while loading conftest 'c:\\azure\\kms\\componenttest\\python\\pisys\\conftest.py'.\r\nModuleNotFoundError: No module named 'python'\r\nPS C:\\Azure\\KMS\\ComponentTest\\Python>\r\n```\r\n\r\n\n",
  "localized_code": "[start of src/_pytest/config/__init__.py]\n1: \"\"\" command line options, ini-file and conftest.py processing. \"\"\"\n2: import argparse\n3: import copy\n4: import inspect\n5: import os\n6: import shlex\n7: import sys\n8: import types\n9: import warnings\n10: from functools import lru_cache\n11: from pathlib import Path\n12: \n13: import attr\n14: import py\n15: from packaging.version import Version\n16: from pluggy import HookimplMarker\n17: from pluggy import HookspecMarker\n18: from pluggy import PluginManager\n19: \n20: import _pytest._code\n21: import _pytest.assertion\n22: import _pytest.deprecated\n23: import _pytest.hookspec  # the extension point definitions\n24: from .exceptions import PrintHelp\n25: from .exceptions import UsageError\n26: from .findpaths import determine_setup\n27: from .findpaths import exists\n28: from _pytest._code import ExceptionInfo\n29: from _pytest._code import filter_traceback\n30: from _pytest.compat import importlib_metadata\n31: from _pytest.outcomes import fail\n32: from _pytest.outcomes import Skipped\n33: from _pytest.pathlib import unique_path\n34: from _pytest.warning_types import PytestConfigWarning\n35: \n36: hookimpl = HookimplMarker(\"pytest\")\n37: hookspec = HookspecMarker(\"pytest\")\n38: \n39: \n40: class ConftestImportFailure(Exception):\n41:     def __init__(self, path, excinfo):\n42:         Exception.__init__(self, path, excinfo)\n43:         self.path = path\n44:         self.excinfo = excinfo\n45: \n46: \n47: def main(args=None, plugins=None):\n48:     \"\"\" return exit code, after performing an in-process test run.\n49: \n50:     :arg args: list of command line arguments.\n51: \n52:     :arg plugins: list of plugin objects to be auto-registered during\n53:                   initialization.\n54:     \"\"\"\n55:     from _pytest.main import ExitCode\n56: \n57:     try:\n58:         try:\n59:             config = _prepareconfig(args, plugins)\n60:         except ConftestImportFailure as e:\n61:             exc_info = ExceptionInfo(e.excinfo)\n62:             tw = py.io.TerminalWriter(sys.stderr)\n63:             tw.line(\n64:                 \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n65:             )\n66:             exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n67:             exc_repr = (\n68:                 exc_info.getrepr(style=\"short\", chain=False)\n69:                 if exc_info.traceback\n70:                 else exc_info.exconly()\n71:             )\n72:             formatted_tb = str(exc_repr)\n73:             for line in formatted_tb.splitlines():\n74:                 tw.line(line.rstrip(), red=True)\n75:             return 4\n76:         else:\n77:             try:\n78:                 return config.hook.pytest_cmdline_main(config=config)\n79:             finally:\n80:                 config._ensure_unconfigure()\n81:     except UsageError as e:\n82:         tw = py.io.TerminalWriter(sys.stderr)\n83:         for msg in e.args:\n84:             tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n85:         return ExitCode.USAGE_ERROR\n86: \n87: \n88: class cmdline:  # compatibility namespace\n89:     main = staticmethod(main)\n90: \n91: \n92: def filename_arg(path, optname):\nCode replaced for brevity.\n100: \n101: \n102: \n103: def directory_arg(path, optname):\nCode replaced for brevity.\n111: \n112: \n113: \n114: # Plugins that cannot be disabled via \"-p no:X\" currently.\n115: essential_plugins = (  # fmt: off\n116:     \"mark\",\n117:     \"main\",\n118:     \"runner\",\n119:     \"fixtures\",\n120:     \"helpconfig\",  # Provides -p.\n121: )  # fmt: on\n122: \n123: default_plugins = essential_plugins + (\n124:     \"python\",\n125:     \"terminal\",\n126:     \"debugging\",\n127:     \"unittest\",\n128:     \"capture\",\n129:     \"skipping\",\n130:     \"tmpdir\",\n131:     \"monkeypatch\",\n132:     \"recwarn\",\n133:     \"pastebin\",\n134:     \"nose\",\n135:     \"assertion\",\n136:     \"junitxml\",\n137:     \"resultlog\",\n138:     \"doctest\",\n139:     \"cacheprovider\",\n140:     \"freeze_support\",\n141:     \"setuponly\",\n142:     \"setupplan\",\n143:     \"stepwise\",\n144:     \"warnings\",\n145:     \"logging\",\n146:     \"reports\",\n147:     \"faulthandler\",\n148: )\n149: \n150: builtin_plugins = set(default_plugins)\n151: builtin_plugins.add(\"pytester\")\n152: \n153: \n154:     # subsequent calls to main will create a fresh instance\nCode replaced for brevity.\n170: \n171: \n172: \n173: def get_plugin_manager():\nCode replaced for brevity.\n182: \n183: \n184: \n185: def _prepareconfig(args=None, plugins=None):\nCode replaced for brevity.\n213: \n214: \n215: \n216: def _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\nCode replaced for brevity.\n226: \n227: \n228: \n229: class PytestPluginManager(PluginManager):\n230:     \"\"\"\n231:     Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n232:     functionality:\n233: \n234:     * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n235:       ``pytest_plugins`` global variables found in plugins being loaded;\n236:     * ``conftest.py`` loading during start-up;\n237:     \"\"\"\n238: \n239:     def __init__(self):\n240:         super().__init__(\"pytest\")\n241:         self._conftest_plugins = set()\n242: \n243:         # state related to local conftest plugins\n244:         self._dirpath2confmods = {}\n245:         self._conftestpath2mod = {}\n246:         self._confcutdir = None\n247:         self._noconftest = False\n248:         self._duplicatepaths = set()\n249: \n250:         self.add_hookspecs(_pytest.hookspec)\n251:         self.register(self)\n252:         if os.environ.get(\"PYTEST_DEBUG\"):\n253:             err = sys.stderr\n254:             encoding = getattr(err, \"encoding\", \"utf8\")\n255:             try:\n256:                 err = py.io.dupfile(err, encoding=encoding)\n257:             except Exception:\n258:                 pass\n259:             self.trace.root.setwriter(err.write)\n260:             self.enable_tracing()\n261: \n262:         # Config._consider_importhook will set a real object if required.\n263:         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n264:         # Used to know when we are importing conftests after the pytest_configure stage\n265:         self._configured = False\n266: \n267:     def parse_hookimpl_opts(self, plugin, name):\n268:         # pytest hooks are always prefixed with pytest_\n269:         # so we avoid accessing possibly non-readable attributes\n270:         # (see issue #1073)\n271:         if not name.startswith(\"pytest_\"):\n272:             return\n273:         # ignore names which can not be hooks\n274:         if name == \"pytest_plugins\":\n275:             return\n276: \n277:         method = getattr(plugin, name)\n278:         opts = super().parse_hookimpl_opts(plugin, name)\n279: \n280:         # consider only actual functions for hooks (#3775)\n281:         if not inspect.isroutine(method):\n282:             return\n283: \n284:         # collect unmarked hooks as long as they have the `pytest_' prefix\n285:         if opts is None and name.startswith(\"pytest_\"):\n286:             opts = {}\n287:         if opts is not None:\n288:             # TODO: DeprecationWarning, people should use hookimpl\n289:             # https://github.com/pytest-dev/pytest/issues/4562\n290:             known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n291: \n292:             for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n293:                 opts.setdefault(name, hasattr(method, name) or name in known_marks)\n294:         return opts\n295: \n296:     def parse_hookspec_opts(self, module_or_class, name):\n297:         opts = super().parse_hookspec_opts(module_or_class, name)\n298:         if opts is None:\n299:             method = getattr(module_or_class, name)\n300: \n301:             if name.startswith(\"pytest_\"):\n302:                 # todo: deprecate hookspec hacks\n303:                 # https://github.com/pytest-dev/pytest/issues/4562\n304:                 known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n305:                 opts = {\n306:                     \"firstresult\": hasattr(method, \"firstresult\")\n307:                     or \"firstresult\" in known_marks,\n308:                     \"historic\": hasattr(method, \"historic\")\n309:                     or \"historic\" in known_marks,\n310:                 }\n311:         return opts\n312: \n313:     def register(self, plugin, name=None):\n314:         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n315:             warnings.warn(\n316:                 PytestConfigWarning(\n317:                     \"{} plugin has been merged into the core, \"\n318:                     \"please remove it from your requirements.\".format(\n319:                         name.replace(\"_\", \"-\")\n320:                     )\n321:                 )\n322:             )\n323:             return\n324:         ret = super().register(plugin, name)\n325:         if ret:\n326:             self.hook.pytest_plugin_registered.call_historic(\n327:                 kwargs=dict(plugin=plugin, manager=self)\n328:             )\n329: \n330:             if isinstance(plugin, types.ModuleType):\n331:                 self.consider_module(plugin)\n332:         return ret\n333: \n334:     def getplugin(self, name):\n335:         # support deprecated naming because plugins (xdist e.g.) use it\n336:         return self.get_plugin(name)\n337: \n338:     def hasplugin(self, name):\n339:         \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n340:         return bool(self.get_plugin(name))\n341: \n342:     def pytest_configure(self, config):\n343:         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n344:         # we should remove tryfirst/trylast as markers\n345:         config.addinivalue_line(\n346:             \"markers\",\n347:             \"tryfirst: mark a hook implementation function such that the \"\n348:             \"plugin machinery will try to call it first/as early as possible.\",\n349:         )\n350:         config.addinivalue_line(\n351:             \"markers\",\n352:             \"trylast: mark a hook implementation function such that the \"\n353:             \"plugin machinery will try to call it last/as late as possible.\",\n354:         )\n355:         self._configured = True\n356: \n357:     #\n358:     # internal API for local conftest plugin handling\n359:     #\n360:     def _set_initial_conftests(self, namespace):\n361:         \"\"\" load initial conftest files given a preparsed \"namespace\".\n362:             As conftest files may add their own command line options\n363:             which have arguments ('--my-opt somepath') we might get some\n364:             false positives.  All builtin and 3rd party plugins will have\n365:             been loaded, however, so common options will not confuse our logic\n366:             here.\n367:         \"\"\"\n368:         current = py.path.local()\n369:         self._confcutdir = (\n370:             unique_path(current.join(namespace.confcutdir, abs=True))\n371:             if namespace.confcutdir\n372:             else None\n373:         )\n374:         self._noconftest = namespace.noconftest\n375:         self._using_pyargs = namespace.pyargs\n376:         testpaths = namespace.file_or_dir\n377:         foundanchor = False\n378:         for path in testpaths:\n379:             path = str(path)\n380:             # remove node-id syntax\n381:             i = path.find(\"::\")\n382:             if i != -1:\n383:                 path = path[:i]\n384:             anchor = current.join(path, abs=1)\n385:             if exists(anchor):  # we found some file object\n386:                 self._try_load_conftest(anchor)\n387:                 foundanchor = True\n388:         if not foundanchor:\n389:             self._try_load_conftest(current)\n390: \n391:     def _try_load_conftest(self, anchor):\n392:         self._getconftestmodules(anchor)\n393:         # let's also consider test* subdirs\n394:         if anchor.check(dir=1):\n395:             for x in anchor.listdir(\"test*\"):\n396:                 if x.check(dir=1):\n397:                     self._getconftestmodules(x)\n398: \n399:     @lru_cache(maxsize=128)\n400:     def _getconftestmodules(self, path):\n401:         if self._noconftest:\n402:             return []\n403: \n404:         if path.isfile():\n405:             directory = path.dirpath()\n406:         else:\n407:             directory = path\n408: \n409:         directory = unique_path(directory)\n410: \n411:         # XXX these days we may rather want to use config.rootdir\n412:         # and allow users to opt into looking into the rootdir parent\n413:         # directories instead of requiring to specify confcutdir\n414:         clist = []\n415:         for parent in directory.parts():\n416:             if self._confcutdir and self._confcutdir.relto(parent):\n417:                 continue\n418:             conftestpath = parent.join(\"conftest.py\")\n419:             if conftestpath.isfile():\n420:                 mod = self._importconftest(conftestpath)\n421:                 clist.append(mod)\n422:         self._dirpath2confmods[directory] = clist\n423:         return clist\n424: \n425:     def _rget_with_confmod(self, name, path):\n426:         modules = self._getconftestmodules(path)\n427:         for mod in reversed(modules):\n428:             try:\n429:                 return mod, getattr(mod, name)\n430:             except AttributeError:\n431:                 continue\n432:         raise KeyError(name)\n433: \n434:     def _importconftest(self, conftestpath):\n435:         # Use realpath to avoid loading the same conftest twice\n436:         # with build systems that create build directories containing\n437:         # symlinks to actual files.\n438:         conftestpath = unique_path(conftestpath)\n439:         try:\n440:             return self._conftestpath2mod[conftestpath]\n441:         except KeyError:\n442:             pkgpath = conftestpath.pypkgpath()\n443:             if pkgpath is None:\n444:                 _ensure_removed_sysmodule(conftestpath.purebasename)\n445:             try:\n446:                 mod = conftestpath.pyimport()\n447:                 if (\n448:                     hasattr(mod, \"pytest_plugins\")\n449:                     and self._configured\n450:                     and not self._using_pyargs\n451:                 ):\n452:                     _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n453:             except Exception:\n454:                 raise ConftestImportFailure(conftestpath, sys.exc_info())\n455: \n456:             self._conftest_plugins.add(mod)\n457:             self._conftestpath2mod[conftestpath] = mod\n458:             dirpath = conftestpath.dirpath()\n459:             if dirpath in self._dirpath2confmods:\n460:                 for path, mods in self._dirpath2confmods.items():\n461:                     if path and path.relto(dirpath) or path == dirpath:\n462:                         assert mod not in mods\n463:                         mods.append(mod)\n464:             self.trace(\"loaded conftestmodule %r\" % (mod))\n465:             self.consider_conftest(mod)\n466:             return mod\n467: \n468:     #\n469:     # API for bootstrapping plugin loading\n470:     #\n471:     #\n472: \n473:     def consider_preparse(self, args):\n474:         i = 0\n475:         n = len(args)\n476:         while i < n:\n477:             opt = args[i]\n478:             i += 1\n479:             if isinstance(opt, str):\n480:                 if opt == \"-p\":\n481:                     try:\n482:                         parg = args[i]\n483:                     except IndexError:\n484:                         return\n485:                     i += 1\n486:                 elif opt.startswith(\"-p\"):\n487:                     parg = opt[2:]\n488:                 else:\n489:                     continue\n490:                 self.consider_pluginarg(parg)\n491: \n492:     def consider_pluginarg(self, arg):\n493:         if arg.startswith(\"no:\"):\n494:             name = arg[3:]\n495:             if name in essential_plugins:\n496:                 raise UsageError(\"plugin %s cannot be disabled\" % name)\n497: \n498:             # PR #4304 : remove stepwise if cacheprovider is blocked\n499:             if name == \"cacheprovider\":\n500:                 self.set_blocked(\"stepwise\")\n501:                 self.set_blocked(\"pytest_stepwise\")\n502: \n503:             self.set_blocked(name)\n504:             if not name.startswith(\"pytest_\"):\n505:                 self.set_blocked(\"pytest_\" + name)\n506:         else:\n507:             name = arg\n508:             # Unblock the plugin.  None indicates that it has been blocked.\n509:             # There is no interface with pluggy for this.\n510:             if self._name2plugin.get(name, -1) is None:\n511:                 del self._name2plugin[name]\n512:             if not name.startswith(\"pytest_\"):\n513:                 if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n514:                     del self._name2plugin[\"pytest_\" + name]\n515:             self.import_plugin(arg, consider_entry_points=True)\n516: \n517:     def consider_conftest(self, conftestmodule):\n518:         self.register(conftestmodule, name=conftestmodule.__file__)\n519: \n520:     def consider_env(self):\n521:         self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n522: \n523:     def consider_module(self, mod):\n524:         self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n525: \n... Code Truncated ...\n\n[start of src/_pytest/pathlib.py]\n1: import atexit\n2: import fnmatch\n3: import itertools\n4: import operator\n5: import os\n6: import shutil\n7: import sys\n8: import uuid\n9: import warnings\n10: from functools import partial\n11: from os.path import expanduser\n12: from os.path import expandvars\n13: from os.path import isabs\n14: from os.path import normcase\n15: from os.path import sep\n16: from posixpath import sep as posix_sep\n17: \n18: from _pytest.warning_types import PytestWarning\n19: \n20: if sys.version_info[:2] >= (3, 6):\n21:     from pathlib import Path, PurePath\n22: else:\n23:     from pathlib2 import Path, PurePath\n24: \n25: __all__ = [\"Path\", \"PurePath\"]\n26: \n27: \n28: LOCK_TIMEOUT = 60 * 60 * 3\n29: \n30: get_lock_path = operator.methodcaller(\"joinpath\", \".lock\")\n31: \n32: \n33: def ensure_reset_dir(path):\n34:     \"\"\"\n35:     ensures the given path is an empty directory\n36:     \"\"\"\n37:     if path.exists():\n38:         rm_rf(path)\n39:     path.mkdir()\n40: \n41: \n42: def on_rm_rf_error(func, path: str, exc, *, start_path):\n43:     \"\"\"Handles known read-only errors during rmtree.\"\"\"\n44:     excvalue = exc[1]\n45: \n46:     if not isinstance(excvalue, PermissionError):\n47:         warnings.warn(\n48:             PytestWarning(\"(rm_rf) error removing {}: {}\".format(path, excvalue))\n49:         )\n50:         return\n51: \n52:     if func not in (os.rmdir, os.remove, os.unlink):\n53:         warnings.warn(\n54:             PytestWarning(\"(rm_rf) error removing {}: {}\".format(path, excvalue))\n55:         )\n56:         return\n57: \n58:     # Chmod + retry.\n59:     import stat\n60: \n61:     def chmod_rw(p: str):\n62:         mode = os.stat(p).st_mode\n63:         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)\n64: \n65:     # For files, we need to recursively go upwards in the directories to\n66:     # ensure they all are also writable.\n67:     p = Path(path)\n68:     if p.is_file():\n69:         for parent in p.parents:\n70:             chmod_rw(str(parent))\n71:             # stop when we reach the original path passed to rm_rf\n72:             if parent == start_path:\n73:                 break\n74:     chmod_rw(str(path))\n75: \n76:     func(path)\n77: \n78: \n79: def rm_rf(path: Path):\nCode replaced for brevity.\n84: \n85: \n86: \n87: def find_prefixed(root, prefix):\nCode replaced for brevity.\n92: \n93: \n94: \n95: def extract_suffixes(iter, prefix):\nCode replaced for brevity.\n103: \n104: \n105: \n106: def find_suffixes(root, prefix):\nCode replaced for brevity.\n109: \n110: \n111: \n112: def parse_num(maybe_num):\nCode replaced for brevity.\n117: \n118: \n119: \n120: def _force_symlink(root, target, link_to):\nCode replaced for brevity.\n137: \n138: \n139: \n140: def make_numbered_dir(root, prefix):\nCode replaced for brevity.\n158: \n159: \n160: \n161: def create_cleanup_lock(p):\nCode replaced for brevity.\n175: \n176: \n177: \n178: def register_cleanup_lock_removal(lock_path, register=atexit.register):\nCode replaced for brevity.\n192: \n193: \n194: \n195: def maybe_delete_a_numbered_dir(path):\nCode replaced for brevity.\n218: \n219: \n220: \n221: def ensure_deletable(path, consider_lock_dead_if_created_before):\nCode replaced for brevity.\n237: \n238: \n239: \n240: def try_cleanup(path, consider_lock_dead_if_created_before):\nCode replaced for brevity.\n243: \n244: \n245: \n246: def cleanup_candidates(root, prefix, keep):\nCode replaced for brevity.\n255: \n256: \n257: \n258: def cleanup_numbered_dir(root, prefix, keep, consider_lock_dead_if_created_before):\nCode replaced for brevity.\n263: \n264: \n265: \n266: def make_numbered_dir_with_cleanup(root, prefix, keep, lock_timeout):\nCode replaced for brevity.\n286: \n287: \n288: \n289: def resolve_from_str(input, root):\nCode replaced for brevity.\n297: \n298: \n299: \n300: def fnmatch_ex(pattern, path):\nCode replaced for brevity.\n332: \n333: \n334: \n335: def parts(s):\nCode replaced for brevity.\n337: \n338: \n339: \n340: def unique_path(path):\n341:     \"\"\"Returns a unique path in case-insensitive (but case-preserving) file\n342:     systems such as Windows.\n343: \n344:     This is needed only for ``py.path.local``; ``pathlib.Path`` handles this\n345:     natively with ``resolve()``.\"\"\"\n346:     return type(path)(normcase(str(path.realpath())))\n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/config/__init__.py",
      "suspect_lines": [
        33,
        370,
        409,
        410,
        415,
        435,
        438,
        440,
        457
      ]
    },
    {
      "filename": "/src/_pytest/pathlib.py",
      "suspect_lines": [
        14,
        338,
        339,
        340,
        341,
        342,
        343,
        344,
        345,
        346
      ]
    }
  ]
}