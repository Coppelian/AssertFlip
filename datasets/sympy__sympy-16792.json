{
  "instance_id": "sympy__sympy-16792",
  "problem_statement": "autowrap with cython backend fails when array arguments do not appear in wrapped expr\nWhen using the cython backend for autowrap, it appears that the code is not correctly generated when the function in question has array arguments that do not appear in the final expression. A minimal counterexample is:\r\n\r\n```python\r\nfrom sympy.utilities.autowrap import autowrap\r\nfrom sympy import MatrixSymbol\r\nimport numpy as np\r\n\r\nx = MatrixSymbol('x', 2, 1)\r\nexpr = 1.0\r\nf = autowrap(expr, args=(x,), backend='cython')\r\n\r\nf(np.array([[1.0, 2.0]]))\r\n```\r\n\r\nThis should of course return `1.0` but instead fails with:\r\n```python\r\nTypeError: only size-1 arrays can be converted to Python scalars\r\n```\r\n\r\nA little inspection reveals that this is because the corresponding C function is generated with an incorrect signature:\r\n\r\n```C\r\ndouble autofunc(double x) {\r\n\r\n   double autofunc_result;\r\n   autofunc_result = 1.0;\r\n   return autofunc_result;\r\n\r\n}\r\n```\r\n\r\n(`x` should be `double *`, not `double` in this case)\r\n\r\nI've found that this error won't occur so long as `expr` depends at least in part on each argument. For example this slight modification of the above counterexample works perfectly:\r\n\r\n```python\r\nfrom sympy.utilities.autowrap import autowrap\r\nfrom sympy import MatrixSymbol\r\nimport numpy as np\r\n\r\nx = MatrixSymbol('x', 2, 1)\r\n# now output depends on x\r\nexpr = x[0,0]\r\nf = autowrap(expr, args=(x,), backend='cython')\r\n\r\n# returns 1.0 as expected, without failure\r\nf(np.array([[1.0, 2.0]]))\r\n```\r\n\r\nThis may seem like a silly issue (\"why even have `x` as an argument if it doesn't appear in the expression you're trying to evaluate?\"). But of course in interfacing with external libraries (e.g. for numerical integration), one often needs functions to have a pre-defined signature regardless of whether a given argument contributes to the output.\r\n\r\nI think I've identified the problem in `codegen` and will suggest a PR shortly.\n",
  "localized_code": "[start of sympy/utilities/codegen.py]\n1: \"\"\"\n2: module for generating C, C++, Fortran77, Fortran90, Julia, Rust\n3: and Octave/Matlab routines that evaluate sympy expressions.\n4: This module is work in progress.\n5: Only the milestones with a '+' character in the list below have been completed.\n6: \n7: --- How is sympy.utilities.codegen different from sympy.printing.ccode? ---\n8: \n9: We considered the idea to extend the printing routines for sympy functions in\n10: such a way that it prints complete compilable code, but this leads to a few\n11: unsurmountable issues that can only be tackled with dedicated code generator:\n12: \n13: - For C, one needs both a code and a header file, while the printing routines\n14:   generate just one string. This code generator can be extended to support\n15:   .pyf files for f2py.\n16: \n17: - SymPy functions are not concerned with programming-technical issues, such\n18:   as input, output and input-output arguments. Other examples are contiguous\n19:   or non-contiguous arrays, including headers of other libraries such as gsl\n20:   or others.\n21: \n22: - It is highly interesting to evaluate several sympy functions in one C\n23:   routine, eventually sharing common intermediate results with the help\n24:   of the cse routine. This is more than just printing.\n25: \n26: - From the programming perspective, expressions with constants should be\n27:   evaluated in the code generator as much as possible. This is different\n28:   for printing.\n29: \n30: --- Basic assumptions ---\n31: \n32: * A generic Routine data structure describes the routine that must be\n33:   translated into C/Fortran/... code. This data structure covers all\n34:   features present in one or more of the supported languages.\n35: \n36: * Descendants from the CodeGen class transform multiple Routine instances\n37:   into compilable code. Each derived class translates into a specific\n38:   language.\n39: \n40: * In many cases, one wants a simple workflow. The friendly functions in the\n41:   last part are a simple api on top of the Routine/CodeGen stuff. They are\n42:   easier to use, but are less powerful.\n43: \n44: --- Milestones ---\n45: \n46: + First working version with scalar input arguments, generating C code,\n47:   tests\n48: + Friendly functions that are easier to use than the rigorous\n49:   Routine/CodeGen workflow.\n50: + Integer and Real numbers as input and output\n51: + Output arguments\n52: + InputOutput arguments\n53: + Sort input/output arguments properly\n54: + Contiguous array arguments (numpy matrices)\n55: + Also generate .pyf code for f2py (in autowrap module)\n56: + Isolate constants and evaluate them beforehand in double precision\n57: + Fortran 90\n58: + Octave/Matlab\n59: \n60: - Common Subexpression Elimination\n61: - User defined comments in the generated code\n62: - Optional extra include lines for libraries/objects that can eval special\n63:   functions\n64: - Test other C compilers and libraries: gcc, tcc, libtcc, gcc+gsl, ...\n65: - Contiguous array arguments (sympy matrices)\n66: - Non-contiguous array arguments (sympy matrices)\n67: - ccode must raise an error when it encounters something that can not be\n68:   translated into c. ccode(integrate(sin(x)/x, x)) does not make sense.\n69: - Complex numbers as input and output\n70: - A default complex datatype\n71: - Include extra information in the header: date, user, hostname, sha1\n72:   hash, ...\n73: - Fortran 77\n74: - C++\n75: - Python\n76: - Julia\n77: - Rust\n78: - ...\n79: \n80: \"\"\"\n81: \n82: from __future__ import print_function, division\n83: \n84: import os\n85: import textwrap\n86: \n87: from sympy import __version__ as sympy_version\n88: from sympy.core import Symbol, S, Tuple, Equality, Function, Basic\n89: from sympy.core.compatibility import is_sequence, StringIO, string_types\n90: from sympy.printing.ccode import c_code_printers\n91: from sympy.printing.codeprinter import AssignmentError\n92: from sympy.printing.fcode import FCodePrinter\n93: from sympy.printing.julia import JuliaCodePrinter\n94: from sympy.printing.octave import OctaveCodePrinter\n95: from sympy.printing.rust import RustCodePrinter\n96: from sympy.tensor import Idx, Indexed, IndexedBase\n97: from sympy.matrices import (MatrixSymbol, ImmutableMatrix, MatrixBase,\n98:                             MatrixExpr, MatrixSlice)\n99: \n100: \n101: __all__ = [\n102:     # description of routines\n103:     \"Routine\", \"DataType\", \"default_datatypes\", \"get_default_datatype\",\n104:     \"Argument\", \"InputArgument\", \"OutputArgument\", \"Result\",\n105:     # routines -> code\n106:     \"CodeGen\", \"CCodeGen\", \"FCodeGen\", \"JuliaCodeGen\", \"OctaveCodeGen\",\n107:     \"RustCodeGen\",\n108:     # friendly functions\n109:     \"codegen\", \"make_routine\",\n110: ]\n111: \n112: \n113: #\n114: # Description of routines\n115: #\n116: \n117: \n118: class Routine(object):\nCode replaced for brevity.\n235: \n236: \n237: \n238: class DataType(object):\nCode replaced for brevity.\n246: \n247: \n248: \n249: default_datatypes = {\n250:     \"int\": DataType(\"int\", \"INTEGER*4\", \"int\", \"\", \"\", \"i32\"),\n251:     \"float\": DataType(\"double\", \"REAL*8\", \"float\", \"\", \"\", \"f64\"),\n252:     \"complex\": DataType(\"double\", \"COMPLEX*16\", \"complex\", \"\", \"\", \"float\") #FIXME:\n253:        # complex is only supported in fortran, python, julia, and octave.\n254:        # So to not break c or rust code generation, we stick with double or\n255:        # float, respecitvely (but actually should raise an exeption for\n256:        # explicitly complex variables (x.is_complex==True))\n257: }\n258: \n259: \n260: COMPLEX_ALLOWED = False\n261: def get_default_datatype(expr, complex_allowed=None):\nCode replaced for brevity.\n283: \n284: \n285: \n286: class Variable(object):\nCode replaced for brevity.\n361: \n362: \n363: \n364: class Argument(Variable):\nCode replaced for brevity.\n370: \n371: \n372: \n373: class InputArgument(Argument):\n374:     pass\n375: \n376: \n377: class ResultBase(object):\nCode replaced for brevity.\n393: \n394: \n395: \n396: class OutputArgument(Argument, ResultBase):\nCode replaced for brevity.\n439: \n440: \n441: \n442: class InOutArgument(Argument, ResultBase):\nCode replaced for brevity.\n457: \n458: \n459: \n460: class Result(Variable, ResultBase):\nCode replaced for brevity.\n532: \n533: \n534: \n535: #\n536: # Transformation of routine objects into code\n537: #\n538: \n539: class CodeGen(object):\n540:     \"\"\"Abstract class for the code generators.\"\"\"\n541: \n542:     printer = None  # will be set to an instance of a CodePrinter subclass\n543: \n544:     def _indent_code(self, codelines):\n545:         return self.printer.indent_code(codelines)\n546: \n547:     def _printer_method_with_settings(self, method, settings=None, *args, **kwargs):\n548:         settings = settings or {}\n549:         ori = {k: self.printer._settings[k] for k in settings}\n550:         for k, v in settings.items():\n551:             self.printer._settings[k] = v\n552:         result = getattr(self.printer, method)(*args, **kwargs)\n553:         for k, v in ori.items():\n554:             self.printer._settings[k] = v\n555:         return result\n556: \n557:     def _get_symbol(self, s):\n558:         \"\"\"Returns the symbol as fcode prints it.\"\"\"\n559:         if self.printer._settings['human']:\n560:             expr_str = self.printer.doprint(s)\n561:         else:\n562:             constants, not_supported, expr_str = self.printer.doprint(s)\n563:             if constants or not_supported:\n564:                 raise ValueError(\"Failed to print %s\" % str(s))\n565:         return expr_str.strip()\n566: \n567:     def __init__(self, project=\"project\", cse=False):\n568:         \"\"\"Initialize a code generator.\n569: \n570:         Derived classes will offer more options that affect the generated\n571:         code.\n572: \n573:         \"\"\"\n574:         self.project = project\n575:         self.cse = cse\n576: \n577:     def routine(self, name, expr, argument_sequence=None, global_vars=None):\n578:         \"\"\"Creates an Routine object that is appropriate for this language.\n579: \n580:         This implementation is appropriate for at least C/Fortran.  Subclasses\n581:         can override this if necessary.\n582: \n583:         Here, we assume at most one return value (the l-value) which must be\n584:         scalar.  Additional outputs are OutputArguments (e.g., pointers on\n585:         right-hand-side or pass-by-reference).  Matrices are always returned\n586:         via OutputArguments.  If ``argument_sequence`` is None, arguments will\n587:         be ordered alphabetically, but with all InputArguments first, and then\n588:         OutputArgument and InOutArguments.\n589: \n590:         \"\"\"\n591: \n592:         if self.cse:\n593:             from sympy.simplify.cse_main import cse\n594: \n595:             if is_sequence(expr) and not isinstance(expr, (MatrixBase, MatrixExpr)):\n596:                 if not expr:\n597:                     raise ValueError(\"No expression given\")\n598:                 for e in expr:\n599:                     if not e.is_Equality:\n600:                         raise CodeGenError(\"Lists of expressions must all be Equalities. {} is not.\".format(e))\n601: \n602:                 # create a list of right hand sides and simplify them\n603:                 rhs = [e.rhs for e in expr]\n604:                 common, simplified = cse(rhs)\n605: \n606:                 # pack the simplified expressions back up with their left hand sides\n607:                 expr = [Equality(e.lhs, rhs) for e, rhs in zip(expr, simplified)]\n608:             else:\n609:                 rhs = [expr]\n610: \n611:                 if isinstance(expr, Equality):\n612:                     common, simplified = cse(expr.rhs) #, ignore=in_out_args)\n613:                     expr = Equality(expr.lhs, simplified[0])\n614:                 else:\n615:                     common, simplified = cse(expr)\n616:                     expr = simplified\n617: \n618:             local_vars = [Result(b,a) for a,b in common]\n619:             local_symbols = set([a for a,_ in common])\n620:             local_expressions = Tuple(*[b for _,b in common])\n621:         else:\n622:             local_expressions = Tuple()\n623: \n624:         if is_sequence(expr) and not isinstance(expr, (MatrixBase, MatrixExpr)):\n625:             if not expr:\n626:                 raise ValueError(\"No expression given\")\n627:             expressions = Tuple(*expr)\n628:         else:\n629:             expressions = Tuple(expr)\n630: \n631:         if self.cse:\n632:             if {i.label for i in expressions.atoms(Idx)} != set():\n633:                 raise CodeGenError(\"CSE and Indexed expressions do not play well together yet\")\n634:         else:\n635:             # local variables for indexed expressions\n636:             local_vars = {i.label for i in expressions.atoms(Idx)}\n637:             local_symbols = local_vars\n638: \n639:         # global variables\n640:         global_vars = set() if global_vars is None else set(global_vars)\n641: \n642:         # symbols that should be arguments\n643:         symbols = (expressions.free_symbols | local_expressions.free_symbols) - local_symbols - global_vars\n644:         new_symbols = set([])\n645:         new_symbols.update(symbols)\n646: \n647:         for symbol in symbols:\n648:             if isinstance(symbol, Idx):\n649:                 new_symbols.remove(symbol)\n650:                 new_symbols.update(symbol.args[1].free_symbols)\n651:             if isinstance(symbol, Indexed):\n652:                 new_symbols.remove(symbol)\n653:         symbols = new_symbols\n654: \n655:         # Decide whether to use output argument or return value\n656:         return_val = []\n657:         output_args = []\n658:         for expr in expressions:\n659:             if isinstance(expr, Equality):\n660:                 out_arg = expr.lhs\n661:                 expr = expr.rhs\n662:                 if isinstance(out_arg, Indexed):\n663:                     dims = tuple([ (S.Zero, dim - 1) for dim in out_arg.shape])\n664:                     symbol = out_arg.base.label\n665:                 elif isinstance(out_arg, Symbol):\n666:                     dims = []\n667:                     symbol = out_arg\n668:                 elif isinstance(out_arg, MatrixSymbol):\n669:                     dims = tuple([ (S.Zero, dim - 1) for dim in out_arg.shape])\n670:                     symbol = out_arg\n671:                 else:\n672:                     raise CodeGenError(\"Only Indexed, Symbol, or MatrixSymbol \"\n673:                                        \"can define output arguments.\")\n674: \n675:                 if expr.has(symbol):\n676:                     output_args.append(\n677:                         InOutArgument(symbol, out_arg, expr, dimensions=dims))\n678:                 else:\n679:                     output_args.append(\n680:                         OutputArgument(symbol, out_arg, expr, dimensions=dims))\n681: \n682:                 # remove duplicate arguments when they are not local variables\n683:                 if symbol not in local_vars:\n684:                     # avoid duplicate arguments\n685:                     symbols.remove(symbol)\n686:             elif isinstance(expr, (ImmutableMatrix, MatrixSlice)):\n687:                 # Create a \"dummy\" MatrixSymbol to use as the Output arg\n688:                 out_arg = MatrixSymbol('out_%s' % abs(hash(expr)), *expr.shape)\n689:                 dims = tuple([(S.Zero, dim - 1) for dim in out_arg.shape])\n690:                 output_args.append(\n691:                     OutputArgument(out_arg, out_arg, expr, dimensions=dims))\n692:             else:\n693:                 return_val.append(Result(expr))\n694: \n695:         arg_list = []\n696: \n697:         # setup input argument list\n698:         array_symbols = {}\n699:         for array in expressions.atoms(Indexed) | local_expressions.atoms(Indexed):\n700:             array_symbols[array.base.label] = array\n701:         for array in expressions.atoms(MatrixSymbol) | local_expressions.atoms(MatrixSymbol):\n702:             array_symbols[array] = array\n703: \n704:         for symbol in sorted(symbols, key=str):\n705:             if symbol in array_symbols:\n706:                 dims = []\n707:                 array = array_symbols[symbol]\n708:                 for dim in array.shape:\n709:                     dims.append((S.Zero, dim - 1))\n710:                 metadata = {'dimensions': dims}\n711:             else:\n712:                 metadata = {}\n713: \n714:             arg_list.append(InputArgument(symbol, **metadata))\n715: \n716:         output_args.sort(key=lambda x: str(x.name))\n717:         arg_list.extend(output_args)\n718: \n719:         if argument_sequence is not None:\n720:             # if the user has supplied IndexedBase instances, we'll accept that\n721:             new_sequence = []\n722:             for arg in argument_sequence:\n723:                 if isinstance(arg, IndexedBase):\n724:                     new_sequence.append(arg.label)\n725:                 else:\n726:                     new_sequence.append(arg)\n727:             argument_sequence = new_sequence\n728: \n729:             missing = [x for x in arg_list if x.name not in argument_sequence]\n730:             if missing:\n731:                 msg = \"Argument list didn't specify: {0} \"\n732:                 msg = msg.format(\", \".join([str(m.name) for m in missing]))\n733:                 raise CodeGenArgumentListError(msg, missing)\n734: \n735:             # create redundant arguments to produce the requested sequence\n736:             name_arg_dict = {x.name: x for x in arg_list}\n737:             new_args = []\n738:             for symbol in argument_sequence:\n739:                 try:\n740:                     new_args.append(name_arg_dict[symbol])\n741:                 except KeyError:\n742:                     new_args.append(InputArgument(symbol))\n743:             arg_list = new_args\n744: \n745:         return Routine(name, arg_list, return_val, local_vars, global_vars)\n746: \n747:     def write(self, routines, prefix, to_files=False, header=True, empty=True):\n748:         \"\"\"Writes all the source code files for the given routines.\n749: \n750:         The generated source is returned as a list of (filename, contents)\n751:         tuples, or is written to files (see below).  Each filename consists\n752:         of the given prefix, appended with an appropriate extension.\n753: \n754:         Parameters\n755:         ==========\n756: \n757:         routines : list\n758:             A list of Routine instances to be written\n759: \n760:         prefix : string\n761:             The prefix for the output files\n762: \n763:         to_files : bool, optional\n764:             When True, the output is written to files.  Otherwise, a list\n765:             of (filename, contents) tuples is returned.  [default: False]\n766: \n767:         header : bool, optional\n768:             When True, a header comment is included on top of each source\n769:             file. [default: True]\n770: \n771:         empty : bool, optional\n772:             When True, empty lines are included to structure the source\n773:             files. [default: True]\n774: \n775:         \"\"\"\n776:         if to_files:\n777:             for dump_fn in self.dump_fns:\n778:                 filename = \"%s.%s\" % (prefix, dump_fn.extension)\n779:                 with open(filename, \"w\") as f:\n780:                     dump_fn(self, routines, f, prefix, header, empty)\n781:         else:\n782:             result = []\n783:             for dump_fn in self.dump_fns:\n784:                 filename = \"%s.%s\" % (prefix, dump_fn.extension)\n785:                 contents = StringIO()\n786:                 dump_fn(self, routines, contents, prefix, header, empty)\n787:                 result.append((filename, contents.getvalue()))\n788:             return result\n789: \n790:     def dump_code(self, routines, f, prefix, header=True, empty=True):\n791:         \"\"\"Write the code by calling language specific methods.\n792: \n793:         The generated file contains all the definitions of the routines in\n794:         low-level code and refers to the header file if appropriate.\n795: \n796:         Parameters\n797:         ==========\n798: \n799:         routines : list\n800:             A list of Routine instances.\n801: \n802:         f : file-like\n803:             Where to write the file.\n804: \n805:         prefix : string\n806:             The filename prefix, used to refer to the proper header file.\n807:             Only the basename of the prefix is used.\n808: \n809:         header : bool, optional\n810:             When True, a header comment is included on top of each source\n811:             file.  [default : True]\n812: \n813:         empty : bool, optional\n814:             When True, empty lines are included to structure the source\n815:             files.  [default : True]\n816: \n817:         \"\"\"\n818: \n819:         code_lines = self._preprocessor_statements(prefix)\n820: \n821:         for routine in routines:\n822:             if empty:\n823:                 code_lines.append(\"\\n\")\n824:             code_lines.extend(self._get_routine_opening(routine))\n825:             code_lines.extend(self._declare_arguments(routine))\n826:             code_lines.extend(self._declare_globals(routine))\n827:             code_lines.extend(self._declare_locals(routine))\n828:             if empty:\n829:                 code_lines.append(\"\\n\")\n830:             code_lines.extend(self._call_printer(routine))\n831:             if empty:\n832:                 code_lines.append(\"\\n\")\n833:             code_lines.extend(self._get_routine_ending(routine))\n834: \n835:         code_lines = self._indent_code(''.join(code_lines))\n836: \n837:         if header:\n838:             code_lines = ''.join(self._get_header() + [code_lines])\n839: \n840:         if code_lines:\n841:             f.write(code_lines)\n842: \n843: \n844: class CodeGenError(Exception):\n845:     pass\n846: \n847: \n848: class CodeGenArgumentListError(Exception):\nCode replaced for brevity.\n851: \n852: \n853: \n854: header_comment = \"\"\"Code generated with sympy %(version)s\n855: \n856: See http://www.sympy.org/ for more information.\n857: \n858: This file is part of '%(project)s'\n859: \"\"\"\n860: \n861: \n862: class CCodeGen(CodeGen):\nCode replaced for brevity.\n1082: \n1083: \n1084: class C89CodeGen(CCodeGen):\n1085:     standard = 'C89'\n1086: \n1087: class C99CodeGen(CCodeGen):\n1088:     standard = 'C99'\n1089: \n1090: class FCodeGen(CodeGen):\nCode replaced for brevity.\n1302: \n1303: \n1304: \n1305: class JuliaCodeGen(CodeGen):\nCode replaced for brevity.\n1503: \n1504: \n1505: \n1506: class OctaveCodeGen(CodeGen):\nCode replaced for brevity.\n1748: \n1749: \n1750: class RustCodeGen(CodeGen):\nCode replaced for brevity.\n1964: \n1965: \n1966: \n1967: \n1968: \n1969: def get_code_generator(language, project=None, standard=None, printer = None):\nCode replaced for brevity.\n1983: \n1984: \n1985: \n1986: #\n1987: # Friendly functions\n1988: #\n1989: \n1990: \n1991:             global_vars=None, standard=None, code_gen=None, printer = None):\nCode replaced for brevity.\n2143: \n2144: \n2145: \n2146:                  global_vars=None, language=\"F95\"):\nCode replaced for brevity.\n2232: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/utilities/codegen.py",
      "suspect_lines": [
        706,
        708,
        709,
        710,
        742
      ]
    }
  ]
}