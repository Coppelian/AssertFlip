{
  "instance_id": "sympy__sympy-18199",
  "problem_statement": "nthroot_mod function misses one root of x = 0 mod p.\nWhen in the equation x**n = a mod p , when a % p == 0. Then x = 0 mod p is also a root of this equation. But right now `nthroot_mod` does not check for this condition. `nthroot_mod(17*17, 5 , 17)` has a root `0 mod 17`. But it does not return it.\n",
  "localized_code": "[start of sympy/ntheory/residue_ntheory.py]\n1: from __future__ import print_function, division\n2: \n3: from sympy.core.compatibility import as_int, range\n4: from sympy.core.function import Function\n5: from sympy.core.numbers import igcd, igcdex, mod_inverse\n6: from sympy.core.power import isqrt\n7: from sympy.core.singleton import S\n8: from .primetest import isprime\n9: from .factor_ import factorint, trailing, totient, multiplicity\n10: from random import randint, Random\n11: \n12: \n13: \n14: def n_order(a, n):\n15:     \"\"\"Returns the order of ``a`` modulo ``n``.\n16: \n17:     The order of ``a`` modulo ``n`` is the smallest integer\n18:     ``k`` such that ``a**k`` leaves a remainder of 1 with ``n``.\n19: \n20:     Examples\n21:     ========\n22: \n23:     >>> from sympy.ntheory import n_order\n24:     >>> n_order(3, 7)\n25:     6\n26:     >>> n_order(4, 7)\n27:     3\n28:     \"\"\"\n29:     from collections import defaultdict\n30:     a, n = as_int(a), as_int(n)\n31:     if igcd(a, n) != 1:\n32:         raise ValueError(\"The two numbers should be relatively prime\")\n33:     factors = defaultdict(int)\n34:     f = factorint(n)\n35:     for px, kx in f.items():\n36:         if kx > 1:\n37:             factors[px] += kx - 1\n38:         fpx = factorint(px - 1)\n39:         for py, ky in fpx.items():\n40:             factors[py] += ky\n41:     group_order = 1\n42:     for px, kx in factors.items():\n43:         group_order *= px**kx\n44:     order = 1\n45:     if a > n:\n46:         a = a % n\n47:     for p, e in factors.items():\n48:         exponent = group_order\n49:         for f in range(e + 1):\n50:             if pow(a, exponent, n) != 1:\n51:                 order *= p ** (e - f + 1)\n52:                 break\n53:             exponent = exponent // p\n54:     return order\n55: \n56: \n57: def _primitive_root_prime_iter(p):\nCode replaced for brevity.\n84: \n85: \n86: \n87: def primitive_root(p):\nCode replaced for brevity.\n150: \n151: \n152: \n153: def is_primitive_root(a, p):\nCode replaced for brevity.\n181: \n182: \n183: \n184: def _sqrt_mod_tonelli_shanks(a, p):\nCode replaced for brevity.\n213: \n214: \n215: \n216: def sqrt_mod(a, p, all_roots=False):\nCode replaced for brevity.\n265: \n266: \n267: \n268: def _product(*iters):\nCode replaced for brevity.\n299: \n300: \n301: \n302: def sqrt_mod_iter(a, p, domain=int):\nCode replaced for brevity.\n359: \n360: \n361: \n362: def _sqrt_mod_prime_power(a, p, k):\nCode replaced for brevity.\n476: \n477: \n478: \n479: def _sqrt_mod1(a, p, n):\nCode replaced for brevity.\n581: \n582: \n583: \n584: def is_quad_residue(a, p):\nCode replaced for brevity.\n617: \n618: \n619: \n620: def is_nthpow_residue(a, n, m):\nCode replaced for brevity.\n647: \n648: \n649: \n650: def _is_nthpow_residue_bign(a, n, m):\nCode replaced for brevity.\n662: \n663: \n664: \n665: def _is_nthpow_residue_bign_prime_power(a, n, p, k):\nCode replaced for brevity.\n687: \n688: \n689: \n690: def _nthroot_mod2(s, q, p):\nCode replaced for brevity.\n697: \n698: \n699: \n700: def _nthroot_mod1(s, q, p, all_roots):\nCode replaced for brevity.\n743: \n744: \n745: \n746: def nthroot_mod(a, n, p, all_roots=False):\n747:     \"\"\"\n748:     Find the solutions to ``x**n = a mod p``\n749: \n750:     Parameters\n751:     ==========\n752: \n753:     a : integer\n754:     n : positive integer\n755:     p : positive integer\n756:     all_roots : if False returns the smallest root, else the list of roots\n757: \n758:     Examples\n759:     ========\n760: \n761:     >>> from sympy.ntheory.residue_ntheory import nthroot_mod\n762:     >>> nthroot_mod(11, 4, 19)\n763:     8\n764:     >>> nthroot_mod(11, 4, 19, True)\n765:     [8, 11]\n766:     >>> nthroot_mod(68, 3, 109)\n767:     23\n768:     \"\"\"\n769:     from sympy.core.numbers import igcdex\n770:     a, n, p = as_int(a), as_int(n), as_int(p)\n771:     if n == 2:\n772:         return sqrt_mod(a, p, all_roots)\n773:     # see Hackman \"Elementary Number Theory\" (2009), page 76\n774:     if not is_nthpow_residue(a, n, p):\n775:         return None\n776:     if not isprime(p):\n777:         raise NotImplementedError(\"Not implemented for composite p\")\n778: \n779:     if (p - 1) % n == 0:\n780:         return _nthroot_mod1(a, n, p, all_roots)\n781:     # The roots of ``x**n - a = 0 (mod p)`` are roots of\n782:     # ``gcd(x**n - a, x**(p - 1) - 1) = 0 (mod p)``\n783:     pa = n\n784:     pb = p - 1\n785:     b = 1\n786:     if pa < pb:\n787:         a, pa, b, pb = b, pb, a, pa\n788:     while pb:\n789:         # x**pa - a = 0; x**pb - b = 0\n790:         # x**pa - a = x**(q*pb + r) - a = (x**pb)**q * x**r - a =\n791:         #             b**q * x**r - a; x**r - c = 0; c = b**-q * a mod p\n792:         q, r = divmod(pa, pb)\n793:         c = pow(b, q, p)\n794:         c = igcdex(c, p)[0]\n795:         c = (c * a) % p\n796:         pa, pb = pb, r\n797:         a, b = b, c\n798:     if pa == 1:\n799:         if all_roots:\n800:             res = [a]\n801:         else:\n802:             res = a\n803:     elif pa == 2:\n804:         return sqrt_mod(a, p , all_roots)\n805:     else:\n806:         res = _nthroot_mod1(a, pa, p, all_roots)\n807:     return res\n808: \n809: \n810: def quadratic_residues(p):\nCode replaced for brevity.\n825: \n826: \n827: \n828: def legendre_symbol(a, p):\nCode replaced for brevity.\n871: \n872: \n873: \n874: def jacobi_symbol(m, n):\nCode replaced for brevity.\n959: \n960: \n961: \n962: class mobius(Function):\nCode replaced for brevity.\n1017: \n1018: \n1019: \n1020: def _discrete_log_trial_mul(n, a, b, order=None):\nCode replaced for brevity.\n1056: \n1057: \n1058: \n1059: def _discrete_log_shanks_steps(n, a, b, order=None):\nCode replaced for brevity.\n1102: \n1103: \n1104: \n1105: def _discrete_log_pollard_rho(n, a, b, order=None, retries=10, rseed=None):\nCode replaced for brevity.\n1205: \n1206: \n1207: \n1208: def _discrete_log_pohlig_hellman(n, a, b, order=None):\nCode replaced for brevity.\n1254: \n1255: \n1256: \n1257: def discrete_log(n, a, b, order=None, prime_order=None):\nCode replaced for brevity.\n1302: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/ntheory/residue_ntheory.py",
      "suspect_lines": [
        776,
        777,
        778
      ]
    }
  ]
}