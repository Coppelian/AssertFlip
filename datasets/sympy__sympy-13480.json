{
  "instance_id": "sympy__sympy-13480",
  "problem_statement": ".subs on coth(log(tan(x))) errors for certain integral values\n    >>> from sympy import *\r\n    >>> x = Symbol('x')\r\n    >>> e = coth(log(tan(x)))\r\n    >>> print(e.subs(x, 2))\r\n    ...\r\n    File \"C:\\Users\\E\\Desktop\\sympy-master\\sympy\\functions\\elementary\\hyperbolic.py\", line 590, in eval\r\n        if cotm is S.ComplexInfinity:\r\n    NameError: name 'cotm' is not defined\r\n\r\nFails for 2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18, ... etc.\n",
  "localized_code": "[start of sympy/functions/elementary/hyperbolic.py]\n1: from __future__ import print_function, division\n2: \n3: from sympy.core import S, sympify, cacheit\n4: from sympy.core.add import Add\n5: from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg\n6: \n7: from sympy.functions.elementary.miscellaneous import sqrt\n8: \n9: from sympy.functions.elementary.exponential import exp, log\n10: from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n11: \n12: \n13: def _rewrite_hyperbolics_as_exp(expr):\n14:     expr = sympify(expr)\n15:     return expr.xreplace(dict([(h, h.rewrite(exp))\n16:         for h in expr.atoms(HyperbolicFunction)]))\n17: \n18: \n19: ###############################################################################\n20: ########################### HYPERBOLIC FUNCTIONS ##############################\n21: ###############################################################################\n22: \n23: \n24: class HyperbolicFunction(Function):\n25:     \"\"\"\n26:     Base class for hyperbolic functions.\n27: \n28:     See Also\n29:     ========\n30: \n31:     sinh, cosh, tanh, coth\n32:     \"\"\"\n33: \n34:     unbranched = True\n35: \n36: \n37: def _peeloff_ipi(arg):\n38:     \"\"\"\n39:     Split ARG into two parts, a \"rest\" and a multiple of I*pi/2.\n40:     This assumes ARG to be an Add.\n41:     The multiple of I*pi returned in the second position is always a Rational.\n42: \n43:     Examples\n44:     ========\n45: \n46:     >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel\n47:     >>> from sympy import pi, I\n48:     >>> from sympy.abc import x, y\n49:     >>> peel(x + I*pi/2)\n50:     (x, I*pi/2)\n51:     >>> peel(x + I*2*pi/3 + I*pi*y)\n52:     (x + I*pi*y + I*pi/6, I*pi/2)\n53:     \"\"\"\n54:     for a in Add.make_args(arg):\n55:         if a == S.Pi*S.ImaginaryUnit:\n56:             K = S.One\n57:             break\n58:         elif a.is_Mul:\n59:             K, p = a.as_two_terms()\n60:             if p == S.Pi*S.ImaginaryUnit and K.is_Rational:\n61:                 break\n62:     else:\n63:         return arg, S.Zero\n64: \n65:     m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit\n66:     m2 = K*S.Pi*S.ImaginaryUnit - m1\n67:     return arg - m2, m2\n68: \n69: \n70: class sinh(HyperbolicFunction):\nCode replaced for brevity.\n236: \n237: \n238: \n239: class cosh(HyperbolicFunction):\nCode replaced for brevity.\n388: \n389: \n390: \n391: class tanh(HyperbolicFunction):\nCode replaced for brevity.\n534: \n535: \n536: \n537: class coth(HyperbolicFunction):\n538:     r\"\"\"\n539:     The hyperbolic cotangent function, `\\frac{\\cosh(x)}{\\sinh(x)}`.\n540: \n541:     * coth(x) -> Returns the hyperbolic cotangent of x\n542:     \"\"\"\n543: \n544:     def fdiff(self, argindex=1):\n545:         if argindex == 1:\n546:             return -1/sinh(self.args[0])**2\n547:         else:\n548:             raise ArgumentIndexError(self, argindex)\n549: \n550:     def inverse(self, argindex=1):\n551:         \"\"\"\n552:         Returns the inverse of this function.\n553:         \"\"\"\n554:         return acoth\n555: \n556:     @classmethod\n557:     def eval(cls, arg):\n558:         from sympy import cot\n559:         arg = sympify(arg)\n560: \n561:         if arg.is_Number:\n562:             if arg is S.NaN:\n563:                 return S.NaN\n564:             elif arg is S.Infinity:\n565:                 return S.One\n566:             elif arg is S.NegativeInfinity:\n567:                 return S.NegativeOne\n568:             elif arg is S.Zero:\n569:                 return S.ComplexInfinity\n570:             elif arg.is_negative:\n571:                 return -cls(-arg)\n572:         else:\n573:             if arg is S.ComplexInfinity:\n574:                 return S.NaN\n575: \n576:             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n577: \n578:             if i_coeff is not None:\n579:                 if _coeff_isneg(i_coeff):\n580:                     return S.ImaginaryUnit * cot(-i_coeff)\n581:                 return -S.ImaginaryUnit * cot(i_coeff)\n582:             else:\n583:                 if _coeff_isneg(arg):\n584:                     return -cls(-arg)\n585: \n586:             if arg.is_Add:\n587:                 x, m = _peeloff_ipi(arg)\n588:                 if m:\n589:                     cothm = coth(m)\n590:                     if cotm is S.ComplexInfinity:\n591:                         return coth(x)\n592:                     else: # cothm == 0\n593:                         return tanh(x)\n594: \n595:             if arg.func == asinh:\n596:                 x = arg.args[0]\n597:                 return sqrt(1 + x**2)/x\n598: \n599:             if arg.func == acosh:\n600:                 x = arg.args[0]\n601:                 return x/(sqrt(x - 1) * sqrt(x + 1))\n602: \n603:             if arg.func == atanh:\n604:                 return 1/arg.args[0]\n605: \n606:             if arg.func == acoth:\n607:                 return arg.args[0]\n608: \n609:     @staticmethod\n610:     @cacheit\n611:     def taylor_term(n, x, *previous_terms):\n612:         from sympy import bernoulli\n613:         if n == 0:\n614:             return 1 / sympify(x)\n615:         elif n < 0 or n % 2 == 0:\n616:             return S.Zero\n617:         else:\n618:             x = sympify(x)\n619: \n620:             B = bernoulli(n + 1)\n621:             F = factorial(n + 1)\n622: \n623:             return 2**(n + 1) * B/F * x**n\n624: \n625:     def _eval_conjugate(self):\n626:         return self.func(self.args[0].conjugate())\n627: \n628:     def as_real_imag(self, deep=True, **hints):\n629:         from sympy import cos, sin\n630:         if self.args[0].is_real:\n631:             if deep:\n632:                 hints['complex'] = False\n633:                 return (self.expand(deep, **hints), S.Zero)\n634:             else:\n635:                 return (self, S.Zero)\n636:         if deep:\n637:             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n638:         else:\n639:             re, im = self.args[0].as_real_imag()\n640:         denom = sinh(re)**2 + sin(im)**2\n641:         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)\n642: \n643:     def _eval_rewrite_as_tractable(self, arg):\n644:         neg_exp, pos_exp = exp(-arg), exp(arg)\n645:         return (pos_exp + neg_exp)/(pos_exp - neg_exp)\n646: \n647:     def _eval_rewrite_as_exp(self, arg):\n648:         neg_exp, pos_exp = exp(-arg), exp(arg)\n649:         return (pos_exp + neg_exp)/(pos_exp - neg_exp)\n650: \n651:     def _eval_rewrite_as_sinh(self, arg):\n652:         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)\n653: \n654:     def _eval_rewrite_as_cosh(self, arg):\n655:         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)\n656: \n657:     def _eval_rewrite_as_tanh(self, arg):\n658:         return 1/tanh(arg)\n659: \n660:     def _eval_as_leading_term(self, x):\n661:         from sympy import Order\n662:         arg = self.args[0].as_leading_term(x)\n663: \n664:         if x in arg.free_symbols and Order(1, x).contains(arg):\n665:             return 1/arg\n666:         else:\n667:             return self.func(arg)\n668: \n669: \n670: class ReciprocalHyperbolicFunction(HyperbolicFunction):\nCode replaced for brevity.\n738: \n739: \n740: \n741: class csch(ReciprocalHyperbolicFunction):\nCode replaced for brevity.\n789: \n790: \n791: \n792: class sech(ReciprocalHyperbolicFunction):\nCode replaced for brevity.\n828: \n829: \n830: \n831: \n832: ###############################################################################\n833: ############################# HYPERBOLIC INVERSES #############################\n834: ###############################################################################\n835: \n836: class InverseHyperbolicFunction(Function):\nCode replaced for brevity.\n839: \n840: \n841: \n842: class asinh(InverseHyperbolicFunction):\nCode replaced for brevity.\n924: \n925: \n926: \n927: class acosh(InverseHyperbolicFunction):\nCode replaced for brevity.\n1029: \n1030: \n1031: \n1032: class atanh(InverseHyperbolicFunction):\nCode replaced for brevity.\n1107: \n1108: \n1109: \n1110: class acoth(InverseHyperbolicFunction):\nCode replaced for brevity.\n1182: \n1183: \n1184: \n1185: class asech(InverseHyperbolicFunction):\nCode replaced for brevity.\n1309: \n1310: \n1311: \n1312: class acsch(InverseHyperbolicFunction):\nCode replaced for brevity.\n1403: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/functions/elementary/hyperbolic.py",
      "suspect_lines": [
        590
      ]
    }
  ]
}