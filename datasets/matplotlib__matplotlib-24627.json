{
  "instance_id": "matplotlib__matplotlib-24627",
  "problem_statement": "cla(), clf() should unset the `.axes` and `.figure` attributes of deparented artists\nmpl2.0b3: Removing an artist from its axes unsets its `.axes` attribute, but clearing the axes does not do so.\n\n```\nIn [11]: f, a = plt.subplots(); l, = a.plot([1, 2]); l.remove(); print(l.axes)\nNone\n\nIn [12]: f, a = plt.subplots(); l, = a.plot([1, 2]); a.cla(); print(l.axes)\nAxes(0.125,0.11;0.775x0.77)\n```\n\n",
  "localized_code": "[start of lib/matplotlib/axes/_base.py]\n1: from collections.abc import Iterable, MutableSequence\n2: from contextlib import ExitStack\n3: import functools\n4: import inspect\n5: import itertools\n6: import logging\n7: from numbers import Real\n8: from operator import attrgetter\n9: import types\n10: \n11: import numpy as np\n12: \n13: import matplotlib as mpl\n14: from matplotlib import _api, cbook, _docstring, offsetbox\n15: import matplotlib.artist as martist\n16: import matplotlib.axis as maxis\n17: from matplotlib.cbook import _OrderedSet, _check_1d, index_of\n18: import matplotlib.collections as mcoll\n19: import matplotlib.colors as mcolors\n20: import matplotlib.font_manager as font_manager\n21: from matplotlib.gridspec import SubplotSpec\n22: import matplotlib.image as mimage\n23: import matplotlib.lines as mlines\n24: import matplotlib.patches as mpatches\n25: from matplotlib.rcsetup import cycler, validate_axisbelow\n26: import matplotlib.spines as mspines\n27: import matplotlib.table as mtable\n28: import matplotlib.text as mtext\n29: import matplotlib.ticker as mticker\n30: import matplotlib.transforms as mtransforms\n31: \n32: _log = logging.getLogger(__name__)\n33: \n34: \n35: class _axis_method_wrapper:\n36:     \"\"\"\n37:     Helper to generate Axes methods wrapping Axis methods.\n38: \n39:     After ::\n40: \n41:         get_foo = _axis_method_wrapper(\"xaxis\", \"get_bar\")\n42: \n43:     (in the body of a class) ``get_foo`` is a method that forwards it arguments\n44:     to the ``get_bar`` method of the ``xaxis`` attribute, and gets its\n45:     signature and docstring from ``Axis.get_bar``.\n46: \n47:     The docstring of ``get_foo`` is built by replacing \"this Axis\" by \"the\n48:     {attr_name}\" (i.e., \"the xaxis\", \"the yaxis\") in the wrapped method's\n49:     dedented docstring; additional replacements can be given in *doc_sub*.\n50:     \"\"\"\n51: \n52:     def __init__(self, attr_name, method_name, *, doc_sub=None):\n53:         self.attr_name = attr_name\n54:         self.method_name = method_name\n55:         # Immediately put the docstring in ``self.__doc__`` so that docstring\n56:         # manipulations within the class body work as expected.\n57:         doc = inspect.getdoc(getattr(maxis.Axis, method_name))\n58:         self._missing_subs = []\n59:         if doc:\n60:             doc_sub = {\"this Axis\": f\"the {self.attr_name}\", **(doc_sub or {})}\n61:             for k, v in doc_sub.items():\n62:                 if k not in doc:  # Delay raising error until we know qualname.\n63:                     self._missing_subs.append(k)\n64:                 doc = doc.replace(k, v)\n65:         self.__doc__ = doc\n66: \n67:     def __set_name__(self, owner, name):\n68:         # This is called at the end of the class body as\n69:         # ``self.__set_name__(cls, name_under_which_self_is_assigned)``; we\n70:         # rely on that to give the wrapper the correct __name__/__qualname__.\n71:         get_method = attrgetter(f\"{self.attr_name}.{self.method_name}\")\n72: \n73:         def wrapper(self, *args, **kwargs):\n74:             return get_method(self)(*args, **kwargs)\n75: \n76:         wrapper.__module__ = owner.__module__\n77:         wrapper.__name__ = name\n78:         wrapper.__qualname__ = f\"{owner.__qualname__}.{name}\"\n79:         wrapper.__doc__ = self.__doc__\n80:         # Manually copy the signature instead of using functools.wraps because\n81:         # displaying the Axis method source when asking for the Axes method\n82:         # source would be confusing.\n83:         wrapper.__signature__ = inspect.signature(\n84:             getattr(maxis.Axis, self.method_name))\n85: \n86:         if self._missing_subs:\n87:             raise ValueError(\n88:                 \"The definition of {} expected that the docstring of Axis.{} \"\n89:                 \"contains {!r} as substrings\".format(\n90:                     wrapper.__qualname__, self.method_name,\n91:                     \", \".join(map(repr, self._missing_subs))))\n92: \n93:         setattr(owner, name, wrapper)\n94: \n95: \n96: class _TransformedBoundsLocator:\nCode replaced for brevity.\n118: \n119: \n120: \n121: def _process_plot_format(fmt, *, ambiguous_fmt_datakey=False):\nCode replaced for brevity.\n208: \n209: \n210: \n211: class _process_plot_var_args:\nCode replaced for brevity.\n545: \n546: \n547: \n548: @_api.define_aliases({\"facecolor\": [\"fc\"]})\n549: class _AxesBase(martist.Artist):\n550:     name = \"rectilinear\"\n551: \n552:     # axis names are the prefixes for the attributes that contain the\n553:     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.\n554:     # Note that PolarAxes uses these attributes as well, so that we have\n555:     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not\n556:     # have 'theta' in _axis_names.\n557:     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')\n558:     # for Axes3D.\n559:     _axis_names = (\"x\", \"y\")\n560:     _shared_axes = {name: cbook.Grouper() for name in _axis_names}\n561:     _twinned_axes = cbook.Grouper()\n562: \n563:     _subclass_uses_cla = False\n564: \n565:     @property\n566:     def _axis_map(self):\n567:         \"\"\"A mapping of axis names, e.g. 'x', to `Axis` instances.\"\"\"\n568:         return {name: getattr(self, f\"{name}axis\")\n569:                 for name in self._axis_names}\n570: \n571:     def __str__(self):\n572:         return \"{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})\".format(\n573:             type(self).__name__, self._position.bounds)\n574: \n575:     def __init__(self, fig,\n576:                  *args,\n577:                  facecolor=None,  # defaults to rc axes.facecolor\n578:                  frameon=True,\n579:                  sharex=None,  # use Axes instance's xaxis info\n580:                  sharey=None,  # use Axes instance's yaxis info\n581:                  label='',\n582:                  xscale=None,\n583:                  yscale=None,\n584:                  box_aspect=None,\n585:                  **kwargs\n586:                  ):\n587:         \"\"\"\n588:         Build an Axes in a figure.\n589: \n590:         Parameters\n591:         ----------\n592:         fig : `~matplotlib.figure.Figure`\n593:             The Axes is built in the `.Figure` *fig*.\n594: \n595:         *args\n596:             ``*args`` can be a single ``(left, bottom, width, height)``\n597:             rectangle or a single `.Bbox`.  This specifies the rectangle (in\n598:             figure coordinates) where the Axes is positioned.\n599: \n600:             ``*args`` can also consist of three numbers or a single three-digit\n601:             number; in the latter case, the digits are considered as\n602:             independent numbers.  The numbers are interpreted as ``(nrows,\n603:             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array\n604:             of subplots, and ``index`` is the 1-based index of the subplot\n605:             being created.  Finally, ``*args`` can also directly be a\n606:             `.SubplotSpec` instance.\n607: \n608:         sharex, sharey : `~.axes.Axes`, optional\n609:             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in\n610:             the input `~.axes.Axes`.\n611: \n612:         frameon : bool, default: True\n613:             Whether the Axes frame is visible.\n614: \n615:         box_aspect : float, optional\n616:             Set a fixed aspect for the Axes box, i.e. the ratio of height to\n617:             width. See `~.axes.Axes.set_box_aspect` for details.\n618: \n619:         **kwargs\n620:             Other optional keyword arguments:\n621: \n622:             %(Axes:kwdoc)s\n623: \n624:         Returns\n625:         -------\n626:         `~.axes.Axes`\n627:             The new `~.axes.Axes` object.\n628:         \"\"\"\n629: \n630:         super().__init__()\n631:         if \"rect\" in kwargs:\n632:             if args:\n633:                 raise TypeError(\n634:                     \"'rect' cannot be used together with positional arguments\")\n635:             rect = kwargs.pop(\"rect\")\n636:             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)\n637:             args = (rect,)\n638:         subplotspec = None\n639:         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):\n640:             self._position = args[0]\n641:         elif len(args) == 1 and np.iterable(args[0]):\n642:             self._position = mtransforms.Bbox.from_bounds(*args[0])\n643:         else:\n644:             self._position = self._originalPosition = mtransforms.Bbox.unit()\n645:             subplotspec = SubplotSpec._from_subplot_args(fig, args)\n646:         if self._position.width < 0 or self._position.height < 0:\n647:             raise ValueError('Width and height specified must be non-negative')\n648:         self._originalPosition = self._position.frozen()\n649:         self.axes = self\n650:         self._aspect = 'auto'\n651:         self._adjustable = 'box'\n652:         self._anchor = 'C'\n653:         self._stale_viewlims = {name: False for name in self._axis_names}\n654:         self._sharex = sharex\n655:         self._sharey = sharey\n656:         self.set_label(label)\n657:         self.set_figure(fig)\n658:         # The subplotspec needs to be set after the figure (so that\n659:         # figure-level subplotpars are taken into account), but the figure\n660:         # needs to be set after self._position is initialized.\n661:         if subplotspec:\n662:             self.set_subplotspec(subplotspec)\n663:         else:\n664:             self._subplotspec = None\n665:         self.set_box_aspect(box_aspect)\n666:         self._axes_locator = None  # Optionally set via update(kwargs).\n667: \n668:         self._children = []\n669: \n670:         # placeholder for any colorbars added that use this Axes.\n671:         # (see colorbar.py):\n672:         self._colorbars = []\n673:         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())\n674: \n675:         # this call may differ for non-sep axes, e.g., polar\n676:         self._init_axis()\n677:         if facecolor is None:\n678:             facecolor = mpl.rcParams['axes.facecolor']\n679:         self._facecolor = facecolor\n680:         self._frameon = frameon\n681:         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])\n682: \n683:         self._rasterization_zorder = None\n684:         self.clear()\n685: \n686:         # funcs used to format x and y - fall back on major formatters\n687:         self.fmt_xdata = None\n688:         self.fmt_ydata = None\n689: \n690:         self.set_navigate(True)\n691:         self.set_navigate_mode(None)\n692: \n693:         if xscale:\n694:             self.set_xscale(xscale)\n695:         if yscale:\n696:             self.set_yscale(yscale)\n697: \n698:         self._internal_update(kwargs)\n699: \n700:         for name, axis in self._axis_map.items():\n701:             axis.callbacks._connect_picklable(\n702:                 'units', self._unit_change_handler(name))\n703: \n704:         rcParams = mpl.rcParams\n705:         self.tick_params(\n706:             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],\n707:             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],\n708:             labeltop=(rcParams['xtick.labeltop'] and\n709:                       rcParams['xtick.minor.top']),\n710:             labelbottom=(rcParams['xtick.labelbottom'] and\n711:                          rcParams['xtick.minor.bottom']),\n712:             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],\n713:             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],\n714:             labelleft=(rcParams['ytick.labelleft'] and\n715:                        rcParams['ytick.minor.left']),\n716:             labelright=(rcParams['ytick.labelright'] and\n717:                         rcParams['ytick.minor.right']),\n718:             which='minor')\n719: \n720:         self.tick_params(\n721:             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],\n722:             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],\n723:             labeltop=(rcParams['xtick.labeltop'] and\n724:                       rcParams['xtick.major.top']),\n725:             labelbottom=(rcParams['xtick.labelbottom'] and\n726:                          rcParams['xtick.major.bottom']),\n727:             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],\n728:             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],\n729:             labelleft=(rcParams['ytick.labelleft'] and\n730:                        rcParams['ytick.major.left']),\n731:             labelright=(rcParams['ytick.labelright'] and\n732:                         rcParams['ytick.major.right']),\n733:             which='major')\n734: \n735:     def __init_subclass__(cls, **kwargs):\n736:         parent_uses_cla = super(cls, cls)._subclass_uses_cla\n737:         if 'cla' in cls.__dict__:\n738:             _api.warn_deprecated(\n739:                 '3.6',\n740:                 pending=True,\n741:                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '\n742:                 'pending deprecation in %(since)s and will be fully '\n743:                 'deprecated in favor of `Axes.clear` in the future. '\n744:                 'Please report '\n745:                 f'this to the {cls.__module__!r} author.')\n746:         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla\n747:         super().__init_subclass__(**kwargs)\n748: \n749:     def __getstate__(self):\n750:         state = super().__getstate__()\n751:         # Prune the sharing & twinning info to only contain the current group.\n752:         state[\"_shared_axes\"] = {\n753:             name: self._shared_axes[name].get_siblings(self)\n754:             for name in self._axis_names if self in self._shared_axes[name]}\n755:         state[\"_twinned_axes\"] = (self._twinned_axes.get_siblings(self)\n756:                                   if self in self._twinned_axes else None)\n757:         return state\n758: \n759:     def __setstate__(self, state):\n760:         # Merge the grouping info back into the global groupers.\n761:         shared_axes = state.pop(\"_shared_axes\")\n762:         for name, shared_siblings in shared_axes.items():\n763:             self._shared_axes[name].join(*shared_siblings)\n764:         twinned_siblings = state.pop(\"_twinned_axes\")\n765:         if twinned_siblings:\n766:             self._twinned_axes.join(*twinned_siblings)\n767:         self.__dict__ = state\n768:         self._stale = True\n769: \n770:     def __repr__(self):\n771:         fields = []\n772:         if self.get_label():\n773:             fields += [f\"label={self.get_label()!r}\"]\n774:         if hasattr(self, \"get_title\"):\n775:             titles = {}\n776:             for k in [\"left\", \"center\", \"right\"]:\n777:                 title = self.get_title(loc=k)\n778:                 if title:\n779:                     titles[k] = title\n780:             if titles:\n781:                 fields += [f\"title={titles}\"]\n782:         for name, axis in self._axis_map.items():\n783:             if axis.get_label() and axis.get_label().get_text():\n784:                 fields += [f\"{name}label={axis.get_label().get_text()!r}\"]\n785:         return f\"<{self.__class__.__name__}: \" + \", \".join(fields) + \">\"\n786: \n787:     def get_subplotspec(self):\n788:         \"\"\"Return the `.SubplotSpec` associated with the subplot, or None.\"\"\"\n789:         return self._subplotspec\n790: \n791:     def set_subplotspec(self, subplotspec):\n792:         \"\"\"Set the `.SubplotSpec`. associated with the subplot.\"\"\"\n793:         self._subplotspec = subplotspec\n794:         self._set_position(subplotspec.get_position(self.figure))\n795: \n796:     def get_gridspec(self):\n797:         \"\"\"Return the `.GridSpec` associated with the subplot, or None.\"\"\"\n798:         return self._subplotspec.get_gridspec() if self._subplotspec else None\n799: \n800:     @_api.delete_parameter(\"3.6\", \"args\")\n801:     @_api.delete_parameter(\"3.6\", \"kwargs\")\n802:     def get_window_extent(self, renderer=None, *args, **kwargs):\n803:         \"\"\"\n804:         Return the Axes bounding box in display space; *args* and *kwargs*\n805:         are empty.\n806: \n807:         This bounding box does not include the spines, ticks, ticklabels,\n808:         or other labels.  For a bounding box including these elements use\n809:         `~matplotlib.axes.Axes.get_tightbbox`.\n810: \n811:         See Also\n812:         --------\n813:         matplotlib.axes.Axes.get_tightbbox\n814:         matplotlib.axis.Axis.get_tightbbox\n815:         matplotlib.spines.Spine.get_window_extent\n816:         \"\"\"\n817:         return self.bbox\n818: \n819:     def _init_axis(self):\n820:         # This is moved out of __init__ because non-separable axes don't use it\n821:         self.xaxis = maxis.XAxis(self)\n822:         self.spines.bottom.register_axis(self.xaxis)\n823:         self.spines.top.register_axis(self.xaxis)\n824:         self.yaxis = maxis.YAxis(self)\n825:         self.spines.left.register_axis(self.yaxis)\n826:         self.spines.right.register_axis(self.yaxis)\n827:         self._update_transScale()\n828: \n829:     def set_figure(self, fig):\n830:         # docstring inherited\n831:         super().set_figure(fig)\n832: \n833:         self.bbox = mtransforms.TransformedBbox(self._position,\n834:                                                 fig.transSubfigure)\n835:         # these will be updated later as data is added\n836:         self.dataLim = mtransforms.Bbox.null()\n837:         self._viewLim = mtransforms.Bbox.unit()\n838:         self.transScale = mtransforms.TransformWrapper(\n839:             mtransforms.IdentityTransform())\n840: \n841:         self._set_lim_and_transforms()\n842: \n843:     def _unstale_viewLim(self):\n844:         # We should arrange to store this information once per share-group\n845:         # instead of on every axis.\n846:         need_scale = {\n847:             name: any(ax._stale_viewlims[name]\n848:                       for ax in self._shared_axes[name].get_siblings(self))\n849:             for name in self._axis_names}\n850:         if any(need_scale.values()):\n851:             for name in need_scale:\n852:                 for ax in self._shared_axes[name].get_siblings(self):\n853:                     ax._stale_viewlims[name] = False\n854:             self.autoscale_view(**{f\"scale{name}\": scale\n855:                                    for name, scale in need_scale.items()})\n856: \n857:     @property\n858:     def viewLim(self):\n859:         self._unstale_viewLim()\n860:         return self._viewLim\n861: \n862:     def _request_autoscale_view(self, axis=\"all\", tight=None):\n863:         \"\"\"\n864:         Mark a single axis, or all of them, as stale wrt. autoscaling.\n865: \n866:         No computation is performed until the next autoscaling; thus, separate\n867:         calls to control individual axises incur negligible performance cost.\n868: \n869:         Parameters\n870:         ----------\n871:         axis : str, default: \"all\"\n872:             Either an element of ``self._axis_names``, or \"all\".\n873:         tight : bool or None, default: None\n874:         \"\"\"\n875:         axis_names = _api.check_getitem(\n876:             {**{k: [k] for k in self._axis_names}, \"all\": self._axis_names},\n877:             axis=axis)\n878:         for name in axis_names:\n879:             self._stale_viewlims[name] = True\n880:         if tight is not None:\n881:             self._tight = tight\n882: \n883:     def _set_lim_and_transforms(self):\n884:         \"\"\"\n885:         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,\n886:         *transData*, *transLimits* and *transAxes* transformations.\n887: \n888:         .. note::\n889: \n890:             This method is primarily used by rectilinear projections of the\n891:             `~matplotlib.axes.Axes` class, and is meant to be overridden by\n892:             new kinds of projection Axes that need different transformations\n893:             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an\n894:             example.)\n895:         \"\"\"\n896:         self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n897: \n898:         # Transforms the x and y axis separately by a scale factor.\n899:         # It is assumed that this part will have non-linear components\n900:         # (e.g., for a log scale).\n901:         self.transScale = mtransforms.TransformWrapper(\n902:             mtransforms.IdentityTransform())\n903: \n904:         # An affine transformation on the data, generally to limit the\n905:         # range of the axes\n906:         self.transLimits = mtransforms.BboxTransformFrom(\n907:             mtransforms.TransformedBbox(self._viewLim, self.transScale))\n908: \n909:         # The parentheses are important for efficiency here -- they\n910:         # group the last two (which are usually affines) separately\n911:         # from the first (which, with log-scaling can be non-affine).\n912:         self.transData = self.transScale + (self.transLimits + self.transAxes)\n913: \n914:         self._xaxis_transform = mtransforms.blended_transform_factory(\n915:             self.transData, self.transAxes)\n916:         self._yaxis_transform = mtransforms.blended_transform_factory(\n917:             self.transAxes, self.transData)\n918: \n919:     def get_xaxis_transform(self, which='grid'):\n920:         \"\"\"\n921:         Get the transformation used for drawing x-axis labels, ticks\n922:         and gridlines.  The x-direction is in data coordinates and the\n923:         y-direction is in axis coordinates.\n924: \n925:         .. note::\n926: \n927:             This transformation is primarily used by the\n928:             `~matplotlib.axis.Axis` class, and is meant to be\n929:             overridden by new kinds of projections that may need to\n930:             place axis elements in different locations.\n931: \n932:         Parameters\n933:         ----------\n934:         which : {'grid', 'tick1', 'tick2'}\n935:         \"\"\"\n936:         if which == 'grid':\n937:             return self._xaxis_transform\n938:         elif which == 'tick1':\n939:             # for cartesian projection, this is bottom spine\n940:             return self.spines.bottom.get_spine_transform()\n941:         elif which == 'tick2':\n942:             # for cartesian projection, this is top spine\n943:             return self.spines.top.get_spine_transform()\n944:         else:\n945:             raise ValueError(f'unknown value for which: {which!r}')\n946: \n947:     def get_xaxis_text1_transform(self, pad_points):\n948:         \"\"\"\n949:         Returns\n950:         -------\n951:         transform : Transform\n952:             The transform used for drawing x-axis labels, which will add\n953:             *pad_points* of padding (in points) between the axis and the label.\n954:             The x-direction is in data coordinates and the y-direction is in\n955:             axis coordinates\n956:         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n957:             The text vertical alignment.\n958:         halign : {'center', 'left', 'right'}\n959:             The text horizontal alignment.\n960: \n961:         Notes\n962:         -----\n963:         This transformation is primarily used by the `~matplotlib.axis.Axis`\n964:         class, and is meant to be overridden by new kinds of projections that\n965:         may need to place axis elements in different locations.\n966:         \"\"\"\n967:         labels_align = mpl.rcParams[\"xtick.alignment\"]\n968:         return (self.get_xaxis_transform(which='tick1') +\n969:                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,\n970:                                               self.figure.dpi_scale_trans),\n971:                 \"top\", labels_align)\n972: \n973:     def get_xaxis_text2_transform(self, pad_points):\n974:         \"\"\"\n975:         Returns\n976:         -------\n977:         transform : Transform\n978:             The transform used for drawing secondary x-axis labels, which will\n979:             add *pad_points* of padding (in points) between the axis and the\n980:             label.  The x-direction is in data coordinates and the y-direction\n981:             is in axis coordinates\n982:         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n983:             The text vertical alignment.\n984:         halign : {'center', 'left', 'right'}\n985:             The text horizontal alignment.\n986: \n987:         Notes\n988:         -----\n989:         This transformation is primarily used by the `~matplotlib.axis.Axis`\n990:         class, and is meant to be overridden by new kinds of projections that\n991:         may need to place axis elements in different locations.\n992:         \"\"\"\n993:         labels_align = mpl.rcParams[\"xtick.alignment\"]\n994:         return (self.get_xaxis_transform(which='tick2') +\n995:                 mtransforms.ScaledTranslation(0, pad_points / 72,\n996:                                               self.figure.dpi_scale_trans),\n997:                 \"bottom\", labels_align)\n998: \n999:     def get_yaxis_transform(self, which='grid'):\n1000:         \"\"\"\n1001:         Get the transformation used for drawing y-axis labels, ticks\n1002:         and gridlines.  The x-direction is in axis coordinates and the\n1003:         y-direction is in data coordinates.\n1004: \n1005:         .. note::\n1006: \n1007:             This transformation is primarily used by the\n1008:             `~matplotlib.axis.Axis` class, and is meant to be\n1009:             overridden by new kinds of projections that may need to\n1010:             place axis elements in different locations.\n1011: \n1012:         Parameters\n1013:         ----------\n1014:         which : {'grid', 'tick1', 'tick2'}\n1015:         \"\"\"\n1016:         if which == 'grid':\n1017:             return self._yaxis_transform\n1018:         elif which == 'tick1':\n1019:             # for cartesian projection, this is bottom spine\n1020:             return self.spines.left.get_spine_transform()\n1021:         elif which == 'tick2':\n1022:             # for cartesian projection, this is top spine\n1023:             return self.spines.right.get_spine_transform()\n1024:         else:\n1025:             raise ValueError(f'unknown value for which: {which!r}')\n1026: \n1027:     def get_yaxis_text1_transform(self, pad_points):\n1028:         \"\"\"\n1029:         Returns\n1030:         -------\n1031:         transform : Transform\n1032:             The transform used for drawing y-axis labels, which will add\n1033:             *pad_points* of padding (in points) between the axis and the label.\n1034:             The x-direction is in axis coordinates and the y-direction is in\n1035:             data coordinates\n1036:         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n1037:             The text vertical alignment.\n1038:         halign : {'center', 'left', 'right'}\n1039:             The text horizontal alignment.\n1040: \n1041:         Notes\n1042:         -----\n1043:         This transformation is primarily used by the `~matplotlib.axis.Axis`\n1044:         class, and is meant to be overridden by new kinds of projections that\n1045:         may need to place axis elements in different locations.\n1046:         \"\"\"\n1047:         labels_align = mpl.rcParams[\"ytick.alignment\"]\n1048:         return (self.get_yaxis_transform(which='tick1') +\n1049:                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,\n1050:                                               self.figure.dpi_scale_trans),\n1051:                 labels_align, \"right\")\n1052: \n1053:     def get_yaxis_text2_transform(self, pad_points):\n1054:         \"\"\"\n1055:         Returns\n1056:         -------\n1057:         transform : Transform\n1058:             The transform used for drawing secondart y-axis labels, which will\n1059:             add *pad_points* of padding (in points) between the axis and the\n1060:             label.  The x-direction is in axis coordinates and the y-direction\n1061:             is in data coordinates\n1062:         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n1063:             The text vertical alignment.\n1064:         halign : {'center', 'left', 'right'}\n1065:             The text horizontal alignment.\n1066: \n1067:         Notes\n1068:         -----\n1069:         This transformation is primarily used by the `~matplotlib.axis.Axis`\n1070:         class, and is meant to be overridden by new kinds of projections that\n1071:         may need to place axis elements in different locations.\n1072:         \"\"\"\n1073:         labels_align = mpl.rcParams[\"ytick.alignment\"]\n1074:         return (self.get_yaxis_transform(which='tick2') +\n1075:                 mtransforms.ScaledTranslation(pad_points / 72, 0,\n1076:                                               self.figure.dpi_scale_trans),\n1077:                 labels_align, \"left\")\n1078: \n1079:     def _update_transScale(self):\n1080:         self.transScale.set(\n1081:             mtransforms.blended_transform_factory(\n1082:                 self.xaxis.get_transform(), self.yaxis.get_transform()))\n1083:         for line in self._children:\n1084:             if not isinstance(line, mlines.Line2D):\n1085:                 continue\n1086:             try:\n1087:                 line._transformed_path.invalidate()\n1088:             except AttributeError:\n1089:                 pass\n1090: \n1091:     def get_position(self, original=False):\n1092:         \"\"\"\n1093:         Return the position of the Axes within the figure as a `.Bbox`.\n1094: \n1095:         Parameters\n1096:         ----------\n1097:         original : bool\n1098:             If ``True``, return the original position. Otherwise, return the\n1099:             active position. For an explanation of the positions see\n1100:             `.set_position`.\n1101: \n1102:         Returns\n1103:         -------\n1104:         `.Bbox`\n1105: \n1106:         \"\"\"\n1107:         if original:\n1108:             return self._originalPosition.frozen()\n1109:         else:\n1110:             locator = self.get_axes_locator()\n1111:             if not locator:\n1112:                 self.apply_aspect()\n1113:             return self._position.frozen()\n1114: \n1115:     def set_position(self, pos, which='both'):\n1116:         \"\"\"\n1117:         Set the Axes position.\n1118: \n1119:         Axes have two position attributes. The 'original' position is the\n1120:         position allocated for the Axes. The 'active' position is the\n1121:         position the Axes is actually drawn at. These positions are usually\n1122:         the same unless a fixed aspect is set to the Axes. See\n1123:         `.Axes.set_aspect` for details.\n1124: \n1125:         Parameters\n1126:         ----------\n1127:         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`\n1128:             The new position of the Axes in `.Figure` coordinates.\n1129: \n1130:         which : {'both', 'active', 'original'}, default: 'both'\n1131:             Determines which position variables to change.\n1132: \n1133:         See Also\n1134:         --------\n1135:         matplotlib.transforms.Bbox.from_bounds\n1136:         matplotlib.transforms.Bbox.from_extents\n1137:         \"\"\"\n1138:         self._set_position(pos, which=which)\n1139:         # because this is being called externally to the library we\n1140:         # don't let it be in the layout.\n1141:         self.set_in_layout(False)\n1142: \n1143:     def _set_position(self, pos, which='both'):\n1144:         \"\"\"\n1145:         Private version of set_position.\n1146: \n1147:         Call this internally to get the same functionality of `set_position`,\n1148:         but not to take the axis out of the constrained_layout hierarchy.\n1149:         \"\"\"\n1150:         if not isinstance(pos, mtransforms.BboxBase):\n1151:             pos = mtransforms.Bbox.from_bounds(*pos)\n1152:         for ax in self._twinned_axes.get_siblings(self):\n1153:             if which in ('both', 'active'):\n1154:                 ax._position.set(pos)\n1155:             if which in ('both', 'original'):\n1156:                 ax._originalPosition.set(pos)\n1157:         self.stale = True\n1158: \n1159:     def reset_position(self):\n1160:         \"\"\"\n1161:         Reset the active position to the original position.\n1162: \n1163:         This undoes changes to the active position (as defined in\n1164:         `.set_position`) which may have been performed to satisfy fixed-aspect\n1165:         constraints.\n1166:         \"\"\"\n1167:         for ax in self._twinned_axes.get_siblings(self):\n1168:             pos = ax.get_position(original=True)\n1169:             ax.set_position(pos, which='active')\n1170: \n1171:     def set_axes_locator(self, locator):\n1172:         \"\"\"\n1173:         Set the Axes locator.\n1174: \n1175:         Parameters\n1176:         ----------\n1177:         locator : Callable[[Axes, Renderer], Bbox]\n1178:         \"\"\"\n1179:         self._axes_locator = locator\n1180:         self.stale = True\n1181: \n1182:     def get_axes_locator(self):\n1183:         \"\"\"\n1184:         Return the axes_locator.\n1185:         \"\"\"\n1186:         return self._axes_locator\n1187: \n1188:     def _set_artist_props(self, a):\n1189:         \"\"\"Set the boilerplate props for artists added to Axes.\"\"\"\n1190:         a.set_figure(self.figure)\n1191:         if not a.is_transform_set():\n1192:             a.set_transform(self.transData)\n1193: \n1194:         a.axes = self\n1195:         if a.get_mouseover():\n1196:             self._mouseover_set.add(a)\n1197: \n1198:     def _gen_axes_patch(self):\n1199:         \"\"\"\n1200:         Returns\n1201:         -------\n1202:         Patch\n1203:             The patch used to draw the background of the Axes.  It is also used\n1204:             as the clipping path for any data elements on the Axes.\n1205: \n1206:             In the standard Axes, this is a rectangle, but in other projections\n1207:             it may not be.\n1208: \n1209:         Notes\n1210:         -----\n1211:         Intended to be overridden by new projection types.\n1212:         \"\"\"\n1213:         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)\n1214: \n1215:     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):\n1216:         \"\"\"\n1217:         Returns\n1218:         -------\n1219:         dict\n1220:             Mapping of spine names to `.Line2D` or `.Patch` instances that are\n1221:             used to draw Axes spines.\n1222: \n1223:             In the standard Axes, spines are single line segments, but in other\n1224:             projections they may not be.\n1225: \n1226:         Notes\n1227:         -----\n1228:         Intended to be overridden by new projection types.\n1229:         \"\"\"\n1230:         return {side: mspines.Spine.linear_spine(self, side)\n1231:                 for side in ['left', 'right', 'bottom', 'top']}\n1232: \n1233:     def sharex(self, other):\n1234:         \"\"\"\n1235:         Share the x-axis with *other*.\n1236: \n1237:         This is equivalent to passing ``sharex=other`` when constructing the\n1238:         Axes, and cannot be used if the x-axis is already being shared with\n1239:         another Axes.\n1240:         \"\"\"\n1241:         _api.check_isinstance(_AxesBase, other=other)\n1242:         if self._sharex is not None and other is not self._sharex:\n1243:             raise ValueError(\"x-axis is already shared\")\n1244:         self._shared_axes[\"x\"].join(self, other)\n1245:         self._sharex = other\n1246:         self.xaxis.major = other.xaxis.major  # Ticker instances holding\n1247:         self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n1248:         x0, x1 = other.get_xlim()\n1249:         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n1250:         self.xaxis._scale = other.xaxis._scale\n1251: \n1252:     def sharey(self, other):\n1253:         \"\"\"\n1254:         Share the y-axis with *other*.\n1255: \n1256:         This is equivalent to passing ``sharey=other`` when constructing the\n1257:         Axes, and cannot be used if the y-axis is already being shared with\n1258:         another Axes.\n1259:         \"\"\"\n1260:         _api.check_isinstance(_AxesBase, other=other)\n1261:         if self._sharey is not None and other is not self._sharey:\n1262:             raise ValueError(\"y-axis is already shared\")\n1263:         self._shared_axes[\"y\"].join(self, other)\n1264:         self._sharey = other\n1265:         self.yaxis.major = other.yaxis.major  # Ticker instances holding\n1266:         self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n1267:         y0, y1 = other.get_ylim()\n1268:         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n1269:         self.yaxis._scale = other.yaxis._scale\n1270: \n1271:     def __clear(self):\n1272:         \"\"\"Clear the Axes.\"\"\"\n1273:         # The actual implementation of clear() as long as clear() has to be\n1274:         # an adapter delegating to the correct implementation.\n1275:         # The implementation can move back into clear() when the\n1276:         # deprecation on cla() subclassing expires.\n1277: \n1278:         # stash the current visibility state\n1279:         if hasattr(self, 'patch'):\n1280:             patch_visible = self.patch.get_visible()\n1281:         else:\n1282:             patch_visible = True\n1283: \n1284:         xaxis_visible = self.xaxis.get_visible()\n1285:         yaxis_visible = self.yaxis.get_visible()\n1286: \n1287:         for axis in self._axis_map.values():\n1288:             axis.clear()  # Also resets the scale to linear.\n1289:         for spine in self.spines.values():\n1290:             spine.clear()\n1291: \n1292:         self.ignore_existing_data_limits = True\n1293:         self.callbacks = cbook.CallbackRegistry(\n1294:             signals=[\"xlim_changed\", \"ylim_changed\", \"zlim_changed\"])\n1295: \n1296:         # update the minor locator for x and y axis based on rcParams\n1297:         if mpl.rcParams['xtick.minor.visible']:\n1298:             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n1299:         if mpl.rcParams['ytick.minor.visible']:\n1300:             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n1301: \n1302:         self._xmargin = mpl.rcParams['axes.xmargin']\n1303:         self._ymargin = mpl.rcParams['axes.ymargin']\n1304:         self._tight = None\n1305:         self._use_sticky_edges = True\n1306: \n1307:         self._get_lines = _process_plot_var_args(self)\n1308:         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')\n1309: \n1310:         self._gridOn = mpl.rcParams['axes.grid']\n1311:         self._children = []\n1312:         self._mouseover_set = _OrderedSet()\n1313:         self.child_axes = []\n1314:         self._current_image = None  # strictly for pyplot via _sci, _gci\n1315:         self._projection_init = None  # strictly for pyplot.subplot\n1316:         self.legend_ = None\n1317:         self.containers = []\n1318: \n1319:         self.grid(False)  # Disable grid on init to use rcParameter\n1320:         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],\n1321:                   axis=mpl.rcParams['axes.grid.axis'])\n1322:         props = font_manager.FontProperties(\n1323:             size=mpl.rcParams['axes.titlesize'],\n1324:             weight=mpl.rcParams['axes.titleweight'])\n1325: \n1326:         y = mpl.rcParams['axes.titley']\n1327:         if y is None:\n1328:             y = 1.0\n1329:             self._autotitlepos = True\n1330:         else:\n1331:             self._autotitlepos = False\n1332: \n1333:         self.title = mtext.Text(\n1334:             x=0.5, y=y, text='',\n1335:             fontproperties=props,\n1336:             verticalalignment='baseline',\n1337:             horizontalalignment='center',\n1338:             )\n1339:         self._left_title = mtext.Text(\n1340:             x=0.0, y=y, text='',\n1341:             fontproperties=props.copy(),\n1342:             verticalalignment='baseline',\n1343:             horizontalalignment='left', )\n1344:         self._right_title = mtext.Text(\n1345:             x=1.0, y=y, text='',\n1346:             fontproperties=props.copy(),\n1347:             verticalalignment='baseline',\n1348:             horizontalalignment='right',\n1349:             )\n1350:         title_offset_points = mpl.rcParams['axes.titlepad']\n1351:         # refactor this out so it can be called in ax.set_title if\n1352:         # pad argument used...\n1353:         self._set_title_offset_trans(title_offset_points)\n1354: \n1355:         for _title in (self.title, self._left_title, self._right_title):\n1356:             self._set_artist_props(_title)\n1357: \n1358:         # The patch draws the background of the Axes.  We want this to be below\n1359:         # the other artists.  We use the frame to draw the edges so we are\n1360:         # setting the edgecolor to None.\n1361:         self.patch = self._gen_axes_patch()\n1362:         self.patch.set_figure(self.figure)\n1363:         self.patch.set_facecolor(self._facecolor)\n1364:         self.patch.set_edgecolor('none')\n1365:         self.patch.set_linewidth(0)\n1366:         self.patch.set_transform(self.transAxes)\n1367: \n1368:         self.set_axis_on()\n1369: \n1370:         self.xaxis.set_clip_path(self.patch)\n1371:         self.yaxis.set_clip_path(self.patch)\n1372: \n1373:         self._shared_axes[\"x\"].clean()\n1374:         self._shared_axes[\"y\"].clean()\n1375:         if self._sharex is not None:\n1376:             self.xaxis.set_visible(xaxis_visible)\n1377:             self.patch.set_visible(patch_visible)\n1378:         if self._sharey is not None:\n1379:             self.yaxis.set_visible(yaxis_visible)\n1380:             self.patch.set_visible(patch_visible)\n1381: \n1382:         # This comes last, as the call to _set_lim may trigger an autoscale (in\n1383:         # case of shared axes), requiring children to be already set up.\n1384:         for name, axis in self._axis_map.items():\n1385:             share = getattr(self, f\"_share{name}\")\n1386:             if share is not None:\n1387:                 getattr(self, f\"share{name}\")(share)\n1388:             else:\n1389:                 axis._set_scale(\"linear\")\n1390:                 axis._set_lim(0, 1, auto=True)\n1391:         self._update_transScale()\n1392: \n1393:         self.stale = True\n1394: \n1395:     def clear(self):\n1396:         \"\"\"Clear the Axes.\"\"\"\n1397:         # Act as an alias, or as the superclass implementation depending on the\n1398:         # subclass implementation.\n1399:         if self._subclass_uses_cla:\n1400:             self.cla()\n1401:         else:\n1402:             self.__clear()\n1403: \n1404:     def cla(self):\n1405:         \"\"\"Clear the Axes.\"\"\"\n1406:         # Act as an alias, or as the superclass implementation depending on the\n1407:         # subclass implementation.\n1408:         if self._subclass_uses_cla:\n1409:             self.__clear()\n1410:         else:\n1411:             self.clear()\n1412: \n1413:     class ArtistList(MutableSequence):\n1414:         \"\"\"\n1415:         A sublist of Axes children based on their type.\n1416: \n1417:         The type-specific children sublists will become immutable in\n1418:         Matplotlib 3.7. Then, these artist lists will likely be replaced by\n1419:         tuples. Use as if this is a tuple already.\n1420: \n1421:         This class exists only for the transition period to warn on the\n1422:         deprecated modification of artist lists.\n1423:         \"\"\"\n1424:         def __init__(self, axes, prop_name, add_name,\n1425:                      valid_types=None, invalid_types=None):\n1426:             \"\"\"\n1427:             Parameters\n1428:             ----------\n1429:             axes : `~matplotlib.axes.Axes`\n1430:                 The Axes from which this sublist will pull the children\n1431:                 Artists.\n1432:             prop_name : str\n1433:                 The property name used to access this sublist from the Axes;\n1434:                 used to generate deprecation warnings.\n1435:             add_name : str\n1436:                 The method name used to add Artists of this sublist's type to\n1437:                 the Axes; used to generate deprecation warnings.\n1438:             valid_types : list of type, optional\n1439:                 A list of types that determine which children will be returned\n1440:                 by this sublist. If specified, then the Artists in the sublist\n1441:                 must be instances of any of these types. If unspecified, then\n1442:                 any type of Artist is valid (unless limited by\n1443:                 *invalid_types*.)\n1444:             invalid_types : tuple, optional\n1445:                 A list of types that determine which children will *not* be\n1446:                 returned by this sublist. If specified, then Artists in the\n1447:                 sublist will never be an instance of these types. Otherwise, no\n1448:                 types will be excluded.\n1449:             \"\"\"\n1450:             self._axes = axes\n1451:             self._prop_name = prop_name\n1452:             self._add_name = add_name\n1453:             self._type_check = lambda artist: (\n1454:                 (not valid_types or isinstance(artist, valid_types)) and\n1455:                 (not invalid_types or not isinstance(artist, invalid_types))\n1456:             )\n1457: \n1458:         def __repr__(self):\n1459:             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n1460: \n1461:         def __len__(self):\n1462:             return sum(self._type_check(artist)\n1463:                        for artist in self._axes._children)\n1464: \n1465:         def __iter__(self):\n1466:             for artist in list(self._axes._children):\n1467:                 if self._type_check(artist):\n1468:                     yield artist\n1469: \n1470:         def __getitem__(self, key):\n1471:             return [artist\n1472:                     for artist in self._axes._children\n1473:                     if self._type_check(artist)][key]\n1474: \n1475:         def __add__(self, other):\n1476:             if isinstance(other, (list, _AxesBase.ArtistList)):\n1477:                 return [*self, *other]\n1478:             return NotImplemented\n1479: \n1480:         def __radd__(self, other):\n1481:             if isinstance(other, list):\n1482:                 return other + list(self)\n1483:             return NotImplemented\n1484: \n1485:         def insert(self, index, item):\n1486:             _api.warn_deprecated(\n1487:                 '3.5',\n1488:                 name=f'modification of the Axes.{self._prop_name}',\n1489:                 obj_type='property',\n1490:                 alternative=f'Axes.{self._add_name}')\n1491:             try:\n1492:                 index = self._axes._children.index(self[index])\n1493:             except IndexError:\n1494:                 index = None\n1495:             getattr(self._axes, self._add_name)(item)\n1496:             if index is not None:\n1497:                 # Move new item to the specified index, if there's something to\n1498:                 # put it before.\n1499:                 self._axes._children[index:index] = self._axes._children[-1:]\n1500:                 del self._axes._children[-1]\n1501: \n1502:         def __setitem__(self, key, item):\n1503:             _api.warn_deprecated(\n1504:                 '3.5',\n1505:                 name=f'modification of the Axes.{self._prop_name}',\n1506:                 obj_type='property',\n1507:                 alternative=f'Artist.remove() and Axes.f{self._add_name}')\n1508:             del self[key]\n1509:             if isinstance(key, slice):\n1510:                 key = key.start\n1511:             if not np.iterable(item):\n1512:                 self.insert(key, item)\n1513:                 return\n1514: \n1515:             try:\n1516:                 index = self._axes._children.index(self[key])\n1517:             except IndexError:\n1518:                 index = None\n1519:             for i, artist in enumerate(item):\n1520:                 getattr(self._axes, self._add_name)(artist)\n1521:             if index is not None:\n1522:                 # Move new items to the specified index, if there's something\n1523:                 # to put it before.\n1524:                 i = -(i + 1)\n1525:                 self._axes._children[index:index] = self._axes._children[i:]\n1526:                 del self._axes._children[i:]\n1527: \n1528:         def __delitem__(self, key):\n1529:             _api.warn_deprecated(\n1530:                 '3.5',\n1531:                 name=f'modification of the Axes.{self._prop_name}',\n1532:                 obj_type='property',\n1533:                 alternative='Artist.remove()')\n1534:             if isinstance(key, slice):\n1535:                 for artist in self[key]:\n1536:                     artist.remove()\n1537:             else:\n1538:                 self[key].remove()\n1539: \n1540:     @property\n1541:     def artists(self):\n1542:         return self.ArtistList(self, 'artists', 'add_artist', invalid_types=(\n1543:             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n1544:             mtable.Table, mtext.Text))\n1545: \n1546:     @property\n1547:     def collections(self):\n1548:         return self.ArtistList(self, 'collections', 'add_collection',\n1549:                                valid_types=mcoll.Collection)\n1550: \n1551:     @property\n1552:     def images(self):\n1553:         return self.ArtistList(self, 'images', 'add_image',\n1554:                                valid_types=mimage.AxesImage)\n1555: \n1556:     @property\n1557:     def lines(self):\n1558:         return self.ArtistList(self, 'lines', 'add_line',\n1559:                                valid_types=mlines.Line2D)\n1560: \n1561:     @property\n1562:     def patches(self):\n1563:         return self.ArtistList(self, 'patches', 'add_patch',\n1564:                                valid_types=mpatches.Patch)\n1565: \n1566:     @property\n1567:     def tables(self):\n1568:         return self.ArtistList(self, 'tables', 'add_table',\n1569:                                valid_types=mtable.Table)\n1570: \n1571:     @property\n1572:     def texts(self):\n1573:         return self.ArtistList(self, 'texts', 'add_artist',\n1574:                                valid_types=mtext.Text)\n1575: \n1576:     def get_facecolor(self):\n1577:         \"\"\"Get the facecolor of the Axes.\"\"\"\n1578:         return self.patch.get_facecolor()\n1579: \n1580:     def set_facecolor(self, color):\n1581:         \"\"\"\n1582:         Set the facecolor of the Axes.\n1583: \n1584:         Parameters\n1585:         ----------\n1586:         color : color\n1587:         \"\"\"\n1588:         self._facecolor = color\n1589:         self.stale = True\n1590:         return self.patch.set_facecolor(color)\n1591: \n1592:     def _set_title_offset_trans(self, title_offset_points):\n1593:         \"\"\"\n1594:         Set the offset for the title either from :rc:`axes.titlepad`\n1595:         or from set_title kwarg ``pad``.\n1596:         \"\"\"\n1597:         self.titleOffsetTrans = mtransforms.ScaledTranslation(\n1598:                 0.0, title_offset_points / 72,\n1599:                 self.figure.dpi_scale_trans)\n1600:         for _title in (self.title, self._left_title, self._right_title):\n1601:             _title.set_transform(self.transAxes + self.titleOffsetTrans)\n1602:             _title.set_clip_box(None)\n1603: \n1604:     def set_prop_cycle(self, *args, **kwargs):\n1605:         \"\"\"\n1606:         Set the property cycle of the Axes.\n1607: \n1608:         The property cycle controls the style properties such as color,\n1609:         marker and linestyle of future plot commands. The style properties\n1610:         of data already added to the Axes are not modified.\n1611: \n1612:         Call signatures::\n1613: \n1614:           set_prop_cycle(cycler)\n1615:           set_prop_cycle(label=values[, label2=values2[, ...]])\n1616:           set_prop_cycle(label, values)\n1617: \n1618:         Form 1 sets given `~cycler.Cycler` object.\n1619: \n1620:         Form 2 creates a `~cycler.Cycler` which cycles over one or more\n1621:         properties simultaneously and set it as the property cycle of the\n1622:         Axes. If multiple properties are given, their value lists must have\n1623:         the same length. This is just a shortcut for explicitly creating a\n1624:         cycler and passing it to the function, i.e. it's short for\n1625:         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.\n1626: \n1627:         Form 3 creates a `~cycler.Cycler` for a single property and set it\n1628:         as the property cycle of the Axes. This form exists for compatibility\n1629:         with the original `cycler.cycler` interface. Its use is discouraged\n1630:         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.\n1631: \n1632:         Parameters\n1633:         ----------\n1634:         cycler : Cycler\n1635:             Set the given Cycler. *None* resets to the cycle defined by the\n1636:             current style.\n1637: \n1638:         label : str\n1639:             The property key. Must be a valid `.Artist` property.\n1640:             For example, 'color' or 'linestyle'. Aliases are allowed,\n1641:             such as 'c' for 'color' and 'lw' for 'linewidth'.\n1642: \n1643:         values : iterable\n1644:             Finite-length iterable of the property values. These values\n1645:             are validated and will raise a ValueError if invalid.\n1646: \n1647:         See Also\n1648:         --------\n1649:         matplotlib.rcsetup.cycler\n1650:             Convenience function for creating validated cyclers for properties.\n1651:         cycler.cycler\n1652:             The original function for creating unvalidated cyclers.\n1653: \n1654:         Examples\n1655:         --------\n1656:         Setting the property cycle for a single property:\n1657: \n1658:         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])\n1659: \n1660:         Setting the property cycle for simultaneously cycling over multiple\n1661:         properties (e.g. red circle, green plus, blue cross):\n1662: \n1663:         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],\n1664:         ...                   marker=['o', '+', 'x'])\n1665: \n1666:         \"\"\"\n1667:         if args and kwargs:\n1668:             raise TypeError(\"Cannot supply both positional and keyword \"\n1669:                             \"arguments to this method.\")\n1670:         # Can't do `args == (None,)` as that crashes cycler.\n1671:         if len(args) == 1 and args[0] is None:\n1672:             prop_cycle = None\n1673:         else:\n1674:             prop_cycle = cycler(*args, **kwargs)\n1675:         self._get_lines.set_prop_cycle(prop_cycle)\n1676:         self._get_patches_for_fill.set_prop_cycle(prop_cycle)\n1677: \n1678:     def get_aspect(self):\n1679:         \"\"\"\n1680:         Return the aspect ratio of the axes scaling.\n1681: \n1682:         This is either \"auto\" or a float giving the ratio of y/x-scale.\n1683:         \"\"\"\n1684:         return self._aspect\n1685: \n1686:     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):\n1687:         \"\"\"\n1688:         Set the aspect ratio of the axes scaling, i.e. y/x-scale.\n1689: \n1690:         Parameters\n1691:         ----------\n1692:         aspect : {'auto', 'equal'} or float\n1693:             Possible values:\n1694: \n1695:             - 'auto': fill the position rectangle with data.\n1696:             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.\n1697:             - *float*: The displayed size of 1 unit in y-data coordinates will\n1698:               be *aspect* times the displayed size of 1 unit in x-data\n1699:               coordinates; e.g. for ``aspect=2`` a square in data coordinates\n1700:               will be rendered with a height of twice its width.\n1701: \n1702:         adjustable : None or {'box', 'datalim'}, optional\n1703:             If not ``None``, this defines which parameter will be adjusted to\n1704:             meet the required aspect. See `.set_adjustable` for further\n1705:             details.\n1706: \n1707:         anchor : None or str or (float, float), optional\n1708:             If not ``None``, this defines where the Axes will be drawn if there\n1709:             is extra space due to aspect constraints. The most common way\n1710:             to specify the anchor are abbreviations of cardinal directions:\n1711: \n1712:             =====   =====================\n1713:             value   description\n1714:             =====   =====================\n1715:             'C'     centered\n1716:             'SW'    lower left corner\n1717:             'S'     middle of bottom edge\n1718:             'SE'    lower right corner\n1719:             etc.\n1720:             =====   =====================\n1721: \n1722:             See `~.Axes.set_anchor` for further details.\n1723: \n1724:         share : bool, default: False\n1725:             If ``True``, apply the settings to all shared Axes.\n1726: \n1727:         See Also\n1728:         --------\n1729:         matplotlib.axes.Axes.set_adjustable\n1730:             Set how the Axes adjusts to achieve the required aspect ratio.\n1731:         matplotlib.axes.Axes.set_anchor\n1732:             Set the position in case of extra space.\n1733:         \"\"\"\n1734:         if cbook._str_equal(aspect, 'equal'):\n1735:             aspect = 1\n1736:         if not cbook._str_equal(aspect, 'auto'):\n1737:             aspect = float(aspect)  # raise ValueError if necessary\n1738:             if aspect <= 0 or not np.isfinite(aspect):\n1739:                 raise ValueError(\"aspect must be finite and positive \")\n1740: \n1741:         if share:\n1742:             axes = {sibling for name in self._axis_names\n1743:                     for sibling in self._shared_axes[name].get_siblings(self)}\n1744:         else:\n1745:             axes = [self]\n1746: \n1747:         for ax in axes:\n1748:             ax._aspect = aspect\n1749: \n1750:         if adjustable is None:\n1751:             adjustable = self._adjustable\n1752:         self.set_adjustable(adjustable, share=share)  # Handle sharing.\n1753: \n1754:         if anchor is not None:\n1755:             self.set_anchor(anchor, share=share)\n1756:         self.stale = True\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/axes/_base.py",
      "suspect_lines": [
        1318
      ]
    }
  ]
}