{
  "instance_id": "django__django-14140",
  "problem_statement": "Combining Q() objects with boolean expressions crashes.\nDescription\n\t \n\t\t(last modified by jonathan-golorry)\n\t \nCurrently Q objects with 1 child are treated differently during deconstruct.\n>>> from django.db.models import Q\n>>> Q(x=1).deconstruct()\n('django.db.models.Q', (), {'x': 1})\n>>> Q(x=1, y=2).deconstruct()\n('django.db.models.Q', (('x', 1), ('y', 2)), {})\nThis causes issues when deconstructing Q objects with a non-subscriptable child.\n>>> from django.contrib.auth import get_user_model\n>>> from django.db.models import Exists\n>>> Q(Exists(get_user_model().objects.filter(username='jim'))).deconstruct()\nTraceback (most recent call last):\n File \"<console>\", line 1, in <module>\n File \"...\", line 90, in deconstruct\n\tkwargs = {child[0]: child[1]}\nTypeError: 'Exists' object is not subscriptable\nPatch â€‹https://github.com/django/django/pull/14126 removes the special case, meaning single-child Q objects deconstruct into args instead of kwargs. A more backward-compatible approach would be to keep the special case and explicitly check that the child is a length-2 tuple, but it's unlikely that anyone is relying on this undocumented behavior.\n",
  "localized_code": "[start of django/db/models/query_utils.py]\n1: \"\"\"\n2: Various data structures used in query construction.\n3: \n4: Factored out from django.db.models.query to avoid making the main module very\n5: large and/or so that they can be used by other modules without getting into\n6: circular import difficulties.\n7: \"\"\"\n8: import functools\n9: import inspect\n10: from collections import namedtuple\n11: \n12: from django.core.exceptions import FieldError\n13: from django.db.models.constants import LOOKUP_SEP\n14: from django.utils import tree\n15: \n16: # PathInfo is used when converting lookups (fk__somecol). The contents\n17: # describe the relation in Model terms (model Options and Fields for both\n18: # sides of the relation. The join_field is the field backing the relation.\n19: PathInfo = namedtuple('PathInfo', 'from_opts to_opts target_fields join_field m2m direct filtered_relation')\n20: \n21: \n22: def subclasses(cls):\n23:     yield cls\n24:     for subclass in cls.__subclasses__():\n25:         yield from subclasses(subclass)\n26: \n27: \n28: class Q(tree.Node):\n29:     \"\"\"\n30:     Encapsulate filters as objects that can then be combined logically (using\n31:     `&` and `|`).\n32:     \"\"\"\n33:     # Connection types\n34:     AND = 'AND'\n35:     OR = 'OR'\n36:     default = AND\n37:     conditional = True\n38: \n39:     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n40:         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n41: \n42:     def _combine(self, other, conn):\n43:         if not(isinstance(other, Q) or getattr(other, 'conditional', False) is True):\n44:             raise TypeError(other)\n45: \n46:         # If the other Q() is empty, ignore it and just use `self`.\n47:         if not other:\n48:             _, args, kwargs = self.deconstruct()\n49:             return type(self)(*args, **kwargs)\n50:         # Or if this Q is empty, ignore it and just use `other`.\n51:         elif not self:\n52:             _, args, kwargs = other.deconstruct()\n53:             return type(other)(*args, **kwargs)\n54: \n55:         obj = type(self)()\n56:         obj.connector = conn\n57:         obj.add(self, conn)\n58:         obj.add(other, conn)\n59:         return obj\n60: \n61:     def __or__(self, other):\n62:         return self._combine(other, self.OR)\n63: \n64:     def __and__(self, other):\n65:         return self._combine(other, self.AND)\n66: \n67:     def __invert__(self):\n68:         obj = type(self)()\n69:         obj.add(self, self.AND)\n70:         obj.negate()\n71:         return obj\n72: \n73:     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n74:         # We must promote any new joins to left outer joins so that when Q is\n75:         # used as an expression, rows aren't filtered due to joins.\n76:         clause, joins = query._add_q(\n77:             self, reuse, allow_joins=allow_joins, split_subq=False,\n78:             check_filterable=False,\n79:         )\n80:         query.promote_joins(joins)\n81:         return clause\n82: \n83:     def deconstruct(self):\n84:         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)\n85:         if path.startswith('django.db.models.query_utils'):\n86:             path = path.replace('django.db.models.query_utils', 'django.db.models')\n87:         args, kwargs = (), {}\n88:         if len(self.children) == 1 and not isinstance(self.children[0], Q):\n89:             child = self.children[0]\n90:             kwargs = {child[0]: child[1]}\n91:         else:\n92:             args = tuple(self.children)\n93:             if self.connector != self.default:\n94:                 kwargs = {'_connector': self.connector}\n95:         if self.negated:\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/query_utils.py",
      "suspect_lines": [
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94
      ]
    }
  ]
}