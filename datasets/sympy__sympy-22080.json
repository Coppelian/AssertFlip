{
  "instance_id": "sympy__sympy-22080",
  "problem_statement": "Mod function lambdify bug\nDescription:\r\nWhen lambdifying any function of structure like `expr * Mod(a, b)` sympy moves the multiplier into the first argument of Mod, like `Mod(expr * a, b)`, WHEN we specify `modules=[]`\r\n\r\nThis is an example from Sympy online shell\r\n```\r\n>>> from sympy import Mod, lambdify, symbols\r\n>>> x, y = symbols('x y')\r\n>>> expr = -Mod(x, y)\r\n>>> f = lambdify([x, y], expr)\r\n>>> f(3, 7)\r\n-3\r\n>>> inspect.getsource(f)\r\ndef _lambdifygenerated(x, y):\r\n    return (-mod(x, y))\r\n\r\n\r\n>>> g = lambdify([x, y], expr, modules=[])\r\n>>> g(3, 7)\r\n4\r\n>>> inspect.getsource(g)\r\ndef _lambdifygenerated(x, y):\r\n    return (-x % y)\r\n```\n",
  "localized_code": "[start of sympy/printing/codeprinter.py]\n1: from typing import Any, Dict, Set, Tuple\n2: \n3: from functools import wraps\n4: \n5: from sympy.core import Add, Expr, Mul, Pow, S, sympify, Float\n6: from sympy.core.basic import Basic\n7: from sympy.core.compatibility import default_sort_key\n8: from sympy.core.function import Lambda\n9: from sympy.core.mul import _keep_coeff\n10: from sympy.core.symbol import Symbol\n11: from sympy.printing.str import StrPrinter\n12: from sympy.printing.precedence import precedence\n13: \n14: \n15: class requires:\n16:     \"\"\" Decorator for registering requirements on print methods. \"\"\"\n17:     def __init__(self, **kwargs):\n18:         self._req = kwargs\n19: \n20:     def __call__(self, method):\n21:         def _method_wrapper(self_, *args, **kwargs):\n22:             for k, v in self._req.items():\n23:                 getattr(self_, k).update(v)\n24:             return method(self_, *args, **kwargs)\n25:         return wraps(method)(_method_wrapper)\n26: \n27: \n28: class AssignmentError(Exception):\n29:     \"\"\"\n30:     Raised if an assignment variable for a loop is missing.\n31:     \"\"\"\n32:     pass\n33: \n34: \n35: class CodePrinter(StrPrinter):\n36:     \"\"\"\n37:     The base class for code-printing subclasses.\n38:     \"\"\"\n39: \n40:     _operators = {\n41:         'and': '&&',\n42:         'or': '||',\n43:         'not': '!',\n44:     }\n45: \n46:     _default_settings = {\n47:         'order': None,\n48:         'full_prec': 'auto',\n49:         'error_on_reserved': False,\n50:         'reserved_word_suffix': '_',\n51:         'human': True,\n52:         'inline': False,\n53:         'allow_unknown_functions': False,\n54:     }  # type: Dict[str, Any]\n55: \n56:     # Functions which are \"simple\" to rewrite to other functions that\n57:     # may be supported\n58:     _rewriteable_functions = {\n59:             'erf2': 'erf',\n60:             'Li': 'li',\n61:             'beta': 'gamma'\n62:     }\n63: \n64:     def __init__(self, settings=None):\n65: \n66:         super().__init__(settings=settings)\n67:         if not hasattr(self, 'reserved_words'):\n68:             self.reserved_words = set()\n69: \n70:     def doprint(self, expr, assign_to=None):\n71:         \"\"\"\n72:         Print the expression as code.\n73: \n74:         Parameters\n75:         ----------\n76:         expr : Expression\n77:             The expression to be printed.\n78: \n79:         assign_to : Symbol, string, MatrixSymbol, list of strings or Symbols (optional)\n80:             If provided, the printed code will set the expression to a variable or multiple variables\n81:             with the name or names given in ``assign_to``.\n82:         \"\"\"\n83:         from sympy.matrices.expressions.matexpr import MatrixSymbol\n84:         from sympy.codegen.ast import CodeBlock, Assignment\n85: \n86:         def _handle_assign_to(expr, assign_to):\n87:             if assign_to is None:\n88:                 return sympify(expr)\n89:             if isinstance(assign_to, (list, tuple)):\n90:                 if len(expr) != len(assign_to):\n91:                     raise ValueError('Failed to assign an expression of length {} to {} variables'.format(len(expr), len(assign_to)))\n92:                 return CodeBlock(*[_handle_assign_to(lhs, rhs) for lhs, rhs in zip(expr, assign_to)])\n93:             if isinstance(assign_to, str):\n94:                 if expr.is_Matrix:\n95:                     assign_to = MatrixSymbol(assign_to, *expr.shape)\n96:                 else:\n97:                     assign_to = Symbol(assign_to)\n98:             elif not isinstance(assign_to, Basic):\n99:                 raise TypeError(\"{} cannot assign to object of type {}\".format(\n100:                         type(self).__name__, type(assign_to)))\n101:             return Assignment(assign_to, expr)\n102: \n103:         expr = _handle_assign_to(expr, assign_to)\n104: \n105:         # keep a set of expressions that are not strictly translatable to Code\n106:         # and number constants that must be declared and initialized\n107:         self._not_supported = set()\n108:         self._number_symbols = set()  # type: Set[Tuple[Expr, Float]]\n109: \n110:         lines = self._print(expr).splitlines()\n111: \n112:         # format the output\n113:         if self._settings[\"human\"]:\n114:             frontlines = []\n115:             if self._not_supported:\n116:                 frontlines.append(self._get_comment(\n117:                         \"Not supported in {}:\".format(self.language)))\n118:                 for expr in sorted(self._not_supported, key=str):\n119:                     frontlines.append(self._get_comment(type(expr).__name__))\n120:             for name, value in sorted(self._number_symbols, key=str):\n121:                 frontlines.append(self._declare_number_const(name, value))\n122:             lines = frontlines + lines\n123:             lines = self._format_code(lines)\n124:             result = \"\\n\".join(lines)\n125:         else:\n126:             lines = self._format_code(lines)\n127:             num_syms = {(k, self._print(v)) for k, v in self._number_symbols}\n128:             result = (num_syms, self._not_supported, \"\\n\".join(lines))\n129:         self._not_supported = set()\n130:         self._number_symbols = set()\n131:         return result\n132: \n133:     def _doprint_loops(self, expr, assign_to=None):\n134:         # Here we print an expression that contains Indexed objects, they\n135:         # correspond to arrays in the generated code.  The low-level implementation\n136:         # involves looping over array elements and possibly storing results in temporary\n137:         # variables or accumulate it in the assign_to object.\n138: \n139:         if self._settings.get('contract', True):\n140:             from sympy.tensor import get_contraction_structure\n141:             # Setup loops over non-dummy indices  --  all terms need these\n142:             indices = self._get_expression_indices(expr, assign_to)\n143:             # Setup loops over dummy indices  --  each term needs separate treatment\n144:             dummies = get_contraction_structure(expr)\n145:         else:\n146:             indices = []\n147:             dummies = {None: (expr,)}\n148:         openloop, closeloop = self._get_loop_opening_ending(indices)\n149: \n150:         # terms with no summations first\n151:         if None in dummies:\n152:             text = StrPrinter.doprint(self, Add(*dummies[None]))\n153:         else:\n154:             # If all terms have summations we must initialize array to Zero\n155:             text = StrPrinter.doprint(self, 0)\n156: \n157:         # skip redundant assignments (where lhs == rhs)\n158:         lhs_printed = self._print(assign_to)\n159:         lines = []\n160:         if text != lhs_printed:\n161:             lines.extend(openloop)\n162:             if assign_to is not None:\n163:                 text = self._get_statement(\"%s = %s\" % (lhs_printed, text))\n164:             lines.append(text)\n165:             lines.extend(closeloop)\n166: \n167:         # then terms with summations\n168:         for d in dummies:\n169:             if isinstance(d, tuple):\n170:                 indices = self._sort_optimized(d, expr)\n171:                 openloop_d, closeloop_d = self._get_loop_opening_ending(\n172:                     indices)\n173: \n174:                 for term in dummies[d]:\n175:                     if term in dummies and not ([list(f.keys()) for f in dummies[term]]\n176:                             == [[None] for f in dummies[term]]):\n177:                         # If one factor in the term has it's own internal\n178:                         # contractions, those must be computed first.\n179:                         # (temporary variables?)\n180:                         raise NotImplementedError(\n181:                             \"FIXME: no support for contractions in factor yet\")\n182:                     else:\n183: \n184:                         # We need the lhs expression as an accumulator for\n185:                         # the loops, i.e\n186:                         #\n187:                         # for (int d=0; d < dim; d++){\n188:                         #    lhs[] = lhs[] + term[][d]\n189:                         # }           ^.................. the accumulator\n190:                         #\n191:                         # We check if the expression already contains the\n192:                         # lhs, and raise an exception if it does, as that\n193:                         # syntax is currently undefined.  FIXME: What would be\n194:                         # a good interpretation?\n195:                         if assign_to is None:\n196:                             raise AssignmentError(\n197:                                 \"need assignment variable for loops\")\n198:                         if term.has(assign_to):\n199:                             raise ValueError(\"FIXME: lhs present in rhs,\\\n200:                                 this is undefined in CodePrinter\")\n201: \n202:                         lines.extend(openloop)\n203:                         lines.extend(openloop_d)\n204:                         text = \"%s = %s\" % (lhs_printed, StrPrinter.doprint(\n205:                             self, assign_to + term))\n206:                         lines.append(self._get_statement(text))\n207:                         lines.extend(closeloop_d)\n208:                         lines.extend(closeloop)\n209: \n210:         return \"\\n\".join(lines)\n211: \n212:     def _get_expression_indices(self, expr, assign_to):\n213:         from sympy.tensor import get_indices\n214:         rinds, junk = get_indices(expr)\n215:         linds, junk = get_indices(assign_to)\n216: \n217:         # support broadcast of scalar\n218:         if linds and not rinds:\n219:             rinds = linds\n220:         if rinds != linds:\n221:             raise ValueError(\"lhs indices must match non-dummy\"\n222:                     \" rhs indices in %s\" % expr)\n223: \n224:         return self._sort_optimized(rinds, assign_to)\n225: \n226:     def _sort_optimized(self, indices, expr):\n227: \n228:         from sympy.tensor.indexed import Indexed\n229: \n230:         if not indices:\n231:             return []\n232: \n233:         # determine optimized loop order by giving a score to each index\n234:         # the index with the highest score are put in the innermost loop.\n235:         score_table = {}\n236:         for i in indices:\n237:             score_table[i] = 0\n238: \n239:         arrays = expr.atoms(Indexed)\n240:         for arr in arrays:\n241:             for p, ind in enumerate(arr.indices):\n242:                 try:\n243:                     score_table[ind] += self._rate_index_position(p)\n244:                 except KeyError:\n245:                     pass\n246: \n247:         return sorted(indices, key=lambda x: score_table[x])\n248: \n249:     def _rate_index_position(self, p):\n250:         \"\"\"function to calculate score based on position among indices\n251: \n252:         This method is used to sort loops in an optimized order, see\n253:         CodePrinter._sort_optimized()\n254:         \"\"\"\n255:         raise NotImplementedError(\"This function must be implemented by \"\n256:                                   \"subclass of CodePrinter.\")\n257: \n258:     def _get_statement(self, codestring):\n259:         \"\"\"Formats a codestring with the proper line ending.\"\"\"\n260:         raise NotImplementedError(\"This function must be implemented by \"\n261:                                   \"subclass of CodePrinter.\")\n262: \n263:     def _get_comment(self, text):\n264:         \"\"\"Formats a text string as a comment.\"\"\"\n265:         raise NotImplementedError(\"This function must be implemented by \"\n266:                                   \"subclass of CodePrinter.\")\n267: \n268:     def _declare_number_const(self, name, value):\n269:         \"\"\"Declare a numeric constant at the top of a function\"\"\"\n270:         raise NotImplementedError(\"This function must be implemented by \"\n271:                                   \"subclass of CodePrinter.\")\n272: \n273:     def _format_code(self, lines):\n274:         \"\"\"Take in a list of lines of code, and format them accordingly.\n275: \n276:         This may include indenting, wrapping long lines, etc...\"\"\"\n277:         raise NotImplementedError(\"This function must be implemented by \"\n278:                                   \"subclass of CodePrinter.\")\n279: \n280:     def _get_loop_opening_ending(self, indices):\n281:         \"\"\"Returns a tuple (open_lines, close_lines) containing lists\n282:         of codelines\"\"\"\n283:         raise NotImplementedError(\"This function must be implemented by \"\n284:                                   \"subclass of CodePrinter.\")\n285: \n286:     def _print_Dummy(self, expr):\n287:         if expr.name.startswith('Dummy_'):\n288:             return '_' + expr.name\n289:         else:\n290:             return '%s_%d' % (expr.name, expr.dummy_index)\n291: \n292:     def _print_CodeBlock(self, expr):\n293:         return '\\n'.join([self._print(i) for i in expr.args])\n294: \n295:     def _print_String(self, string):\n296:         return str(string)\n297: \n298:     def _print_QuotedString(self, arg):\n299:         return '\"%s\"' % arg.text\n300: \n301:     def _print_Comment(self, string):\n302:         return self._get_comment(str(string))\n303: \n304:     def _print_Assignment(self, expr):\n305:         from sympy.codegen.ast import Assignment\n306:         from sympy.functions.elementary.piecewise import Piecewise\n307:         from sympy.matrices.expressions.matexpr import MatrixSymbol\n308:         from sympy.tensor.indexed import IndexedBase\n309:         lhs = expr.lhs\n310:         rhs = expr.rhs\n311:         # We special case assignments that take multiple lines\n312:         if isinstance(expr.rhs, Piecewise):\n313:             # Here we modify Piecewise so each expression is now\n314:             # an Assignment, and then continue on the print.\n315:             expressions = []\n316:             conditions = []\n317:             for (e, c) in rhs.args:\n318:                 expressions.append(Assignment(lhs, e))\n319:                 conditions.append(c)\n320:             temp = Piecewise(*zip(expressions, conditions))\n321:             return self._print(temp)\n322:         elif isinstance(lhs, MatrixSymbol):\n323:             # Here we form an Assignment for each element in the array,\n324:             # printing each one.\n325:             lines = []\n326:             for (i, j) in self._traverse_matrix_indices(lhs):\n327:                 temp = Assignment(lhs[i, j], rhs[i, j])\n328:                 code0 = self._print(temp)\n329:                 lines.append(code0)\n330:             return \"\\n\".join(lines)\n331:         elif self._settings.get(\"contract\", False) and (lhs.has(IndexedBase) or\n332:                 rhs.has(IndexedBase)):\n333:             # Here we check if there is looping to be done, and if so\n334:             # print the required loops.\n335:             return self._doprint_loops(rhs, lhs)\n336:         else:\n337:             lhs_code = self._print(lhs)\n338:             rhs_code = self._print(rhs)\n339:             return self._get_statement(\"%s = %s\" % (lhs_code, rhs_code))\n340: \n341:     def _print_AugmentedAssignment(self, expr):\n342:         lhs_code = self._print(expr.lhs)\n343:         rhs_code = self._print(expr.rhs)\n344:         return self._get_statement(\"{} {} {}\".format(\n345:             *map(lambda arg: self._print(arg),\n346:                  [lhs_code, expr.op, rhs_code])))\n347: \n348:     def _print_FunctionCall(self, expr):\n349:         return '%s(%s)' % (\n350:             expr.name,\n351:             ', '.join(map(lambda arg: self._print(arg),\n352:                           expr.function_args)))\n353: \n354:     def _print_Variable(self, expr):\n355:         return self._print(expr.symbol)\n356: \n357:     def _print_Statement(self, expr):\n358:         arg, = expr.args\n359:         return self._get_statement(self._print(arg))\n360: \n361:     def _print_Symbol(self, expr):\n362: \n363:         name = super()._print_Symbol(expr)\n364: \n365:         if name in self.reserved_words:\n366:             if self._settings['error_on_reserved']:\n367:                 msg = ('This expression includes the symbol \"{}\" which is a '\n368:                        'reserved keyword in this language.')\n369:                 raise ValueError(msg.format(name))\n370:             return name + self._settings['reserved_word_suffix']\n371:         else:\n372:             return name\n373: \n374:     def _print_Function(self, expr):\n375:         if expr.func.__name__ in self.known_functions:\n376:             cond_func = self.known_functions[expr.func.__name__]\n377:             func = None\n378:             if isinstance(cond_func, str):\n379:                 func = cond_func\n380:             else:\n381:                 for cond, func in cond_func:\n382:                     if cond(*expr.args):\n383:                         break\n384:             if func is not None:\n385:                 try:\n386:                     return func(*[self.parenthesize(item, 0) for item in expr.args])\n387:                 except TypeError:\n388:                     return \"%s(%s)\" % (func, self.stringify(expr.args, \", \"))\n389:         elif hasattr(expr, '_imp_') and isinstance(expr._imp_, Lambda):\n390:             # inlined function\n391:             return self._print(expr._imp_(*expr.args))\n392:         elif (expr.func.__name__ in self._rewriteable_functions and\n393:               self._rewriteable_functions[expr.func.__name__] in self.known_functions):\n394:             # Simple rewrite to supported function possible\n395:             return self._print(expr.rewrite(self._rewriteable_functions[expr.func.__name__]))\n396:         elif expr.is_Function and self._settings.get('allow_unknown_functions', False):\n397:             return '%s(%s)' % (self._print(expr.func), ', '.join(map(self._print, expr.args)))\n398:         else:\n399:             return self._print_not_supported(expr)\n400: \n401:     _print_Expr = _print_Function\n402: \n403:     def _print_NumberSymbol(self, expr):\n404:         if self._settings.get(\"inline\", False):\n405:             return self._print(Float(expr.evalf(self._settings[\"precision\"])))\n406:         else:\n407:             # A Number symbol that is not implemented here or with _printmethod\n408:             # is registered and evaluated\n409:             self._number_symbols.add((expr,\n410:                 Float(expr.evalf(self._settings[\"precision\"]))))\n411:             return str(expr)\n412: \n413:     def _print_Catalan(self, expr):\n414:         return self._print_NumberSymbol(expr)\n415:     def _print_EulerGamma(self, expr):\n416:         return self._print_NumberSymbol(expr)\n417:     def _print_GoldenRatio(self, expr):\n418:         return self._print_NumberSymbol(expr)\n419:     def _print_TribonacciConstant(self, expr):\n420:         return self._print_NumberSymbol(expr)\n421:     def _print_Exp1(self, expr):\n422:         return self._print_NumberSymbol(expr)\n423:     def _print_Pi(self, expr):\n424:         return self._print_NumberSymbol(expr)\n425: \n426:     def _print_And(self, expr):\n427:         PREC = precedence(expr)\n428:         return (\" %s \" % self._operators['and']).join(self.parenthesize(a, PREC)\n429:                 for a in sorted(expr.args, key=default_sort_key))\n430: \n431:     def _print_Or(self, expr):\n432:         PREC = precedence(expr)\n433:         return (\" %s \" % self._operators['or']).join(self.parenthesize(a, PREC)\n434:                 for a in sorted(expr.args, key=default_sort_key))\n435: \n436:     def _print_Xor(self, expr):\n437:         if self._operators.get('xor') is None:\n438:             return self._print_not_supported(expr)\n439:         PREC = precedence(expr)\n440:         return (\" %s \" % self._operators['xor']).join(self.parenthesize(a, PREC)\n441:                 for a in expr.args)\n442: \n443:     def _print_Equivalent(self, expr):\n444:         if self._operators.get('equivalent') is None:\n445:             return self._print_not_supported(expr)\n446:         PREC = precedence(expr)\n447:         return (\" %s \" % self._operators['equivalent']).join(self.parenthesize(a, PREC)\n448:                 for a in expr.args)\n449: \n450:     def _print_Not(self, expr):\n451:         PREC = precedence(expr)\n452:         return self._operators['not'] + self.parenthesize(expr.args[0], PREC)\n453: \n454:     def _print_Mul(self, expr):\n455: \n456:         prec = precedence(expr)\n457: \n458:         c, e = expr.as_coeff_Mul()\n459:         if c < 0:\n460:             expr = _keep_coeff(-c, e)\n461:             sign = \"-\"\n462:         else:\n463:             sign = \"\"\n464: \n465:         a = []  # items in the numerator\n466:         b = []  # items that are in the denominator (if any)\n467: \n468:         pow_paren = []  # Will collect all pow with more than one base element and exp = -1\n469: \n470:         if self.order not in ('old', 'none'):\n471:             args = expr.as_ordered_factors()\n472:         else:\n473:             # use make_args in case expr was something like -x -> x\n474:             args = Mul.make_args(expr)\n475: \n476:         # Gather args for numerator/denominator\n477:         for item in args:\n478:             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n479:                 if item.exp != -1:\n480:                     b.append(Pow(item.base, -item.exp, evaluate=False))\n481:                 else:\n482:                     if len(item.args[0].args) != 1 and isinstance(item.base, Mul):   # To avoid situations like #14160\n483:                         pow_paren.append(item)\n484:                     b.append(Pow(item.base, -item.exp))\n485:             else:\n486:                 a.append(item)\n487: \n488:         a = a or [S.One]\n489: \n490:         a_str = [self.parenthesize(x, prec) for x in a]\n491:         b_str = [self.parenthesize(x, prec) for x in b]\n... Code Truncated ...\n\n[start of sympy/printing/precedence.py]\n1: \"\"\"A module providing information about the necessity of brackets\"\"\"\n2: \n3: from sympy.core.function import _coeff_isneg\n4: \n5: # Default precedence values for some basic types\n6: PRECEDENCE = {\n7:     \"Lambda\": 1,\n8:     \"Xor\": 10,\n9:     \"Or\": 20,\n10:     \"And\": 30,\n11:     \"Relational\": 35,\n12:     \"Add\": 40,\n13:     \"Mul\": 50,\n14:     \"Pow\": 60,\n15:     \"Func\": 70,\n16:     \"Not\": 100,\n17:     \"Atom\": 1000,\n18:     \"BitwiseOr\": 36,\n19:     \"BitwiseXor\": 37,\n20:     \"BitwiseAnd\": 38\n21: }\n22: \n23: # A dictionary assigning precedence values to certain classes. These values are\n24: # treated like they were inherited, so not every single class has to be named\n25: # here.\n26: # Do not use this with printers other than StrPrinter\n27: PRECEDENCE_VALUES = {\n28:     \"Equivalent\": PRECEDENCE[\"Xor\"],\n29:     \"Xor\": PRECEDENCE[\"Xor\"],\n30:     \"Implies\": PRECEDENCE[\"Xor\"],\n31:     \"Or\": PRECEDENCE[\"Or\"],\n32:     \"And\": PRECEDENCE[\"And\"],\n33:     \"Add\": PRECEDENCE[\"Add\"],\n34:     \"Pow\": PRECEDENCE[\"Pow\"],\n35:     \"Relational\": PRECEDENCE[\"Relational\"],\n36:     \"Sub\": PRECEDENCE[\"Add\"],\n37:     \"Not\": PRECEDENCE[\"Not\"],\n38:     \"Function\" : PRECEDENCE[\"Func\"],\n39:     \"NegativeInfinity\": PRECEDENCE[\"Add\"],\n40:     \"MatAdd\": PRECEDENCE[\"Add\"],\n41:     \"MatPow\": PRECEDENCE[\"Pow\"],\n42:     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n43:     \"TensAdd\": PRECEDENCE[\"Add\"],\n44:     # As soon as `TensMul` is a subclass of `Mul`, remove this:\n45:     \"TensMul\": PRECEDENCE[\"Mul\"],\n46:     \"HadamardProduct\": PRECEDENCE[\"Mul\"],\n47:     \"HadamardPower\": PRECEDENCE[\"Pow\"],\n48:     \"KroneckerProduct\": PRECEDENCE[\"Mul\"],\n49:     \"Equality\": PRECEDENCE[\"Mul\"],\n50:     \"Unequality\": PRECEDENCE[\"Mul\"],\n51: }\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/printing/codeprinter.py",
      "suspect_lines": [
        12,
        490
      ]
    },
    {
      "filename": "/sympy/printing/precedence.py",
      "suspect_lines": []
    }
  ]
}