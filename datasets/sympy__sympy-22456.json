{
  "instance_id": "sympy__sympy-22456",
  "problem_statement": "Argument invariance of codegen.ast String\nCurrently, the `codegen.ast` `String` class does not support argument invariance like:\r\n`expr.func(*expr.args) == expr`, but instead uses the invariance `expr.func(**expr.kwargs()) == expr`.\r\nThe former should hold for any `Basic` subclass, which `String` is.\n",
  "localized_code": "[start of sympy/codegen/ast.py]\n1: \"\"\"\n2: Types used to represent a full function/module as an Abstract Syntax Tree.\n3: \n4: Most types are small, and are merely used as tokens in the AST. A tree diagram\n5: has been included below to illustrate the relationships between the AST types.\n6: \n7: \n8: AST Type Tree\n9: -------------\n10: ::\n11: \n12:   *Basic*\n13:        |\n14:        |\n15:    CodegenAST\n16:        |\n17:        |--->AssignmentBase\n18:        |             |--->Assignment\n19:        |             |--->AugmentedAssignment\n20:        |                                    |--->AddAugmentedAssignment\n21:        |                                    |--->SubAugmentedAssignment\n22:        |                                    |--->MulAugmentedAssignment\n23:        |                                    |--->DivAugmentedAssignment\n24:        |                                    |--->ModAugmentedAssignment\n25:        |\n26:        |--->CodeBlock\n27:        |\n28:        |\n29:        |--->Token\n30:                 |--->Attribute\n31:                 |--->For\n32:                 |--->String\n33:                 |       |--->QuotedString\n34:                 |       |--->Comment\n35:                 |--->Type\n36:                 |       |--->IntBaseType\n37:                 |       |              |--->_SizedIntType\n38:                 |       |                               |--->SignedIntType\n39:                 |       |                               |--->UnsignedIntType\n40:                 |       |--->FloatBaseType\n41:                 |                        |--->FloatType\n42:                 |                        |--->ComplexBaseType\n43:                 |                                           |--->ComplexType\n44:                 |--->Node\n45:                 |       |--->Variable\n46:                 |       |           |---> Pointer\n47:                 |       |--->FunctionPrototype\n48:                 |                            |--->FunctionDefinition\n49:                 |--->Element\n50:                 |--->Declaration\n51:                 |--->While\n52:                 |--->Scope\n53:                 |--->Stream\n54:                 |--->Print\n55:                 |--->FunctionCall\n56:                 |--->BreakToken\n57:                 |--->ContinueToken\n58:                 |--->NoneToken\n59:                 |--->Return\n60: \n61: \n62: Predefined types\n63: ----------------\n64: \n65: A number of ``Type`` instances are provided in the ``sympy.codegen.ast`` module\n66: for convenience. Perhaps the two most common ones for code-generation (of numeric\n67: codes) are ``float32`` and ``float64`` (known as single and double precision respectively).\n68: There are also precision generic versions of Types (for which the codeprinters selects the\n69: underlying data type at time of printing): ``real``, ``integer``, ``complex_``, ``bool_``.\n70: \n71: The other ``Type`` instances defined are:\n72: \n73: - ``intc``: Integer type used by C's \"int\".\n74: - ``intp``: Integer type used by C's \"unsigned\".\n75: - ``int8``, ``int16``, ``int32``, ``int64``: n-bit integers.\n76: - ``uint8``, ``uint16``, ``uint32``, ``uint64``: n-bit unsigned integers.\n77: - ``float80``: known as \"extended precision\" on modern x86/amd64 hardware.\n78: - ``complex64``: Complex number represented by two ``float32`` numbers\n79: - ``complex128``: Complex number represented by two ``float64`` numbers\n80: \n81: Using the nodes\n82: ---------------\n83: \n84: It is possible to construct simple algorithms using the AST nodes. Let's construct a loop applying\n85: Newton's method::\n86: \n87:     >>> from sympy import symbols, cos\n88:     >>> from sympy.codegen.ast import While, Assignment, aug_assign, Print\n89:     >>> t, dx, x = symbols('tol delta val')\n90:     >>> expr = cos(x) - x**3\n91:     >>> whl = While(abs(dx) > t, [\n92:     ...     Assignment(dx, -expr/expr.diff(x)),\n93:     ...     aug_assign(x, '+', dx),\n94:     ...     Print([x])\n95:     ... ])\n96:     >>> from sympy import pycode\n97:     >>> py_str = pycode(whl)\n98:     >>> print(py_str)\n99:     while (abs(delta) > tol):\n100:         delta = (val**3 - math.cos(val))/(-3*val**2 - math.sin(val))\n101:         val += delta\n102:         print(val)\n103:     >>> import math\n104:     >>> tol, val, delta = 1e-5, 0.5, float('inf')\n105:     >>> exec(py_str)\n106:     1.1121416371\n107:     0.909672693737\n108:     0.867263818209\n109:     0.865477135298\n110:     0.865474033111\n111:     >>> print('%3.1g' % (math.cos(val) - val**3))\n112:     -3e-11\n113: \n114: If we want to generate Fortran code for the same while loop we simple call ``fcode``::\n115: \n116:     >>> from sympy import fcode\n117:     >>> print(fcode(whl, standard=2003, source_format='free'))\n118:     do while (abs(delta) > tol)\n119:        delta = (val**3 - cos(val))/(-3*val**2 - sin(val))\n120:        val = val + delta\n121:        print *, val\n122:     end do\n123: \n124: There is a function constructing a loop (or a complete function) like this in\n125: :mod:`sympy.codegen.algorithms`.\n126: \n127: \"\"\"\n128: \n129: from typing import Any, Dict as tDict, List\n130: \n131: from collections import defaultdict\n132: \n133: from sympy.core.relational import (Ge, Gt, Le, Lt)\n134: from sympy.core import Symbol, Tuple, Dummy\n135: from sympy.core.basic import Basic\n136: from sympy.core.expr import Expr\n137: from sympy.core.numbers import Float, Integer, oo\n138: from sympy.core.sympify import _sympify, sympify, SympifyError\n139: from sympy.utilities.iterables import (iterable, topological_sort,\n140:                                        numbered_symbols, filter_symbols)\n141: \n142: \n143: def _mk_Tuple(args):\nCode replaced for brevity.\n160: \n161: \n162: \n163: class CodegenAST(Basic):\n164:     pass\n165: \n166: \n167: class Token(CodegenAST):\nCode replaced for brevity.\n336: \n337: \n338: \n339: class BreakToken(Token):\nCode replaced for brevity.\n353: \n354: \n355: break_ = BreakToken()\n356: \n357: \n358: class ContinueToken(Token):\nCode replaced for brevity.\n372: \n373: \n374: continue_ = ContinueToken()\n375: \n376: class NoneToken(Token):\nCode replaced for brevity.\n397: \n398: \n399: \n400: none = NoneToken()\n401: \n402: \n403: class AssignmentBase(CodegenAST):\nCode replaced for brevity.\n457: \n458: \n459: \n460: class Assignment(AssignmentBase):\nCode replaced for brevity.\n497: \n498: \n499: \n500: class AugmentedAssignment(AssignmentBase):\nCode replaced for brevity.\n515: \n516: \n517: \n518: class AddAugmentedAssignment(AugmentedAssignment):\n519:     binop = '+'\n520: \n521: \n522: class SubAugmentedAssignment(AugmentedAssignment):\n523:     binop = '-'\n524: \n525: \n526: class MulAugmentedAssignment(AugmentedAssignment):\n527:     binop = '*'\n528: \n529: \n530: class DivAugmentedAssignment(AugmentedAssignment):\n531:     binop = '/'\n532: \n533: \n534: class ModAugmentedAssignment(AugmentedAssignment):\n535:     binop = '%'\n536: \n537: \n538: # Mapping from binary op strings to AugmentedAssignment subclasses\n539: augassign_classes = {\n540:     cls.binop: cls for cls in [\n541:         AddAugmentedAssignment, SubAugmentedAssignment, MulAugmentedAssignment,\n542:         DivAugmentedAssignment, ModAugmentedAssignment\n543:     ]\n544: }\n545: \n546: \n547: def aug_assign(lhs, op, rhs):\nCode replaced for brevity.\n587: \n588: \n589: \n590: class CodeBlock(CodegenAST):\nCode replaced for brevity.\n807: \n808: \n809: \n810: class For(Token):\nCode replaced for brevity.\n869: \n870: \n871: \n872: class String(Token):\n873:     \"\"\" SymPy object representing a string.\n874: \n875:     Atomic object which is not an expression (as opposed to Symbol).\n876: \n877:     Parameters\n878:     ==========\n879: \n880:     text : str\n881: \n882:     Examples\n883:     ========\n884: \n885:     >>> from sympy.codegen.ast import String\n886:     >>> f = String('foo')\n887:     >>> f\n888:     foo\n889:     >>> str(f)\n890:     'foo'\n891:     >>> f.text\n892:     'foo'\n893:     >>> print(repr(f))\n894:     String('foo')\n895: \n896:     \"\"\"\n897:     __slots__ = ('text',)\n898:     not_in_args = ['text']\n899:     is_Atom = True\n900: \n901:     @classmethod\n902:     def _construct_text(cls, text):\n903:         if not isinstance(text, str):\n904:             raise TypeError(\"Argument text is not a string type.\")\n905:         return text\n906: \n907:     def _sympystr(self, printer, *args, **kwargs):\n908:         return self.text\n909: \n910: \n911: class QuotedString(String):\nCode replaced for brevity.\n912: \n913: \n914: class Comment(String):\n915:     \"\"\" Represents a comment. \"\"\"\n916: \n917: class Node(Token):\nCode replaced for brevity.\n948: \n949: \n950: \n951: class Type(Token):\nCode replaced for brevity.\n1124: \n1125: \n1126: \n1127: class IntBaseType(Type):\nCode replaced for brevity.\n1130: \n1131: \n1132: \n1133: class _SizedIntType(IntBaseType):\nCode replaced for brevity.\n1142: \n1143: \n1144: \n1145: class SignedIntType(_SizedIntType):\nCode replaced for brevity.\n1153: \n1154: \n1155: \n1156: class UnsignedIntType(_SizedIntType):\nCode replaced for brevity.\n1164: \n1165: \n1166: two = Integer(2)\n1167: \n1168: class FloatBaseType(Type):\nCode replaced for brevity.\n1170: \n1171: \n1172: class FloatType(FloatBaseType):\nCode replaced for brevity.\n1288: \n1289: \n1290: class ComplexBaseType(FloatBaseType):\nCode replaced for brevity.\n1303: \n1304: \n1305: \n1306: class ComplexType(ComplexBaseType, FloatType):\nCode replaced for brevity.\n1307: \n1308: \n1309: \n1310: # NumPy types:\n1311: intc = IntBaseType('intc')\n1312: intp = IntBaseType('intp')\n1313: int8 = SignedIntType('int8', 8)\n1314: int16 = SignedIntType('int16', 16)\n1315: int32 = SignedIntType('int32', 32)\n1316: int64 = SignedIntType('int64', 64)\n1317: uint8 = UnsignedIntType('uint8', 8)\n1318: uint16 = UnsignedIntType('uint16', 16)\n1319: uint32 = UnsignedIntType('uint32', 32)\n1320: uint64 = UnsignedIntType('uint64', 64)\n1321: float16 = FloatType('float16', 16, nexp=5, nmant=10)  # IEEE 754 binary16, Half precision\n1322: float32 = FloatType('float32', 32, nexp=8, nmant=23)  # IEEE 754 binary32, Single precision\n1323: float64 = FloatType('float64', 64, nexp=11, nmant=52)  # IEEE 754 binary64, Double precision\n1324: float80 = FloatType('float80', 80, nexp=15, nmant=63)  # x86 extended precision (1 integer part bit), \"long double\"\n1325: float128 = FloatType('float128', 128, nexp=15, nmant=112)  # IEEE 754 binary128, Quadruple precision\n1326: float256 = FloatType('float256', 256, nexp=19, nmant=236)  # IEEE 754 binary256, Octuple precision\n1327: \n1328: complex64 = ComplexType('complex64', nbits=64, **float32.kwargs(exclude=('name', 'nbits')))\n1329: complex128 = ComplexType('complex128', nbits=128, **float64.kwargs(exclude=('name', 'nbits')))\n1330: \n1331: # Generic types (precision may be chosen by code printers):\n1332: untyped = Type('untyped')\n1333: real = FloatBaseType('real')\n1334: integer = IntBaseType('integer')\n1335: complex_ = ComplexBaseType('complex')\n1336: bool_ = Type('bool')\n1337: \n1338: \n1339: class Attribute(Token):\nCode replaced for brevity.\n1377: \n1378: \n1379: value_const = Attribute('value_const')\n1380: pointer_const = Attribute('pointer_const')\n1381: \n1382: \n1383: class Variable(Node):\nCode replaced for brevity.\n1528: \n1529: \n1530: class Pointer(Variable):\nCode replaced for brevity.\n1551: \n1552: \n1553: \n1554: class Element(Token):\nCode replaced for brevity.\n1578: \n1579: \n1580: \n1581: class Declaration(Token):\nCode replaced for brevity.\n1605: \n1606: \n1607: \n1608: class While(Token):\nCode replaced for brevity.\n1643: \n1644: \n1645: \n1646: class Scope(Token):\nCode replaced for brevity.\n1663: \n1664: \n1665: \n1666: class Stream(Token):\nCode replaced for brevity.\n1690: \n1691: \n1692: stdout = Stream('stdout')\n1693: stderr = Stream('stderr')\n1694: \n1695: \n1696: class Print(Token):\nCode replaced for brevity.\n1720: \n1721: \n1722: \n1723: class FunctionPrototype(Node):\nCode replaced for brevity.\n1769: \n1770: \n1771: \n1772: class FunctionDefinition(FunctionPrototype):\nCode replaced for brevity.\n1815: \n1816: \n1817: \n1818: class Return(Token):\nCode replaced for brevity.\n1838: \n1839: \n1840: \n1841: class FunctionCall(Token, Expr):\nCode replaced for brevity.\n1863: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/codegen/ast.py",
      "suspect_lines": [
        136,
        338,
        872
      ]
    }
  ]
}