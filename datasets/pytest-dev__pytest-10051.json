{
  "instance_id": "pytest-dev__pytest-10051",
  "problem_statement": "caplog.get_records and caplog.clear conflict\n# Description\r\n\r\n`caplog.get_records()` gets decoupled from actual caplog records when `caplog.clear()` is called. As a result, after `caplog.clear()` is called, `caplog.get_records()` is frozen: it does not get cleared, nor does it get new records.\r\n\r\nDuring test set up it is [set to the same list](https://github.com/pytest-dev/pytest/blob/28e8c8582ea947704655a3c3f2d57184831336fd/src/_pytest/logging.py#L699) as `caplog.records`, but the latter gets [replaced rather than cleared](https://github.com/pytest-dev/pytest/blob/28e8c8582ea947704655a3c3f2d57184831336fd/src/_pytest/logging.py#L345) in `caplog.clear()`, which diverges the two objects.\r\n\r\n# Reproductive example\r\n```python\r\nimport logging\r\n\r\ndef test(caplog) -> None:\r\n    def verify_consistency() -> None:\r\n        assert caplog.get_records(\"call\") == caplog.records\r\n\r\n    verify_consistency()\r\n    logging.warning(\"test\")\r\n    verify_consistency()\r\n    caplog.clear()\r\n    verify_consistency()  # fails: assert [<LogRecord: ...y, 8, \"test\">] == []\r\n```\r\n\r\n# Environment details\r\nArch Linux, Python 3.9.10:\r\n```\r\nPackage    Version\r\n---------- -------\r\nattrs      21.4.0\r\niniconfig  1.1.1\r\npackaging  21.3\r\npip        22.0.4\r\npluggy     1.0.0\r\npy         1.11.0\r\npyparsing  3.0.8\r\npytest     7.1.1\r\nsetuptools 60.10.0\r\ntomli      2.0.1\r\nwheel      0.37.1\r\n```\n",
  "localized_code": "[start of src/_pytest/logging.py]\n1: \"\"\"Access and control log capturing.\"\"\"\n2: import io\n3: import logging\n4: import os\n5: import re\n6: from contextlib import contextmanager\n7: from contextlib import nullcontext\n8: from io import StringIO\n9: from pathlib import Path\n10: from typing import AbstractSet\n11: from typing import Dict\n12: from typing import Generator\n13: from typing import List\n14: from typing import Mapping\n15: from typing import Optional\n16: from typing import Tuple\n17: from typing import TYPE_CHECKING\n18: from typing import TypeVar\n19: from typing import Union\n20: \n21: from _pytest import nodes\n22: from _pytest._io import TerminalWriter\n23: from _pytest.capture import CaptureManager\n24: from _pytest.compat import final\n25: from _pytest.config import _strtobool\n26: from _pytest.config import Config\n27: from _pytest.config import create_terminal_writer\n28: from _pytest.config import hookimpl\n29: from _pytest.config import UsageError\n30: from _pytest.config.argparsing import Parser\n31: from _pytest.deprecated import check_ispytest\n32: from _pytest.fixtures import fixture\n33: from _pytest.fixtures import FixtureRequest\n34: from _pytest.main import Session\n35: from _pytest.stash import StashKey\n36: from _pytest.terminal import TerminalReporter\n37: \n38: if TYPE_CHECKING:\n39:     logging_StreamHandler = logging.StreamHandler[StringIO]\n40: else:\n41:     logging_StreamHandler = logging.StreamHandler\n42: \n43: \n44: DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n45: DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n46: _ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n47: caplog_handler_key = StashKey[\"LogCaptureHandler\"]()\n48: caplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\n49: \n50: \n51: def _remove_ansi_escape_sequences(text: str) -> str:\nCode replaced for brevity.\n52: \n53: \n54: \n55: class ColoredLevelFormatter(logging.Formatter):\nCode replaced for brevity.\n113: \n114: \n115: \n116: class PercentStyleMultiline(logging.PercentStyle):\nCode replaced for brevity.\n203: \n204: \n205: \n206: def get_option_ini(config: Config, *names: str):\nCode replaced for brevity.\n212: \n213: \n214: \n215: def pytest_addoption(parser: Parser) -> None:\nCode replaced for brevity.\n298: \n299: \n300: \n301: _HandlerType = TypeVar(\"_HandlerType\", bound=logging.Handler)\n302: \n303: \n304: # Not using @contextmanager for performance reasons.\n305: class catching_logs:\nCode replaced for brevity.\n328: \n329: \n330: \n331: class LogCaptureHandler(logging_StreamHandler):\nCode replaced for brevity.\n354: \n355: \n356: \n357: @final\n358: class LogCaptureFixture:\n359:     \"\"\"Provides access and control of log capturing.\"\"\"\n360: \n361:     def __init__(self, item: nodes.Node, *, _ispytest: bool = False) -> None:\n362:         check_ispytest(_ispytest)\n363:         self._item = item\n364:         self._initial_handler_level: Optional[int] = None\n365:         # Dict of log name -> log level.\n366:         self._initial_logger_levels: Dict[Optional[str], int] = {}\n367: \n368:     def _finalize(self) -> None:\n369:         \"\"\"Finalize the fixture.\n370: \n371:         This restores the log levels changed by :meth:`set_level`.\n372:         \"\"\"\n373:         # Restore log levels.\n374:         if self._initial_handler_level is not None:\n375:             self.handler.setLevel(self._initial_handler_level)\n376:         for logger_name, level in self._initial_logger_levels.items():\n377:             logger = logging.getLogger(logger_name)\n378:             logger.setLevel(level)\n379: \n380:     @property\n381:     def handler(self) -> LogCaptureHandler:\n382:         \"\"\"Get the logging handler used by the fixture.\n383: \n384:         :rtype: LogCaptureHandler\n385:         \"\"\"\n386:         return self._item.stash[caplog_handler_key]\n387: \n388:     def get_records(self, when: str) -> List[logging.LogRecord]:\n389:         \"\"\"Get the logging records for one of the possible test phases.\n390: \n391:         :param str when:\n392:             Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n393: \n394:         :returns: The list of captured records at the given stage.\n395:         :rtype: List[logging.LogRecord]\n396: \n397:         .. versionadded:: 3.4\n398:         \"\"\"\n399:         return self._item.stash[caplog_records_key].get(when, [])\n400: \n401:     @property\n402:     def text(self) -> str:\n403:         \"\"\"The formatted log text.\"\"\"\n404:         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n405: \n406:     @property\n407:     def records(self) -> List[logging.LogRecord]:\n408:         \"\"\"The list of log records.\"\"\"\n409:         return self.handler.records\n410: \n411:     @property\n412:     def record_tuples(self) -> List[Tuple[str, int, str]]:\n413:         \"\"\"A list of a stripped down version of log records intended\n414:         for use in assertion comparison.\n415: \n416:         The format of the tuple is:\n417: \n418:             (logger_name, log_level, message)\n419:         \"\"\"\n420:         return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n421: \n422:     @property\n423:     def messages(self) -> List[str]:\n424:         \"\"\"A list of format-interpolated log messages.\n425: \n426:         Unlike 'records', which contains the format string and parameters for\n427:         interpolation, log messages in this list are all interpolated.\n428: \n429:         Unlike 'text', which contains the output from the handler, log\n430:         messages in this list are unadorned with levels, timestamps, etc,\n431:         making exact comparisons more reliable.\n432: \n433:         Note that traceback or stack info (from :func:`logging.exception` or\n434:         the `exc_info` or `stack_info` arguments to the logging functions) is\n435:         not included, as this is added by the formatter in the handler.\n436: \n437:         .. versionadded:: 3.7\n438:         \"\"\"\n439:         return [r.getMessage() for r in self.records]\n440: \n441:     def clear(self) -> None:\n442:         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n443:         self.handler.reset()\n444: \n445:     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n446:         \"\"\"Set the level of a logger for the duration of a test.\n447: \n448:         .. versionchanged:: 3.4\n449:             The levels of the loggers changed by this function will be\n450:             restored to their initial values at the end of the test.\n451: \n452:         :param int level: The level.\n453:         :param str logger: The logger to update. If not given, the root logger.\n454:         \"\"\"\n455:         logger_obj = logging.getLogger(logger)\n456:         # Save the original log-level to restore it during teardown.\n457:         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n458:         logger_obj.setLevel(level)\n459:         if self._initial_handler_level is None:\n460:             self._initial_handler_level = self.handler.level\n461:         self.handler.setLevel(level)\n462: \n463:     @contextmanager\n464:     def at_level(\n465:         self, level: Union[int, str], logger: Optional[str] = None\n466:     ) -> Generator[None, None, None]:\n467:         \"\"\"Context manager that sets the level for capturing of logs. After\n468:         the end of the 'with' statement the level is restored to its original\n469:         value.\n470: \n471:         :param int level: The level.\n472:         :param str logger: The logger to update. If not given, the root logger.\n473:         \"\"\"\n474:         logger_obj = logging.getLogger(logger)\n475:         orig_level = logger_obj.level\n476:         logger_obj.setLevel(level)\n477:         handler_orig_level = self.handler.level\n478:         self.handler.setLevel(level)\n479:         try:\n480:             yield\n481:         finally:\n482:             logger_obj.setLevel(orig_level)\n483:             self.handler.setLevel(handler_orig_level)\n484: \n485: \n486: @fixture\n487: def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\nCode replaced for brevity.\n500: \n501: \n502: \n503: def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:\nCode replaced for brevity.\n523: \n524: \n525: \n526: # run after terminalreporter/capturemanager are configured\n527: @hookimpl(trylast=True)\n528: def pytest_configure(config: Config) -> None:\nCode replaced for brevity.\n529: \n530: \n531: \n532: class LoggingPlugin:\nCode replaced for brevity.\n745: \n746: \n747: \n748: class _FileHandler(logging.FileHandler):\nCode replaced for brevity.\n753: \n754: \n755: \n756: class _LiveLoggingStreamHandler(logging_StreamHandler):\nCode replaced for brevity.\n812: \n813: \n814: \n815: class _LiveLoggingNullHandler(logging.NullHandler):\nCode replaced for brevity.\n826: \n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/logging.py",
      "suspect_lines": [
        43,
        443
      ]
    }
  ]
}