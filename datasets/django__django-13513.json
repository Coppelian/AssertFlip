{
  "instance_id": "django__django-13513",
  "problem_statement": "debug error view doesn't respect exc.__suppress_context__ (PEP 415)\nDescription\n\t\nConsider the following view that raises an exception:\nclass TestView(View):\n\tdef get(self, request, *args, **kwargs):\n\t\ttry:\n\t\t\traise RuntimeError('my error')\n\t\texcept Exception as exc:\n\t\t\traise ValueError('my new error') from None\nEven though the raise is from None, unlike the traceback Python shows, the debug error view still shows the RuntimeError.\nThis is because the explicit_or_implicit_cause() function inside get_traceback_frames() doesn't respect exc.__suppress_context__, which was introduced in Python 3.3's PEP 415:\n​https://github.com/django/django/blob/38a21f2d9ed4f556af934498ec6a242f6a20418a/django/views/debug.py#L392\ndef get_traceback_frames(self):\n\tdef explicit_or_implicit_cause(exc_value):\n\t\texplicit = getattr(exc_value, '__cause__', None)\n\t\timplicit = getattr(exc_value, '__context__', None)\n\t\treturn explicit or implicit\nInstead, it should be something more like (simplifying also for Python 3):\ndef explicit_or_implicit_cause(exc_value):\n\treturn (\n\t\texc_value.__cause__ or\n\t\t(None if exc_value.__suppress_context__ else\n\t\t\texc_value.__context__)\n\t)\n",
  "localized_code": "[start of django/views/debug.py]\n1: import functools\n2: import re\n3: import sys\n4: import types\n5: import warnings\n6: from pathlib import Path\n7: \n8: from django.conf import settings\n9: from django.http import Http404, HttpResponse, HttpResponseNotFound\n10: from django.template import Context, Engine, TemplateDoesNotExist\n11: from django.template.defaultfilters import pprint\n12: from django.urls import resolve\n13: from django.utils import timezone\n14: from django.utils.datastructures import MultiValueDict\n15: from django.utils.encoding import force_str\n16: from django.utils.module_loading import import_string\n17: from django.utils.regex_helper import _lazy_re_compile\n18: from django.utils.version import get_docs_version\n19: \n20: # Minimal Django templates engine to render the error templates\n21: # regardless of the project's TEMPLATES setting. Templates are\n22: # read directly from the filesystem so that the error handler\n23: # works even if the template loader is broken.\n24: DEBUG_ENGINE = Engine(\n25:     debug=True,\n26:     libraries={'i18n': 'django.templatetags.i18n'},\n27: )\n28: \n29: CURRENT_DIR = Path(__file__).parent\n30: \n31: \n32: class ExceptionCycleWarning(UserWarning):\n33:     pass\n34: \n35: \n36: class CallableSettingWrapper:\n37:     \"\"\"\n38:     Object to wrap callable appearing in settings.\n39:     * Not to call in the debug page (#21345).\n40:     * Not to break the debug page if the callable forbidding to set attributes\n41:       (#23070).\n42:     \"\"\"\n43:     def __init__(self, callable_setting):\n44:         self._wrapped = callable_setting\n45: \n46:     def __repr__(self):\n47:         return repr(self._wrapped)\n48: \n49: \n50: def technical_500_response(request, exc_type, exc_value, tb, status_code=500):\n51:     \"\"\"\n52:     Create a technical server error response. The last three arguments are\n53:     the values returned from sys.exc_info() and friends.\n54:     \"\"\"\n55:     reporter = get_exception_reporter_class(request)(request, exc_type, exc_value, tb)\n56:     if request.accepts('text/html'):\n57:         html = reporter.get_traceback_html()\n58:         return HttpResponse(html, status=status_code, content_type='text/html')\n59:     else:\n60:         text = reporter.get_traceback_text()\n61:         return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')\n62: \n63: \n64: @functools.lru_cache()\n65:     # Instantiate the default filter for the first time and cache it.\nCode replaced for brevity.\n67: \n68: \n69: \n70: def get_exception_reporter_filter(request):\nCode replaced for brevity.\n72: \n73: \n74: \n75: def get_exception_reporter_class(request):\nCode replaced for brevity.\n77: \n78: \n79: \n80: class SafeExceptionReporterFilter:\nCode replaced for brevity.\n243: \n244: \n245: \n246: class ExceptionReporter:\n247:     \"\"\"Organize and coordinate reporting on exceptions.\"\"\"\n248:     def __init__(self, request, exc_type, exc_value, tb, is_email=False):\n249:         self.request = request\n250:         self.filter = get_exception_reporter_filter(self.request)\n251:         self.exc_type = exc_type\n252:         self.exc_value = exc_value\n253:         self.tb = tb\n254:         self.is_email = is_email\n255: \n256:         self.template_info = getattr(self.exc_value, 'template_debug', None)\n257:         self.template_does_not_exist = False\n258:         self.postmortem = None\n259: \n260:     def get_traceback_data(self):\n261:         \"\"\"Return a dictionary containing traceback information.\"\"\"\n262:         if self.exc_type and issubclass(self.exc_type, TemplateDoesNotExist):\n263:             self.template_does_not_exist = True\n264:             self.postmortem = self.exc_value.chain or [self.exc_value]\n265: \n266:         frames = self.get_traceback_frames()\n267:         for i, frame in enumerate(frames):\n268:             if 'vars' in frame:\n269:                 frame_vars = []\n270:                 for k, v in frame['vars']:\n271:                     v = pprint(v)\n272:                     # Trim large blobs of data\n273:                     if len(v) > 4096:\n274:                         v = '%s… <trimmed %d bytes string>' % (v[0:4096], len(v))\n275:                     frame_vars.append((k, v))\n276:                 frame['vars'] = frame_vars\n277:             frames[i] = frame\n278: \n279:         unicode_hint = ''\n280:         if self.exc_type and issubclass(self.exc_type, UnicodeError):\n281:             start = getattr(self.exc_value, 'start', None)\n282:             end = getattr(self.exc_value, 'end', None)\n283:             if start is not None and end is not None:\n284:                 unicode_str = self.exc_value.args[1]\n285:                 unicode_hint = force_str(\n286:                     unicode_str[max(start - 5, 0):min(end + 5, len(unicode_str))],\n287:                     'ascii', errors='replace'\n288:                 )\n289:         from django import get_version\n290: \n291:         if self.request is None:\n292:             user_str = None\n293:         else:\n294:             try:\n295:                 user_str = str(self.request.user)\n296:             except Exception:\n297:                 # request.user may raise OperationalError if the database is\n298:                 # unavailable, for example.\n299:                 user_str = '[unable to retrieve the current user]'\n300: \n301:         c = {\n302:             'is_email': self.is_email,\n303:             'unicode_hint': unicode_hint,\n304:             'frames': frames,\n305:             'request': self.request,\n306:             'request_meta': self.filter.get_safe_request_meta(self.request),\n307:             'user_str': user_str,\n308:             'filtered_POST_items': list(self.filter.get_post_parameters(self.request).items()),\n309:             'settings': self.filter.get_safe_settings(),\n310:             'sys_executable': sys.executable,\n311:             'sys_version_info': '%d.%d.%d' % sys.version_info[0:3],\n312:             'server_time': timezone.now(),\n313:             'django_version_info': get_version(),\n314:             'sys_path': sys.path,\n315:             'template_info': self.template_info,\n316:             'template_does_not_exist': self.template_does_not_exist,\n317:             'postmortem': self.postmortem,\n318:         }\n319:         if self.request is not None:\n320:             c['request_GET_items'] = self.request.GET.items()\n321:             c['request_FILES_items'] = self.request.FILES.items()\n322:             c['request_COOKIES_items'] = self.request.COOKIES.items()\n323:         # Check whether exception info is available\n324:         if self.exc_type:\n325:             c['exception_type'] = self.exc_type.__name__\n326:         if self.exc_value:\n327:             c['exception_value'] = str(self.exc_value)\n328:         if frames:\n329:             c['lastframe'] = frames[-1]\n330:         return c\n331: \n332:     def get_traceback_html(self):\n333:         \"\"\"Return HTML version of debug 500 HTTP error page.\"\"\"\n334:         with Path(CURRENT_DIR, 'templates', 'technical_500.html').open(encoding='utf-8') as fh:\n335:             t = DEBUG_ENGINE.from_string(fh.read())\n336:         c = Context(self.get_traceback_data(), use_l10n=False)\n337:         return t.render(c)\n338: \n339:     def get_traceback_text(self):\n340:         \"\"\"Return plain text version of debug 500 HTTP error page.\"\"\"\n341:         with Path(CURRENT_DIR, 'templates', 'technical_500.txt').open(encoding='utf-8') as fh:\n342:             t = DEBUG_ENGINE.from_string(fh.read())\n343:         c = Context(self.get_traceback_data(), autoescape=False, use_l10n=False)\n344:         return t.render(c)\n345: \n346:     def _get_source(self, filename, loader, module_name):\n347:         source = None\n348:         if hasattr(loader, 'get_source'):\n349:             try:\n350:                 source = loader.get_source(module_name)\n351:             except ImportError:\n352:                 pass\n353:             if source is not None:\n354:                 source = source.splitlines()\n355:         if source is None:\n356:             try:\n357:                 with open(filename, 'rb') as fp:\n358:                     source = fp.read().splitlines()\n359:             except OSError:\n360:                 pass\n361:         return source\n362: \n363:     def _get_lines_from_file(self, filename, lineno, context_lines, loader=None, module_name=None):\n364:         \"\"\"\n365:         Return context_lines before and after lineno from file.\n366:         Return (pre_context_lineno, pre_context, context_line, post_context).\n367:         \"\"\"\n368:         source = self._get_source(filename, loader, module_name)\n369:         if source is None:\n370:             return None, [], None, []\n371: \n372:         # If we just read the source from a file, or if the loader did not\n373:         # apply tokenize.detect_encoding to decode the source into a\n374:         # string, then we should do that ourselves.\n375:         if isinstance(source[0], bytes):\n376:             encoding = 'ascii'\n377:             for line in source[:2]:\n378:                 # File coding may be specified. Match pattern from PEP-263\n379:                 # (https://www.python.org/dev/peps/pep-0263/)\n380:                 match = re.search(br'coding[:=]\\s*([-\\w.]+)', line)\n381:                 if match:\n382:                     encoding = match[1].decode('ascii')\n383:                     break\n384:             source = [str(sline, encoding, 'replace') for sline in source]\n385: \n386:         lower_bound = max(0, lineno - context_lines)\n387:         upper_bound = lineno + context_lines\n388: \n389:         try:\n390:             pre_context = source[lower_bound:lineno]\n391:             context_line = source[lineno]\n392:             post_context = source[lineno + 1:upper_bound]\n393:         except IndexError:\n394:             return None, [], None, []\n395:         return lower_bound, pre_context, context_line, post_context\n396: \n397:     def get_traceback_frames(self):\n398:         def explicit_or_implicit_cause(exc_value):\n399:             explicit = getattr(exc_value, '__cause__', None)\n400:             suppress_context = getattr(exc_value, '__suppress_context__', None)\n401:             implicit = getattr(exc_value, '__context__', None)\n402:             return explicit or (None if suppress_context else implicit)\n403: \n404:         # Get the exception and all its causes\n405:         exceptions = []\n406:         exc_value = self.exc_value\n407:         while exc_value:\n408:             exceptions.append(exc_value)\n409:             exc_value = explicit_or_implicit_cause(exc_value)\n410:             if exc_value in exceptions:\n411:                 warnings.warn(\n412:                     \"Cycle in the exception chain detected: exception '%s' \"\n413:                     \"encountered again.\" % exc_value,\n414:                     ExceptionCycleWarning,\n415:                 )\n416:                 # Avoid infinite loop if there's a cyclic reference (#29393).\n417:                 break\n418: \n419:         frames = []\n420:         # No exceptions were supplied to ExceptionReporter\n421:         if not exceptions:\n422:             return frames\n423: \n424:         # In case there's just one exception, take the traceback from self.tb\n425:         exc_value = exceptions.pop()\n426:         tb = self.tb if not exceptions else exc_value.__traceback__\n427: \n428:         while tb is not None:\n429:             # Support for __traceback_hide__ which is used by a few libraries\n430:             # to hide internal frames.\n431:             if tb.tb_frame.f_locals.get('__traceback_hide__'):\n432:                 tb = tb.tb_next\n433:                 continue\n434:             filename = tb.tb_frame.f_code.co_filename\n435:             function = tb.tb_frame.f_code.co_name\n436:             lineno = tb.tb_lineno - 1\n437:             loader = tb.tb_frame.f_globals.get('__loader__')\n438:             module_name = tb.tb_frame.f_globals.get('__name__') or ''\n439:             pre_context_lineno, pre_context, context_line, post_context = self._get_lines_from_file(\n440:                 filename, lineno, 7, loader, module_name,\n441:             )\n442:             if pre_context_lineno is None:\n443:                 pre_context_lineno = lineno\n444:                 pre_context = []\n445:                 context_line = '<source code not available>'\n446:                 post_context = []\n447:             frames.append({\n448:                 'exc_cause': explicit_or_implicit_cause(exc_value),\n449:                 'exc_cause_explicit': getattr(exc_value, '__cause__', True),\n450:                 'tb': tb,\n451:                 'type': 'django' if module_name.startswith('django.') else 'user',\n452:                 'filename': filename,\n453:                 'function': function,\n454:                 'lineno': lineno + 1,\n455:                 'vars': self.filter.get_traceback_frame_variables(self.request, tb.tb_frame),\n456:                 'id': id(tb),\n457:                 'pre_context': pre_context,\n458:                 'context_line': context_line,\n459:                 'post_context': post_context,\n460:                 'pre_context_lineno': pre_context_lineno + 1,\n461:             })\n462: \n463:             # If the traceback for current exception is consumed, try the\n464:             # other exception.\n465:             if not tb.tb_next and exceptions:\n466:                 exc_value = exceptions.pop()\n467:                 tb = exc_value.__traceback__\n468:             else:\n469:                 tb = tb.tb_next\n470: \n471:         return frames\n472: \n473: \n474:     \"\"\nCode replaced for brevity.\n531: \n532: \n533: \n534:     \"\"\nCode replaced for brevity.\n542: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/views/debug.py",
      "suspect_lines": [
        397,
        398,
        399,
        400,
        401,
        402,
        409,
        447,
        448,
        449,
        461,
        462,
        463,
        464,
        465,
        466,
        467,
        468,
        469,
        470,
        471
      ]
    }
  ]
}