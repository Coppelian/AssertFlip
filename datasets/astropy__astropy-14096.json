{
  "instance_id": "astropy__astropy-14096",
  "problem_statement": "Subclassed SkyCoord gives misleading attribute access message\nI'm trying to subclass `SkyCoord`, and add some custom properties. This all seems to be working fine, but when I have a custom property (`prop` below) that tries to access a non-existent attribute (`random_attr`) below, the error message is misleading because it says `prop` doesn't exist, where it should say `random_attr` doesn't exist.\r\n\r\n```python\r\nimport astropy.coordinates as coord\r\n\r\n\r\nclass custom_coord(coord.SkyCoord):\r\n    @property\r\n    def prop(self):\r\n        return self.random_attr\r\n\r\n\r\nc = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\r\nc.prop\r\n```\r\n\r\nraises\r\n```\r\nTraceback (most recent call last):\r\n  File \"test.py\", line 11, in <module>\r\n    c.prop\r\n  File \"/Users/dstansby/miniconda3/lib/python3.7/site-packages/astropy/coordinates/sky_coordinate.py\", line 600, in __getattr__\r\n    .format(self.__class__.__name__, attr))\r\nAttributeError: 'custom_coord' object has no attribute 'prop'\r\n```\n",
  "localized_code": "[start of astropy/coordinates/sky_coordinate.py]\n1: import copy\n2: import operator\n3: import re\n4: import warnings\n5: \n6: import erfa\n7: import numpy as np\n8: \n9: from astropy import units as u\n10: from astropy.constants import c as speed_of_light\n11: from astropy.table import QTable\n12: from astropy.time import Time\n13: from astropy.utils import ShapedLikeNDArray\n14: from astropy.utils.data_info import MixinInfo\n15: from astropy.utils.exceptions import AstropyUserWarning\n16: \n17: from .angles import Angle\n18: from .baseframe import BaseCoordinateFrame, GenericFrame, frame_transform_graph\n19: from .distances import Distance\n20: from .representation import (\n21:     RadialDifferential,\n22:     SphericalDifferential,\n23:     SphericalRepresentation,\n24:     UnitSphericalCosLatDifferential,\n25:     UnitSphericalDifferential,\n26:     UnitSphericalRepresentation,\n27: )\n28: from .sky_coordinate_parsers import (\n29:     _get_frame_class,\n30:     _get_frame_without_data,\n31:     _parse_coordinate_data,\n32: )\n33: \n34: __all__ = [\"SkyCoord\", \"SkyCoordInfo\"]\n35: \n36: \n37: class SkyCoordInfo(MixinInfo):\n38:     \"\"\"\n39:     Container for meta information like name, description, format.  This is\n40:     required when the object is used as a mixin column within a table, but can\n41:     be used as a general way to store meta information.\n42:     \"\"\"\n43: \n44:     attrs_from_parent = {\"unit\"}  # Unit is read-only\n45:     _supports_indexing = False\n46: \n47:     @staticmethod\n48:     def default_format(val):\n49:         repr_data = val.info._repr_data\n50:         formats = [\"{0.\" + compname + \".value:}\" for compname in repr_data.components]\n51:         return \",\".join(formats).format(repr_data)\n52: \n53:     @property\n54:     def unit(self):\n55:         repr_data = self._repr_data\n56:         unit = \",\".join(\n57:             str(getattr(repr_data, comp).unit) or \"None\"\n58:             for comp in repr_data.components\n59:         )\n60:         return unit\n61: \n62:     @property\n63:     def _repr_data(self):\n64:         if self._parent is None:\n65:             return None\n66: \n67:         sc = self._parent\n68:         if issubclass(sc.representation_type, SphericalRepresentation) and isinstance(\n69:             sc.data, UnitSphericalRepresentation\n70:         ):\n71:             repr_data = sc.represent_as(sc.data.__class__, in_frame_units=True)\n72:         else:\n73:             repr_data = sc.represent_as(sc.representation_type, in_frame_units=True)\n74:         return repr_data\n75: \n76:     def _represent_as_dict(self):\n77:         sc = self._parent\n78:         attrs = list(sc.representation_component_names)\n79: \n80:         # Don't output distance unless it's actually distance.\n81:         if isinstance(sc.data, UnitSphericalRepresentation):\n82:             attrs = attrs[:-1]\n83: \n84:         diff = sc.data.differentials.get(\"s\")\n85:         if diff is not None:\n86:             diff_attrs = list(sc.get_representation_component_names(\"s\"))\n87:             # Don't output proper motions if they haven't been specified.\n88:             if isinstance(diff, RadialDifferential):\n89:                 diff_attrs = diff_attrs[2:]\n90:             # Don't output radial velocity unless it's actually velocity.\n91:             elif isinstance(\n92:                 diff, (UnitSphericalDifferential, UnitSphericalCosLatDifferential)\n93:             ):\n94:                 diff_attrs = diff_attrs[:-1]\n95:             attrs.extend(diff_attrs)\n96: \n97:         attrs.extend(frame_transform_graph.frame_attributes.keys())\n98: \n99:         out = super()._represent_as_dict(attrs)\n100: \n101:         out[\"representation_type\"] = sc.representation_type.get_name()\n102:         out[\"frame\"] = sc.frame.name\n103:         # Note that sc.info.unit is a fake composite unit (e.g. 'deg,deg,None'\n104:         # or None,None,m) and is not stored.  The individual attributes have\n105:         # units.\n106: \n107:         return out\n108: \n109:     def new_like(self, skycoords, length, metadata_conflicts=\"warn\", name=None):\n110:         \"\"\"\n111:         Return a new SkyCoord instance which is consistent with the input\n112:         SkyCoord objects ``skycoords`` and has ``length`` rows.  Being\n113:         \"consistent\" is defined as being able to set an item from one to each of\n114:         the rest without any exception being raised.\n115: \n116:         This is intended for creating a new SkyCoord instance whose elements can\n117:         be set in-place for table operations like join or vstack.  This is used\n118:         when a SkyCoord object is used as a mixin column in an astropy Table.\n119: \n120:         The data values are not predictable and it is expected that the consumer\n121:         of the object will fill in all values.\n122: \n123:         Parameters\n124:         ----------\n125:         skycoords : list\n126:             List of input SkyCoord objects\n127:         length : int\n128:             Length of the output skycoord object\n129:         metadata_conflicts : str ('warn'|'error'|'silent')\n130:             How to handle metadata conflicts\n131:         name : str\n132:             Output name (sets output skycoord.info.name)\n133: \n134:         Returns\n135:         -------\n136:         skycoord : SkyCoord (or subclass)\n137:             Instance of this class consistent with ``skycoords``\n138: \n139:         \"\"\"\n140:         # Get merged info attributes like shape, dtype, format, description, etc.\n141:         attrs = self.merge_cols_attributes(\n142:             skycoords, metadata_conflicts, name, (\"meta\", \"description\")\n143:         )\n144:         skycoord0 = skycoords[0]\n145: \n146:         # Make a new SkyCoord object with the desired length and attributes\n147:         # by using the _apply / __getitem__ machinery to effectively return\n148:         # skycoord0[[0, 0, ..., 0, 0]]. This will have the all the right frame\n149:         # attributes with the right shape.\n150:         indexes = np.zeros(length, dtype=np.int64)\n151:         out = skycoord0[indexes]\n152: \n153:         # Use __setitem__ machinery to check for consistency of all skycoords\n154:         for skycoord in skycoords[1:]:\n155:             try:\n156:                 out[0] = skycoord[0]\n157:             except Exception as err:\n158:                 raise ValueError(\"Input skycoords are inconsistent.\") from err\n159: \n160:         # Set (merged) info attributes\n161:         for attr in (\"name\", \"meta\", \"description\"):\n162:             if attr in attrs:\n163:                 setattr(out.info, attr, attrs[attr])\n164: \n165:         return out\n166: \n167: \n168: class SkyCoord(ShapedLikeNDArray):\n169:     \"\"\"High-level object providing a flexible interface for celestial coordinate\n170:     representation, manipulation, and transformation between systems.\n171: \n172:     The `SkyCoord` class accepts a wide variety of inputs for initialization. At\n173:     a minimum these must provide one or more celestial coordinate values with\n174:     unambiguous units.  Inputs may be scalars or lists/tuples/arrays, yielding\n175:     scalar or array coordinates (can be checked via ``SkyCoord.isscalar``).\n176:     Typically one also specifies the coordinate frame, though this is not\n177:     required. The general pattern for spherical representations is::\n178: \n179:       SkyCoord(COORD, [FRAME], keyword_args ...)\n180:       SkyCoord(LON, LAT, [FRAME], keyword_args ...)\n181:       SkyCoord(LON, LAT, [DISTANCE], frame=FRAME, unit=UNIT, keyword_args ...)\n182:       SkyCoord([FRAME], <lon_attr>=LON, <lat_attr>=LAT, keyword_args ...)\n183: \n184:     It is also possible to input coordinate values in other representations\n185:     such as cartesian or cylindrical.  In this case one includes the keyword\n186:     argument ``representation_type='cartesian'`` (for example) along with data\n187:     in ``x``, ``y``, and ``z``.\n188: \n189:     See also: https://docs.astropy.org/en/stable/coordinates/\n190: \n191:     Examples\n192:     --------\n193:     The examples below illustrate common ways of initializing a `SkyCoord`\n194:     object.  For a complete description of the allowed syntax see the\n195:     full coordinates documentation.  First some imports::\n196: \n197:       >>> from astropy.coordinates import SkyCoord  # High-level coordinates\n198:       >>> from astropy.coordinates import ICRS, Galactic, FK4, FK5  # Low-level frames\n199:       >>> from astropy.coordinates import Angle, Latitude, Longitude  # Angles\n200:       >>> import astropy.units as u\n201: \n202:     The coordinate values and frame specification can now be provided using\n203:     positional and keyword arguments::\n204: \n205:       >>> c = SkyCoord(10, 20, unit=\"deg\")  # defaults to ICRS frame\n206:       >>> c = SkyCoord([1, 2, 3], [-30, 45, 8], frame=\"icrs\", unit=\"deg\")  # 3 coords\n207: \n208:       >>> coords = [\"1:12:43.2 +31:12:43\", \"1 12 43.2 +31 12 43\"]\n209:       >>> c = SkyCoord(coords, frame=FK4, unit=(u.hourangle, u.deg), obstime=\"J1992.21\")\n210: \n211:       >>> c = SkyCoord(\"1h12m43.2s +1d12m43s\", frame=Galactic)  # Units from string\n212:       >>> c = SkyCoord(frame=\"galactic\", l=\"1h12m43.2s\", b=\"+1d12m43s\")\n213: \n214:       >>> ra = Longitude([1, 2, 3], unit=u.deg)  # Could also use Angle\n215:       >>> dec = np.array([4.5, 5.2, 6.3]) * u.deg  # Astropy Quantity\n216:       >>> c = SkyCoord(ra, dec, frame='icrs')\n217:       >>> c = SkyCoord(frame=ICRS, ra=ra, dec=dec, obstime='2001-01-02T12:34:56')\n218: \n219:       >>> c = FK4(1 * u.deg, 2 * u.deg)  # Uses defaults for obstime, equinox\n220:       >>> c = SkyCoord(c, obstime='J2010.11', equinox='B1965')  # Override defaults\n221: \n222:       >>> c = SkyCoord(w=0, u=1, v=2, unit='kpc', frame='galactic',\n223:       ...              representation_type='cartesian')\n224: \n225:       >>> c = SkyCoord([ICRS(ra=1*u.deg, dec=2*u.deg), ICRS(ra=3*u.deg, dec=4*u.deg)])\n226: \n227:     Velocity components (proper motions or radial velocities) can also be\n228:     provided in a similar manner::\n229: \n230:       >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, radial_velocity=10*u.km/u.s)\n231: \n232:       >>> c = SkyCoord(ra=1*u.deg, dec=2*u.deg, pm_ra_cosdec=2*u.mas/u.yr, pm_dec=1*u.mas/u.yr)\n233: \n234:     As shown, the frame can be a `~astropy.coordinates.BaseCoordinateFrame`\n235:     class or the corresponding string alias.  The frame classes that are built in\n236:     to astropy are `ICRS`, `FK5`, `FK4`, `FK4NoETerms`, and `Galactic`.\n237:     The string aliases are simply lower-case versions of the class name, and\n238:     allow for creating a `SkyCoord` object and transforming frames without\n239:     explicitly importing the frame classes.\n240: \n241:     Parameters\n242:     ----------\n243:     frame : `~astropy.coordinates.BaseCoordinateFrame` class or string, optional\n244:         Type of coordinate frame this `SkyCoord` should represent. Defaults to\n245:         to ICRS if not given or given as None.\n246:     unit : `~astropy.units.Unit`, string, or tuple of :class:`~astropy.units.Unit` or str, optional\n247:         Units for supplied coordinate values.\n248:         If only one unit is supplied then it applies to all values.\n249:         Note that passing only one unit might lead to unit conversion errors\n250:         if the coordinate values are expected to have mixed physical meanings\n251:         (e.g., angles and distances).\n252:     obstime : time-like, optional\n253:         Time(s) of observation.\n254:     equinox : time-like, optional\n255:         Coordinate frame equinox time.\n256:     representation_type : str or Representation class\n257:         Specifies the representation, e.g. 'spherical', 'cartesian', or\n258:         'cylindrical'.  This affects the positional args and other keyword args\n259:         which must correspond to the given representation.\n260:     copy : bool, optional\n261:         If `True` (default), a copy of any coordinate data is made.  This\n262:         argument can only be passed in as a keyword argument.\n263:     **keyword_args\n264:         Other keyword arguments as applicable for user-defined coordinate frames.\n265:         Common options include:\n266: \n267:         ra, dec : angle-like, optional\n268:             RA and Dec for frames where ``ra`` and ``dec`` are keys in the\n269:             frame's ``representation_component_names``, including `ICRS`,\n270:             `FK5`, `FK4`, and `FK4NoETerms`.\n271:         pm_ra_cosdec, pm_dec  : `~astropy.units.Quantity` ['angular speed'], optional\n272:             Proper motion components, in angle per time units.\n273:         l, b : angle-like, optional\n274:             Galactic ``l`` and ``b`` for for frames where ``l`` and ``b`` are\n275:             keys in the frame's ``representation_component_names``, including\n276:             the `Galactic` frame.\n277:         pm_l_cosb, pm_b : `~astropy.units.Quantity` ['angular speed'], optional\n278:             Proper motion components in the `Galactic` frame, in angle per time\n279:             units.\n280:         x, y, z : float or `~astropy.units.Quantity` ['length'], optional\n281:             Cartesian coordinates values\n282:         u, v, w : float or `~astropy.units.Quantity` ['length'], optional\n283:             Cartesian coordinates values for the Galactic frame.\n284:         radial_velocity : `~astropy.units.Quantity` ['speed'], optional\n285:             The component of the velocity along the line-of-sight (i.e., the\n286:             radial direction), in velocity units.\n287:     \"\"\"\n288: \n289:     # Declare that SkyCoord can be used as a Table column by defining the\n290:     # info property.\n291:     info = SkyCoordInfo()\n292: \n293:     def __init__(self, *args, copy=True, **kwargs):\n294:         # these are frame attributes set on this SkyCoord but *not* a part of\n295:         # the frame object this SkyCoord contains\n296:         self._extra_frameattr_names = set()\n297: \n298:         # If all that is passed in is a frame instance that already has data,\n299:         # we should bypass all of the parsing and logic below. This is here\n300:         # to make this the fastest way to create a SkyCoord instance. Many of\n301:         # the classmethods implemented for performance enhancements will use\n302:         # this as the initialization path\n303:         if (\n304:             len(args) == 1\n305:             and len(kwargs) == 0\n306:             and isinstance(args[0], (BaseCoordinateFrame, SkyCoord))\n307:         ):\n308:             coords = args[0]\n309:             if isinstance(coords, SkyCoord):\n310:                 self._extra_frameattr_names = coords._extra_frameattr_names\n311:                 self.info = coords.info\n312: \n313:                 # Copy over any extra frame attributes\n314:                 for attr_name in self._extra_frameattr_names:\n315:                     # Setting it will also validate it.\n316:                     setattr(self, attr_name, getattr(coords, attr_name))\n317: \n318:                 coords = coords.frame\n319: \n320:             if not coords.has_data:\n321:                 raise ValueError(\n322:                     \"Cannot initialize from a coordinate frame \"\n323:                     \"instance without coordinate data\"\n324:                 )\n325: \n326:             if copy:\n327:                 self._sky_coord_frame = coords.copy()\n328:             else:\n329:                 self._sky_coord_frame = coords\n330: \n331:         else:\n332:             # Get the frame instance without coordinate data but with all frame\n333:             # attributes set - these could either have been passed in with the\n334:             # frame as an instance, or passed in as kwargs here\n335:             frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\n336: \n337:             # Parse the args and kwargs to assemble a sanitized and validated\n338:             # kwargs dict for initializing attributes for this object and for\n339:             # creating the internal self._sky_coord_frame object\n340:             args = list(args)  # Make it mutable\n341:             skycoord_kwargs, components, info = _parse_coordinate_data(\n342:                 frame_cls(**frame_kwargs), args, kwargs\n343:             )\n344: \n345:             # In the above two parsing functions, these kwargs were identified\n346:             # as valid frame attributes for *some* frame, but not the frame that\n347:             # this SkyCoord will have. We keep these attributes as special\n348:             # skycoord frame attributes:\n349:             for attr in skycoord_kwargs:\n350:                 # Setting it will also validate it.\n351:                 setattr(self, attr, skycoord_kwargs[attr])\n352: \n353:             if info is not None:\n354:                 self.info = info\n355: \n356:             # Finally make the internal coordinate object.\n357:             frame_kwargs.update(components)\n358:             self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\n359: \n360:             if not self._sky_coord_frame.has_data:\n361:                 raise ValueError(\"Cannot create a SkyCoord without data\")\n362: \n363:     @property\n364:     def frame(self):\n365:         return self._sky_coord_frame\n366: \n367:     @property\n368:     def representation_type(self):\n369:         return self.frame.representation_type\n370: \n371:     @representation_type.setter\n372:     def representation_type(self, value):\n373:         self.frame.representation_type = value\n374: \n375:     # TODO: remove these in future\n376:     @property\n377:     def representation(self):\n378:         return self.frame.representation\n379: \n380:     @representation.setter\n381:     def representation(self, value):\n382:         self.frame.representation = value\n383: \n384:     @property\n385:     def shape(self):\n386:         return self.frame.shape\n387: \n388:     def __eq__(self, value):\n389:         \"\"\"Equality operator for SkyCoord\n390: \n391:         This implements strict equality and requires that the frames are\n392:         equivalent, extra frame attributes are equivalent, and that the\n393:         representation data are exactly equal.\n394:         \"\"\"\n395: \n396:         if isinstance(value, BaseCoordinateFrame):\n397:             if value._data is None:\n398:                 raise ValueError(\"Can only compare SkyCoord to Frame with data\")\n399: \n400:             return self.frame == value\n401: \n402:         if not isinstance(value, SkyCoord):\n403:             return NotImplemented\n404: \n405:         # Make sure that any extra frame attribute names are equivalent.\n406:         for attr in self._extra_frameattr_names | value._extra_frameattr_names:\n407:             if not self.frame._frameattr_equiv(\n408:                 getattr(self, attr), getattr(value, attr)\n409:             ):\n410:                 raise ValueError(\n411:                     f\"cannot compare: extra frame attribute '{attr}' is not equivalent\"\n412:                     \" (perhaps compare the frames directly to avoid this exception)\"\n413:                 )\n414: \n415:         return self._sky_coord_frame == value._sky_coord_frame\n416: \n417:     def __ne__(self, value):\n418:         return np.logical_not(self == value)\n419: \n420:     def _apply(self, method, *args, **kwargs):\n421:         \"\"\"Create a new instance, applying a method to the underlying data.\n422: \n423:         In typical usage, the method is any of the shape-changing methods for\n424:         `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those\n425:         picking particular elements (``__getitem__``, ``take``, etc.), which\n426:         are all defined in `~astropy.utils.shapes.ShapedLikeNDArray`. It will be\n427:         applied to the underlying arrays in the representation (e.g., ``x``,\n428:         ``y``, and ``z`` for `~astropy.coordinates.CartesianRepresentation`),\n429:         as well as to any frame attributes that have a shape, with the results\n430:         used to create a new instance.\n431: \n432:         Internally, it is also used to apply functions to the above parts\n433:         (in particular, `~numpy.broadcast_to`).\n434: \n435:         Parameters\n436:         ----------\n437:         method : str or callable\n438:             If str, it is the name of a method that is applied to the internal\n439:             ``components``. If callable, the function is applied.\n440:         *args\n441:             Any positional arguments for ``method``.\n442:         **kwargs : dict\n443:             Any keyword arguments for ``method``.\n444:         \"\"\"\n445: \n446:         def apply_method(value):\n447:             if isinstance(value, ShapedLikeNDArray):\n448:                 return value._apply(method, *args, **kwargs)\n449:             else:\n450:                 if callable(method):\n451:                     return method(value, *args, **kwargs)\n452:                 else:\n453:                     return getattr(value, method)(*args, **kwargs)\n454: \n455:         # create a new but empty instance, and copy over stuff\n456:         new = super().__new__(self.__class__)\n457:         new._sky_coord_frame = self._sky_coord_frame._apply(method, *args, **kwargs)\n458:         new._extra_frameattr_names = self._extra_frameattr_names.copy()\n459:         for attr in self._extra_frameattr_names:\n460:             value = getattr(self, attr)\n461:             if getattr(value, \"shape\", ()):\n462:                 value = apply_method(value)\n463:             elif method == \"copy\" or method == \"flatten\":\n464:                 # flatten should copy also for a single element array, but\n465:                 # we cannot use it directly for array scalars, since it\n466:                 # always returns a one-dimensional array. So, just copy.\n467:                 value = copy.copy(value)\n468:             setattr(new, \"_\" + attr, value)\n469: \n470:         # Copy other 'info' attr only if it has actually been defined.\n471:         # See PR #3898 for further explanation and justification, along\n472:         # with Quantity.__array_finalize__\n473:         if \"info\" in self.__dict__:\n474:             new.info = self.info\n475: \n476:         return new\n477: \n478:     def __setitem__(self, item, value):\n479:         \"\"\"Implement self[item] = value for SkyCoord\n480: \n481:         The right hand ``value`` must be strictly consistent with self:\n482:         - Identical class\n483:         - Equivalent frames\n484:         - Identical representation_types\n485:         - Identical representation differentials keys\n486:         - Identical frame attributes\n487:         - Identical \"extra\" frame attributes (e.g. obstime for an ICRS coord)\n488: \n489:         With these caveats the setitem ends up as effectively a setitem on\n490:         the representation data.\n491: \n492:           self.frame.data[item] = value.frame.data\n493:         \"\"\"\n494:         if self.__class__ is not value.__class__:\n495:             raise TypeError(\n496:                 \"can only set from object of same class: \"\n497:                 f\"{self.__class__.__name__} vs. {value.__class__.__name__}\"\n498:             )\n499: \n500:         # Make sure that any extra frame attribute names are equivalent.\n501:         for attr in self._extra_frameattr_names | value._extra_frameattr_names:\n502:             if not self.frame._frameattr_equiv(\n503:                 getattr(self, attr), getattr(value, attr)\n504:             ):\n505:                 raise ValueError(f\"attribute {attr} is not equivalent\")\n506: \n507:         # Set the frame values.  This checks frame equivalence and also clears\n508:         # the cache to ensure that the object is not in an inconsistent state.\n509:         self._sky_coord_frame[item] = value._sky_coord_frame\n510: \n511:     def insert(self, obj, values, axis=0):\n512:         \"\"\"\n513:         Insert coordinate values before the given indices in the object and\n514:         return a new Frame object.\n515: \n516:         The values to be inserted must conform to the rules for in-place setting\n517:         of ``SkyCoord`` objects.\n518: \n519:         The API signature matches the ``np.insert`` API, but is more limited.\n520:         The specification of insert index ``obj`` must be a single integer,\n521:         and the ``axis`` must be ``0`` for simple insertion before the index.\n522: \n523:         Parameters\n524:         ----------\n525:         obj : int\n526:             Integer index before which ``values`` is inserted.\n527:         values : array-like\n528:             Value(s) to insert.  If the type of ``values`` is different\n529:             from that of quantity, ``values`` is converted to the matching type.\n530:         axis : int, optional\n531:             Axis along which to insert ``values``.  Default is 0, which is the\n532:             only allowed value and will insert a row.\n533: \n534:         Returns\n535:         -------\n536:         out : `~astropy.coordinates.SkyCoord` instance\n537:             New coordinate object with inserted value(s)\n538: \n539:         \"\"\"\n540:         # Validate inputs: obj arg is integer, axis=0, self is not a scalar, and\n541:         # input index is in bounds.\n542:         try:\n543:             idx0 = operator.index(obj)\n544:         except TypeError:\n545:             raise TypeError(\"obj arg must be an integer\")\n546: \n547:         if axis != 0:\n548:             raise ValueError(\"axis must be 0\")\n549: \n550:         if not self.shape:\n551:             raise TypeError(\n552:                 f\"cannot insert into scalar {self.__class__.__name__} object\"\n553:             )\n554: \n555:         if abs(idx0) > len(self):\n556:             raise IndexError(\n557:                 f\"index {idx0} is out of bounds for axis 0 with size {len(self)}\"\n558:             )\n559: \n560:         # Turn negative index into positive\n561:         if idx0 < 0:\n562:             idx0 = len(self) + idx0\n563: \n564:         n_values = len(values) if values.shape else 1\n565: \n566:         # Finally make the new object with the correct length and set values for the\n567:         # three sections, before insert, the insert, and after the insert.\n568:         out = self.__class__.info.new_like(\n569:             [self], len(self) + n_values, name=self.info.name\n570:         )\n571: \n572:         # Set the output values. This is where validation of `values` takes place to ensure\n573:         # that it can indeed be inserted.\n574:         out[:idx0] = self[:idx0]\n575:         out[idx0 : idx0 + n_values] = values\n576:         out[idx0 + n_values :] = self[idx0:]\n577: \n578:         return out\n579: \n580:     def is_transformable_to(self, new_frame):\n581:         \"\"\"\n582:         Determines if this coordinate frame can be transformed to another\n583:         given frame.\n584: \n585:         Parameters\n586:         ----------\n587:         new_frame : frame class, frame object, or str\n588:             The proposed frame to transform into.\n589: \n590:         Returns\n591:         -------\n592:         transformable : bool or str\n593:             `True` if this can be transformed to ``new_frame``, `False` if\n594:             not, or the string 'same' if ``new_frame`` is the same system as\n595:             this object but no transformation is defined.\n596: \n597:         Notes\n598:         -----\n599:         A return value of 'same' means the transformation will work, but it will\n600:         just give back a copy of this object.  The intended usage is::\n601: \n602:             if coord.is_transformable_to(some_unknown_frame):\n603:                 coord2 = coord.transform_to(some_unknown_frame)\n604: \n605:         This will work even if ``some_unknown_frame``  turns out to be the same\n606:         frame class as ``coord``.  This is intended for cases where the frame\n607:         is the same regardless of the frame attributes (e.g. ICRS), but be\n608:         aware that it *might* also indicate that someone forgot to define the\n609:         transformation between two objects of the same frame class but with\n610:         different attributes.\n611:         \"\"\"\n612:         # TODO! like matplotlib, do string overrides for modified methods\n613:         new_frame = (\n614:             _get_frame_class(new_frame) if isinstance(new_frame, str) else new_frame\n615:         )\n616:         return self.frame.is_transformable_to(new_frame)\n617: \n618:     def transform_to(self, frame, merge_attributes=True):\n619:         \"\"\"Transform this coordinate to a new frame.\n620: \n621:         The precise frame transformed to depends on ``merge_attributes``.\n622:         If `False`, the destination frame is used exactly as passed in.\n623:         But this is often not quite what one wants.  E.g., suppose one wants to\n624:         transform an ICRS coordinate that has an obstime attribute to FK4; in\n625:         this case, one likely would want to use this information. Thus, the\n626:         default for ``merge_attributes`` is `True`, in which the precedence is\n627:         as follows: (1) explicitly set (i.e., non-default) values in the\n628:         destination frame; (2) explicitly set values in the source; (3) default\n629:         value in the destination frame.\n630: \n631:         Note that in either case, any explicitly set attributes on the source\n632:         `SkyCoord` that are not part of the destination frame's definition are\n633:         kept (stored on the resulting `SkyCoord`), and thus one can round-trip\n634:         (e.g., from FK4 to ICRS to FK4 without losing obstime).\n635: \n636:         Parameters\n637:         ----------\n638:         frame : str, `BaseCoordinateFrame` class or instance, or `SkyCoord` instance\n639:             The frame to transform this coordinate into.  If a `SkyCoord`, the\n640:             underlying frame is extracted, and all other information ignored.\n641:         merge_attributes : bool, optional\n642:             Whether the default attributes in the destination frame are allowed\n643:             to be overridden by explicitly set attributes in the source\n644:             (see note above; default: `True`).\n645: \n646:         Returns\n647:         -------\n648:         coord : `SkyCoord`\n649:             A new object with this coordinate represented in the `frame` frame.\n650: \n651:         Raises\n652:         ------\n653:         ValueError\n654:             If there is no possible transformation route.\n655: \n656:         \"\"\"\n657:         from astropy.coordinates.errors import ConvertError\n658: \n659:         frame_kwargs = {}\n660: \n661:         # Frame name (string) or frame class?  Coerce into an instance.\n662:         try:\n663:             frame = _get_frame_class(frame)()\n664:         except Exception:\n665:             pass\n666: \n667:         if isinstance(frame, SkyCoord):\n668:             frame = frame.frame  # Change to underlying coord frame instance\n669: \n670:         if isinstance(frame, BaseCoordinateFrame):\n671:             new_frame_cls = frame.__class__\n672:             # Get frame attributes, allowing defaults to be overridden by\n673:             # explicitly set attributes of the source if ``merge_attributes``.\n674:             for attr in frame_transform_graph.frame_attributes:\n675:                 self_val = getattr(self, attr, None)\n676:                 frame_val = getattr(frame, attr, None)\n677:                 if frame_val is not None and not (\n678:                     merge_attributes and frame.is_frame_attr_default(attr)\n679:                 ):\n680:                     frame_kwargs[attr] = frame_val\n681:                 elif self_val is not None and not self.is_frame_attr_default(attr):\n682:                     frame_kwargs[attr] = self_val\n683:                 elif frame_val is not None:\n684:                     frame_kwargs[attr] = frame_val\n685:         else:\n686:             raise ValueError(\n687:                 \"Transform `frame` must be a frame name, class, or instance\"\n688:             )\n689: \n690:         # Get the composite transform to the new frame\n691:         trans = frame_transform_graph.get_transform(self.frame.__class__, new_frame_cls)\n692:         if trans is None:\n693:             raise ConvertError(\n694:                 f\"Cannot transform from {self.frame.__class__} to {new_frame_cls}\"\n695:             )\n696: \n697:         # Make a generic frame which will accept all the frame kwargs that\n698:         # are provided and allow for transforming through intermediate frames\n699:         # which may require one or more of those kwargs.\n700:         generic_frame = GenericFrame(frame_kwargs)\n701: \n702:         # Do the transformation, returning a coordinate frame of the desired\n703:         # final type (not generic).\n704:         new_coord = trans(self.frame, generic_frame)\n705: \n706:         # Finally make the new SkyCoord object from the `new_coord` and\n707:         # remaining frame_kwargs that are not frame_attributes in `new_coord`.\n708:         for attr in set(new_coord.frame_attributes) & set(frame_kwargs.keys()):\n709:             frame_kwargs.pop(attr)\n710: \n711:         # Always remove the origin frame attribute, as that attribute only makes\n712:         # sense with a SkyOffsetFrame (in which case it will be stored on the frame).\n713:         # See gh-11277.\n714:         # TODO: Should it be a property of the frame attribute that it can\n715:         # or cannot be stored on a SkyCoord?\n716:         frame_kwargs.pop(\"origin\", None)\n717: \n718:         return self.__class__(new_coord, **frame_kwargs)\n719: \n720:     def apply_space_motion(self, new_obstime=None, dt=None):\n721:         \"\"\"\n722:         Compute the position of the source represented by this coordinate object\n723:         to a new time using the velocities stored in this object and assuming\n724:         linear space motion (including relativistic corrections). This is\n725:         sometimes referred to as an \"epoch transformation.\"\n726: \n727:         The initial time before the evolution is taken from the ``obstime``\n728:         attribute of this coordinate.  Note that this method currently does not\n729:         support evolving coordinates where the *frame* has an ``obstime`` frame\n730:         attribute, so the ``obstime`` is only used for storing the before and\n731:         after times, not actually as an attribute of the frame. Alternatively,\n732:         if ``dt`` is given, an ``obstime`` need not be provided at all.\n733: \n734:         Parameters\n735:         ----------\n736:         new_obstime : `~astropy.time.Time`, optional\n737:             The time at which to evolve the position to. Requires that the\n738:             ``obstime`` attribute be present on this frame.\n739:         dt : `~astropy.units.Quantity`, `~astropy.time.TimeDelta`, optional\n740:             An amount of time to evolve the position of the source. Cannot be\n741:             given at the same time as ``new_obstime``.\n742: \n743:         Returns\n744:         -------\n745:         new_coord : `SkyCoord`\n746:             A new coordinate object with the evolved location of this coordinate\n747:             at the new time.  ``obstime`` will be set on this object to the new\n748:             time only if ``self`` also has ``obstime``.\n749:         \"\"\"\n750:         from .builtin_frames.icrs import ICRS\n751: \n752:         if (new_obstime is None) == (dt is None):\n753:             raise ValueError(\n754:                 \"You must specify one of `new_obstime` or `dt`, but not both.\"\n755:             )\n756: \n757:         # Validate that we have velocity info\n758:         if \"s\" not in self.frame.data.differentials:\n759:             raise ValueError(\"SkyCoord requires velocity data to evolve the position.\")\n760: \n761:         if \"obstime\" in self.frame.frame_attributes:\n762:             raise NotImplementedError(\n763:                 \"Updating the coordinates in a frame with explicit time dependence is\"\n764:                 \" currently not supported. If you would like this functionality, please\"\n765:                 \" open an issue on github:\\nhttps://github.com/astropy/astropy\"\n766:             )\n767: \n768:         if new_obstime is not None and self.obstime is None:\n769:             # If no obstime is already on this object, raise an error if a new\n770:             # obstime is passed: we need to know the time / epoch at which the\n771:             # the position / velocity were measured initially\n772:             raise ValueError(\n773:                 \"This object has no associated `obstime`. apply_space_motion() must\"\n774:                 \" receive a time difference, `dt`, and not a new obstime.\"\n775:             )\n776: \n777:         # Compute t1 and t2, the times used in the starpm call, which *only*\n778:         # uses them to compute a delta-time\n779:         t1 = self.obstime\n780:         if dt is None:\n781:             # self.obstime is not None and new_obstime is not None b/c of above\n782:             # checks\n783:             t2 = new_obstime\n784:         else:\n785:             # new_obstime is definitely None b/c of the above checks\n786:             if t1 is None:\n787:                 # MAGIC NUMBER: if the current SkyCoord object has no obstime,\n788:                 # assume J2000 to do the dt offset. This is not actually used\n789:                 # for anything except a delta-t in starpm, so it's OK that it's\n790:                 # not necessarily the \"real\" obstime\n791:                 t1 = Time(\"J2000\")\n792:                 new_obstime = None  # we don't actually know the initial obstime\n793:                 t2 = t1 + dt\n794:             else:\n795:                 t2 = t1 + dt\n796:                 new_obstime = t2\n797:         # starpm wants tdb time\n798:         t1 = t1.tdb\n799:         t2 = t2.tdb\n800: \n801:         # proper motion in RA should not include the cos(dec) term, see the\n802:         # erfa function eraStarpv, comment (4).  So we convert to the regular\n803:         # spherical differentials.\n804:         icrsrep = self.icrs.represent_as(SphericalRepresentation, SphericalDifferential)\n805:         icrsvel = icrsrep.differentials[\"s\"]\n806: \n807:         parallax_zero = False\n808:         try:\n809:             plx = icrsrep.distance.to_value(u.arcsecond, u.parallax())\n810:         except u.UnitConversionError:  # No distance: set to 0 by convention\n811:             plx = 0.0\n812:             parallax_zero = True\n813: \n814:         try:\n815:             rv = icrsvel.d_distance.to_value(u.km / u.s)\n816:         except u.UnitConversionError:  # No RV\n817:             rv = 0.0\n818: \n819:         starpm = erfa.pmsafe(\n820:             icrsrep.lon.radian,\n821:             icrsrep.lat.radian,\n822:             icrsvel.d_lon.to_value(u.radian / u.yr),\n823:             icrsvel.d_lat.to_value(u.radian / u.yr),\n824:             plx,\n825:             rv,\n826:             t1.jd1,\n827:             t1.jd2,\n828:             t2.jd1,\n829:             t2.jd2,\n830:         )\n831: \n832:         if parallax_zero:\n833:             new_distance = None\n834:         else:\n835:             new_distance = Distance(parallax=starpm[4] << u.arcsec)\n836: \n837:         icrs2 = ICRS(\n838:             ra=u.Quantity(starpm[0], u.radian, copy=False),\n839:             dec=u.Quantity(starpm[1], u.radian, copy=False),\n840:             pm_ra=u.Quantity(starpm[2], u.radian / u.yr, copy=False),\n841:             pm_dec=u.Quantity(starpm[3], u.radian / u.yr, copy=False),\n842:             distance=new_distance,\n843:             radial_velocity=u.Quantity(starpm[5], u.km / u.s, copy=False),\n844:             differential_type=SphericalDifferential,\n845:         )\n846: \n847:         # Update the obstime of the returned SkyCoord, and need to carry along\n848:         # the frame attributes\n849:         frattrs = {\n850:             attrnm: getattr(self, attrnm) for attrnm in self._extra_frameattr_names\n851:         }\n852:         frattrs[\"obstime\"] = new_obstime\n853:         result = self.__class__(icrs2, **frattrs).transform_to(self.frame)\n854: \n855:         # Without this the output might not have the right differential type.\n856:         # Not sure if this fixes the problem or just hides it.  See #11932\n857:         result.differential_type = self.differential_type\n858: \n859:         return result\n860: \n861:     def _is_name(self, string):\n862:         \"\"\"\n863:         Returns whether a string is one of the aliases for the frame.\n864:         \"\"\"\n865:         return self.frame.name == string or (\n866:             isinstance(self.frame.name, list) and string in self.frame.name\n867:         )\n868: \n869:     def __getattr__(self, attr):\n870:         \"\"\"\n871:         Overrides getattr to return coordinates that this can be transformed\n872:         to, based on the alias attr in the primary transform graph.\n873:         \"\"\"\n874:         if \"_sky_coord_frame\" in self.__dict__:\n875:             if self._is_name(attr):\n876:                 return self  # Should this be a deepcopy of self?\n877: \n878:             # Anything in the set of all possible frame_attr_names is handled\n879:             # here. If the attr is relevant for the current frame then delegate\n880:             # to self.frame otherwise get it from self._<attr>.\n881:             if attr in frame_transform_graph.frame_attributes:\n882:                 if attr in self.frame.frame_attributes:\n883:                     return getattr(self.frame, attr)\n884:                 else:\n885:                     return getattr(self, \"_\" + attr, None)\n886: \n887:             # Some attributes might not fall in the above category but still\n888:             # are available through self._sky_coord_frame.\n889:             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n890:                 return getattr(self._sky_coord_frame, attr)\n891: \n892:             # Try to interpret as a new frame for transforming.\n893:             frame_cls = frame_transform_graph.lookup_name(attr)\n894:             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n895:                 return self.transform_to(attr)\n896: \n897:         # Fail\n898:         raise AttributeError(\n899:             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n900:         )\n901: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/astropy/coordinates/sky_coordinate.py",
      "suspect_lines": [
        897,
        898,
        899,
        900
      ]
    }
  ]
}