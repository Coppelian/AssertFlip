{
  "instance_id": "sympy__sympy-23413",
  "problem_statement": "bug with HNF removing rows\nI expect\r\n`np.flip (hermite_normal_form (Matrix (np.flip (np.array ([[5, 8, 12], [0, 0, 1]]))).T).T))`\r\nto give\r\n`[[5,  8, 0], [0,  0, 1]]`\r\nbut instead I get\r\n`[[5,  8, 0]]`\r\nIt seems to be falsely identifying my matrix as rank-deficient and removing the row when I try to achieve a row-style HNF using flips and transposes.\n",
  "localized_code": "[start of sympy/polys/matrices/normalforms.py]\n1: '''Functions returning normal forms of matrices'''\n2: \n3: from collections import defaultdict\n4: \n5: from .domainmatrix import DomainMatrix\n6: from .exceptions import DMDomainError, DMShapeError\n7: from sympy.ntheory.modular import symmetric_residue\n8: from sympy.polys.domains import QQ, ZZ\n9: \n10: \n11: # TODO (future work):\n12: #  There are faster algorithms for Smith and Hermite normal forms, which\n13: #  we should implement. See e.g. the Kannan-Bachem algorithm:\n14: #  <https://www.researchgate.net/publication/220617516_Polynomial_Algorithms_for_Computing_the_Smith_and_Hermite_Normal_Forms_of_an_Integer_Matrix>\n15: \n16: \n17: def smith_normal_form(m):\n18:     '''\n19:     Return the Smith Normal Form of a matrix `m` over the ring `domain`.\n20:     This will only work if the ring is a principal ideal domain.\n21: \n22:     Examples\n23:     ========\n24: \n25:     >>> from sympy import ZZ\n26:     >>> from sympy.polys.matrices import DomainMatrix\n27:     >>> from sympy.polys.matrices.normalforms import smith_normal_form\n28:     >>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n29:     ...                   [ZZ(3), ZZ(9), ZZ(6)],\n30:     ...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n31:     >>> print(smith_normal_form(m).to_Matrix())\n32:     Matrix([[1, 0, 0], [0, 10, 0], [0, 0, -30]])\n33: \n34:     '''\n35:     invs = invariant_factors(m)\n36:     smf = DomainMatrix.diag(invs, m.domain, m.shape)\n37:     return smf\n38: \n39: \n40: def add_columns(m, i, j, a, b, c, d):\n41:     # replace m[:, i] by a*m[:, i] + b*m[:, j]\n42:     # and m[:, j] by c*m[:, i] + d*m[:, j]\n43:     for k in range(len(m)):\n44:         e = m[k][i]\n45:         m[k][i] = a*e + b*m[k][j]\n46:         m[k][j] = c*e + d*m[k][j]\n47: \n48: \n49: def invariant_factors(m):\n50:     '''\n51:     Return the tuple of abelian invariants for a matrix `m`\n52:     (as in the Smith-Normal form)\n53: \n54:     References\n55:     ==========\n56: \n57:     [1] https://en.wikipedia.org/wiki/Smith_normal_form#Algorithm\n58:     [2] http://sierra.nmsu.edu/morandi/notes/SmithNormalForm.pdf\n59: \n60:     '''\n61:     domain = m.domain\n62:     if not domain.is_PID:\n63:         msg = \"The matrix entries must be over a principal ideal domain\"\n64:         raise ValueError(msg)\n65: \n66:     if 0 in m.shape:\n67:         return ()\n68: \n69:     rows, cols = shape = m.shape\n70:     m = list(m.to_dense().rep)\n71: \n72:     def add_rows(m, i, j, a, b, c, d):\n73:         # replace m[i, :] by a*m[i, :] + b*m[j, :]\n74:         # and m[j, :] by c*m[i, :] + d*m[j, :]\n75:         for k in range(cols):\n76:             e = m[i][k]\n77:             m[i][k] = a*e + b*m[j][k]\n78:             m[j][k] = c*e + d*m[j][k]\n79: \n80:     def clear_column(m):\n81:         # make m[1:, 0] zero by row and column operations\n82:         if m[0][0] == 0:\n83:             return m  # pragma: nocover\n84:         pivot = m[0][0]\n85:         for j in range(1, rows):\n86:             if m[j][0] == 0:\n87:                 continue\n88:             d, r = domain.div(m[j][0], pivot)\n89:             if r == 0:\n90:                 add_rows(m, 0, j, 1, 0, -d, 1)\n91:             else:\n92:                 a, b, g = domain.gcdex(pivot, m[j][0])\n93:                 d_0 = domain.div(m[j][0], g)[0]\n94:                 d_j = domain.div(pivot, g)[0]\n95:                 add_rows(m, 0, j, a, b, d_0, -d_j)\n96:                 pivot = g\n97:         return m\n98: \n99:     def clear_row(m):\n100:         # make m[0, 1:] zero by row and column operations\n101:         if m[0][0] == 0:\n102:             return m  # pragma: nocover\n103:         pivot = m[0][0]\n104:         for j in range(1, cols):\n105:             if m[0][j] == 0:\n106:                 continue\n107:             d, r = domain.div(m[0][j], pivot)\n108:             if r == 0:\n109:                 add_columns(m, 0, j, 1, 0, -d, 1)\n110:             else:\n111:                 a, b, g = domain.gcdex(pivot, m[0][j])\n112:                 d_0 = domain.div(m[0][j], g)[0]\n113:                 d_j = domain.div(pivot, g)[0]\n114:                 add_columns(m, 0, j, a, b, d_0, -d_j)\n115:                 pivot = g\n116:         return m\n117: \n118:     # permute the rows and columns until m[0,0] is non-zero if possible\n119:     ind = [i for i in range(rows) if m[i][0] != 0]\n120:     if ind and ind[0] != 0:\n121:         m[0], m[ind[0]] = m[ind[0]], m[0]\n122:     else:\n123:         ind = [j for j in range(cols) if m[0][j] != 0]\n124:         if ind and ind[0] != 0:\n125:             for row in m:\n126:                 row[0], row[ind[0]] = row[ind[0]], row[0]\n127: \n128:     # make the first row and column except m[0,0] zero\n129:     while (any(m[0][i] != 0 for i in range(1,cols)) or\n130:            any(m[i][0] != 0 for i in range(1,rows))):\n131:         m = clear_column(m)\n132:         m = clear_row(m)\n133: \n134:     if 1 in shape:\n135:         invs = ()\n136:     else:\n137:         lower_right = DomainMatrix([r[1:] for r in m[1:]], (rows-1, cols-1), domain)\n138:         invs = invariant_factors(lower_right)\n139: \n140:     if m[0][0]:\n141:         result = [m[0][0]]\n142:         result.extend(invs)\n143:         # in case m[0] doesn't divide the invariants of the rest of the matrix\n144:         for i in range(len(result)-1):\n145:             if result[i] and domain.div(result[i+1], result[i])[1] != 0:\n146:                 g = domain.gcd(result[i+1], result[i])\n147:                 result[i+1] = domain.div(result[i], g)[0]*result[i+1]\n148:                 result[i] = g\n149:             else:\n150:                 break\n151:     else:\n152:         result = invs + (m[0][0],)\n153:     return tuple(result)\n154: \n155: \n156: def _gcdex(a, b):\nCode replaced for brevity.\n174: \n175: \n176: \n177: def _hermite_normal_form(A):\n178:     r\"\"\"\n179:     Compute the Hermite Normal Form of DomainMatrix *A* over :ref:`ZZ`.\n180: \n181:     Parameters\n182:     ==========\n183: \n184:     A : :py:class:`~.DomainMatrix` over domain :ref:`ZZ`.\n185: \n186:     Returns\n187:     =======\n188: \n189:     :py:class:`~.DomainMatrix`\n190:         The HNF of matrix *A*.\n191: \n192:     Raises\n193:     ======\n194: \n195:     DMDomainError\n196:         If the domain of the matrix is not :ref:`ZZ`.\n197: \n198:     References\n199:     ==========\n200: \n201:     .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n202:        (See Algorithm 2.4.5.)\n203: \n204:     \"\"\"\n205:     if not A.domain.is_ZZ:\n206:         raise DMDomainError('Matrix must be over domain ZZ.')\n207:     # We work one row at a time, starting from the bottom row, and working our\n208:     # way up. The total number of rows we will consider is min(m, n), where\n209:     # A is an m x n matrix.\n210:     m, n = A.shape\n211:     rows = min(m, n)\n212:     A = A.to_dense().rep.copy()\n213:     # Our goal is to put pivot entries in the rightmost columns.\n214:     # Invariant: Before processing each row, k should be the index of the\n215:     # leftmost column in which we have so far put a pivot.\n216:     k = n\n217:     for i in range(m - 1, m - 1 - rows, -1):\n218:         k -= 1\n219:         # k now points to the column in which we want to put a pivot.\n220:         # We want zeros in all entries to the left of the pivot column.\n221:         for j in range(k - 1, -1, -1):\n222:             if A[i][j] != 0:\n223:                 # Replace cols j, k by lin combs of these cols such that, in row i,\n224:                 # col j has 0, while col k has the gcd of their row i entries. Note\n225:                 # that this ensures a nonzero entry in col k.\n226:                 u, v, d = _gcdex(A[i][k], A[i][j])\n227:                 r, s = A[i][k] // d, A[i][j] // d\n228:                 add_columns(A, k, j, u, v, -s, r)\n229:         b = A[i][k]\n230:         # Do not want the pivot entry to be negative.\n231:         if b < 0:\n232:             add_columns(A, k, k, -1, 0, -1, 0)\n233:             b = -b\n234:         # The pivot entry will be 0 iff the row was 0 from the pivot col all the\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/polys/matrices/normalforms.py",
      "suspect_lines": [
        208,
        209,
        211,
        217
      ]
    }
  ]
}