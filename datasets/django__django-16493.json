{
  "instance_id": "django__django-16493",
  "problem_statement": "Callable storage on FileField fails to deconstruct when it returns default_storage\nDescription\n\t\nIf the storage argument on a FileField is set to a callable that returns default_storage, it is omitted from the deconstructed form of the field, rather than being included as a reference to the callable as expected.\nFor example, given a model definition:\nfrom django.core.files.storage import FileSystemStorage, default_storage\nfrom django.db import models\nimport random\nother_storage = FileSystemStorage(location='/media/other')\ndef get_storage():\n\treturn random.choice([default_storage, other_storage])\nclass MyModel(models.Model):\n\tmy_file = models.FileField(storage=get_storage)\nrepeatedly running makemigrations will randomly generate a migration that alternately includes or omits storage=myapp.models.get_storage on the FileField definition.\nThis case was overlooked in the fix for #31941 - the deconstruct method tests if self.storage is not default_storage to determine whether to add the storage kwarg, but at this point self.storage is the evaluated version, so it wrongly returns false for a callable that returns default_storage.\n",
  "localized_code": "[start of django/db/models/fields/files.py]\n1: import datetime\n2: import posixpath\n3: \n4: from django import forms\n5: from django.core import checks\n6: from django.core.files.base import File\n7: from django.core.files.images import ImageFile\n8: from django.core.files.storage import Storage, default_storage\n9: from django.core.files.utils import validate_file_name\n10: from django.db.models import signals\n11: from django.db.models.fields import Field\n12: from django.db.models.query_utils import DeferredAttribute\n13: from django.db.models.utils import AltersData\n14: from django.utils.translation import gettext_lazy as _\n15: \n16: \n17: class FieldFile(File, AltersData):\n18:     def __init__(self, instance, field, name):\n19:         super().__init__(None, name)\n20:         self.instance = instance\n21:         self.field = field\n22:         self.storage = field.storage\n23:         self._committed = True\n24: \n25:     def __eq__(self, other):\n26:         # Older code may be expecting FileField values to be simple strings.\n27:         # By overriding the == operator, it can remain backwards compatibility.\n28:         if hasattr(other, \"name\"):\n29:             return self.name == other.name\n30:         return self.name == other\n31: \n32:     def __hash__(self):\n33:         return hash(self.name)\n34: \n35:     # The standard File contains most of the necessary properties, but\n36:     # FieldFiles can be instantiated without a name, so that needs to\n37:     # be checked for here.\n38: \n39:     def _require_file(self):\n40:         if not self:\n41:             raise ValueError(\n42:                 \"The '%s' attribute has no file associated with it.\" % self.field.name\n43:             )\n44: \n45:     def _get_file(self):\n46:         self._require_file()\n47:         if getattr(self, \"_file\", None) is None:\n48:             self._file = self.storage.open(self.name, \"rb\")\n49:         return self._file\n50: \n51:     def _set_file(self, file):\n52:         self._file = file\n53: \n54:     def _del_file(self):\n55:         del self._file\n56: \n57:     file = property(_get_file, _set_file, _del_file)\n58: \n59:     @property\n60:     def path(self):\n61:         self._require_file()\n62:         return self.storage.path(self.name)\n63: \n64:     @property\n65:     def url(self):\n66:         self._require_file()\n67:         return self.storage.url(self.name)\n68: \n69:     @property\n70:     def size(self):\n71:         self._require_file()\n72:         if not self._committed:\n73:             return self.file.size\n74:         return self.storage.size(self.name)\n75: \n76:     def open(self, mode=\"rb\"):\n77:         self._require_file()\n78:         if getattr(self, \"_file\", None) is None:\n79:             self.file = self.storage.open(self.name, mode)\n80:         else:\n81:             self.file.open(mode)\n82:         return self\n83: \n84:     # open() doesn't alter the file's contents, but it does reset the pointer\n85:     open.alters_data = True\n86: \n87:     # In addition to the standard File API, FieldFiles have extra methods\n88:     # to further manipulate the underlying file, as well as update the\n89:     # associated model instance.\n90: \n91:     def save(self, name, content, save=True):\n92:         name = self.field.generate_filename(self.instance, name)\n93:         self.name = self.storage.save(name, content, max_length=self.field.max_length)\n94:         setattr(self.instance, self.field.attname, self.name)\n95:         self._committed = True\n96: \n97:         # Save the object because it has changed, unless save is False\n98:         if save:\n99:             self.instance.save()\n100: \n101:     save.alters_data = True\n102: \n103:     def delete(self, save=True):\n104:         if not self:\n105:             return\n106:         # Only close the file if it's already open, which we know by the\n107:         # presence of self._file\n108:         if hasattr(self, \"_file\"):\n109:             self.close()\n110:             del self.file\n111: \n112:         self.storage.delete(self.name)\n113: \n114:         self.name = None\n115:         setattr(self.instance, self.field.attname, self.name)\n116:         self._committed = False\n117: \n118:         if save:\n119:             self.instance.save()\n120: \n121:     delete.alters_data = True\n122: \n123:     @property\n124:     def closed(self):\n125:         file = getattr(self, \"_file\", None)\n126:         return file is None or file.closed\n127: \n128:     def close(self):\n129:         file = getattr(self, \"_file\", None)\n130:         if file is not None:\n131:             file.close()\n132: \n133:     def __getstate__(self):\n134:         # FieldFile needs access to its associated model field, an instance and\n135:         # the file's name. Everything else will be restored later, by\n136:         # FileDescriptor below.\n137:         return {\n138:             \"name\": self.name,\n139:             \"closed\": False,\n140:             \"_committed\": True,\n141:             \"_file\": None,\n142:             \"instance\": self.instance,\n143:             \"field\": self.field,\n144:         }\n145: \n146:     def __setstate__(self, state):\n147:         self.__dict__.update(state)\n148:         self.storage = self.field.storage\n149: \n150: \n151: class FileDescriptor(DeferredAttribute):\nCode replaced for brevity.\n221: \n222: \n223: \n224: class FileField(Field):\n225: \n226:     # The class to wrap instance attributes in. Accessing the file object off\n227:     # the instance will always return an instance of attr_class.\n228:     attr_class = FieldFile\n229: \n230:     # The descriptor to use for accessing the attribute off of the class.\n231:     descriptor_class = FileDescriptor\n232: \n233:     description = _(\"File\")\n234: \n235:     def __init__(\n236:         self, verbose_name=None, name=None, upload_to=\"\", storage=None, **kwargs\n237:     ):\n238:         self._primary_key_set_explicitly = \"primary_key\" in kwargs\n239: \n240:         self.storage = storage or default_storage\n241:         if callable(self.storage):\n242:             # Hold a reference to the callable for deconstruct().\n243:             self._storage_callable = self.storage\n244:             self.storage = self.storage()\n245:             if not isinstance(self.storage, Storage):\n246:                 raise TypeError(\n247:                     \"%s.storage must be a subclass/instance of %s.%s\"\n248:                     % (\n249:                         self.__class__.__qualname__,\n250:                         Storage.__module__,\n251:                         Storage.__qualname__,\n252:                     )\n253:                 )\n254:         self.upload_to = upload_to\n255: \n256:         kwargs.setdefault(\"max_length\", 100)\n257:         super().__init__(verbose_name, name, **kwargs)\n258: \n259:     def check(self, **kwargs):\n260:         return [\n261:             *super().check(**kwargs),\n262:             *self._check_primary_key(),\n263:             *self._check_upload_to(),\n264:         ]\n265: \n266:     def _check_primary_key(self):\n267:         if self._primary_key_set_explicitly:\n268:             return [\n269:                 checks.Error(\n270:                     \"'primary_key' is not a valid argument for a %s.\"\n271:                     % self.__class__.__name__,\n272:                     obj=self,\n273:                     id=\"fields.E201\",\n274:                 )\n275:             ]\n276:         else:\n277:             return []\n278: \n279:     def _check_upload_to(self):\n280:         if isinstance(self.upload_to, str) and self.upload_to.startswith(\"/\"):\n281:             return [\n282:                 checks.Error(\n283:                     \"%s's 'upload_to' argument must be a relative path, not an \"\n284:                     \"absolute path.\" % self.__class__.__name__,\n285:                     obj=self,\n286:                     id=\"fields.E202\",\n287:                     hint=\"Remove the leading slash.\",\n288:                 )\n289:             ]\n290:         else:\n291:             return []\n292: \n293:     def deconstruct(self):\n294:         name, path, args, kwargs = super().deconstruct()\n295:         if kwargs.get(\"max_length\") == 100:\n296:             del kwargs[\"max_length\"]\n297:         kwargs[\"upload_to\"] = self.upload_to\n298:         if self.storage is not default_storage:\n299:             kwargs[\"storage\"] = getattr(self, \"_storage_callable\", self.storage)\n300:         return name, path, args, kwargs\n301: \n302:     def get_internal_type(self):\n303:         return \"FileField\"\n304: \n305:     def get_prep_value(self, value):\n306:         value = super().get_prep_value(value)\n307:         # Need to convert File objects provided via a form to string for\n308:         # database insertion.\n309:         if value is None:\n310:             return None\n311:         return str(value)\n312: \n313:     def pre_save(self, model_instance, add):\n314:         file = super().pre_save(model_instance, add)\n315:         if file and not file._committed:\n316:             # Commit the file to storage prior to saving the model\n317:             file.save(file.name, file.file, save=False)\n318:         return file\n319: \n320:     def contribute_to_class(self, cls, name, **kwargs):\n321:         super().contribute_to_class(cls, name, **kwargs)\n322:         setattr(cls, self.attname, self.descriptor_class(self))\n323: \n324:     def generate_filename(self, instance, filename):\n325:         \"\"\"\n326:         Apply (if callable) or prepend (if a string) upload_to to the filename,\n327:         then delegate further processing of the name to the storage backend.\n328:         Until the storage layer, all file paths are expected to be Unix style\n329:         (with forward slashes).\n330:         \"\"\"\n331:         if callable(self.upload_to):\n332:             filename = self.upload_to(instance, filename)\n333:         else:\n334:             dirname = datetime.datetime.now().strftime(str(self.upload_to))\n335:             filename = posixpath.join(dirname, filename)\n336:         filename = validate_file_name(filename, allow_relative_path=True)\n337:         return self.storage.generate_filename(filename)\n338: \n339:     def save_form_data(self, instance, data):\n340:         # Important: None means \"no change\", other false value means \"clear\"\n341:         # This subtle distinction (rather than a more explicit marker) is\n342:         # needed because we need to consume values that are also sane for a\n343:         # regular (non Model-) Form to find in its cleaned_data dictionary.\n344:         if data is not None:\n345:             # This value will be converted to str and stored in the\n346:             # database, so leaving False as-is is not acceptable.\n347:             setattr(instance, self.name, data or \"\")\n348: \n349:     def formfield(self, **kwargs):\n350:         return super().formfield(\n351:             **{\n352:                 \"form_class\": forms.FileField,\n353:                 \"max_length\": self.max_length,\n354:                 **kwargs,\n355:             }\n356:         )\n357: \n358: \n359: class ImageFileDescriptor(FileDescriptor):\nCode replaced for brevity.\n379: \n380: \n381: \n382: class ImageFieldFile(ImageFile, FieldFile):\nCode replaced for brevity.\n387: \n388: \n389: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/files.py",
      "suspect_lines": [
        298,
        299
      ]
    }
  ]
}