{
  "instance_id": "django__django-12155",
  "problem_statement": "docutils reports an error rendering view docstring when the first line is not empty\nDescription\n\t\nCurrently admindoc works correctly only with docstrings where the first line is empty, and all Django docstrings are formatted in this way.\nHowever usually the docstring text starts at the first line, e.g.:\ndef test():\n\t\"\"\"test tests something.\n\t\"\"\"\nand this cause an error:\nError in \"default-role\" directive:\nno content permitted.\n.. default-role:: cmsreference\nThe culprit is this code in trim_docstring:\nindent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\nThe problem is that the indentation of the first line is 0.\nThe solution is to skip the first line:\nindent = min(len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip())\nThanks.\n",
  "localized_code": "[start of django/contrib/admindocs/utils.py]\n1: \"Misc. utility functions/classes for admin documentation generator.\"\n2: \n3: import re\n4: from email.errors import HeaderParseError\n5: from email.parser import HeaderParser\n6: \n7: from django.urls import reverse\n8: from django.utils.regex_helper import _lazy_re_compile\n9: from django.utils.safestring import mark_safe\n10: \n11: try:\n12:     import docutils.core\n13:     import docutils.nodes\n14:     import docutils.parsers.rst.roles\n15: except ImportError:\n16:     docutils_is_available = False\n17: else:\n18:     docutils_is_available = True\n19: \n20: \n21: def get_view_name(view_func):\n22:     mod_name = view_func.__module__\n23:     view_name = getattr(view_func, '__qualname__', view_func.__class__.__name__)\n24:     return mod_name + '.' + view_name\n25: \n26: \n27: def trim_docstring(docstring):\n28:     \"\"\"\n29:     Uniformly trim leading/trailing whitespace from docstrings.\n30: \n31:     Based on https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation\n32:     \"\"\"\n33:     if not docstring or not docstring.strip():\n34:         return ''\n35:     # Convert tabs to spaces and split into lines\n36:     lines = docstring.expandtabs().splitlines()\n37:     indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n38:     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n39:     return \"\\n\".join(trimmed).strip()\n40: \n41: \n42: def parse_docstring(docstring):\n43:     \"\"\"\n44:     Parse out the parts of a docstring.  Return (title, body, metadata).\n45:     \"\"\"\n46:     docstring = trim_docstring(docstring)\n47:     parts = re.split(r'\\n{2,}', docstring)\n48:     title = parts[0]\n49:     if len(parts) == 1:\n50:         body = ''\n51:         metadata = {}\n... Code Truncated ...\n\n[start of django/contrib/admindocs/views.py]\n1: import inspect\n2: from importlib import import_module\n3: from pathlib import Path\n4: \n5: from django.apps import apps\n6: from django.conf import settings\n7: from django.contrib import admin\n8: from django.contrib.admin.views.decorators import staff_member_required\n9: from django.contrib.admindocs import utils\n10: from django.contrib.admindocs.utils import (\n11:     replace_named_groups, replace_unnamed_groups,\n12: )\n13: from django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist\n14: from django.db import models\n15: from django.http import Http404\n16: from django.template.engine import Engine\n17: from django.urls import get_mod_func, get_resolver, get_urlconf\n18: from django.utils.decorators import method_decorator\n19: from django.utils.inspect import (\n20:     func_accepts_kwargs, func_accepts_var_args, get_func_full_args,\n21:     method_has_no_args,\n22: )\n23: from django.utils.translation import gettext as _\n24: from django.views.generic import TemplateView\n25: \n26: from .utils import get_view_name\n27: \n28: # Exclude methods starting with these strings from documentation\n29: MODEL_METHODS_EXCLUDE = ('_', 'add_', 'delete', 'save', 'set_')\n30: \n31: \n32: class BaseAdminDocsView(TemplateView):\n33:     \"\"\"\n34:     Base view for admindocs views.\n35:     \"\"\"\n36:     @method_decorator(staff_member_required)\n37:     def dispatch(self, request, *args, **kwargs):\n38:         if not utils.docutils_is_available:\n39:             # Display an error message for people without docutils\n40:             self.template_name = 'admin_doc/missing_docutils.html'\n41:             return self.render_to_response(admin.site.each_context(request))\n42:         return super().dispatch(request, *args, **kwargs)\n43: \n44:     def get_context_data(self, **kwargs):\n45:         return super().get_context_data(**{\n46:             **kwargs,\n47:             **admin.site.each_context(self.request),\n48:         })\n49: \n50: \n51: class BookmarkletsView(BaseAdminDocsView):\nCode replaced for brevity.\n52: \n53: \n54: \n55: class TemplateTagIndexView(BaseAdminDocsView):\nCode replaced for brevity.\n83: \n84: \n85: \n86: class TemplateFilterIndexView(BaseAdminDocsView):\nCode replaced for brevity.\n114: \n115: \n116: \n117: class ViewIndexView(BaseAdminDocsView):\nCode replaced for brevity.\n132: \n133: \n134: \n135: class ViewDetailView(BaseAdminDocsView):\nCode replaced for brevity.\n171: \n172: \n173: \n174: class ModelIndexView(BaseAdminDocsView):\nCode replaced for brevity.\n179: \n180: \n181: \n182: class ModelDetailView(BaseAdminDocsView):\n183:     template_name = 'admin_doc/model_detail.html'\n184: \n185:     def get_context_data(self, **kwargs):\n186:         model_name = self.kwargs['model_name']\n187:         # Get the model class.\n188:         try:\n189:             app_config = apps.get_app_config(self.kwargs['app_label'])\n190:         except LookupError:\n191:             raise Http404(_(\"App %(app_label)r not found\") % self.kwargs)\n192:         try:\n193:             model = app_config.get_model(model_name)\n194:         except LookupError:\n195:             raise Http404(_(\"Model %(model_name)r not found in app %(app_label)r\") % self.kwargs)\n196: \n197:         opts = model._meta\n198: \n199:         title, body, metadata = utils.parse_docstring(model.__doc__)\n200:         title = title and utils.parse_rst(title, 'model', _('model:') + model_name)\n201:         body = body and utils.parse_rst(body, 'model', _('model:') + model_name)\n202: \n203:         # Gather fields/field descriptions.\n204:         fields = []\n205:         for field in opts.fields:\n206:             # ForeignKey is a special case since the field will actually be a\n207:             # descriptor that returns the other object\n208:             if isinstance(field, models.ForeignKey):\n209:                 data_type = field.remote_field.model.__name__\n210:                 app_label = field.remote_field.model._meta.app_label\n211:                 verbose = utils.parse_rst(\n212:                     (_(\"the related `%(app_label)s.%(data_type)s` object\") % {\n213:                         'app_label': app_label, 'data_type': data_type,\n214:                     }),\n215:                     'model',\n216:                     _('model:') + data_type,\n217:                 )\n218:             else:\n219:                 data_type = get_readable_field_data_type(field)\n220:                 verbose = field.verbose_name\n221:             fields.append({\n222:                 'name': field.name,\n223:                 'data_type': data_type,\n224:                 'verbose': verbose or '',\n225:                 'help_text': field.help_text,\n226:             })\n227: \n228:         # Gather many-to-many fields.\n229:         for field in opts.many_to_many:\n230:             data_type = field.remote_field.model.__name__\n231:             app_label = field.remote_field.model._meta.app_label\n232:             verbose = _(\"related `%(app_label)s.%(object_name)s` objects\") % {\n233:                 'app_label': app_label,\n234:                 'object_name': data_type,\n235:             }\n236:             fields.append({\n237:                 'name': \"%s.all\" % field.name,\n238:                 \"data_type\": 'List',\n239:                 'verbose': utils.parse_rst(_(\"all %s\") % verbose, 'model', _('model:') + opts.model_name),\n240:             })\n241:             fields.append({\n242:                 'name': \"%s.count\" % field.name,\n243:                 'data_type': 'Integer',\n244:                 'verbose': utils.parse_rst(_(\"number of %s\") % verbose, 'model', _('model:') + opts.model_name),\n245:             })\n246: \n247:         methods = []\n248:         # Gather model methods.\n249:         for func_name, func in model.__dict__.items():\n250:             if inspect.isfunction(func) or isinstance(func, property):\n251:                 try:\n252:                     for exclude in MODEL_METHODS_EXCLUDE:\n253:                         if func_name.startswith(exclude):\n254:                             raise StopIteration\n255:                 except StopIteration:\n256:                     continue\n257:                 verbose = func.__doc__\n258:                 verbose = verbose and (\n259:                     utils.parse_rst(utils.trim_docstring(verbose), 'model', _('model:') + opts.model_name)\n260:                 )\n261:                 # Show properties and methods without arguments as fields.\n262:                 # Otherwise, show as a 'method with arguments'.\n263:                 if isinstance(func, property):\n264:                     fields.append({\n265:                         'name': func_name,\n266:                         'data_type': get_return_data_type(func_name),\n267:                         'verbose': verbose or ''\n268:                     })\n269:                 elif method_has_no_args(func) and not func_accepts_kwargs(func) and not func_accepts_var_args(func):\n270:                     fields.append({\n271:                         'name': func_name,\n272:                         'data_type': get_return_data_type(func_name),\n273:                         'verbose': verbose or '',\n274:                     })\n275:                 else:\n276:                     arguments = get_func_full_args(func)\n277:                     # Join arguments with ', ' and in case of default value,\n278:                     # join it with '='. Use repr() so that strings will be\n279:                     # correctly displayed.\n280:                     print_arguments = ', '.join([\n281:                         '='.join([arg_el[0], *map(repr, arg_el[1:])])\n282:                         for arg_el in arguments\n283:                     ])\n284:                     methods.append({\n285:                         'name': func_name,\n286:                         'arguments': print_arguments,\n287:                         'verbose': verbose or '',\n288:                     })\n289: \n290:         # Gather related objects\n291:         for rel in opts.related_objects:\n292:             verbose = _(\"related `%(app_label)s.%(object_name)s` objects\") % {\n293:                 'app_label': rel.related_model._meta.app_label,\n294:                 'object_name': rel.related_model._meta.object_name,\n295:             }\n296:             accessor = rel.get_accessor_name()\n297:             fields.append({\n298:                 'name': \"%s.all\" % accessor,\n299:                 'data_type': 'List',\n300:                 'verbose': utils.parse_rst(_(\"all %s\") % verbose, 'model', _('model:') + opts.model_name),\n301:             })\n302:             fields.append({\n303:                 'name': \"%s.count\" % accessor,\n304:                 'data_type': 'Integer',\n305:                 'verbose': utils.parse_rst(_(\"number of %s\") % verbose, 'model', _('model:') + opts.model_name),\n306:             })\n307:         return super().get_context_data(**{\n308:             **kwargs,\n309:             'name': '%s.%s' % (opts.app_label, opts.object_name),\n310:             'summary': title,\n311:             'description': body,\n312:             'fields': fields,\n313:             'methods': methods,\n314:         })\n315: \n316: \n317: class TemplateDetailView(BaseAdminDocsView):\nCode replaced for brevity.\n346: \n347: \n348: \n349: ####################\n350: # Helper functions #\n351: ####################\n352: \n353: \n354: def get_return_data_type(func_name):\nCode replaced for brevity.\n361: \n362: \n363: \n364: def get_readable_field_data_type(field):\nCode replaced for brevity.\n370: \n371: \n372: \n373: def extract_views_from_urlpatterns(urlpatterns, base='', namespace=None):\nCode replaced for brevity.\n398: \n399: \n400: \n401: def simplify_regex(pattern):\nCode replaced for brevity.\n413: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admindocs/utils.py",
      "suspect_lines": [
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        46
      ]
    },
    {
      "filename": "/django/contrib/admindocs/views.py",
      "suspect_lines": [
        259
      ]
    }
  ]
}