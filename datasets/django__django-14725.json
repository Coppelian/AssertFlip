{
  "instance_id": "django__django-14725",
  "problem_statement": "Provide a way for model formsets to disallow new object creation\nDescription\n\t\nModel formsets don't provide a way to create an \"edit only\" view of objects. We see users trying to use extra=0 to accomplish this, but that's not reliable as extra is merely meant for the extra number of forms to display. You can add more forms with Javascript (or just send additional post data).\n",
  "localized_code": "[start of django/forms/models.py]\n1: \"\"\"\n2: Helper functions for creating Form classes from Django models\n3: and database field objects.\n4: \"\"\"\n5: from itertools import chain\n6: \n7: from django.core.exceptions import (\n8:     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n9: )\n10: from django.forms.fields import ChoiceField, Field\n11: from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n12: from django.forms.formsets import BaseFormSet, formset_factory\n13: from django.forms.utils import ErrorList\n14: from django.forms.widgets import (\n15:     HiddenInput, MultipleHiddenInput, RadioSelect, SelectMultiple,\n16: )\n17: from django.utils.text import capfirst, get_text_list\n18: from django.utils.translation import gettext, gettext_lazy as _\n19: \n20: __all__ = (\n21:     'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',\n22:     'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS',\n23:     'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',\n24:     'inlineformset_factory', 'modelform_factory',\n25: )\n26: \n27: ALL_FIELDS = '__all__'\n28: \n29: \n30: def construct_instance(form, instance, fields=None, exclude=None):\n31:     \"\"\"\n32:     Construct and return a model instance from the bound ``form``'s\n33:     ``cleaned_data``, but do not save the returned instance to the database.\n34:     \"\"\"\n35:     from django.db import models\n36:     opts = instance._meta\n37: \n38:     cleaned_data = form.cleaned_data\n39:     file_field_list = []\n40:     for f in opts.fields:\n41:         if not f.editable or isinstance(f, models.AutoField) \\\n42:                 or f.name not in cleaned_data:\n43:             continue\n44:         if fields is not None and f.name not in fields:\n45:             continue\n46:         if exclude and f.name in exclude:\n47:             continue\n48:         # Leave defaults for fields that aren't in POST data, except for\n49:         # checkbox inputs because they don't appear in POST data if not checked.\n50:         if (\n51:             f.has_default() and\n52:             form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)) and\n53:             cleaned_data.get(f.name) in form[f.name].field.empty_values\n54:         ):\n55:             continue\n56:         # Defer saving file-type fields until after the other fields, so a\n57:         # callable upload_to can use the values from other fields.\n58:         if isinstance(f, models.FileField):\n59:             file_field_list.append(f)\n60:         else:\n61:             f.save_form_data(instance, cleaned_data[f.name])\n62: \n63:     for f in file_field_list:\n64:         f.save_form_data(instance, cleaned_data[f.name])\n65: \n66:     return instance\n67: \n68: \n69: # ModelForms #################################################################\n70: \n71: def model_to_dict(instance, fields=None, exclude=None):\nCode replaced for brevity.\n93: \n94: \n95: \n96: def apply_limit_choices_to_to_formfield(formfield):\nCode replaced for brevity.\n109: \n110: \n111: \n112:                      field_classes=None, *, apply_limit_choices_to=True):\nCode replaced for brevity.\n198: \n199: \n200: \n201: class ModelFormOptions:\nCode replaced for brevity.\n211: \n212: \n213: \n214: class ModelFormMetaclass(DeclarativeFieldsMetaclass):\nCode replaced for brevity.\n283: \n284: \n285: \n286: class BaseModelForm(BaseForm):\nCode replaced for brevity.\n474: \n475: \n476: \n477: class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n478:     pass\n479: \n480: \n481:                       field_classes=None):\nCode replaced for brevity.\n561: \n562: \n563: \n564: # ModelFormSets ##############################################################\n565: \n566: class BaseModelFormSet(BaseFormSet):\n567:     \"\"\"\n568:     A ``FormSet`` for editing a queryset and/or adding new objects to it.\n569:     \"\"\"\n570:     model = None\n571: \n572:     # Set of fields that must be unique among forms of this set.\n573:     unique_fields = set()\n574: \n575:     def __init__(self, data=None, files=None, auto_id='id_%s', prefix=None,\n576:                  queryset=None, *, initial=None, **kwargs):\n577:         self.queryset = queryset\n578:         self.initial_extra = initial\n579:         super().__init__(**{'data': data, 'files': files, 'auto_id': auto_id, 'prefix': prefix, **kwargs})\n580: \n581:     def initial_form_count(self):\n582:         \"\"\"Return the number of forms that are required in this FormSet.\"\"\"\n583:         if not self.is_bound:\n584:             return len(self.get_queryset())\n585:         return super().initial_form_count()\n586: \n587:     def _existing_object(self, pk):\n588:         if not hasattr(self, '_object_dict'):\n589:             self._object_dict = {o.pk: o for o in self.get_queryset()}\n590:         return self._object_dict.get(pk)\n591: \n592:     def _get_to_python(self, field):\n593:         \"\"\"\n594:         If the field is a related field, fetch the concrete field's (that\n595:         is, the ultimate pointed-to field's) to_python.\n596:         \"\"\"\n597:         while field.remote_field is not None:\n598:             field = field.remote_field.get_related_field()\n599:         return field.to_python\n600: \n601:     def _construct_form(self, i, **kwargs):\n602:         pk_required = i < self.initial_form_count()\n603:         if pk_required:\n604:             if self.is_bound:\n605:                 pk_key = '%s-%s' % (self.add_prefix(i), self.model._meta.pk.name)\n606:                 try:\n607:                     pk = self.data[pk_key]\n608:                 except KeyError:\n609:                     # The primary key is missing. The user may have tampered\n610:                     # with POST data.\n611:                     pass\n612:                 else:\n613:                     to_python = self._get_to_python(self.model._meta.pk)\n614:                     try:\n615:                         pk = to_python(pk)\n616:                     except ValidationError:\n617:                         # The primary key exists but is an invalid value. The\n618:                         # user may have tampered with POST data.\n619:                         pass\n620:                     else:\n621:                         kwargs['instance'] = self._existing_object(pk)\n622:             else:\n623:                 kwargs['instance'] = self.get_queryset()[i]\n624:         elif self.initial_extra:\n625:             # Set initial values for extra forms\n626:             try:\n627:                 kwargs['initial'] = self.initial_extra[i - self.initial_form_count()]\n628:             except IndexError:\n629:                 pass\n630:         form = super()._construct_form(i, **kwargs)\n631:         if pk_required:\n632:             form.fields[self.model._meta.pk.name].required = True\n633:         return form\n634: \n635:     def get_queryset(self):\n636:         if not hasattr(self, '_queryset'):\n637:             if self.queryset is not None:\n638:                 qs = self.queryset\n639:             else:\n640:                 qs = self.model._default_manager.get_queryset()\n641: \n642:             # If the queryset isn't already ordered we need to add an\n643:             # artificial ordering here to make sure that all formsets\n644:             # constructed from this queryset have the same form order.\n645:             if not qs.ordered:\n646:                 qs = qs.order_by(self.model._meta.pk.name)\n647: \n648:             # Removed queryset limiting here. As per discussion re: #13023\n649:             # on django-dev, max_num should not prevent existing\n650:             # related objects/inlines from being displayed.\n651:             self._queryset = qs\n652:         return self._queryset\n653: \n654:     def save_new(self, form, commit=True):\n655:         \"\"\"Save and return a new model instance for the given form.\"\"\"\n656:         return form.save(commit=commit)\n657: \n658:     def save_existing(self, form, instance, commit=True):\n659:         \"\"\"Save and return an existing model instance for the given form.\"\"\"\n660:         return form.save(commit=commit)\n661: \n662:     def delete_existing(self, obj, commit=True):\n663:         \"\"\"Deletes an existing model instance.\"\"\"\n664:         if commit:\n665:             obj.delete()\n666: \n667:     def save(self, commit=True):\n668:         \"\"\"\n669:         Save model instances for every form, adding and changing instances\n670:         as necessary, and return the list of instances.\n671:         \"\"\"\n672:         if not commit:\n673:             self.saved_forms = []\n674: \n675:             def save_m2m():\n676:                 for form in self.saved_forms:\n677:                     form.save_m2m()\n678:             self.save_m2m = save_m2m\n679:         return self.save_existing_objects(commit) + self.save_new_objects(commit)\n680: \n681:     save.alters_data = True\n682: \n683:     def clean(self):\n684:         self.validate_unique()\n685: \n686:     def validate_unique(self):\n687:         # Collect unique_checks and date_checks to run from all the forms.\n688:         all_unique_checks = set()\n689:         all_date_checks = set()\n690:         forms_to_delete = self.deleted_forms\n691:         valid_forms = [form for form in self.forms if form.is_valid() and form not in forms_to_delete]\n692:         for form in valid_forms:\n693:             exclude = form._get_validation_exclusions()\n694:             unique_checks, date_checks = form.instance._get_unique_checks(exclude=exclude)\n695:             all_unique_checks.update(unique_checks)\n696:             all_date_checks.update(date_checks)\n697: \n698:         errors = []\n699:         # Do each of the unique checks (unique and unique_together)\n700:         for uclass, unique_check in all_unique_checks:\n701:             seen_data = set()\n702:             for form in valid_forms:\n703:                 # Get the data for the set of fields that must be unique among the forms.\n704:                 row_data = (\n705:                     field if field in self.unique_fields else form.cleaned_data[field]\n706:                     for field in unique_check if field in form.cleaned_data\n707:                 )\n708:                 # Reduce Model instances to their primary key values\n709:                 row_data = tuple(\n710:                     d._get_pk_val() if hasattr(d, '_get_pk_val')\n711:                     # Prevent \"unhashable type: list\" errors later on.\n712:                     else tuple(d) if isinstance(d, list)\n713:                     else d for d in row_data\n714:                 )\n715:                 if row_data and None not in row_data:\n716:                     # if we've already seen it then we have a uniqueness failure\n717:                     if row_data in seen_data:\n718:                         # poke error messages into the right places and mark\n719:                         # the form as invalid\n720:                         errors.append(self.get_unique_error_message(unique_check))\n721:                         form._errors[NON_FIELD_ERRORS] = self.error_class(\n722:                             [self.get_form_error()],\n723:                             renderer=self.renderer,\n724:                         )\n725:                         # remove the data from the cleaned_data dict since it was invalid\n726:                         for field in unique_check:\n727:                             if field in form.cleaned_data:\n728:                                 del form.cleaned_data[field]\n729:                     # mark the data as seen\n730:                     seen_data.add(row_data)\n731:         # iterate over each of the date checks now\n732:         for date_check in all_date_checks:\n733:             seen_data = set()\n734:             uclass, lookup, field, unique_for = date_check\n735:             for form in valid_forms:\n736:                 # see if we have data for both fields\n737:                 if (form.cleaned_data and form.cleaned_data[field] is not None and\n738:                         form.cleaned_data[unique_for] is not None):\n739:                     # if it's a date lookup we need to get the data for all the fields\n740:                     if lookup == 'date':\n741:                         date = form.cleaned_data[unique_for]\n742:                         date_data = (date.year, date.month, date.day)\n743:                     # otherwise it's just the attribute on the date/datetime\n744:                     # object\n745:                     else:\n746:                         date_data = (getattr(form.cleaned_data[unique_for], lookup),)\n747:                     data = (form.cleaned_data[field],) + date_data\n748:                     # if we've already seen it then we have a uniqueness failure\n749:                     if data in seen_data:\n750:                         # poke error messages into the right places and mark\n751:                         # the form as invalid\n752:                         errors.append(self.get_date_error_message(date_check))\n753:                         form._errors[NON_FIELD_ERRORS] = self.error_class(\n754:                             [self.get_form_error()],\n755:                             renderer=self.renderer,\n756:                         )\n757:                         # remove the data from the cleaned_data dict since it was invalid\n758:                         del form.cleaned_data[field]\n759:                     # mark the data as seen\n760:                     seen_data.add(data)\n761: \n762:         if errors:\n763:             raise ValidationError(errors)\n764: \n765:     def get_unique_error_message(self, unique_check):\n766:         if len(unique_check) == 1:\n767:             return gettext(\"Please correct the duplicate data for %(field)s.\") % {\n768:                 \"field\": unique_check[0],\n769:             }\n770:         else:\n771:             return gettext(\"Please correct the duplicate data for %(field)s, which must be unique.\") % {\n772:                 \"field\": get_text_list(unique_check, _(\"and\")),\n773:             }\n774: \n775:     def get_date_error_message(self, date_check):\n776:         return gettext(\n777:             \"Please correct the duplicate data for %(field_name)s \"\n778:             \"which must be unique for the %(lookup)s in %(date_field)s.\"\n779:         ) % {\n780:             'field_name': date_check[2],\n781:             'date_field': date_check[3],\n782:             'lookup': str(date_check[1]),\n783:         }\n784: \n785:     def get_form_error(self):\n786:         return gettext(\"Please correct the duplicate values below.\")\n787: \n788:     def save_existing_objects(self, commit=True):\n789:         self.changed_objects = []\n790:         self.deleted_objects = []\n791:         if not self.initial_forms:\n792:             return []\n793: \n794:         saved_instances = []\n795:         forms_to_delete = self.deleted_forms\n796:         for form in self.initial_forms:\n797:             obj = form.instance\n798:             # If the pk is None, it means either:\n799:             # 1. The object is an unexpected empty model, created by invalid\n800:             #    POST data such as an object outside the formset's queryset.\n801:             # 2. The object was already deleted from the database.\n802:             if obj.pk is None:\n803:                 continue\n804:             if form in forms_to_delete:\n805:                 self.deleted_objects.append(obj)\n806:                 self.delete_existing(obj, commit=commit)\n807:             elif form.has_changed():\n808:                 self.changed_objects.append((obj, form.changed_data))\n809:                 saved_instances.append(self.save_existing(form, obj, commit=commit))\n810:                 if not commit:\n811:                     self.saved_forms.append(form)\n812:         return saved_instances\n813: \n814:     def save_new_objects(self, commit=True):\n815:         self.new_objects = []\n816:         for form in self.extra_forms:\n817:             if not form.has_changed():\n818:                 continue\n819:             # If someone has marked an add form for deletion, don't save the\n820:             # object.\n821:             if self.can_delete and self._should_delete_form(form):\n822:                 continue\n823:             self.new_objects.append(self.save_new(form, commit=commit))\n824:             if not commit:\n825:                 self.saved_forms.append(form)\n826:         return self.new_objects\n827: \n828:     def add_fields(self, form, index):\n829:         \"\"\"Add a hidden field for the object's primary key.\"\"\"\n830:         from django.db.models import AutoField, ForeignKey, OneToOneField\n831:         self._pk_field = pk = self.model._meta.pk\n832:         # If a pk isn't editable, then it won't be on the form, so we need to\n833:         # add it here so we can tell which object is which when we get the\n834:         # data back. Generally, pk.editable should be false, but for some\n835:         # reason, auto_created pk fields and AutoField's editable attribute is\n836:         # True, so check for that as well.\n837: \n838:         def pk_is_not_editable(pk):\n839:             return (\n840:                 (not pk.editable) or (pk.auto_created or isinstance(pk, AutoField)) or (\n841:                     pk.remote_field and pk.remote_field.parent_link and\n842:                     pk_is_not_editable(pk.remote_field.model._meta.pk)\n843:                 )\n844:             )\n845:         if pk_is_not_editable(pk) or pk.name not in form.fields:\n846:             if form.is_bound:\n847:                 # If we're adding the related instance, ignore its primary key\n848:                 # as it could be an auto-generated default which isn't actually\n849:                 # in the database.\n850:                 pk_value = None if form.instance._state.adding else form.instance.pk\n851:             else:\n852:                 try:\n853:                     if index is not None:\n854:                         pk_value = self.get_queryset()[index].pk\n855:                     else:\n856:                         pk_value = None\n857:                 except IndexError:\n858:                     pk_value = None\n859:             if isinstance(pk, (ForeignKey, OneToOneField)):\n860:                 qs = pk.remote_field.model._default_manager.get_queryset()\n861:             else:\n862:                 qs = self.model._default_manager.get_queryset()\n863:             qs = qs.using(form.instance._state.db)\n864:             if form._meta.widgets:\n865:                 widget = form._meta.widgets.get(self._pk_field.name, HiddenInput)\n866:             else:\n867:                 widget = HiddenInput\n868:             form.fields[self._pk_field.name] = ModelChoiceField(qs, initial=pk_value, required=False, widget=widget)\n869:         super().add_fields(form, index)\n870: \n871: \n872: def modelformset_factory(model, form=ModelForm, formfield_callback=None,\n873:                          formset=BaseModelFormSet, extra=1, can_delete=False,\n874:                          can_order=False, max_num=None, fields=None, exclude=None,\n875:                          widgets=None, validate_max=False, localized_fields=None,\n876:                          labels=None, help_texts=None, error_messages=None,\n877:                          min_num=None, validate_min=False, field_classes=None,\n878:                          absolute_max=None, can_delete_extra=True, renderer=None):\n879:     \"\"\"Return a FormSet class for the given Django model class.\"\"\"\n880:     meta = getattr(form, 'Meta', None)\n881:     if (getattr(meta, 'fields', fields) is None and\n882:             getattr(meta, 'exclude', exclude) is None):\n883:         raise ImproperlyConfigured(\n884:             \"Calling modelformset_factory without defining 'fields' or \"\n885:             \"'exclude' explicitly is prohibited.\"\n886:         )\n887: \n888:     form = modelform_factory(model, form=form, fields=fields, exclude=exclude,\n889:                              formfield_callback=formfield_callback,\n890:                              widgets=widgets, localized_fields=localized_fields,\n891:                              labels=labels, help_texts=help_texts,\n892:                              error_messages=error_messages, field_classes=field_classes)\n893:     FormSet = formset_factory(form, formset, extra=extra, min_num=min_num, max_num=max_num,\n894:                               can_order=can_order, can_delete=can_delete,\n895:                               validate_min=validate_min, validate_max=validate_max,\n896:                               absolute_max=absolute_max, can_delete_extra=can_delete_extra,\n897:                               renderer=renderer)\n898:     FormSet.model = model\n899:     return FormSet\n900: \n901: \n902: # InlineFormSets #############################################################\n903: \n904: class BaseInlineFormSet(BaseModelFormSet):\nCode replaced for brevity.\n1001: \n1002: \n1003: \n1004: def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\nCode replaced for brevity.\n1069: \n1070: \n1071: \n1072: def inlineformset_factory(parent_model, model, form=ModelForm,\n1073:                           formset=BaseInlineFormSet, fk_name=None,\n1074:                           fields=None, exclude=None, extra=3, can_order=False,\n1075:                           can_delete=True, max_num=None, formfield_callback=None,\n1076:                           widgets=None, validate_max=False, localized_fields=None,\n1077:                           labels=None, help_texts=None, error_messages=None,\n1078:                           min_num=None, validate_min=False, field_classes=None,\n1079:                           absolute_max=None, can_delete_extra=True, renderer=None):\n1080:     \"\"\"\n1081:     Return an ``InlineFormSet`` for the given kwargs.\n1082: \n1083:     ``fk_name`` must be provided if ``model`` has more than one ``ForeignKey``\n1084:     to ``parent_model``.\n1085:     \"\"\"\n1086:     fk = _get_foreign_key(parent_model, model, fk_name=fk_name)\n1087:     # enforce a max_num=1 when the foreign key to the parent model is unique.\n1088:     if fk.unique:\n1089:         max_num = 1\n1090:     kwargs = {\n1091:         'form': form,\n1092:         'formfield_callback': formfield_callback,\n1093:         'formset': formset,\n1094:         'extra': extra,\n1095:         'can_delete': can_delete,\n1096:         'can_order': can_order,\n1097:         'fields': fields,\n1098:         'exclude': exclude,\n1099:         'min_num': min_num,\n1100:         'max_num': max_num,\n1101:         'widgets': widgets,\n1102:         'validate_min': validate_min,\n1103:         'validate_max': validate_max,\n1104:         'localized_fields': localized_fields,\n1105:         'labels': labels,\n1106:         'help_texts': help_texts,\n1107:         'error_messages': error_messages,\n1108:         'field_classes': field_classes,\n1109:         'absolute_max': absolute_max,\n1110:         'can_delete_extra': can_delete_extra,\n1111:         'renderer': renderer,\n1112:     }\n1113:     FormSet = modelformset_factory(model, **kwargs)\n1114:     FormSet.fk = fk\n1115:     return FormSet\n1116: \n1117: \n1118: # Fields #####################################################################\n1119: \n1120: class InlineForeignKeyField(Field):\nCode replaced for brevity.\n1158: \n1159: \n1160: \n1161: class ModelChoiceIteratorValue:\nCode replaced for brevity.\n1175: \n1176: \n1177: \n1178: class ModelChoiceIterator:\nCode replaced for brevity.\n1206: \n1207: \n1208: \n1209: class ModelChoiceField(ChoiceField):\nCode replaced for brevity.\n1325: \n1326: \n1327: \n1328: class ModelMultipleChoiceField(ModelChoiceField):\nCode replaced for brevity.\n1420: \n1421: \n1422: \n1423:     retu\nCode replaced for brevity.\n1427: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/forms/models.py",
      "suspect_lines": [
        679,
        878,
        1079
      ]
    }
  ]
}