{
  "instance_id": "sympy__sympy-24562",
  "problem_statement": "Rational calc value error\npython 3.11, sympy 1.11.1\r\nwhen calc Rational('0.5', '100'), the value is 1/100100; but Rational(0.5, 100) the value is 1/200, this value is the true value, and the version of sympy 1.8 is normal\n",
  "localized_code": "[start of sympy/core/numbers.py]\n1: from __future__ import annotations\n2: \n3: import numbers\n4: import decimal\n5: import fractions\n6: import math\n7: import re as regex\n8: import sys\n9: from functools import lru_cache\n10: \n11: from .containers import Tuple\n12: from .sympify import (SympifyError, _sympy_converter, sympify, _convert_numpy_types,\n13:               _sympify, _is_numpy_instance)\n14: from .singleton import S, Singleton\n15: from .basic import Basic\n16: from .expr import Expr, AtomicExpr\n17: from .evalf import pure_complex\n18: from .cache import cacheit, clear_cache\n19: from .decorators import _sympifyit\n20: from .logic import fuzzy_not\n21: from .kind import NumberKind\n22: from sympy.external.gmpy import SYMPY_INTS, HAS_GMPY, gmpy\n23: from sympy.multipledispatch import dispatch\n24: import mpmath\n25: import mpmath.libmp as mlib\n26: from mpmath.libmp import bitcount, round_nearest as rnd\n27: from mpmath.libmp.backend import MPZ\n28: from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed\n29: from mpmath.ctx_mp import mpnumeric\n30: from mpmath.libmp.libmpf import (\n31:     finf as _mpf_inf, fninf as _mpf_ninf,\n32:     fnan as _mpf_nan, fzero, _normalize as mpf_normalize,\n33:     prec_to_dps, dps_to_prec)\n34: from sympy.utilities.misc import as_int, debug, filldedent\n35: from .parameters import global_parameters\n36: \n37: _LOG2 = math.log(2)\n38: \n39: \n40: def comp(z1, z2, tol=None):\n41:     r\"\"\"Return a bool indicating whether the error between z1 and z2\n42:     is $\\le$ ``tol``.\n43: \n44:     Examples\n45:     ========\n46: \n47:     If ``tol`` is ``None`` then ``True`` will be returned if\n48:     :math:`|z1 - z2|\\times 10^p \\le 5` where $p$ is minimum value of the\n49:     decimal precision of each value.\n50: \n51:     >>> from sympy import comp, pi\n52:     >>> pi4 = pi.n(4); pi4\n53:     3.142\n54:     >>> comp(_, 3.142)\n55:     True\n56:     >>> comp(pi4, 3.141)\n57:     False\n58:     >>> comp(pi4, 3.143)\n59:     False\n60: \n61:     A comparison of strings will be made\n62:     if ``z1`` is a Number and ``z2`` is a string or ``tol`` is ''.\n63: \n64:     >>> comp(pi4, 3.1415)\n65:     True\n66:     >>> comp(pi4, 3.1415, '')\n67:     False\n68: \n69:     When ``tol`` is provided and $z2$ is non-zero and\n70:     :math:`|z1| > 1` the error is normalized by :math:`|z1|`:\n71: \n72:     >>> abs(pi4 - 3.14)/pi4\n73:     0.000509791731426756\n74:     >>> comp(pi4, 3.14, .001)  # difference less than 0.1%\n75:     True\n76:     >>> comp(pi4, 3.14, .0005)  # difference less than 0.1%\n77:     False\n78: \n79:     When :math:`|z1| \\le 1` the absolute error is used:\n80: \n81:     >>> 1/pi4\n82:     0.3183\n83:     >>> abs(1/pi4 - 0.3183)/(1/pi4)\n84:     3.07371499106316e-5\n85:     >>> abs(1/pi4 - 0.3183)\n86:     9.78393554684764e-6\n87:     >>> comp(1/pi4, 0.3183, 1e-5)\n88:     True\n89: \n90:     To see if the absolute error between ``z1`` and ``z2`` is less\n91:     than or equal to ``tol``, call this as ``comp(z1 - z2, 0, tol)``\n92:     or ``comp(z1 - z2, tol=tol)``:\n93: \n94:     >>> abs(pi4 - 3.14)\n95:     0.00160156249999988\n96:     >>> comp(pi4 - 3.14, 0, .002)\n97:     True\n98:     >>> comp(pi4 - 3.14, 0, .001)\n99:     False\n100:     \"\"\"\n101:     if isinstance(z2, str):\n102:         if not pure_complex(z1, or_real=True):\n103:             raise ValueError('when z2 is a str z1 must be a Number')\n104:         return str(z1) == z2\n105:     if not z1:\n106:         z1, z2 = z2, z1\n107:     if not z1:\n108:         return True\n109:     if not tol:\n110:         a, b = z1, z2\n111:         if tol == '':\n112:             return str(a) == str(b)\n113:         if tol is None:\n114:             a, b = sympify(a), sympify(b)\n115:             if not all(i.is_number for i in (a, b)):\n116:                 raise ValueError('expecting 2 numbers')\n117:             fa = a.atoms(Float)\n118:             fb = b.atoms(Float)\n119:             if not fa and not fb:\n120:                 # no floats -- compare exactly\n121:                 return a == b\n122:             # get a to be pure_complex\n123:             for _ in range(2):\n124:                 ca = pure_complex(a, or_real=True)\n125:                 if not ca:\n126:                     if fa:\n127:                         a = a.n(prec_to_dps(min([i._prec for i in fa])))\n128:                         ca = pure_complex(a, or_real=True)\n129:                         break\n130:                     else:\n131:                         fa, fb = fb, fa\n132:                         a, b = b, a\n133:             cb = pure_complex(b)\n134:             if not cb and fb:\n135:                 b = b.n(prec_to_dps(min([i._prec for i in fb])))\n136:                 cb = pure_complex(b, or_real=True)\n137:             if ca and cb and (ca[1] or cb[1]):\n138:                 return all(comp(i, j) for i, j in zip(ca, cb))\n139:             tol = 10**prec_to_dps(min(a._prec, getattr(b, '_prec', a._prec)))\n140:             return int(abs(a - b)*tol) <= 5\n141:     diff = abs(z1 - z2)\n142:     az1 = abs(z1)\n143:     if z2 and az1 > 1:\n144:         return diff/az1 <= tol\n145:     else:\n146:         return diff <= tol\n147: \n148: \n149: def mpf_norm(mpf, prec):\nCode replaced for brevity.\n176: \n177: \n178: # TODO: we should use the warnings module\n179: _errdict = {\"divide\": False}\n180: \n181: \n182: def seterr(divide=False):\nCode replaced for brevity.\n191: \n192: \n193: \n194: def _as_integer_ratio(p):\nCode replaced for brevity.\n202: \n203: \n204: \n205: def _decimal_to_Rational_prec(dec):\nCode replaced for brevity.\n217: \n218: \n219: \n220: _floatpat = regex.compile(r\"[-+]?((\\d*\\.\\d+)|(\\d+\\.?))\")\n221: def _literal_float(f):\nCode replaced for brevity.\n223: \n224: \n225: # (a,b) -> gcd(a,b)\n226: \n227: # TODO caching with decorator, but not to degrade performance\n228: \n229: @lru_cache(1024)\n230: def igcd(*args):\nCode replaced for brevity.\n267: \n268: \n269: \n270: igcd2 = math.gcd\n271: \n272: \n273: def igcd_lehmer(a, b):\nCode replaced for brevity.\n416: \n417: \n418: \n419: def ilcm(*args):\nCode replaced for brevity.\n442: \n443: \n444: \n445: def igcdex(a, b):\nCode replaced for brevity.\n488: \n489: \n490: \n491: def mod_inverse(a, m):\nCode replaced for brevity.\n553: \n554: \n555: \n556: class Number(AtomicExpr):\nCode replaced for brevity.\n853: \n854: \n855: \n856: class Float(Number):\nCode replaced for brevity.\n1473: \n1474: \n1475: \n1476: # Add sympify converters\n1477: _sympy_converter[float] = _sympy_converter[decimal.Decimal] = Float\n1478: \n1479: # this is here to work nicely in Sage\n1480: RealNumber = Float\n1481: \n1482: \n1483: class Rational(Number):\n1484:     \"\"\"Represents rational numbers (p/q) of any size.\n1485: \n1486:     Examples\n1487:     ========\n1488: \n1489:     >>> from sympy import Rational, nsimplify, S, pi\n1490:     >>> Rational(1, 2)\n1491:     1/2\n1492: \n1493:     Rational is unprejudiced in accepting input. If a float is passed, the\n1494:     underlying value of the binary representation will be returned:\n1495: \n1496:     >>> Rational(.5)\n1497:     1/2\n1498:     >>> Rational(.2)\n1499:     3602879701896397/18014398509481984\n1500: \n1501:     If the simpler representation of the float is desired then consider\n1502:     limiting the denominator to the desired value or convert the float to\n1503:     a string (which is roughly equivalent to limiting the denominator to\n1504:     10**12):\n1505: \n1506:     >>> Rational(str(.2))\n1507:     1/5\n1508:     >>> Rational(.2).limit_denominator(10**12)\n1509:     1/5\n1510: \n1511:     An arbitrarily precise Rational is obtained when a string literal is\n1512:     passed:\n1513: \n1514:     >>> Rational(\"1.23\")\n1515:     123/100\n1516:     >>> Rational('1e-2')\n1517:     1/100\n1518:     >>> Rational(\".1\")\n1519:     1/10\n1520:     >>> Rational('1e-2/3.2')\n1521:     1/320\n1522: \n1523:     The conversion of other types of strings can be handled by\n1524:     the sympify() function, and conversion of floats to expressions\n1525:     or simple fractions can be handled with nsimplify:\n1526: \n1527:     >>> S('.[3]')  # repeating digits in brackets\n1528:     1/3\n1529:     >>> S('3**2/10')  # general expressions\n1530:     9/10\n1531:     >>> nsimplify(.3)  # numbers that have a simple form\n1532:     3/10\n1533: \n1534:     But if the input does not reduce to a literal Rational, an error will\n1535:     be raised:\n1536: \n1537:     >>> Rational(pi)\n1538:     Traceback (most recent call last):\n1539:     ...\n1540:     TypeError: invalid input: pi\n1541: \n1542: \n1543:     Low-level\n1544:     ---------\n1545: \n1546:     Access numerator and denominator as .p and .q:\n1547: \n1548:     >>> r = Rational(3, 4)\n1549:     >>> r\n1550:     3/4\n1551:     >>> r.p\n1552:     3\n1553:     >>> r.q\n1554:     4\n1555: \n1556:     Note that p and q return integers (not SymPy Integers) so some care\n1557:     is needed when using them in expressions:\n1558: \n1559:     >>> r.p/r.q\n1560:     0.75\n1561: \n1562:     If an unevaluated Rational is desired, ``gcd=1`` can be passed and\n1563:     this will keep common divisors of the numerator and denominator\n1564:     from being eliminated. It is not possible, however, to leave a\n1565:     negative value in the denominator.\n1566: \n1567:     >>> Rational(2, 4, gcd=1)\n1568:     2/4\n1569:     >>> Rational(2, -4, gcd=1).q\n1570:     4\n1571: \n1572:     See Also\n1573:     ========\n1574:     sympy.core.sympify.sympify, sympy.simplify.simplify.nsimplify\n1575:     \"\"\"\n1576:     is_real = True\n1577:     is_integer = False\n1578:     is_rational = True\n1579:     is_number = True\n1580: \n1581:     __slots__ = ('p', 'q')\n1582: \n1583:     p: int\n1584:     q: int\n1585: \n1586:     is_Rational = True\n1587: \n1588:     @cacheit\n1589:     def __new__(cls, p, q=None, gcd=None):\n1590:         if q is None:\n1591:             if isinstance(p, Rational):\n1592:                 return p\n1593: \n1594:             if isinstance(p, SYMPY_INTS):\n1595:                 pass\n1596:             else:\n1597:                 if isinstance(p, (float, Float)):\n1598:                     return Rational(*_as_integer_ratio(p))\n1599: \n1600:                 if not isinstance(p, str):\n1601:                     try:\n1602:                         p = sympify(p)\n1603:                     except (SympifyError, SyntaxError):\n1604:                         pass  # error will raise below\n1605:                 else:\n1606:                     if p.count('/') > 1:\n1607:                         raise TypeError('invalid input: %s' % p)\n1608:                     p = p.replace(' ', '')\n1609:                     pq = p.rsplit('/', 1)\n1610:                     if len(pq) == 2:\n1611:                         p, q = pq\n1612:                         fp = fractions.Fraction(p)\n1613:                         fq = fractions.Fraction(q)\n1614:                         p = fp/fq\n1615:                     try:\n1616:                         p = fractions.Fraction(p)\n1617:                     except ValueError:\n1618:                         pass  # error will raise below\n1619:                     else:\n1620:                         return Rational(p.numerator, p.denominator, 1)\n1621: \n1622:                 if not isinstance(p, Rational):\n1623:                     raise TypeError('invalid input: %s' % p)\n1624: \n1625:             q = 1\n1626:             gcd = 1\n1627: \n1628:         if not isinstance(p, SYMPY_INTS):\n1629:             p = Rational(p)\n1630:             q *= p.q\n1631:             p = p.p\n1632:         else:\n1633:             p = int(p)\n1634: \n1635:         if not isinstance(q, SYMPY_INTS):\n1636:             q = Rational(q)\n1637:             p *= q.q\n1638:             q = q.p\n1639:         else:\n1640:             q = int(q)\n1641: \n1642:         # p and q are now ints\n1643:         if q == 0:\n1644:             if p == 0:\n1645:                 if _errdict[\"divide\"]:\n1646:                     raise ValueError(\"Indeterminate 0/0\")\n1647:                 else:\n1648:                     return S.NaN\n1649:             return S.ComplexInfinity\n1650:         if q < 0:\n1651:             q = -q\n1652:             p = -p\n1653:         if not gcd:\n1654:             gcd = igcd(abs(p), q)\n1655:         if gcd > 1:\n1656:             p //= gcd\n1657:             q //= gcd\n1658:         if q == 1:\n1659:             return Integer(p)\n1660:         if p == 1 and q == 2:\n1661:             return S.Half\n1662:         obj = Expr.__new__(cls)\n1663:         obj.p = p\n1664:         obj.q = q\n1665:         return obj\n1666: \n1667:     def limit_denominator(self, max_denominator=1000000):\n1668:         \"\"\"Closest Rational to self with denominator at most max_denominator.\n1669: \n1670:         Examples\n1671:         ========\n1672: \n1673:         >>> from sympy import Rational\n1674:         >>> Rational('3.141592653589793').limit_denominator(10)\n1675:         22/7\n1676:         >>> Rational('3.141592653589793').limit_denominator(100)\n1677:         311/99\n1678: \n1679:         \"\"\"\n1680:         f = fractions.Fraction(self.p, self.q)\n1681:         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))\n1682: \n1683:     def __getnewargs__(self):\n1684:         return (self.p, self.q)\n1685: \n1686:     def _hashable_content(self):\n1687:         return (self.p, self.q)\n1688: \n1689:     def _eval_is_positive(self):\n1690:         return self.p > 0\n1691: \n1692:     def _eval_is_zero(self):\n1693:         return self.p == 0\n1694: \n1695:     def __neg__(self):\n1696:         return Rational(-self.p, self.q)\n1697: \n1698:     @_sympifyit('other', NotImplemented)\n1699:     def __add__(self, other):\n1700:         if global_parameters.evaluate:\n1701:             if isinstance(other, Integer):\n1702:                 return Rational(self.p + self.q*other.p, self.q, 1)\n1703:             elif isinstance(other, Rational):\n1704:                 #TODO: this can probably be optimized more\n1705:                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)\n1706:             elif isinstance(other, Float):\n1707:                 return other + self\n1708:             else:\n1709:                 return Number.__add__(self, other)\n1710:         return Number.__add__(self, other)\n1711:     __radd__ = __add__\n1712: \n1713:     @_sympifyit('other', NotImplemented)\n1714:     def __sub__(self, other):\n1715:         if global_parameters.evaluate:\n1716:             if isinstance(other, Integer):\n1717:                 return Rational(self.p - self.q*other.p, self.q, 1)\n1718:             elif isinstance(other, Rational):\n1719:                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)\n1720:             elif isinstance(other, Float):\n1721:                 return -other + self\n1722:             else:\n1723:                 return Number.__sub__(self, other)\n1724:         return Number.__sub__(self, other)\n1725:     @_sympifyit('other', NotImplemented)\n1726:     def __rsub__(self, other):\n1727:         if global_parameters.evaluate:\n1728:             if isinstance(other, Integer):\n1729:                 return Rational(self.q*other.p - self.p, self.q, 1)\n1730:             elif isinstance(other, Rational):\n1731:                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)\n1732:             elif isinstance(other, Float):\n1733:                 return -self + other\n1734:             else:\n1735:                 return Number.__rsub__(self, other)\n1736:         return Number.__rsub__(self, other)\n1737:     @_sympifyit('other', NotImplemented)\n1738:     def __mul__(self, other):\n1739:         if global_parameters.evaluate:\n1740:             if isinstance(other, Integer):\n1741:                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))\n1742:             elif isinstance(other, Rational):\n1743:                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))\n1744:             elif isinstance(other, Float):\n1745:                 return other*self\n1746:             else:\n1747:                 return Number.__mul__(self, other)\n1748:         return Number.__mul__(self, other)\n1749:     __rmul__ = __mul__\n1750: \n1751:     @_sympifyit('other', NotImplemented)\n1752:     def __truediv__(self, other):\n1753:         if global_parameters.evaluate:\n1754:             if isinstance(other, Integer):\n1755:                 if self.p and other.p == S.Zero:\n1756:                     return S.ComplexInfinity\n1757:                 else:\n1758:                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))\n1759:             elif isinstance(other, Rational):\n1760:                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1761:             elif isinstance(other, Float):\n1762:                 return self*(1/other)\n1763:             else:\n1764:                 return Number.__truediv__(self, other)\n1765:         return Number.__truediv__(self, other)\n1766:     @_sympifyit('other', NotImplemented)\n1767:     def __rtruediv__(self, other):\n1768:         if global_parameters.evaluate:\n1769:             if isinstance(other, Integer):\n1770:                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))\n1771:             elif isinstance(other, Rational):\n1772:                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1773:             elif isinstance(other, Float):\n1774:                 return other*(1/self)\n1775:             else:\n1776:                 return Number.__rtruediv__(self, other)\n1777:         return Number.__rtruediv__(self, other)\n1778: \n1779:     @_sympifyit('other', NotImplemented)\n1780:     def __mod__(self, other):\n1781:         if global_parameters.evaluate:\n1782:             if isinstance(other, Rational):\n1783:                 n = (self.p*other.q) // (other.p*self.q)\n1784:                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)\n1785:             if isinstance(other, Float):\n1786:                 # calculate mod with Rationals, *then* round the answer\n1787:                 return Float(self.__mod__(Rational(other)),\n1788:                              precision=other._prec)\n1789:             return Number.__mod__(self, other)\n1790:         return Number.__mod__(self, other)\n1791: \n1792:     @_sympifyit('other', NotImplemented)\n1793:     def __rmod__(self, other):\n1794:         if isinstance(other, Rational):\n1795:             return Rational.__mod__(other, self)\n1796:         return Number.__rmod__(self, other)\n1797: \n1798:     def _eval_power(self, expt):\n1799:         if isinstance(expt, Number):\n1800:             if isinstance(expt, Float):\n1801:                 return self._eval_evalf(expt._prec)**expt\n1802:             if expt.is_extended_negative:\n1803:                 # (3/4)**-2 -> (4/3)**2\n1804:                 ne = -expt\n1805:                 if (ne is S.One):\n1806:                     return Rational(self.q, self.p)\n1807:                 if self.is_negative:\n1808:                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne\n1809:                 else:\n1810:                     return Rational(self.q, self.p)**ne\n1811:             if expt is S.Infinity:  # -oo already caught by test for negative\n1812:                 if self.p > self.q:\n1813:                     # (3/2)**oo -> oo\n1814:                     return S.Infinity\n1815:                 if self.p < -self.q:\n1816:                     # (-3/2)**oo -> oo + I*oo\n1817:                     return S.Infinity + S.Infinity*S.ImaginaryUnit\n1818:                 return S.Zero\n1819:             if isinstance(expt, Integer):\n1820:                 # (4/3)**2 -> 4**2 / 3**2\n1821:                 return Rational(self.p**expt.p, self.q**expt.p, 1)\n1822:             if isinstance(expt, Rational):\n1823:                 intpart = expt.p // expt.q\n1824:                 if intpart:\n1825:                     intpart += 1\n1826:                     remfracpart = intpart*expt.q - expt.p\n1827:                     ratfracpart = Rational(remfracpart, expt.q)\n1828:                     if self.p != 1:\n1829:                         return Integer(self.p)**expt*Integer(self.q)**ratfracpart*Rational(1, self.q**intpart, 1)\n1830:                     return Integer(self.q)**ratfracpart*Rational(1, self.q**intpart, 1)\n1831:                 else:\n1832:                     remfracpart = expt.q - expt.p\n1833:                     ratfracpart = Rational(remfracpart, expt.q)\n1834:                     if self.p != 1:\n1835:                         return Integer(self.p)**expt*Integer(self.q)**ratfracpart*Rational(1, self.q, 1)\n1836:                     return Integer(self.q)**ratfracpart*Rational(1, self.q, 1)\n1837: \n1838:         if self.is_extended_negative and expt.is_even:\n1839:             return (-self)**expt\n1840: \n1841:         return\n1842: \n1843:     def _as_mpf_val(self, prec):\n1844:         return mlib.from_rational(self.p, self.q, prec, rnd)\n1845: \n1846:     def _mpmath_(self, prec, rnd):\n1847:         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))\n1848: \n1849:     def __abs__(self):\n1850:         return Rational(abs(self.p), self.q)\n1851: \n1852:     def __int__(self):\n1853:         p, q = self.p, self.q\n1854:         if p < 0:\n1855:             return -int(-p//q)\n1856:         return int(p//q)\n1857: \n1858:     def floor(self):\n1859:         return Integer(self.p // self.q)\n1860: \n1861:     def ceiling(self):\n1862:         return -Integer(-self.p // self.q)\n1863: \n1864:     def __floor__(self):\n1865:         return self.floor()\n1866: \n1867:     def __ceil__(self):\n1868:         return self.ceiling()\n1869: \n1870:     def __eq__(self, other):\n1871:         try:\n1872:             other = _sympify(other)\n1873:         except SympifyError:\n1874:             return NotImplemented\n1875:         if not isinstance(other, Number):\n1876:             # S(0) == S.false is False\n1877:             # S(0) == False is True\n1878:             return False\n1879:         if not self:\n1880:             return not other\n1881:         if other.is_NumberSymbol:\n1882:             if other.is_irrational:\n1883:                 return False\n1884:             return other.__eq__(self)\n1885:         if other.is_Rational:\n1886:             # a Rational is always in reduced form so will never be 2/4\n1887:             # so we can just check equivalence of args\n1888:             return self.p == other.p and self.q == other.q\n1889:         if other.is_Float:\n1890:             # all Floats have a denominator that is a power of 2\n1891:             # so if self doesn't, it can't be equal to other\n1892:             if self.q & (self.q - 1):\n1893:                 return False\n1894:             s, m, t = other._mpf_[:3]\n1895:             if s:\n1896:                 m = -m\n1897:             if not t:\n1898:                 # other is an odd integer\n1899:                 if not self.is_Integer or self.is_even:\n1900:                     return False\n1901:                 return m == self.p\n1902: \n1903:             from .power import integer_log\n1904:             if t > 0:\n1905:                 # other is an even integer\n1906:                 if not self.is_Integer:\n1907:                     return False\n1908:                 # does m*2**t == self.p\n1909:                 return self.p and not self.p % m and \\\n1910:                     integer_log(self.p//m, 2) == (t, True)\n1911:             # does non-integer s*m/2**-t = p/q?\n1912:             if self.is_Integer:\n1913:                 return False\n1914:             return m == self.p and integer_log(self.q, 2) == (-t, True)\n1915:         return False\n1916: \n1917:     def __ne__(self, other):\n1918:         return not self == other\n1919: \n1920:     def _Rrel(self, other, attr):\n1921:         # if you want self < other, pass self, other, __gt__\n1922:         try:\n1923:             other = _sympify(other)\n1924:         except SympifyError:\n1925:             return NotImplemented\n1926:         if other.is_Number:\n1927:             op = None\n1928:             s, o = self, other\n1929:             if other.is_NumberSymbol:\n1930:                 op = getattr(o, attr)\n1931:             elif other.is_Float:\n1932:                 op = getattr(o, attr)\n1933:             elif other.is_Rational:\n1934:                 s, o = Integer(s.p*o.q), Integer(s.q*o.p)\n1935:                 op = getattr(o, attr)\n1936:             if op:\n1937:                 return op(s)\n1938:             if o.is_number and o.is_extended_real:\n1939:                 return Integer(s.p), s.q*o\n1940: \n1941:     def __gt__(self, other):\n1942:         rv = self._Rrel(other, '__lt__')\n1943:         if rv is None:\n1944:             rv = self, other\n1945:         elif not isinstance(rv, tuple):\n1946:             return rv\n1947:         return Expr.__gt__(*rv)\n1948: \n1949:     def __ge__(self, other):\n1950:         rv = self._Rrel(other, '__le__')\n1951:         if rv is None:\n1952:             rv = self, other\n1953:         elif not isinstance(rv, tuple):\n1954:             return rv\n1955:         return Expr.__ge__(*rv)\n1956: \n1957:     def __lt__(self, other):\n1958:         rv = self._Rrel(other, '__gt__')\n1959:         if rv is None:\n1960:             rv = self, other\n1961:         elif not isinstance(rv, tuple):\n1962:             return rv\n1963:         return Expr.__lt__(*rv)\n1964: \n1965:     def __le__(self, other):\n1966:         rv = self._Rrel(other, '__ge__')\n1967:         if rv is None:\n1968:             rv = self, other\n1969:         elif not isinstance(rv, tuple):\n1970:             return rv\n1971:         return Expr.__le__(*rv)\n1972: \n1973:     def __hash__(self):\n1974:         return super().__hash__()\n1975: \n1976:     def factors(self, limit=None, use_trial=True, use_rho=False,\n1977:                 use_pm1=False, verbose=False, visual=False):\n1978:         \"\"\"A wrapper to factorint which return factors of self that are\n1979:         smaller than limit (or cheap to compute). Special methods of\n1980:         factoring are disabled by default so that only trial division is used.\n1981:         \"\"\"\n1982:         from sympy.ntheory.factor_ import factorrat\n1983: \n1984:         return factorrat(self, limit=limit, use_trial=use_trial,\n1985:                       use_rho=use_rho, use_pm1=use_pm1,\n1986:                       verbose=verbose).copy()\n1987: \n1988:     @property\n1989:     def numerator(self):\n1990:         return self.p\n1991: \n1992:     @property\n1993:     def denominator(self):\n1994:         return self.q\n1995: \n1996:     @_sympifyit('other', NotImplemented)\n1997:     def gcd(self, other):\n1998:         if isinstance(other, Rational):\n1999:             if other == S.Zero:\n2000:                 return other\n2001:             return Rational(\n2002:                 igcd(self.p, other.p),\n2003:                 ilcm(self.q, other.q))\n2004:         return Number.gcd(self, other)\n2005: \n2006:     @_sympifyit('other', NotImplemented)\n2007:     def lcm(self, other):\n2008:         if isinstance(other, Rational):\n2009:             return Rational(\n2010:                 self.p // igcd(self.p, other.p) * other.p,\n2011:                 igcd(self.q, other.q))\n2012:         return Number.lcm(self, other)\n2013: \n2014:     def as_numer_denom(self):\n2015:         return Integer(self.p), Integer(self.q)\n2016: \n2017:     def as_content_primitive(self, radical=False, clear=True):\n2018:         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n2019:         extracted from self.\n2020: \n2021:         Examples\n2022:         ========\n2023: \n2024:         >>> from sympy import S\n2025:         >>> (S(-3)/2).as_content_primitive()\n2026:         (3/2, -1)\n2027: \n2028:         See docstring of Expr.as_content_primitive for more examples.\n2029:         \"\"\"\n2030: \n2031:         if self:\n2032:             if self.is_positive:\n2033:                 return self, S.One\n2034:             return -self, S.NegativeOne\n2035:         return S.One, self\n2036: \n2037:     def as_coeff_Mul(self, rational=False):\n2038:         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n2039:         return self, S.One\n2040: \n2041:     def as_coeff_Add(self, rational=False):\n2042:         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2043:         return self, S.Zero\n2044: \n2045: \n2046: class Integer(Rational):\nCode replaced for brevity.\n2499: \n2500: \n2501: # Add sympify converters\n2502: _sympy_converter[int] = Integer\n2503: \n2504: \n2505: class AlgebraicNumber(Expr):\nCode replaced for brevity.\n3023: \n3024: \n3025: \n3026: class RationalConstant(Rational):\nCode replaced for brevity.\n3036: \n3037: \n3038: \n3039: class IntegerConstant(Integer):\nCode replaced for brevity.\n3043: \n3044: \n3045: \n3046: class Zero(IntegerConstant, metaclass=Singleton):\nCode replaced for brevity.\n3111: \n3112: \n3113: \n3114: class One(IntegerConstant, metaclass=Singleton):\nCode replaced for brevity.\n3162: \n3163: \n3164: \n3165: class NegativeOne(IntegerConstant, metaclass=Singleton):\nCode replaced for brevity.\n3226: \n3227: \n3228: \n3229: class Half(RationalConstant, metaclass=Singleton):\nCode replaced for brevity.\n3258: \n3259: \n3260: \n3261: class Infinity(Number, metaclass=Singleton):\nCode replaced for brevity.\n3446: \n3447: \n3448: oo = S.Infinity\n3449: \n3450: \n3451: class NegativeInfinity(Number, metaclass=Singleton):\nCode replaced for brevity.\n3615: \n3616: \n3617: \n3618: class NaN(Number, metaclass=Singleton):\nCode replaced for brevity.\n3731: \n3732: \n3733: nan = S.NaN\n3734: \n3735: @dispatch(NaN, Expr) # type:ignore\n3736: def _eval_is_eq(a, b): # noqa:F811\n3737:     return False\n3738: \n3739: \n3740: class ComplexInfinity(AtomicExpr, metaclass=Singleton):\nCode replaced for brevity.\n3814: \n3815: \n3816: \n3817: zoo = S.ComplexInfinity\n3818: \n3819: \n3820: class NumberSymbol(AtomicExpr):\nCode replaced for brevity.\n3874: \n3875: \n3876: \n3877: class Exp1(NumberSymbol, metaclass=Singleton):\nCode replaced for brevity.\n4027: \n4028: \n4029: E = S.Exp1\n4030: \n4031: \n4032: class Pi(NumberSymbol, metaclass=Singleton):\nCode replaced for brevity.\n4095: \n4096: \n4097: pi = S.Pi\n4098: \n4099: \n4100: class GoldenRatio(NumberSymbol, metaclass=Singleton):\nCode replaced for brevity.\n4160: \n4161: \n4162: \n4163: class TribonacciConstant(NumberSymbol, metaclass=Singleton):\nCode replaced for brevity.\n4230: \n4231: \n4232: \n4233: class EulerGamma(NumberSymbol, metaclass=Singleton):\nCode replaced for brevity.\n4289: \n4290: \n4291: \n4292: class Catalan(NumberSymbol, metaclass=Singleton):\nCode replaced for brevity.\n4352: \n4353: \n4354: \n4355: class ImaginaryUnit(AtomicExpr, metaclass=Singleton):\nCode replaced for brevity.\n4436: \n4437: \n4438: I = S.ImaginaryUnit\n4439: \n4440: @dispatch(Tuple, Number) # type:ignore\n4441: def _eval_is_eq(self, other): # noqa: F811\n4442:     return False\n4443: \n4444: def sympify_fractions(f):\n4445:     return Rational(f.numerator, f.denominator, 1)\n4446: \n4447: _sympy_converter[fractions.Fraction] = sympify_fractions\n4448: \n4449: if HAS_GMPY:\n4450:     def sympify_mpz(x):\n4451:         return Integer(int(x))\n4452: \n4453:     # XXX: The sympify_mpq function here was never used because it is\n4454:     # overridden by the other sympify_mpq function below. Maybe it should just\n4455:     # be removed or maybe it should be used for something...\n4456:     def sympify_mpq(x):\nCode replaced for brevity.\n4457: \n4458: \n4459:     _sympy_converter[type(gmpy.mpz(1))] = sympify_mpz\n4460:     _sympy_converter[type(gmpy.mpq(1, 2))] = sympify_mpq\n4461: \n4462: \n4463: def sympify_mpmath_mpq(x):\n4464:     p, q = x._mpq_\n4465:     return Rational(p, q, 1)\n4466: \n4467: _sympy_converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpmath_mpq\n4468: \n4469: \n4470: def sympify_mpmath(x):\n4471:     return Expr._from_mpmath(x, x.context.prec)\n4472: \n4473: _sympy_converter[mpnumeric] = sympify_mpmath\n4474: \n4475: \n4476: def sympify_complex(a):\nCode replaced for brevity.\n4478: \n4479: \n4480: _sympy_converter[complex] = sympify_complex\n4481: \n4482: from .power import Pow, integer_nthroot\n4483: from .mul import Mul\n4484: Mul.identity = One()\n4485: from .add import Add\n4486: Add.identity = Zero()\n4487: \n4488: def _register_classes():\nCode replaced for brevity.\n4492: \n4493: \n4494: _register_classes()\n4495: \n4496: _illegal = (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity)\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/numbers.py",
      "suspect_lines": [
        1630,
        1638,
        1640
      ]
    }
  ]
}