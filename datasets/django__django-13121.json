{
  "instance_id": "django__django-13121",
  "problem_statement": "durations-only expressions doesn't work on SQLite and MySQL\nDescription\n\t\nclass Experiment(models.Model):\n\testimated_time = models.DurationField()\nlist(Experiment.objects.annotate(duration=F('estimated_time') + datime.timedelta(1)))\nTraceback (most recent call last):\n File \"/home/sergey/dev/django/tests/expressions/tests.py\", line 1218, in test_duration_expressions\n\tlist(Experiment.objects.annotate(duration=F('estimated_time') + delta))\n File \"/home/sergey/dev/django/django/db/models/query.py\", line 269, in __iter__\n\tself._fetch_all()\n File \"/home/sergey/dev/django/django/db/models/query.py\", line 1172, in _fetch_all\n\tself._result_cache = list(self._iterable_class(self))\n File \"/home/sergey/dev/django/django/db/models/query.py\", line 63, in __iter__\n\tfor row in compiler.results_iter(results):\n File \"/home/sergey/dev/django/django/db/models/sql/compiler.py\", line 998, in apply_converters\n\tvalue = converter(value, expression, connection)\n File \"/home/sergey/dev/django/django/db/backends/base/operations.py\", line 571, in convert_durationfield_value\n\tvalue = str(decimal.Decimal(value) / decimal.Decimal(1000000))\ndecimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]\n",
  "localized_code": "[start of django/db/backends/base/operations.py]\n1: import datetime\n2: import decimal\n3: from importlib import import_module\n4: \n5: import sqlparse\n6: \n7: from django.conf import settings\n8: from django.db import NotSupportedError, transaction\n9: from django.db.backends import utils\n10: from django.utils import timezone\n11: from django.utils.encoding import force_str\n12: \n13: \n14: class BaseDatabaseOperations:\n15:     \"\"\"\n16:     Encapsulate backend-specific differences, such as the way a backend\n17:     performs ordering or calculates the ID of a recently-inserted row.\n18:     \"\"\"\n19:     compiler_module = \"django.db.models.sql.compiler\"\n20: \n21:     # Integer field safe ranges by `internal_type` as documented\n22:     # in docs/ref/models/fields.txt.\n23:     integer_field_ranges = {\n24:         'SmallIntegerField': (-32768, 32767),\n25:         'IntegerField': (-2147483648, 2147483647),\n26:         'BigIntegerField': (-9223372036854775808, 9223372036854775807),\n27:         'PositiveBigIntegerField': (0, 9223372036854775807),\n28:         'PositiveSmallIntegerField': (0, 32767),\n29:         'PositiveIntegerField': (0, 2147483647),\n30:         'SmallAutoField': (-32768, 32767),\n31:         'AutoField': (-2147483648, 2147483647),\n32:         'BigAutoField': (-9223372036854775808, 9223372036854775807),\n33:     }\n34:     set_operators = {\n35:         'union': 'UNION',\n36:         'intersection': 'INTERSECT',\n37:         'difference': 'EXCEPT',\n38:     }\n39:     # Mapping of Field.get_internal_type() (typically the model field's class\n40:     # name) to the data type to use for the Cast() function, if different from\n41:     # DatabaseWrapper.data_types.\n42:     cast_data_types = {}\n43:     # CharField data type if the max_length argument isn't provided.\n44:     cast_char_field_without_max_length = None\n45: \n46:     # Start and end points for window expressions.\n47:     PRECEDING = 'PRECEDING'\n48:     FOLLOWING = 'FOLLOWING'\n49:     UNBOUNDED_PRECEDING = 'UNBOUNDED ' + PRECEDING\n50:     UNBOUNDED_FOLLOWING = 'UNBOUNDED ' + FOLLOWING\n51:     CURRENT_ROW = 'CURRENT ROW'\n52: \n53:     # Prefix for EXPLAIN queries, or None EXPLAIN isn't supported.\n54:     explain_prefix = None\n55: \n56:     def __init__(self, connection):\n57:         self.connection = connection\n58:         self._cache = None\n59: \n60:     def autoinc_sql(self, table, column):\n61:         \"\"\"\n62:         Return any SQL needed to support auto-incrementing primary keys, or\n63:         None if no SQL is necessary.\n64: \n65:         This SQL is executed when a table is created.\n66:         \"\"\"\n67:         return None\n68: \n69:     def bulk_batch_size(self, fields, objs):\n70:         \"\"\"\n71:         Return the maximum allowed batch size for the backend. The fields\n72:         are the fields going to be inserted in the batch, the objs contains\n73:         all the objects to be inserted.\n74:         \"\"\"\n75:         return len(objs)\n76: \n77:     def cache_key_culling_sql(self):\n78:         \"\"\"\n79:         Return an SQL query that retrieves the first cache key greater than the\n80:         n smallest.\n81: \n82:         This is used by the 'db' cache backend to determine where to start\n83:         culling.\n84:         \"\"\"\n85:         return \"SELECT cache_key FROM %s ORDER BY cache_key LIMIT 1 OFFSET %%s\"\n86: \n87:     def unification_cast_sql(self, output_field):\n88:         \"\"\"\n89:         Given a field instance, return the SQL that casts the result of a union\n90:         to that type. The resulting string should contain a '%s' placeholder\n91:         for the expression being cast.\n92:         \"\"\"\n93:         return '%s'\n94: \n95:     def date_extract_sql(self, lookup_type, field_name):\n96:         \"\"\"\n97:         Given a lookup_type of 'year', 'month', or 'day', return the SQL that\n98:         extracts a value from the given date field field_name.\n99:         \"\"\"\n100:         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a date_extract_sql() method')\n101: \n102:     def date_interval_sql(self, timedelta):\n103:         \"\"\"\n104:         Implement the date interval functionality for expressions.\n105:         \"\"\"\n106:         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a date_interval_sql() method')\n107: \n108:     def date_trunc_sql(self, lookup_type, field_name):\n... Code Truncated ...\n\n[start of django/db/backends/mysql/operations.py]\n1: import uuid\n2: \n3: from django.conf import settings\n4: from django.db.backends.base.operations import BaseDatabaseOperations\n5: from django.utils import timezone\n6: from django.utils.duration import duration_microseconds\n7: from django.utils.encoding import force_str\n8: \n9: \n10: class DatabaseOperations(BaseDatabaseOperations):\n11:     compiler_module = \"django.db.backends.mysql.compiler\"\n12: \n13:     # MySQL stores positive fields as UNSIGNED ints.\n14:     integer_field_ranges = {\n15:         **BaseDatabaseOperations.integer_field_ranges,\n16:         'PositiveSmallIntegerField': (0, 65535),\n17:         'PositiveIntegerField': (0, 4294967295),\n18:         'PositiveBigIntegerField': (0, 18446744073709551615),\n19:     }\n20:     cast_data_types = {\n21:         'AutoField': 'signed integer',\n22:         'BigAutoField': 'signed integer',\n23:         'SmallAutoField': 'signed integer',\n24:         'CharField': 'char(%(max_length)s)',\n25:         'DecimalField': 'decimal(%(max_digits)s, %(decimal_places)s)',\n26:         'TextField': 'char',\n27:         'IntegerField': 'signed integer',\n28:         'BigIntegerField': 'signed integer',\n29:         'SmallIntegerField': 'signed integer',\n30:         'PositiveBigIntegerField': 'unsigned integer',\n31:         'PositiveIntegerField': 'unsigned integer',\n32:         'PositiveSmallIntegerField': 'unsigned integer',\n33:     }\n34:     cast_char_field_without_max_length = 'char'\n35:     explain_prefix = 'EXPLAIN'\n36: \n37:     def date_extract_sql(self, lookup_type, field_name):\n38:         # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html\n39:         if lookup_type == 'week_day':\n40:             # DAYOFWEEK() returns an integer, 1-7, Sunday=1.\n41:             return \"DAYOFWEEK(%s)\" % field_name\n42:         elif lookup_type == 'iso_week_day':\n43:             # WEEKDAY() returns an integer, 0-6, Monday=0.\n44:             return \"WEEKDAY(%s) + 1\" % field_name\n45:         elif lookup_type == 'week':\n46:             # Override the value of default_week_format for consistency with\n47:             # other database backends.\n48:             # Mode 3: Monday, 1-53, with 4 or more days this year.\n49:             return \"WEEK(%s, 3)\" % field_name\n50:         elif lookup_type == 'iso_year':\n51:             # Get the year part from the YEARWEEK function, which returns a\n52:             # number as year * 100 + week.\n53:             return \"TRUNCATE(YEARWEEK(%s, 3), -2) / 100\" % field_name\n54:         else:\n55:             # EXTRACT returns 1-53 based on ISO-8601 for the week number.\n56:             return \"EXTRACT(%s FROM %s)\" % (lookup_type.upper(), field_name)\n57: \n58:     def date_trunc_sql(self, lookup_type, field_name):\n59:         fields = {\n60:             'year': '%%Y-01-01',\n61:             'month': '%%Y-%%m-01',\n62:         }  # Use double percents to escape.\n63:         if lookup_type in fields:\n64:             format_str = fields[lookup_type]\n65:             return \"CAST(DATE_FORMAT(%s, '%s') AS DATE)\" % (field_name, format_str)\n66:         elif lookup_type == 'quarter':\n67:             return \"MAKEDATE(YEAR(%s), 1) + INTERVAL QUARTER(%s) QUARTER - INTERVAL 1 QUARTER\" % (\n68:                 field_name, field_name\n69:             )\n70:         elif lookup_type == 'week':\n71:             return \"DATE_SUB(%s, INTERVAL WEEKDAY(%s) DAY)\" % (\n72:                 field_name, field_name\n73:             )\n74:         else:\n75:             return \"DATE(%s)\" % (field_name)\n76: \n77:     def _prepare_tzname_delta(self, tzname):\n78:         if '+' in tzname:\n79:             return tzname[tzname.find('+'):]\n80:         elif '-' in tzname:\n81:             return tzname[tzname.find('-'):]\n82:         return tzname\n83: \n84:     def _convert_field_to_tz(self, field_name, tzname):\n85:         if settings.USE_TZ and self.connection.timezone_name != tzname:\n86:             field_name = \"CONVERT_TZ(%s, '%s', '%s')\" % (\n87:                 field_name,\n88:                 self.connection.timezone_name,\n89:                 self._prepare_tzname_delta(tzname),\n90:             )\n91:         return field_name\n92: \n93:     def datetime_cast_date_sql(self, field_name, tzname):\n94:         field_name = self._convert_field_to_tz(field_name, tzname)\n95:         return \"DATE(%s)\" % field_name\n96: \n97:     def datetime_cast_time_sql(self, field_name, tzname):\n98:         field_name = self._convert_field_to_tz(field_name, tzname)\n99:         return \"TIME(%s)\" % field_name\n100: \n101:     def datetime_extract_sql(self, lookup_type, field_name, tzname):\n102:         field_name = self._convert_field_to_tz(field_name, tzname)\n103:         return self.date_extract_sql(lookup_type, field_name)\n104: \n105:     def datetime_trunc_sql(self, lookup_type, field_name, tzname):\n106:         field_name = self._convert_field_to_tz(field_name, tzname)\n107:         fields = ['year', 'month', 'day', 'hour', 'minute', 'second']\n108:         format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s')  # Use double percents to escape.\n109:         format_def = ('0000-', '01', '-01', ' 00:', '00', ':00')\n110:         if lookup_type == 'quarter':\n111:             return (\n112:                 \"CAST(DATE_FORMAT(MAKEDATE(YEAR({field_name}), 1) + \"\n113:                 \"INTERVAL QUARTER({field_name}) QUARTER - \" +\n114:                 \"INTERVAL 1 QUARTER, '%%Y-%%m-01 00:00:00') AS DATETIME)\"\n115:             ).format(field_name=field_name)\n116:         if lookup_type == 'week':\n117:             return (\n118:                 \"CAST(DATE_FORMAT(DATE_SUB({field_name}, \"\n119:                 \"INTERVAL WEEKDAY({field_name}) DAY), \"\n120:                 \"'%%Y-%%m-%%d 00:00:00') AS DATETIME)\"\n121:             ).format(field_name=field_name)\n122:         try:\n123:             i = fields.index(lookup_type) + 1\n124:         except ValueError:\n125:             sql = field_name\n126:         else:\n127:             format_str = ''.join(format[:i] + format_def[i:])\n128:             sql = \"CAST(DATE_FORMAT(%s, '%s') AS DATETIME)\" % (field_name, format_str)\n129:         return sql\n130: \n131:     def time_trunc_sql(self, lookup_type, field_name):\n132:         fields = {\n133:             'hour': '%%H:00:00',\n134:             'minute': '%%H:%%i:00',\n135:             'second': '%%H:%%i:%%s',\n136:         }  # Use double percents to escape.\n137:         if lookup_type in fields:\n138:             format_str = fields[lookup_type]\n139:             return \"CAST(DATE_FORMAT(%s, '%s') AS TIME)\" % (field_name, format_str)\n140:         else:\n141:             return \"TIME(%s)\" % (field_name)\n142: \n143:     def date_interval_sql(self, timedelta):\n144:         return 'INTERVAL %s MICROSECOND' % duration_microseconds(timedelta)\n145: \n146:     def fetch_returned_insert_rows(self, cursor):\n... Code Truncated ...\n\n[start of django/db/backends/sqlite3/operations.py]\n1: import datetime\n2: import decimal\n3: import uuid\n4: from functools import lru_cache\n5: from itertools import chain\n6: \n7: from django.conf import settings\n8: from django.core.exceptions import FieldError\n9: from django.db import DatabaseError, NotSupportedError, models\n10: from django.db.backends.base.operations import BaseDatabaseOperations\n11: from django.db.models.expressions import Col\n12: from django.utils import timezone\n13: from django.utils.dateparse import parse_date, parse_datetime, parse_time\n14: from django.utils.duration import duration_microseconds\n15: from django.utils.functional import cached_property\n16: \n17: \n18: class DatabaseOperations(BaseDatabaseOperations):\n19:     cast_char_field_without_max_length = 'text'\n20:     cast_data_types = {\n21:         'DateField': 'TEXT',\n22:         'DateTimeField': 'TEXT',\n23:     }\n24:     explain_prefix = 'EXPLAIN QUERY PLAN'\n25: \n26:     def bulk_batch_size(self, fields, objs):\n27:         \"\"\"\n28:         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of\n29:         999 variables per query.\n30: \n31:         If there's only a single field to insert, the limit is 500\n32:         (SQLITE_MAX_COMPOUND_SELECT).\n33:         \"\"\"\n34:         if len(fields) == 1:\n35:             return 500\n36:         elif len(fields) > 1:\n37:             return self.connection.features.max_query_params // len(fields)\n38:         else:\n39:             return len(objs)\n40: \n41:     def check_expression_support(self, expression):\n42:         bad_fields = (models.DateField, models.DateTimeField, models.TimeField)\n43:         bad_aggregates = (models.Sum, models.Avg, models.Variance, models.StdDev)\n44:         if isinstance(expression, bad_aggregates):\n45:             for expr in expression.get_source_expressions():\n46:                 try:\n47:                     output_field = expr.output_field\n48:                 except (AttributeError, FieldError):\n49:                     # Not every subexpression has an output_field which is fine\n50:                     # to ignore.\n51:                     pass\n52:                 else:\n53:                     if isinstance(output_field, bad_fields):\n54:                         raise NotSupportedError(\n55:                             'You cannot use Sum, Avg, StdDev, and Variance '\n56:                             'aggregations on date/time fields in sqlite3 '\n57:                             'since date/time is saved as text.'\n58:                         )\n59:         if (\n60:             isinstance(expression, models.Aggregate) and\n61:             expression.distinct and\n62:             len(expression.source_expressions) > 1\n63:         ):\n64:             raise NotSupportedError(\n65:                 \"SQLite doesn't support DISTINCT on aggregate functions \"\n66:                 \"accepting multiple arguments.\"\n67:             )\n68: \n69:     def date_extract_sql(self, lookup_type, field_name):\n70:         \"\"\"\n71:         Support EXTRACT with a user-defined function django_date_extract()\n72:         that's registered in connect(). Use single quotes because this is a\n73:         string and could otherwise cause a collision with a field name.\n74:         \"\"\"\n75:         return \"django_date_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n76: \n77:     def date_interval_sql(self, timedelta):\n78:         return str(duration_microseconds(timedelta))\n79: \n80:     def format_for_duration_arithmetic(self, sql):\n... Code Truncated ...\n\n[start of django/db/models/expressions.py]\n1: import copy\n2: import datetime\n3: import inspect\n4: from decimal import Decimal\n5: \n6: from django.core.exceptions import EmptyResultSet, FieldError\n7: from django.db import NotSupportedError, connection\n8: from django.db.models import fields\n9: from django.db.models.constants import LOOKUP_SEP\n10: from django.db.models.query_utils import Q\n11: from django.utils.deconstruct import deconstructible\n12: from django.utils.functional import cached_property\n13: from django.utils.hashable import make_hashable\n14: \n15: \n16: class SQLiteNumericMixin:\n17:     \"\"\"\n18:     Some expressions with output_field=DecimalField() must be cast to\n19:     numeric to be properly filtered.\n20:     \"\"\"\n21:     def as_sqlite(self, compiler, connection, **extra_context):\n22:         sql, params = self.as_sql(compiler, connection, **extra_context)\n23:         try:\n24:             if self.output_field.get_internal_type() == 'DecimalField':\n25:                 sql = 'CAST(%s AS NUMERIC)' % sql\n26:         except FieldError:\n27:             pass\n28:         return sql, params\n29: \n30: \n31: class Combinable:\n32:     \"\"\"\n33:     Provide the ability to combine one or two objects with\n34:     some connector. For example F('foo') + F('bar').\n35:     \"\"\"\n36: \n37:     # Arithmetic connectors\n38:     ADD = '+'\n39:     SUB = '-'\n40:     MUL = '*'\n41:     DIV = '/'\n42:     POW = '^'\n43:     # The following is a quoted % operator - it is quoted because it can be\n44:     # used in strings that also have parameter substitution.\n45:     MOD = '%%'\n46: \n47:     # Bitwise operators - note that these are generated by .bitand()\n48:     # and .bitor(), the '&' and '|' are reserved for boolean operator\n49:     # usage.\n50:     BITAND = '&'\n51:     BITOR = '|'\n52:     BITLEFTSHIFT = '<<'\n53:     BITRIGHTSHIFT = '>>'\n54:     BITXOR = '#'\n55: \n56:     def _combine(self, other, connector, reversed):\n57:         if not hasattr(other, 'resolve_expression'):\n58:             # everything must be resolvable to an expression\n59:             if isinstance(other, datetime.timedelta):\n60:                 other = DurationValue(other, output_field=fields.DurationField())\n61:             else:\n62:                 other = Value(other)\n63: \n64:         if reversed:\n65:             return CombinedExpression(other, connector, self)\n66:         return CombinedExpression(self, connector, other)\n67: \n68:     #############\n69:     # OPERATORS #\n70:     #############\n71: \n72:     def __neg__(self):\n73:         return self._combine(-1, self.MUL, False)\n74: \n75:     def __add__(self, other):\n76:         return self._combine(other, self.ADD, False)\n77: \n78:     def __sub__(self, other):\n79:         return self._combine(other, self.SUB, False)\n80: \n81:     def __mul__(self, other):\n82:         return self._combine(other, self.MUL, False)\n83: \n84:     def __truediv__(self, other):\n85:         return self._combine(other, self.DIV, False)\n86: \n87:     def __mod__(self, other):\n88:         return self._combine(other, self.MOD, False)\n89: \n90:     def __pow__(self, other):\n91:         return self._combine(other, self.POW, False)\n92: \n93:     def __and__(self, other):\n94:         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n95:             return Q(self) & Q(other)\n96:         raise NotImplementedError(\n97:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n98:         )\n99: \n100:     def bitand(self, other):\n101:         return self._combine(other, self.BITAND, False)\n102: \n103:     def bitleftshift(self, other):\n104:         return self._combine(other, self.BITLEFTSHIFT, False)\n105: \n106:     def bitrightshift(self, other):\n107:         return self._combine(other, self.BITRIGHTSHIFT, False)\n108: \n109:     def bitxor(self, other):\n110:         return self._combine(other, self.BITXOR, False)\n111: \n112:     def __or__(self, other):\n113:         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n114:             return Q(self) | Q(other)\n115:         raise NotImplementedError(\n116:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n117:         )\n118: \n119:     def bitor(self, other):\n120:         return self._combine(other, self.BITOR, False)\n121: \n122:     def __radd__(self, other):\n123:         return self._combine(other, self.ADD, True)\n124: \n125:     def __rsub__(self, other):\n126:         return self._combine(other, self.SUB, True)\n127: \n128:     def __rmul__(self, other):\n129:         return self._combine(other, self.MUL, True)\n130: \n131:     def __rtruediv__(self, other):\n132:         return self._combine(other, self.DIV, True)\n133: \n134:     def __rmod__(self, other):\n135:         return self._combine(other, self.MOD, True)\n136: \n137:     def __rpow__(self, other):\n138:         return self._combine(other, self.POW, True)\n139: \n140:     def __rand__(self, other):\n141:         raise NotImplementedError(\n142:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n143:         )\n144: \n145:     def __ror__(self, other):\n146:         raise NotImplementedError(\n147:             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n148:         )\n149: \n150: \n151: @deconstructible\n152: class BaseExpression:\nCode replaced for brevity.\n415: \n416: \n417: \n418: class Expression(BaseExpression, Combinable):\nCode replaced for brevity.\n420: \n421: \n422: \n423: class CombinedExpression(SQLiteNumericMixin, Expression):\n424: \n425:     def __init__(self, lhs, connector, rhs, output_field=None):\n426:         super().__init__(output_field=output_field)\n427:         self.connector = connector\n428:         self.lhs = lhs\n429:         self.rhs = rhs\n430: \n431:     def __repr__(self):\n432:         return \"<{}: {}>\".format(self.__class__.__name__, self)\n433: \n434:     def __str__(self):\n435:         return \"{} {} {}\".format(self.lhs, self.connector, self.rhs)\n436: \n437:     def get_source_expressions(self):\n438:         return [self.lhs, self.rhs]\n439: \n440:     def set_source_expressions(self, exprs):\n441:         self.lhs, self.rhs = exprs\n442: \n443:     def as_sql(self, compiler, connection):\n444:         try:\n445:             lhs_output = self.lhs.output_field\n446:         except FieldError:\n447:             lhs_output = None\n448:         try:\n449:             rhs_output = self.rhs.output_field\n450:         except FieldError:\n451:             rhs_output = None\n452:         if (not connection.features.has_native_duration_field and\n453:                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or\n454:                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):\n455:             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n456:         if (lhs_output and rhs_output and self.connector == self.SUB and\n457:             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and\n458:                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):\n459:             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n460:         expressions = []\n461:         expression_params = []\n462:         sql, params = compiler.compile(self.lhs)\n463:         expressions.append(sql)\n464:         expression_params.extend(params)\n465:         sql, params = compiler.compile(self.rhs)\n466:         expressions.append(sql)\n467:         expression_params.extend(params)\n468:         # order of precedence\n469:         expression_wrapper = '(%s)'\n470:         sql = connection.ops.combine_expression(self.connector, expressions)\n471:         return expression_wrapper % sql, expression_params\n472: \n473:     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n474:         c = self.copy()\n475:         c.is_summary = summarize\n476:         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n477:         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n478:         return c\n479: \n480: \n481: class DurationExpression(CombinedExpression):\n482:     def compile(self, side, compiler, connection):\n483:         if not isinstance(side, DurationValue):\n484:             try:\n485:                 output = side.output_field\n486:             except FieldError:\n487:                 pass\n488:             else:\n489:                 if output.get_internal_type() == 'DurationField':\n490:                     sql, params = compiler.compile(side)\n491:                     return connection.ops.format_for_duration_arithmetic(sql), params\n492:         return compiler.compile(side)\n493: \n494:     def as_sql(self, compiler, connection):\n495:         connection.ops.check_expression_support(self)\n496:         expressions = []\n497:         expression_params = []\n498:         sql, params = self.compile(self.lhs, compiler, connection)\n499:         expressions.append(sql)\n500:         expression_params.extend(params)\n501:         sql, params = self.compile(self.rhs, compiler, connection)\n502:         expressions.append(sql)\n503:         expression_params.extend(params)\n504:         # order of precedence\n505:         expression_wrapper = '(%s)'\n506:         sql = connection.ops.combine_duration_expression(self.connector, expressions)\n507:         return expression_wrapper % sql, expression_params\n508: \n509: \n510: class TemporalSubtraction(CombinedExpression):\nCode replaced for brevity.\n520: \n521: \n522: \n523: @deconstructible\n524: class F(Combinable):\nCode replaced for brevity.\n551: \n552: \n553: \n554: class ResolvedOuterRef(F):\nCode replaced for brevity.\n581: \n582: \n583: \n584:     d\nCode replaced for brevity.\n591: \n592: \n593: \n594:     \"\nCode replaced for brevity.\n665: \n666: \n667: \n668:     \"\nCode replaced for brevity.\n709: \n710: \n711: \n712: class DurationValue(Value):\n713:     def as_sql(self, compiler, connection):\n714:         connection.ops.check_expression_support(self)\n715:         if connection.features.has_native_duration_field:\n716:             return super().as_sql(compiler, connection)\n717:         return connection.ops.date_interval_sql(self.value), []\n718: \n719: \n720:     d\nCode replaced for brevity.\n744: \n745: \n746: \n747:     d\nCode replaced for brevity.\n752: \n753: \n754: \n755:     o\nCode replaced for brevity.\n762: \n763: \n764: \n765:     c\nCode replaced for brevity.\n799: \n800: \n801: \n802:     \"\nCode replaced for brevity.\n832: \n833: \n834: \n835:     \"\nCode replaced for brevity.\n849: \n850: \n851: \n852:     \"\nCode replaced for brevity.\n878: \n879: \n880: \n881:     t\nCode replaced for brevity.\n945: \n946: \n947: \n948:     \"\nCode replaced for brevity.\n1021: \n1022: \n1023: \n1024:     \"\nCode replaced for brevity.\n1083: \n1084: \n1085: \n1086:     t\nCode replaced for brevity.\n1114: \n1115: \n1116: \n1117:     t\nCode replaced for brevity.\n1198: \n1199: \n1200: \n1201:     t\nCode replaced for brevity.\n1292: \n1293: \n1294: \n1295:     \"\nCode replaced for brevity.\n1351: \n1352: \n1353: \n1354:     f\nCode replaced for brevity.\n1358: \n1359: \n1360: \n1361:     f\nCode replaced for brevity.\n1365: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/backends/base/operations.py",
      "suspect_lines": [
        102,
        103,
        104,
        105,
        106,
        107
      ]
    },
    {
      "filename": "/django/db/backends/mysql/operations.py",
      "suspect_lines": [
        6,
        143,
        144,
        145
      ]
    },
    {
      "filename": "/django/db/backends/sqlite3/operations.py",
      "suspect_lines": [
        14,
        77,
        78,
        79
      ]
    },
    {
      "filename": "/django/db/models/expressions.py",
      "suspect_lines": [
        59,
        60,
        61,
        62,
        445,
        447,
        449,
        451,
        452,
        453,
        454,
        456,
        457,
        458,
        483,
        484,
        485,
        486,
        487,
        488,
        489,
        490,
        491,
        712,
        713,
        714,
        715,
        716,
        717,
        718,
        719
      ]
    }
  ]
}