{
  "instance_id": "django__django-13741",
  "problem_statement": "Set disabled prop on ReadOnlyPasswordHashField\nDescription\n\t\nCurrently the django.contrib.auth.forms.UserChangeForm defines a clean_password method that returns the initial password value to prevent (accidental) changes to the password value. It is also documented that custom forms for the User model need to define this method: ​https://docs.djangoproject.com/en/3.1/topics/auth/customizing/#a-full-example\nA while ago the forms.Field base class gained the ​disabled argument to:\n[disable] a form field using the disabled HTML attribute so that it won’t be editable by users. Even if a user tampers with the field’s value submitted to the server, it will be ignored in favor of the value from the form’s initial data.\nIt seems to me that this property could be set to True be default on the ReadOnlyPasswordHashField used to display the password hash. This way the clean_password is no longer necessary and the potential pitfall when using the ReadOnlyPasswordHashField without implementing clean_password is removed.\n",
  "localized_code": "[start of django/contrib/auth/forms.py]\n1: import unicodedata\n2: \n3: from django import forms\n4: from django.contrib.auth import (\n5:     authenticate, get_user_model, password_validation,\n6: )\n7: from django.contrib.auth.hashers import (\n8:     UNUSABLE_PASSWORD_PREFIX, identify_hasher,\n9: )\n10: from django.contrib.auth.models import User\n11: from django.contrib.auth.tokens import default_token_generator\n12: from django.contrib.sites.shortcuts import get_current_site\n13: from django.core.exceptions import ValidationError\n14: from django.core.mail import EmailMultiAlternatives\n15: from django.template import loader\n16: from django.utils.encoding import force_bytes\n17: from django.utils.http import urlsafe_base64_encode\n18: from django.utils.text import capfirst\n19: from django.utils.translation import gettext, gettext_lazy as _\n20: \n21: UserModel = get_user_model()\n22: \n23: \n24: def _unicode_ci_compare(s1, s2):\n25:     \"\"\"\n26:     Perform case-insensitive comparison of two identifiers, using the\n27:     recommended algorithm from Unicode Technical Report 36, section\n28:     2.11.2(B)(2).\n29:     \"\"\"\n30:     return unicodedata.normalize('NFKC', s1).casefold() == unicodedata.normalize('NFKC', s2).casefold()\n31: \n32: \n33: class ReadOnlyPasswordHashWidget(forms.Widget):\n34:     template_name = 'auth/widgets/read_only_password_hash.html'\n35:     read_only = True\n36: \n37:     def get_context(self, name, value, attrs):\n38:         context = super().get_context(name, value, attrs)\n39:         summary = []\n40:         if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n41:             summary.append({'label': gettext(\"No password set.\")})\n42:         else:\n43:             try:\n44:                 hasher = identify_hasher(value)\n45:             except ValueError:\n46:                 summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n47:             else:\n48:                 for key, value_ in hasher.safe_summary(value).items():\n49:                     summary.append({'label': gettext(key), 'value': value_})\n50:         context['summary'] = summary\n51:         return context\n52: \n53: \n54: class ReadOnlyPasswordHashField(forms.Field):\n55:     widget = ReadOnlyPasswordHashWidget\n56: \n57:     def __init__(self, *args, **kwargs):\n58:         kwargs.setdefault(\"required\", False)\n59:         super().__init__(*args, **kwargs)\n60: \n61:     def bound_data(self, data, initial):\n62:         # Always return initial because the widget doesn't\n63:         # render an input field.\n64:         return initial\n65: \n66:     def has_changed(self, initial, data):\n67:         return False\n68: \n69: \n70: class UsernameField(forms.CharField):\nCode replaced for brevity.\n79: \n80: \n81: \n82: class UserCreationForm(forms.ModelForm):\nCode replaced for brevity.\n139: \n140: \n141: \n142: class UserChangeForm(forms.ModelForm):\n143:     password = ReadOnlyPasswordHashField(\n144:         label=_(\"Password\"),\n145:         help_text=_(\n146:             'Raw passwords are not stored, so there is no way to see this '\n147:             'user’s password, but you can change the password using '\n148:             '<a href=\"{}\">this form</a>.'\n149:         ),\n150:     )\n151: \n152:     class Meta:\n153:         model = User\n154:         fields = '__all__'\n155:         field_classes = {'username': UsernameField}\n156: \n157:     def __init__(self, *args, **kwargs):\n158:         super().__init__(*args, **kwargs)\n159:         password = self.fields.get('password')\n160:         if password:\n161:             password.help_text = password.help_text.format('../password/')\n162:         user_permissions = self.fields.get('user_permissions')\n163:         if user_permissions:\n164:             user_permissions.queryset = user_permissions.queryset.select_related('content_type')\n165: \n166:     def clean_password(self):\n167:         # Regardless of what the user provides, return the initial value.\n168:         # This is done here, rather than on the field, because the\n169:         # field does not have access to the initial value\n170:         return self.initial.get('password')\n171: \n172: \n173:     \"\"\"\nCode replaced for brevity.\n248: \n249: \n250: \n251:     emai\nCode replaced for brevity.\n326: \n327: \n328: \n329:     \"\"\"\nCode replaced for brevity.\n370: \n371: \n372: \n373:     \"\"\"\nCode replaced for brevity.\n400: \n401: \n402: \n403:     \"\"\"\nCode replaced for brevity.\n453: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/auth/forms.py",
      "suspect_lines": [
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        166,
        167,
        168,
        169,
        170,
        171
      ]
    }
  ]
}