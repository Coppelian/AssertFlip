{
  "instance_id": "sphinx-doc__sphinx-8548",
  "problem_statement": "autodoc inherited-members won't work for inherited attributes (data members).\nautodoc searches for a cached docstring using (namespace, attrname) as search-key, but doesn't check for baseclass-namespace.\n\n---\n- Bitbucket: https://bitbucket.org/birkenfeld/sphinx/issue/741\n- Originally reported by: Anonymous\n- Originally created at: 2011-08-02T17:05:58.754\n\n",
  "localized_code": "[start of sphinx/ext/autodoc/__init__.py]\n1: \"\"\"\n2:     sphinx.ext.autodoc\n3:     ~~~~~~~~~~~~~~~~~~\n4: \n5:     Automatically insert docstrings for functions, classes or whole modules into\n6:     the doctree, thus avoiding duplication between docstrings and documentation\n7:     for those who like elaborate docstrings.\n8: \n9:     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10:     :license: BSD, see LICENSE for details.\n11: \"\"\"\n12: \n13: import importlib\n14: import re\n15: import warnings\n16: from inspect import Parameter, Signature\n17: from types import ModuleType\n18: from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,\n19:                     TypeVar, Union)\n20: \n21: from docutils.statemachine import StringList\n22: \n23: import sphinx\n24: from sphinx.application import Sphinx\n25: from sphinx.config import ENUM, Config\n26: from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,\n27:                                 RemovedInSphinx60Warning)\n28: from sphinx.environment import BuildEnvironment\n29: from sphinx.ext.autodoc.importer import (get_class_members, get_module_members,\n30:                                          get_object_members, import_object)\n31: from sphinx.ext.autodoc.mock import mock\n32: from sphinx.locale import _, __\n33: from sphinx.pycode import ModuleAnalyzer, PycodeError\n34: from sphinx.util import inspect, logging\n35: from sphinx.util.docstrings import extract_metadata, prepare_docstring\n36: from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n37:                                  stringify_signature)\n38: from sphinx.util.typing import get_type_hints, restify\n39: from sphinx.util.typing import stringify as stringify_typehint\n40: \n41: if False:\n42:     # For type annotation\n43:     from typing import Type  # NOQA # for python3.5.1\n44: \n45:     from sphinx.ext.autodoc.directive import DocumenterBridge\n46: \n47: \n48: logger = logging.getLogger(__name__)\n49: \n50: \n51: # This type isn't exposed directly in any modules, but can be found\n52: # here in most Python versions\n53: MethodDescriptorType = type(type.__subclasses__)\n54: \n55: \n56: #: extended signature RE: with explicit module name separated by ::\n57: py_ext_sig_re = re.compile(\n58:     r'''^ ([\\w.]+::)?            # explicit module name\n59:           ([\\w.]+\\.)?            # module and/or class name(s)\n60:           (\\w+)  \\s*             # thing name\n61:           (?: \\((.*)\\)           # optional: arguments\n62:            (?:\\s* -> \\s* (.*))?  #           return annotation\n63:           )? $                   # and nothing more\n64:           ''', re.VERBOSE)\n65: special_member_re = re.compile(r'^__\\S+__$')\n66: \n67: \n68: def identity(x: Any) -> Any:\n69:     return x\n70: \n71: \n72: class _All:\nCode replaced for brevity.\n76: \n77: \n78: \n79: class _Empty:\nCode replaced for brevity.\n83: \n84: \n85: \n86: ALL = _All()\n87: EMPTY = _Empty()\n88: UNINITIALIZED_ATTR = object()\n89: INSTANCEATTR = object()\n90: SLOTSATTR = object()\n91: \n92: \n93: def members_option(arg: Any) -> Union[object, List[str]]:\nCode replaced for brevity.\n100: \n101: \n102: \n103: def members_set_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n109: \n110: \n111: \n112: def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n116: \n117: \n118: \n119: def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n124: \n125: \n126: \n127: def member_order_option(arg: Any) -> Optional[str]:\nCode replaced for brevity.\n134: \n135: \n136: \n137: SUPPRESS = object()\n138: \n139: \n140: def annotation_option(arg: Any) -> Any:\nCode replaced for brevity.\n145: \n146: \n147: \n148: def bool_option(arg: Any) -> bool:\nCode replaced for brevity.\n152: \n153: \n154: \n155: def merge_special_members_option(options: Dict) -> None:\nCode replaced for brevity.\n167: \n168: \n169: \n170: def merge_members_option(options: Dict) -> None:\nCode replaced for brevity.\n181: \n182: \n183: \n184: # Some useful event listener factories for autodoc-process-docstring.\n185: \n186: def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\nCode replaced for brevity.\n211: \n212: \n213: \n214:             exclude: bool = False) -> Callable:\nCode replaced for brevity.\n247: \n248: \n249: \n250: # This class is used only in ``sphinx.ext.autodoc.directive``,\n251: # But we define this class here to keep compatibility (see #4538)\n252: class Options(dict):\nCode replaced for brevity.\n258: \n259: \n260: \n261: class ObjectMember(tuple):\nCode replaced for brevity.\n283: \n284: \n285: \n286: ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n287: \n288: \n289: class Documenter:\nCode replaced for brevity.\n957: \n958: \n959: \n960: class ModuleDocumenter(Documenter):\nCode replaced for brevity.\n1082: \n1083: \n1084: \n1085: class ModuleLevelDocumenter(Documenter):\nCode replaced for brevity.\n1103: \n1104: \n1105: \n1106: class ClassLevelDocumenter(Documenter):\nCode replaced for brevity.\n1136: \n1137: \n1138: \n1139: class DocstringSignatureMixin:\nCode replaced for brevity.\n1231: \n1232: \n1233: \n1234: class DocstringStripSignatureMixin(DocstringSignatureMixin):\nCode replaced for brevity.\n1249: \n1250: \n1251: \n1252: class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n1352: \n1353: \n1354: \n1355: class DecoratorDocumenter(FunctionDocumenter):\nCode replaced for brevity.\n1369: \n1370: \n1371: \n1372: # Types which have confusing metaclass signatures it would be best not to show.\n1373: # These are listed by name, rather than storing the objects themselves, to avoid\n1374: # needing to import the modules.\n1375: _METACLASS_CALL_BLACKLIST = [\n1376:     'enum.EnumMeta.__call__',\n1377: ]\n1378: \n1379: \n1380: # Types whose __new__ signature is a pass-thru.\n1381: _CLASS_NEW_BLACKLIST = [\n1382:     'typing.Generic.__new__',\n1383: ]\n1384: \n1385: \n1386: class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1387:     \"\"\"\n1388:     Specialized Documenter subclass for classes.\n1389:     \"\"\"\n1390:     objtype = 'class'\n1391:     member_order = 20\n1392:     option_spec = {\n1393:         'members': members_option, 'undoc-members': bool_option,\n1394:         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1395:         'show-inheritance': bool_option, 'member-order': member_order_option,\n1396:         'exclude-members': exclude_members_option,\n1397:         'private-members': members_option, 'special-members': members_option,\n1398:     }  # type: Dict[str, Callable]\n1399: \n1400:     _signature_class = None  # type: Any\n1401:     _signature_method_name = None  # type: str\n1402: \n1403:     def __init__(self, *args: Any) -> None:\n1404:         super().__init__(*args)\n1405:         merge_members_option(self.options)\n1406: \n1407:     @classmethod\n1408:     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1409:                             ) -> bool:\n1410:         return isinstance(member, type)\n1411: \n1412:     def import_object(self, raiseerror: bool = False) -> bool:\n1413:         ret = super().import_object(raiseerror)\n1414:         # if the class is documented under another name, document it\n1415:         # as data/attribute\n1416:         if ret:\n1417:             if hasattr(self.object, '__name__'):\n1418:                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1419:             else:\n1420:                 self.doc_as_attr = True\n1421:         return ret\n1422: \n1423:     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1424:         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1425:             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1426:             if inspect.is_builtin_class_method(obj, attr):\n1427:                 return None\n1428:             attr = self.get_attr(obj, attr, None)\n1429:             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1430:                 return None\n1431:             return attr\n1432: \n1433:         # This sequence is copied from inspect._signature_from_callable.\n1434:         # ValueError means that no signature could be found, so we keep going.\n1435: \n1436:         # First, we check the obj has a __signature__ attribute\n1437:         if (hasattr(self.object, '__signature__') and\n1438:                 isinstance(self.object.__signature__, Signature)):\n1439:             return None, None, self.object.__signature__\n1440: \n1441:         # Next, let's see if it has an overloaded __call__ defined\n1442:         # in its metaclass\n1443:         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1444: \n1445:         if call is not None:\n1446:             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1447:                 call = None\n1448: \n1449:         if call is not None:\n1450:             self.env.app.emit('autodoc-before-process-signature', call, True)\n1451:             try:\n1452:                 sig = inspect.signature(call, bound_method=True,\n1453:                                         type_aliases=self.config.autodoc_type_aliases)\n1454:                 return type(self.object), '__call__', sig\n1455:             except ValueError:\n1456:                 pass\n1457: \n1458:         # Now we check if the 'obj' class has a '__new__' method\n1459:         new = get_user_defined_function_or_method(self.object, '__new__')\n1460: \n1461:         if new is not None:\n1462:             if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n1463:                 new = None\n1464: \n1465:         if new is not None:\n1466:             self.env.app.emit('autodoc-before-process-signature', new, True)\n1467:             try:\n1468:                 sig = inspect.signature(new, bound_method=True,\n1469:                                         type_aliases=self.config.autodoc_type_aliases)\n1470:                 return self.object, '__new__', sig\n1471:             except ValueError:\n1472:                 pass\n1473: \n1474:         # Finally, we should have at least __init__ implemented\n1475:         init = get_user_defined_function_or_method(self.object, '__init__')\n1476:         if init is not None:\n1477:             self.env.app.emit('autodoc-before-process-signature', init, True)\n1478:             try:\n1479:                 sig = inspect.signature(init, bound_method=True,\n1480:                                         type_aliases=self.config.autodoc_type_aliases)\n1481:                 return self.object, '__init__', sig\n1482:             except ValueError:\n1483:                 pass\n1484: \n1485:         # None of the attributes are user-defined, so fall back to let inspect\n1486:         # handle it.\n1487:         # We don't know the exact method that inspect.signature will read\n1488:         # the signature from, so just pass the object itself to our hook.\n1489:         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1490:         try:\n1491:             sig = inspect.signature(self.object, bound_method=False,\n1492:                                     type_aliases=self.config.autodoc_type_aliases)\n1493:             return None, None, sig\n1494:         except ValueError:\n1495:             pass\n1496: \n1497:         # Still no signature: happens e.g. for old-style classes\n1498:         # with __init__ in C and no `__text_signature__`.\n1499:         return None, None, None\n1500: \n1501:     def format_args(self, **kwargs: Any) -> str:\n1502:         if self.config.autodoc_typehints in ('none', 'description'):\n1503:             kwargs.setdefault('show_annotation', False)\n1504: \n1505:         try:\n1506:             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1507:         except TypeError as exc:\n1508:             # __signature__ attribute contained junk\n1509:             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1510:                            self.fullname, exc)\n1511:             return None\n1512: \n1513:         if sig is None:\n1514:             return None\n1515: \n1516:         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1517: \n1518:     def format_signature(self, **kwargs: Any) -> str:\n1519:         if self.doc_as_attr:\n1520:             return ''\n1521: \n1522:         sig = super().format_signature()\n1523:         sigs = []\n1524: \n1525:         overloads = self.get_overloaded_signatures()\n1526:         if overloads and self.config.autodoc_typehints == 'signature':\n1527:             # Use signatures for overloaded methods instead of the implementation method.\n1528:             method = safe_getattr(self._signature_class, self._signature_method_name, None)\n1529:             __globals__ = safe_getattr(method, '__globals__', {})\n1530:             for overload in overloads:\n1531:                 overload = evaluate_signature(overload, __globals__,\n1532:                                               self.config.autodoc_type_aliases)\n1533: \n1534:                 parameters = list(overload.parameters.values())\n1535:                 overload = overload.replace(parameters=parameters[1:],\n1536:                                             return_annotation=Parameter.empty)\n1537:                 sig = stringify_signature(overload, **kwargs)\n1538:                 sigs.append(sig)\n1539:         else:\n1540:             sigs.append(sig)\n1541: \n1542:         return \"\\n\".join(sigs)\n1543: \n1544:     def get_overloaded_signatures(self) -> List[Signature]:\n1545:         if self._signature_class and self._signature_method_name:\n1546:             for cls in self._signature_class.__mro__:\n1547:                 try:\n1548:                     analyzer = ModuleAnalyzer.for_module(cls.__module__)\n1549:                     analyzer.analyze()\n1550:                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])\n1551:                     if qualname in analyzer.overloads:\n1552:                         return analyzer.overloads.get(qualname)\n1553:                     elif qualname in analyzer.tagorder:\n1554:                         # the constructor is defined in the class, but not overrided.\n1555:                         return []\n1556:                 except PycodeError:\n1557:                     pass\n1558: \n1559:         return []\n1560: \n1561:     def add_directive_header(self, sig: str) -> None:\n1562:         sourcename = self.get_sourcename()\n1563: \n1564:         if self.doc_as_attr:\n1565:             self.directivetype = 'attribute'\n1566:         super().add_directive_header(sig)\n1567: \n1568:         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1569:             self.add_line('   :final:', sourcename)\n1570: \n1571:         # add inheritance info, if wanted\n1572:         if not self.doc_as_attr and self.options.show_inheritance:\n1573:             sourcename = self.get_sourcename()\n1574:             self.add_line('', sourcename)\n1575: \n1576:             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):\n1577:                 # A subclass of generic types\n1578:                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>\n1579:                 bases = [restify(cls) for cls in self.object.__orig_bases__]\n1580:                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1581:             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1582:                 # A normal class\n1583:                 bases = [restify(cls) for cls in self.object.__bases__]\n1584:                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1585: \n1586:     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1587:         members = get_class_members(self.object, self.objpath, self.get_attr, self.analyzer)\n1588:         if not want_all:\n1589:             if not self.options.members:\n1590:                 return False, []  # type: ignore\n1591:             # specific members given\n1592:             selected = []\n1593:             for name in self.options.members:  # type: str\n1594:                 if name in members:\n1595:                     selected.append(ObjectMember(name, members[name].value,\n1596:                                                  docstring=members[name].docstring))\n1597:                 else:\n1598:                     logger.warning(__('missing attribute %s in object %s') %\n1599:                                    (name, self.fullname), type='autodoc')\n1600:             return False, selected\n1601:         elif self.options.inherited_members:\n1602:             return False, [ObjectMember(m.name, m.value, docstring=m.docstring)\n1603:                            for m in members.values()]\n1604:         else:\n1605:             return False, [ObjectMember(m.name, m.value, docstring=m.docstring)\n1606:                            for m in members.values() if m.class_ == self.object]\n1607: \n1608:     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1609:         if encoding is not None:\n1610:             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1611:                           % self.__class__.__name__,\n1612:                           RemovedInSphinx40Warning, stacklevel=2)\n1613:         if self.doc_as_attr:\n1614:             # Don't show the docstring of the class when it is an alias.\n1615:             return []\n1616: \n1617:         lines = getattr(self, '_new_docstrings', None)\n1618:         if lines is not None:\n1619:             return lines\n1620: \n1621:         content = self.config.autoclass_content\n1622: \n1623:         docstrings = []\n1624:         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1625:         if attrdocstring:\n1626:             docstrings.append(attrdocstring)\n1627: \n1628:         # for classes, what the \"docstring\" is can be controlled via a\n1629:         # config value; the default is only the class docstring\n1630:         if content in ('both', 'init'):\n1631:             __init__ = self.get_attr(self.object, '__init__', None)\n1632:             initdocstring = getdoc(__init__, self.get_attr,\n1633:                                    self.config.autodoc_inherit_docstrings,\n1634:                                    self.parent, self.object_name)\n1635:             # for new-style classes, no __init__ means default __init__\n1636:             if (initdocstring is not None and\n1637:                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1638:                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1639:                 initdocstring = None\n1640:             if not initdocstring:\n1641:                 # try __new__\n1642:                 __new__ = self.get_attr(self.object, '__new__', None)\n1643:                 initdocstring = getdoc(__new__, self.get_attr,\n1644:                                        self.config.autodoc_inherit_docstrings,\n1645:                                        self.parent, self.object_name)\n1646:                 # for new-style classes, no __new__ means default __new__\n1647:                 if (initdocstring is not None and\n1648:                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1649:                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1650:                     initdocstring = None\n1651:             if initdocstring:\n1652:                 if content == 'init':\n1653:                     docstrings = [initdocstring]\n1654:                 else:\n1655:                     docstrings.append(initdocstring)\n1656: \n1657:         tab_width = self.directive.state.document.settings.tab_width\n1658:         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1659: \n1660:     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1661:                     ) -> None:\n1662:         if self.doc_as_attr:\n1663:             more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n1664: \n1665:         super().add_content(more_content)\n1666: \n1667:     def document_members(self, all_members: bool = False) -> None:\n1668:         if self.doc_as_attr:\n1669:             return\n1670:         super().document_members(all_members)\n1671: \n1672:     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n1673:                  check_module: bool = False, all_members: bool = False) -> None:\n1674:         # Do not pass real_modname and use the name from the __module__\n1675:         # attribute of the class.\n1676:         # If a class gets imported into the module real_modname\n1677:         # the analyzer won't find the source of the class, if\n1678:         # it looks in real_modname.\n1679:         return super().generate(more_content=more_content,\n1680:                                 check_module=check_module,\n1681:                                 all_members=all_members)\n1682: \n1683: \n1684: class ExceptionDocumenter(ClassDocumenter):\nCode replaced for brevity.\n1697: \n1698: \n1699: \n1700:     # define types of instance variables\nCode replaced for brevity.\n1719: \n1720: \n1721: \n1722: class GenericAliasMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1738: \n1739: \n1740: \n1741: class NewTypeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1757: \n1758: \n1759: \n1760: class TypeVarMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1797: \n1798: \n1799: \n1800: class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1836: \n1837: \n1838: \n1839:                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\nCode replaced for brevity.\n1913: \n1914: \n1915: \n1916: class NewTypeDataDocumenter(DataDocumenter):\nCode replaced for brevity.\n1931: \n1932: \n1933: \n1934: class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n2079: \n2080: \n2081: \n2082: class NonDataDescriptorMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2101: \n2102: \n2103: \n2104: class SlotsMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2148: \n2149: \n2150: \n2151: class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2234: \n2235: \n2236: \n2237:                           ClassLevelDocumenter):\nCode replaced for brevity.\n2380: \n2381: \n2382: \n2383: class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n2411: \n2412: \n2413: \n2414: class NewTypeAttributeDocumenter(AttributeDocumenter):\nCode replaced for brevity.\n2429: \n2430: \n2431: \n2432: def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\nCode replaced for brevity.\n2435: \n2436: \n2437: \n2438: def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\nCode replaced for brevity.\n2444: \n2445: \n2446: \n2447: def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\nCode replaced for brevity.\n2452: \n2453: \n2454: \n2455: # for compatibility\n2456: from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2457: from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2458: from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2459: from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2460: from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2461: from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2462: from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2463: \n2464: \n2465: def setup(app: Sphinx) -> Dict[str, Any]:\nCode replaced for brevity.\n2499: \n\n[start of sphinx/ext/autodoc/importer.py]\n1: \"\"\"\n2:     sphinx.ext.autodoc.importer\n3:     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     Importer utilities for autodoc\n6: \n7:     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import importlib\n12: import traceback\n13: import warnings\n14: from typing import Any, Callable, Dict, List, Mapping, NamedTuple, Optional, Tuple\n15: \n16: from sphinx.deprecation import RemovedInSphinx40Warning, deprecated_alias\n17: from sphinx.pycode import ModuleAnalyzer\n18: from sphinx.util import logging\n19: from sphinx.util.inspect import (getannotations, getmro, getslots, isclass, isenumclass,\n20:                                  safe_getattr)\n21: \n22: if False:\n23:     # For type annotation\n24:     from typing import Type  # NOQA\n25: \n26: logger = logging.getLogger(__name__)\n27: \n28: \n29: def mangle(subject: Any, name: str) -> str:\n30:     \"\"\"mangle the given name.\"\"\"\n31:     try:\n32:         if isclass(subject) and name.startswith('__') and not name.endswith('__'):\n33:             return \"_%s%s\" % (subject.__name__, name)\n34:     except AttributeError:\n35:         pass\n36: \n37:     return name\n38: \n39: \n40: def unmangle(subject: Any, name: str) -> Optional[str]:\n41:     \"\"\"unmangle the given name.\"\"\"\n42:     try:\n43:         if isclass(subject) and not name.endswith('__'):\n44:             prefix = \"_%s__\" % subject.__name__\n45:             if name.startswith(prefix):\n46:                 return name.replace(prefix, \"__\", 1)\n47:             else:\n48:                 for cls in subject.__mro__:\n49:                     prefix = \"_%s__\" % cls.__name__\n50:                     if name.startswith(prefix):\n51:                         # mangled attribute defined in parent class\n52:                         return None\n53:     except AttributeError:\n54:         pass\n55: \n56:     return name\n57: \n58: \n59: def import_module(modname: str, warningiserror: bool = False) -> Any:\nCode replaced for brevity.\n71: \n72: \n73: \n74:                   warningiserror: bool = False) -> Any:\nCode replaced for brevity.\n137: \n138: \n139: \n140: def get_module_members(module: Any) -> List[Tuple[str, Any]]:\nCode replaced for brevity.\n160: \n161: \n162: \n163: Attribute = NamedTuple('Attribute', [('name', str),\n164:                                      ('directly_defined', bool),\n165:                                      ('value', Any)])\n166: \n167: \n168: def _getmro(obj: Any) -> Tuple[\"Type\", ...]:\nCode replaced for brevity.\n171: \n172: \n173: \n174: def _getannotations(obj: Any) -> Mapping[str, Any]:\nCode replaced for brevity.\n177: \n178: \n179: \n180:                        analyzer: ModuleAnalyzer = None) -> Dict[str, Attribute]:\nCode replaced for brevity.\n241: \n242: \n243: \n244: class ClassAttribute:\nCode replaced for brevity.\n251: \n252: \n253: \n254: def get_class_members(subject: Any, objpath: List[str], attrgetter: Callable,\n255:                       analyzer: ModuleAnalyzer = None) -> Dict[str, ClassAttribute]:\n256:     \"\"\"Get members and attributes of target class.\"\"\"\n257:     from sphinx.ext.autodoc import INSTANCEATTR\n258: \n259:     # the members directly defined in the class\n260:     obj_dict = attrgetter(subject, '__dict__', {})\n261: \n262:     members = {}  # type: Dict[str, ClassAttribute]\n263: \n264:     # enum members\n265:     if isenumclass(subject):\n266:         for name, value in subject.__members__.items():\n267:             if name not in members:\n268:                 members[name] = ClassAttribute(subject, name, value)\n269: \n270:         superclass = subject.__mro__[1]\n271:         for name in obj_dict:\n272:             if name not in superclass.__dict__:\n273:                 value = safe_getattr(subject, name)\n274:                 members[name] = ClassAttribute(subject, name, value)\n275: \n276:     # members in __slots__\n277:     try:\n278:         __slots__ = getslots(subject)\n279:         if __slots__:\n280:             from sphinx.ext.autodoc import SLOTSATTR\n281: \n282:             for name, docstring in __slots__.items():\n283:                 members[name] = ClassAttribute(subject, name, SLOTSATTR, docstring)\n284:     except (AttributeError, TypeError, ValueError):\n285:         pass\n286: \n287:     # other members\n288:     for name in dir(subject):\n289:         try:\n290:             value = attrgetter(subject, name)\n291:             unmangled = unmangle(subject, name)\n292:             if unmangled and unmangled not in members:\n293:                 if name in obj_dict:\n294:                     members[unmangled] = ClassAttribute(subject, unmangled, value)\n295:                 else:\n296:                     members[unmangled] = ClassAttribute(None, unmangled, value)\n297:         except AttributeError:\n298:             continue\n299: \n300:     # annotation only member (ex. attr: int)\n301:     for cls in getmro(subject):\n302:         try:\n303:             for name in getannotations(cls):\n304:                 name = unmangle(cls, name)\n305:                 if name and name not in members:\n306:                     members[name] = ClassAttribute(cls, name, INSTANCEATTR)\n307:         except AttributeError:\n308:             pass\n309: \n310:     if analyzer:\n311:         # append instance attributes (cf. self.attr1) if analyzer knows\n312:         namespace = '.'.join(objpath)\n313:         for (ns, name), docstring in analyzer.attr_docs.items():\n314:             if namespace == ns and name not in members:\n315:                 members[name] = ClassAttribute(subject, name, INSTANCEATTR,\n316:                                                '\\n'.join(docstring))\n317: \n318:     return members\n319: \n320: \n321: from sphinx.ext.autodoc.mock import (MockFinder, MockLoader, _MockModule, _MockObject,  # NOQA\n322:                                      mock)\n323: \n324: deprecated_alias('sphinx.ext.autodoc.importer',\n325:                  {\n326:                      '_MockModule': _MockModule,\n327:                      '_MockObject': _MockObject,\n328:                      'MockFinder': MockFinder,\n329:                      'MockLoader': MockLoader,\n330:                      'mock': mock,\n331:                  },\n332:                  RemovedInSphinx40Warning,\n333:                  {\n334:                      '_MockModule': 'sphinx.ext.autodoc.mock._MockModule',\n335:                      '_MockObject': 'sphinx.ext.autodoc.mock._MockObject',\n336:                      'MockFinder': 'sphinx.ext.autodoc.mock.MockFinder',\n337:                      'MockLoader': 'sphinx.ext.autodoc.mock.MockLoader',\n338:                      'mock': 'sphinx.ext.autodoc.mock.mock',\n339:                  })\n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/ext/autodoc/__init__.py",
      "suspect_lines": [
        1587
      ]
    },
    {
      "filename": "/sphinx/ext/autodoc/importer.py",
      "suspect_lines": [
        17,
        254,
        255,
        300,
        301,
        302,
        303,
        304,
        305,
        306,
        307,
        308,
        309,
        310,
        311,
        312,
        313,
        314,
        315,
        316
      ]
    }
  ]
}