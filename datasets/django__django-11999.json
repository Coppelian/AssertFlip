{
  "instance_id": "django__django-11999",
  "problem_statement": "Cannot override get_FOO_display() in Django 2.2+.\nDescription\n\t\nI cannot override the get_FIELD_display function on models since version 2.2. It works in version 2.1.\nExample:\nclass FooBar(models.Model):\n\tfoo_bar = models.CharField(_(\"foo\"), choices=[(1, 'foo'), (2, 'bar')])\n\tdef __str__(self):\n\t\treturn self.get_foo_bar_display() # This returns 'foo' or 'bar' in 2.2, but 'something' in 2.1\n\tdef get_foo_bar_display(self):\n\t\treturn \"something\"\nWhat I expect is that I should be able to override this function.\n",
  "localized_code": "[start of django/db/models/fields/__init__.py]\n1: import collections.abc\n2: import copy\n3: import datetime\n4: import decimal\n5: import operator\n6: import uuid\n7: import warnings\n8: from base64 import b64decode, b64encode\n9: from functools import partialmethod, total_ordering\n10: \n11: from django import forms\n12: from django.apps import apps\n13: from django.conf import settings\n14: from django.core import checks, exceptions, validators\n15: from django.db import connection, connections, router\n16: from django.db.models.constants import LOOKUP_SEP\n17: from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin\n18: from django.utils import timezone\n19: from django.utils.datastructures import DictWrapper\n20: from django.utils.dateparse import (\n21:     parse_date, parse_datetime, parse_duration, parse_time,\n22: )\n23: from django.utils.duration import duration_microseconds, duration_string\n24: from django.utils.functional import Promise, cached_property\n25: from django.utils.ipv6 import clean_ipv6_address\n26: from django.utils.itercompat import is_iterable\n27: from django.utils.text import capfirst\n28: from django.utils.translation import gettext_lazy as _\n29: \n30: __all__ = [\n31:     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',\n32:     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',\n33:     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',\n34:     'EmailField', 'Empty', 'Field', 'FilePathField', 'FloatField',\n35:     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',\n36:     'NullBooleanField', 'PositiveIntegerField', 'PositiveSmallIntegerField',\n37:     'SlugField', 'SmallAutoField', 'SmallIntegerField', 'TextField',\n38:     'TimeField', 'URLField', 'UUIDField',\n39: ]\n40: \n41: \n42: class Empty:\n43:     pass\n44: \n45: \n46: class NOT_PROVIDED:\n47:     pass\n48: \n49: \n50: # The values to use for \"blank\" in SelectFields. Will be appended to the start\n51: # of most \"choices\" lists.\n52: BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n53: \n54: \n55: def _load_field(app_label, model_name, field_name):\nCode replaced for brevity.\n56: \n57: \n58: \n59: # A guide to Field parameters:\n60: #\n61: #   * name:      The name of the field specified in the model.\n62: #   * attname:   The attribute to use on the model object. This is the same as\n63: #                \"name\", except in the case of ForeignKeys, where \"_id\" is\n64: #                appended.\n65: #   * db_column: The db_column specified in the model (or None).\n66: #   * column:    The database column for this field. This is the same as\n67: #                \"attname\", except if db_column is specified.\n68: #\n69: # Code that introspects values, or does other dynamic things, should use\n70: # attname. For example, this gets the primary key value of object \"obj\":\n71: #\n72: #     getattr(obj, opts.pk.attname)\n73: \n74: def _empty(of_cls):\n75:     new = Empty()\n76:     new.__class__ = of_cls\n77:     return new\n78: \n79: \n80: def return_None():\n81:     return None\n82: \n83: \n84: @total_ordering\n85: class Field(RegisterLookupMixin):\n86:     \"\"\"Base class for all field types\"\"\"\n87: \n88:     # Designates whether empty strings fundamentally are allowed at the\n89:     # database level.\n90:     empty_strings_allowed = True\n91:     empty_values = list(validators.EMPTY_VALUES)\n92: \n93:     # These track each time a Field instance is created. Used to retain order.\n94:     # The auto_creation_counter is used for fields that Django implicitly\n95:     # creates, creation_counter is used for all user-specified fields.\n96:     creation_counter = 0\n97:     auto_creation_counter = -1\n98:     default_validators = []  # Default set of validators\n99:     default_error_messages = {\n100:         'invalid_choice': _('Value %(value)r is not a valid choice.'),\n101:         'null': _('This field cannot be null.'),\n102:         'blank': _('This field cannot be blank.'),\n103:         'unique': _('%(model_name)s with this %(field_label)s '\n104:                     'already exists.'),\n105:         # Translators: The 'lookup_type' is one of 'date', 'year' or 'month'.\n106:         # Eg: \"Title must be unique for pub_date year\"\n107:         'unique_for_date': _(\"%(field_label)s must be unique for \"\n108:                              \"%(date_field_label)s %(lookup_type)s.\"),\n109:     }\n110:     system_check_deprecated_details = None\n111:     system_check_removed_details = None\n112: \n113:     # Field flags\n114:     hidden = False\n115: \n116:     many_to_many = None\n117:     many_to_one = None\n118:     one_to_many = None\n119:     one_to_one = None\n120:     related_model = None\n121: \n122:     descriptor_class = DeferredAttribute\n123: \n124:     # Generic field type description, usually overridden by subclasses\n125:     def _description(self):\n126:         return _('Field of type: %(field_type)s') % {\n127:             'field_type': self.__class__.__name__\n128:         }\n129:     description = property(_description)\n130: \n131:     def __init__(self, verbose_name=None, name=None, primary_key=False,\n132:                  max_length=None, unique=False, blank=False, null=False,\n133:                  db_index=False, rel=None, default=NOT_PROVIDED, editable=True,\n134:                  serialize=True, unique_for_date=None, unique_for_month=None,\n135:                  unique_for_year=None, choices=None, help_text='', db_column=None,\n136:                  db_tablespace=None, auto_created=False, validators=(),\n137:                  error_messages=None):\n138:         self.name = name\n139:         self.verbose_name = verbose_name  # May be set by set_attributes_from_name\n140:         self._verbose_name = verbose_name  # Store original for deconstruction\n141:         self.primary_key = primary_key\n142:         self.max_length, self._unique = max_length, unique\n143:         self.blank, self.null = blank, null\n144:         self.remote_field = rel\n145:         self.is_relation = self.remote_field is not None\n146:         self.default = default\n147:         self.editable = editable\n148:         self.serialize = serialize\n149:         self.unique_for_date = unique_for_date\n150:         self.unique_for_month = unique_for_month\n151:         self.unique_for_year = unique_for_year\n152:         if isinstance(choices, collections.abc.Iterator):\n153:             choices = list(choices)\n154:         self.choices = choices\n155:         self.help_text = help_text\n156:         self.db_index = db_index\n157:         self.db_column = db_column\n158:         self._db_tablespace = db_tablespace\n159:         self.auto_created = auto_created\n160: \n161:         # Adjust the appropriate creation counter, and save our local copy.\n162:         if auto_created:\n163:             self.creation_counter = Field.auto_creation_counter\n164:             Field.auto_creation_counter -= 1\n165:         else:\n166:             self.creation_counter = Field.creation_counter\n167:             Field.creation_counter += 1\n168: \n169:         self._validators = list(validators)  # Store for deconstruction later\n170: \n171:         messages = {}\n172:         for c in reversed(self.__class__.__mro__):\n173:             messages.update(getattr(c, 'default_error_messages', {}))\n174:         messages.update(error_messages or {})\n175:         self._error_messages = error_messages  # Store for deconstruction later\n176:         self.error_messages = messages\n177: \n178:     def __str__(self):\n179:         \"\"\"\n180:         Return \"app_label.model_label.field_name\" for fields attached to\n181:         models.\n182:         \"\"\"\n183:         if not hasattr(self, 'model'):\n184:             return super().__str__()\n185:         model = self.model\n186:         app = model._meta.app_label\n187:         return '%s.%s.%s' % (app, model._meta.object_name, self.name)\n188: \n189:     def __repr__(self):\n190:         \"\"\"Display the module, class, and name of the field.\"\"\"\n191:         path = '%s.%s' % (self.__class__.__module__, self.__class__.__qualname__)\n192:         name = getattr(self, 'name', None)\n193:         if name is not None:\n194:             return '<%s: %s>' % (path, name)\n195:         return '<%s>' % path\n196: \n197:     def check(self, **kwargs):\n198:         return [\n199:             *self._check_field_name(),\n200:             *self._check_choices(),\n201:             *self._check_db_index(),\n202:             *self._check_null_allowed_for_primary_keys(),\n203:             *self._check_backend_specific_checks(**kwargs),\n204:             *self._check_validators(),\n205:             *self._check_deprecation_details(),\n206:         ]\n207: \n208:     def _check_field_name(self):\n209:         \"\"\"\n210:         Check if field name is valid, i.e. 1) does not end with an\n211:         underscore, 2) does not contain \"__\" and 3) is not \"pk\".\n212:         \"\"\"\n213:         if self.name.endswith('_'):\n214:             return [\n215:                 checks.Error(\n216:                     'Field names must not end with an underscore.',\n217:                     obj=self,\n218:                     id='fields.E001',\n219:                 )\n220:             ]\n221:         elif LOOKUP_SEP in self.name:\n222:             return [\n223:                 checks.Error(\n224:                     'Field names must not contain \"%s\".' % (LOOKUP_SEP,),\n225:                     obj=self,\n226:                     id='fields.E002',\n227:                 )\n228:             ]\n229:         elif self.name == 'pk':\n230:             return [\n231:                 checks.Error(\n232:                     \"'pk' is a reserved word that cannot be used as a field name.\",\n233:                     obj=self,\n234:                     id='fields.E003',\n235:                 )\n236:             ]\n237:         else:\n238:             return []\n239: \n240:     def _check_choices(self):\n241:         if not self.choices:\n242:             return []\n243: \n244:         def is_value(value):\n245:             return isinstance(value, (str, Promise)) or not is_iterable(value)\n246: \n247:         if not is_iterable(self.choices) or isinstance(self.choices, str):\n248:             return [\n249:                 checks.Error(\n250:                     \"'choices' must be an iterable (e.g., a list or tuple).\",\n251:                     obj=self,\n252:                     id='fields.E004',\n253:                 )\n254:             ]\n255: \n256:         choice_max_length = 0\n257:         # Expect [group_name, [value, display]]\n258:         for choices_group in self.choices:\n259:             try:\n260:                 group_name, group_choices = choices_group\n261:             except (TypeError, ValueError):\n262:                 # Containing non-pairs\n263:                 break\n264:             try:\n265:                 if not all(\n266:                     is_value(value) and is_value(human_name)\n267:                     for value, human_name in group_choices\n268:                 ):\n269:                     break\n270:                 if self.max_length is not None and group_choices:\n271:                     choice_max_length = max(\n272:                         choice_max_length,\n273:                         *(len(value) for value, _ in group_choices if isinstance(value, str)),\n274:                     )\n275:             except (TypeError, ValueError):\n276:                 # No groups, choices in the form [value, display]\n277:                 value, human_name = group_name, group_choices\n278:                 if not is_value(value) or not is_value(human_name):\n279:                     break\n280:                 if self.max_length is not None and isinstance(value, str):\n281:                     choice_max_length = max(choice_max_length, len(value))\n282: \n283:             # Special case: choices=['ab']\n284:             if isinstance(choices_group, str):\n285:                 break\n286:         else:\n287:             if self.max_length is not None and choice_max_length > self.max_length:\n288:                 return [\n289:                     checks.Error(\n290:                         \"'max_length' is too small to fit the longest value \"\n291:                         \"in 'choices' (%d characters).\" % choice_max_length,\n292:                         obj=self,\n293:                         id='fields.E009',\n294:                     ),\n295:                 ]\n296:             return []\n297: \n298:         return [\n299:             checks.Error(\n300:                 \"'choices' must be an iterable containing \"\n301:                 \"(actual value, human readable name) tuples.\",\n302:                 obj=self,\n303:                 id='fields.E005',\n304:             )\n305:         ]\n306: \n307:     def _check_db_index(self):\n308:         if self.db_index not in (None, True, False):\n309:             return [\n310:                 checks.Error(\n311:                     \"'db_index' must be None, True or False.\",\n312:                     obj=self,\n313:                     id='fields.E006',\n314:                 )\n315:             ]\n316:         else:\n317:             return []\n318: \n319:     def _check_null_allowed_for_primary_keys(self):\n320:         if (self.primary_key and self.null and\n321:                 not connection.features.interprets_empty_strings_as_nulls):\n322:             # We cannot reliably check this for backends like Oracle which\n323:             # consider NULL and '' to be equal (and thus set up\n324:             # character-based fields a little differently).\n325:             return [\n326:                 checks.Error(\n327:                     'Primary keys must not have null=True.',\n328:                     hint=('Set null=False on the field, or '\n329:                           'remove primary_key=True argument.'),\n330:                     obj=self,\n331:                     id='fields.E007',\n332:                 )\n333:             ]\n334:         else:\n335:             return []\n336: \n337:     def _check_backend_specific_checks(self, **kwargs):\n338:         app_label = self.model._meta.app_label\n339:         for db in connections:\n340:             if router.allow_migrate(db, app_label, model_name=self.model._meta.model_name):\n341:                 return connections[db].validation.check_field(self, **kwargs)\n342:         return []\n343: \n344:     def _check_validators(self):\n345:         errors = []\n346:         for i, validator in enumerate(self.validators):\n347:             if not callable(validator):\n348:                 errors.append(\n349:                     checks.Error(\n350:                         \"All 'validators' must be callable.\",\n351:                         hint=(\n352:                             \"validators[{i}] ({repr}) isn't a function or \"\n353:                             \"instance of a validator class.\".format(\n354:                                 i=i, repr=repr(validator),\n355:                             )\n356:                         ),\n357:                         obj=self,\n358:                         id='fields.E008',\n359:                     )\n360:                 )\n361:         return errors\n362: \n363:     def _check_deprecation_details(self):\n364:         if self.system_check_removed_details is not None:\n365:             return [\n366:                 checks.Error(\n367:                     self.system_check_removed_details.get(\n368:                         'msg',\n369:                         '%s has been removed except for support in historical '\n370:                         'migrations.' % self.__class__.__name__\n371:                     ),\n372:                     hint=self.system_check_removed_details.get('hint'),\n373:                     obj=self,\n374:                     id=self.system_check_removed_details.get('id', 'fields.EXXX'),\n375:                 )\n376:             ]\n377:         elif self.system_check_deprecated_details is not None:\n378:             return [\n379:                 checks.Warning(\n380:                     self.system_check_deprecated_details.get(\n381:                         'msg',\n382:                         '%s has been deprecated.' % self.__class__.__name__\n383:                     ),\n384:                     hint=self.system_check_deprecated_details.get('hint'),\n385:                     obj=self,\n386:                     id=self.system_check_deprecated_details.get('id', 'fields.WXXX'),\n387:                 )\n388:             ]\n389:         return []\n390: \n391:     def get_col(self, alias, output_field=None):\n392:         if output_field is None:\n393:             output_field = self\n394:         if alias != self.model._meta.db_table or output_field != self:\n395:             from django.db.models.expressions import Col\n396:             return Col(alias, self, output_field)\n397:         else:\n398:             return self.cached_col\n399: \n400:     @cached_property\n401:     def cached_col(self):\n402:         from django.db.models.expressions import Col\n403:         return Col(self.model._meta.db_table, self)\n404: \n405:     def select_format(self, compiler, sql, params):\n406:         \"\"\"\n407:         Custom format for select clauses. For example, GIS columns need to be\n408:         selected as AsText(table.col) on MySQL as the table.col data can't be\n409:         used by Django.\n410:         \"\"\"\n411:         return sql, params\n412: \n413:     def deconstruct(self):\n414:         \"\"\"\n415:         Return enough information to recreate the field as a 4-tuple:\n416: \n417:          * The name of the field on the model, if contribute_to_class() has\n418:            been run.\n419:          * The import path of the field, including the class:e.g.\n420:            django.db.models.IntegerField This should be the most portable\n421:            version, so less specific may be better.\n422:          * A list of positional arguments.\n423:          * A dict of keyword arguments.\n424: \n425:         Note that the positional or keyword arguments must contain values of\n426:         the following types (including inner values of collection types):\n427: \n428:          * None, bool, str, int, float, complex, set, frozenset, list, tuple,\n429:            dict\n430:          * UUID\n431:          * datetime.datetime (naive), datetime.date\n432:          * top-level classes, top-level functions - will be referenced by their\n433:            full import path\n434:          * Storage instances - these have their own deconstruct() method\n435: \n436:         This is because the values here must be serialized into a text format\n437:         (possibly new Python code, possibly JSON) and these are the only types\n438:         with encoding handlers defined.\n439: \n440:         There's no need to return the exact way the field was instantiated this\n441:         time, just ensure that the resulting field is the same - prefer keyword\n442:         arguments over positional ones, and omit parameters with their default\n443:         values.\n444:         \"\"\"\n445:         # Short-form way of fetching all the default parameters\n446:         keywords = {}\n447:         possibles = {\n448:             \"verbose_name\": None,\n449:             \"primary_key\": False,\n450:             \"max_length\": None,\n451:             \"unique\": False,\n452:             \"blank\": False,\n453:             \"null\": False,\n454:             \"db_index\": False,\n455:             \"default\": NOT_PROVIDED,\n456:             \"editable\": True,\n457:             \"serialize\": True,\n458:             \"unique_for_date\": None,\n459:             \"unique_for_month\": None,\n460:             \"unique_for_year\": None,\n461:             \"choices\": None,\n462:             \"help_text\": '',\n463:             \"db_column\": None,\n464:             \"db_tablespace\": None,\n465:             \"auto_created\": False,\n466:             \"validators\": [],\n467:             \"error_messages\": None,\n468:         }\n469:         attr_overrides = {\n470:             \"unique\": \"_unique\",\n471:             \"error_messages\": \"_error_messages\",\n472:             \"validators\": \"_validators\",\n473:             \"verbose_name\": \"_verbose_name\",\n474:             \"db_tablespace\": \"_db_tablespace\",\n475:         }\n476:         equals_comparison = {\"choices\", \"validators\"}\n477:         for name, default in possibles.items():\n478:             value = getattr(self, attr_overrides.get(name, name))\n479:             # Unroll anything iterable for choices into a concrete list\n480:             if name == \"choices\" and isinstance(value, collections.abc.Iterable):\n481:                 value = list(value)\n482:             # Do correct kind of comparison\n483:             if name in equals_comparison:\n484:                 if value != default:\n485:                     keywords[name] = value\n486:             else:\n487:                 if value is not default:\n488:                     keywords[name] = value\n489:         # Work out path - we shorten it for known Django core fields\n490:         path = \"%s.%s\" % (self.__class__.__module__, self.__class__.__qualname__)\n491:         if path.startswith(\"django.db.models.fields.related\"):\n492:             path = path.replace(\"django.db.models.fields.related\", \"django.db.models\")\n493:         elif path.startswith(\"django.db.models.fields.files\"):\n494:             path = path.replace(\"django.db.models.fields.files\", \"django.db.models\")\n495:         elif path.startswith(\"django.db.models.fields.proxy\"):\n496:             path = path.replace(\"django.db.models.fields.proxy\", \"django.db.models\")\n497:         elif path.startswith(\"django.db.models.fields\"):\n498:             path = path.replace(\"django.db.models.fields\", \"django.db.models\")\n499:         # Return basic info - other fields should override this.\n500:         return (self.name, path, [], keywords)\n501: \n502:     def clone(self):\n503:         \"\"\"\n504:         Uses deconstruct() to clone a new copy of this Field.\n505:         Will not preserve any class attachments/attribute names.\n506:         \"\"\"\n507:         name, path, args, kwargs = self.deconstruct()\n508:         return self.__class__(*args, **kwargs)\n509: \n510:     def __eq__(self, other):\n511:         # Needed for @total_ordering\n512:         if isinstance(other, Field):\n513:             return self.creation_counter == other.creation_counter\n514:         return NotImplemented\n515: \n516:     def __lt__(self, other):\n517:         # This is needed because bisect does not take a comparison function.\n518:         if isinstance(other, Field):\n519:             return self.creation_counter < other.creation_counter\n520:         return NotImplemented\n521: \n522:     def __hash__(self):\n523:         return hash(self.creation_counter)\n524: \n525:     def __deepcopy__(self, memodict):\n526:         # We don't have to deepcopy very much here, since most things are not\n527:         # intended to be altered after initial creation.\n528:         obj = copy.copy(self)\n529:         if self.remote_field:\n530:             obj.remote_field = copy.copy(self.remote_field)\n531:             if hasattr(self.remote_field, 'field') and self.remote_field.field is self:\n532:                 obj.remote_field.field = obj\n533:         memodict[id(self)] = obj\n534:         return obj\n535: \n536:     def __copy__(self):\n537:         # We need to avoid hitting __reduce__, so define this\n538:         # slightly weird copy construct.\n539:         obj = Empty()\n540:         obj.__class__ = self.__class__\n541:         obj.__dict__ = self.__dict__.copy()\n542:         return obj\n543: \n544:     def __reduce__(self):\n545:         \"\"\"\n546:         Pickling should return the model._meta.fields instance of the field,\n547:         not a new copy of that field. So, use the app registry to load the\n548:         model and then the field back.\n549:         \"\"\"\n550:         if not hasattr(self, 'model'):\n551:             # Fields are sometimes used without attaching them to models (for\n552:             # example in aggregation). In this case give back a plain field\n553:             # instance. The code below will create a new empty instance of\n554:             # class self.__class__, then update its dict with self.__dict__\n555:             # values - so, this is very close to normal pickle.\n556:             state = self.__dict__.copy()\n557:             # The _get_default cached_property can't be pickled due to lambda\n558:             # usage.\n559:             state.pop('_get_default', None)\n560:             return _empty, (self.__class__,), state\n561:         return _load_field, (self.model._meta.app_label, self.model._meta.object_name,\n562:                              self.name)\n563: \n564:     def get_pk_value_on_save(self, instance):\n565:         \"\"\"\n566:         Hook to generate new PK values on save. This method is called when\n567:         saving instances with no primary key value set. If this method returns\n568:         something else than None, then the returned value is used when saving\n569:         the new instance.\n570:         \"\"\"\n571:         if self.default:\n572:             return self.get_default()\n573:         return None\n574: \n575:     def to_python(self, value):\n576:         \"\"\"\n577:         Convert the input value into the expected Python data type, raising\n578:         django.core.exceptions.ValidationError if the data can't be converted.\n579:         Return the converted value. Subclasses should override this.\n580:         \"\"\"\n581:         return value\n582: \n583:     @cached_property\n584:     def validators(self):\n585:         \"\"\"\n586:         Some validators can't be created at field initialization time.\n587:         This method provides a way to delay their creation until required.\n588:         \"\"\"\n589:         return [*self.default_validators, *self._validators]\n590: \n591:     def run_validators(self, value):\n592:         if value in self.empty_values:\n593:             return\n594: \n595:         errors = []\n596:         for v in self.validators:\n597:             try:\n598:                 v(value)\n599:             except exceptions.ValidationError as e:\n600:                 if hasattr(e, 'code') and e.code in self.error_messages:\n601:                     e.message = self.error_messages[e.code]\n602:                 errors.extend(e.error_list)\n603: \n604:         if errors:\n605:             raise exceptions.ValidationError(errors)\n606: \n607:     def validate(self, value, model_instance):\n608:         \"\"\"\n609:         Validate value and raise ValidationError if necessary. Subclasses\n610:         should override this to provide validation logic.\n611:         \"\"\"\n612:         if not self.editable:\n613:             # Skip validation for non-editable fields.\n614:             return\n615: \n616:         if self.choices is not None and value not in self.empty_values:\n617:             for option_key, option_value in self.choices:\n618:                 if isinstance(option_value, (list, tuple)):\n619:                     # This is an optgroup, so look inside the group for\n620:                     # options.\n621:                     for optgroup_key, optgroup_value in option_value:\n622:                         if value == optgroup_key:\n623:                             return\n624:                 elif value == option_key:\n625:                     return\n626:             raise exceptions.ValidationError(\n627:                 self.error_messages['invalid_choice'],\n628:                 code='invalid_choice',\n629:                 params={'value': value},\n630:             )\n631: \n632:         if value is None and not self.null:\n633:             raise exceptions.ValidationError(self.error_messages['null'], code='null')\n634: \n635:         if not self.blank and value in self.empty_values:\n636:             raise exceptions.ValidationError(self.error_messages['blank'], code='blank')\n637: \n638:     def clean(self, value, model_instance):\n639:         \"\"\"\n640:         Convert the value's type and run validation. Validation errors\n641:         from to_python() and validate() are propagated. Return the correct\n642:         value if no error is raised.\n643:         \"\"\"\n644:         value = self.to_python(value)\n645:         self.validate(value, model_instance)\n646:         self.run_validators(value)\n647:         return value\n648: \n649:     def db_type_parameters(self, connection):\n650:         return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')\n651: \n652:     def db_check(self, connection):\n653:         \"\"\"\n654:         Return the database column check constraint for this field, for the\n655:         provided connection. Works the same way as db_type() for the case that\n656:         get_internal_type() does not map to a preexisting model field.\n657:         \"\"\"\n658:         data = self.db_type_parameters(connection)\n659:         try:\n660:             return connection.data_type_check_constraints[self.get_internal_type()] % data\n661:         except KeyError:\n662:             return None\n663: \n664:     def db_type(self, connection):\n665:         \"\"\"\n666:         Return the database column data type for this field, for the provided\n667:         connection.\n668:         \"\"\"\n669:         # The default implementation of this method looks at the\n670:         # backend-specific data_types dictionary, looking up the field by its\n671:         # \"internal type\".\n672:         #\n673:         # A Field class can implement the get_internal_type() method to specify\n674:         # which *preexisting* Django Field class it's most similar to -- i.e.,\n675:         # a custom field might be represented by a TEXT column type, which is\n676:         # the same as the TextField Django field type, which means the custom\n677:         # field's get_internal_type() returns 'TextField'.\n678:         #\n679:         # But the limitation of the get_internal_type() / data_types approach\n680:         # is that it cannot handle database column types that aren't already\n681:         # mapped to one of the built-in Django field types. In this case, you\n682:         # can implement db_type() instead of get_internal_type() to specify\n683:         # exactly which wacky database column type you want to use.\n684:         data = self.db_type_parameters(connection)\n685:         try:\n686:             return connection.data_types[self.get_internal_type()] % data\n687:         except KeyError:\n688:             return None\n689: \n690:     def rel_db_type(self, connection):\n691:         \"\"\"\n692:         Return the data type that a related field pointing to this field should\n693:         use. For example, this method is called by ForeignKey and OneToOneField\n694:         to determine its data type.\n695:         \"\"\"\n696:         return self.db_type(connection)\n697: \n698:     def cast_db_type(self, connection):\n699:         \"\"\"Return the data type to use in the Cast() function.\"\"\"\n700:         db_type = connection.ops.cast_data_types.get(self.get_internal_type())\n701:         if db_type:\n702:             return db_type % self.db_type_parameters(connection)\n703:         return self.db_type(connection)\n704: \n705:     def db_parameters(self, connection):\n706:         \"\"\"\n707:         Extension of db_type(), providing a range of different return values\n708:         (type, checks). This will look at db_type(), allowing custom model\n709:         fields to override it.\n710:         \"\"\"\n711:         type_string = self.db_type(connection)\n712:         check_string = self.db_check(connection)\n713:         return {\n714:             \"type\": type_string,\n715:             \"check\": check_string,\n716:         }\n717: \n718:     def db_type_suffix(self, connection):\n719:         return connection.data_types_suffix.get(self.get_internal_type())\n720: \n721:     def get_db_converters(self, connection):\n722:         if hasattr(self, 'from_db_value'):\n723:             return [self.from_db_value]\n724:         return []\n725: \n726:     @property\n727:     def unique(self):\n728:         return self._unique or self.primary_key\n729: \n730:     @property\n731:     def db_tablespace(self):\n732:         return self._db_tablespace or settings.DEFAULT_INDEX_TABLESPACE\n733: \n734:     @property\n735:     def db_returning(self):\n736:         \"\"\"\n737:         Private API intended only to be used by Django itself. Currently only\n738:         the PostgreSQL backend supports returning multiple fields on a model.\n739:         \"\"\"\n740:         return False\n741: \n742:     def set_attributes_from_name(self, name):\n743:         self.name = self.name or name\n744:         self.attname, self.column = self.get_attname_column()\n745:         self.concrete = self.column is not None\n746:         if self.verbose_name is None and self.name:\n747:             self.verbose_name = self.name.replace('_', ' ')\n748: \n749:     def contribute_to_class(self, cls, name, private_only=False):\n750:         \"\"\"\n751:         Register the field with the model class it belongs to.\n752: \n753:         If private_only is True, create a separate instance of this field\n754:         for every subclass of cls, even if cls is not an abstract model.\n755:         \"\"\"\n756:         self.set_attributes_from_name(name)\n757:         self.model = cls\n758:         cls._meta.add_field(self, private=private_only)\n759:         if self.column:\n760:             # Don't override classmethods with the descriptor. This means that\n761:             # if you have a classmethod and a field with the same name, then\n762:             # such fields can't be deferred (we don't have a check for this).\n763:             if not getattr(cls, self.attname, None):\n764:                 setattr(cls, self.attname, self.descriptor_class(self))\n765:         if self.choices is not None:\n766:             setattr(cls, 'get_%s_display' % self.name,\n767:                     partialmethod(cls._get_FIELD_display, field=self))\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/__init__.py",
      "suspect_lines": [
        766,
        767
      ]
    }
  ]
}