{
  "instance_id": "django__django-16032",
  "problem_statement": "__in doesn't clear selected fields on the RHS when QuerySet.alias() is used after annotate().\nDescription\n\t\nHere is a test case to reproduce the bug, you can add this in tests/annotations/tests.py\n\tdef test_annotation_and_alias_filter_in_subquery(self):\n\t\tlong_books_qs = (\n\t\t\tBook.objects.filter(\n\t\t\t\tpages__gt=400,\n\t\t\t)\n\t\t\t.annotate(book_annotate=Value(1))\n\t\t\t.alias(book_alias=Value(1))\n\t\t)\n\t\tpublisher_books_qs = (\n\t\t\tPublisher.objects.filter(\n\t\t\t\tbook__in=long_books_qs\n\t\t\t)\n\t\t\t.values(\"name\")\n\t\t)\n\t\tself.assertCountEqual(\n\t\t\tpublisher_books_qs,\n\t\t\t[\n\t\t\t\t{'name': 'Apress'},\n\t\t\t\t{'name': 'Sams'},\n\t\t\t\t{'name': 'Prentice Hall'},\n\t\t\t\t{'name': 'Morgan Kaufmann'}\n\t\t\t]\n\t\t)\nYou should get this error:\ndjango.db.utils.OperationalError: sub-select returns 10 columns - expected 1\n",
  "localized_code": "[start of django/db/models/fields/related_lookups.py]\n1: import warnings\n2: \n3: from django.db.models.lookups import (\n4:     Exact,\n5:     GreaterThan,\n6:     GreaterThanOrEqual,\n7:     In,\n8:     IsNull,\n9:     LessThan,\n10:     LessThanOrEqual,\n11: )\n12: from django.utils.deprecation import RemovedInDjango50Warning\n13: \n14: \n15: class MultiColSource:\n16:     contains_aggregate = False\n17:     contains_over_clause = False\n18: \n19:     def __init__(self, alias, targets, sources, field):\n20:         self.targets, self.sources, self.field, self.alias = (\n21:             targets,\n22:             sources,\n23:             field,\n24:             alias,\n25:         )\n26:         self.output_field = self.field\n27: \n28:     def __repr__(self):\n29:         return \"{}({}, {})\".format(self.__class__.__name__, self.alias, self.field)\n30: \n31:     def relabeled_clone(self, relabels):\n32:         return self.__class__(\n33:             relabels.get(self.alias, self.alias), self.targets, self.sources, self.field\n34:         )\n35: \n36:     def get_lookup(self, lookup):\n37:         return self.output_field.get_lookup(lookup)\n38: \n39:     def resolve_expression(self, *args, **kwargs):\n40:         return self\n41: \n42: \n43: def get_normalized_value(value, lhs):\n44:     from django.db.models import Model\n45: \n46:     if isinstance(value, Model):\n47:         if value.pk is None:\n48:             # When the deprecation ends, replace with:\n49:             # raise ValueError(\n50:             #     \"Model instances passed to related filters must be saved.\"\n51:             # )\n52:             warnings.warn(\n53:                 \"Passing unsaved model instances to related filters is deprecated.\",\n54:                 RemovedInDjango50Warning,\n55:             )\n56:         value_list = []\n57:         sources = lhs.output_field.path_infos[-1].target_fields\n58:         for source in sources:\n59:             while not isinstance(value, source.model) and source.remote_field:\n60:                 source = source.remote_field.model._meta.get_field(\n61:                     source.remote_field.field_name\n62:                 )\n63:             try:\n64:                 value_list.append(getattr(value, source.attname))\n65:             except AttributeError:\n66:                 # A case like Restaurant.objects.filter(place=restaurant_instance),\n67:                 # where place is a OneToOneField and the primary key of Restaurant.\n68:                 return (value.pk,)\n69:         return tuple(value_list)\n70:     if not isinstance(value, tuple):\n71:         return (value,)\n72:     return value\n73: \n74: \n75: class RelatedIn(In):\n76:     def get_prep_lookup(self):\n77:         if not isinstance(self.lhs, MultiColSource):\n78:             if self.rhs_is_direct_value():\n79:                 # If we get here, we are dealing with single-column relations.\n80:                 self.rhs = [get_normalized_value(val, self.lhs)[0] for val in self.rhs]\n81:                 # We need to run the related field's get_prep_value(). Consider\n82:                 # case ForeignKey to IntegerField given value 'abc'. The\n83:                 # ForeignKey itself doesn't have validation for non-integers,\n84:                 # so we must run validation using the target field.\n85:                 if hasattr(self.lhs.output_field, \"path_infos\"):\n86:                     # Run the target field's get_prep_value. We can safely\n87:                     # assume there is only one as we don't get to the direct\n88:                     # value branch otherwise.\n89:                     target_field = self.lhs.output_field.path_infos[-1].target_fields[\n90:                         -1\n91:                     ]\n92:                     self.rhs = [target_field.get_prep_value(v) for v in self.rhs]\n93:             elif not getattr(self.rhs, \"has_select_fields\", True) and not getattr(\n94:                 self.lhs.field.target_field, \"primary_key\", False\n95:             ):\n96:                 self.rhs.clear_select_clause()\n97:                 if (\n98:                     getattr(self.lhs.output_field, \"primary_key\", False)\n99:                     and self.lhs.output_field.model == self.rhs.model\n100:                 ):\n101:                     # A case like\n102:                     # Restaurant.objects.filter(place__in=restaurant_qs), where\n103:                     # place is a OneToOneField and the primary key of\n104:                     # Restaurant.\n105:                     target_field = self.lhs.field.name\n106:                 else:\n107:                     target_field = self.lhs.field.target_field.name\n108:                 self.rhs.add_fields([target_field], True)\n109:         return super().get_prep_lookup()\n... Code Truncated ...\n\n[start of django/db/models/sql/query.py]\n1: \"\"\"\n2: Create SQL statements for QuerySets.\n3: \n4: The code in here encapsulates all of the SQL construction so that QuerySets\n5: themselves do not have to (and could be backed by things other than SQL\n6: databases). The abstraction barrier only works one way: this module has to know\n7: all about the internals of models in order to get the information it needs.\n8: \"\"\"\n9: import copy\n10: import difflib\n11: import functools\n12: import sys\n13: from collections import Counter, namedtuple\n14: from collections.abc import Iterator, Mapping\n15: from itertools import chain, count, product\n16: from string import ascii_uppercase\n17: \n18: from django.core.exceptions import FieldDoesNotExist, FieldError\n19: from django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\n20: from django.db.models.aggregates import Count\n21: from django.db.models.constants import LOOKUP_SEP\n22: from django.db.models.expressions import (\n23:     BaseExpression,\n24:     Col,\n25:     Exists,\n26:     F,\n27:     OuterRef,\n28:     Ref,\n29:     ResolvedOuterRef,\n30:     Value,\n31: )\n32: from django.db.models.fields import Field\n33: from django.db.models.fields.related_lookups import MultiColSource\n34: from django.db.models.lookups import Lookup\n35: from django.db.models.query_utils import (\n36:     Q,\n37:     check_rel_lookup_compatibility,\n38:     refs_expression,\n39: )\n40: from django.db.models.sql.constants import INNER, LOUTER, ORDER_DIR, SINGLE\n41: from django.db.models.sql.datastructures import BaseTable, Empty, Join, MultiJoin\n42: from django.db.models.sql.where import AND, OR, ExtraWhere, NothingNode, WhereNode\n43: from django.utils.functional import cached_property\n44: from django.utils.regex_helper import _lazy_re_compile\n45: from django.utils.tree import Node\n46: \n47: __all__ = [\"Query\", \"RawQuery\"]\n48: \n49: # Quotation marks ('\"`[]), whitespace characters, semicolons, or inline\n50: # SQL comments are forbidden in column aliases.\n51: FORBIDDEN_ALIAS_PATTERN = _lazy_re_compile(r\"['`\\\"\\]\\[;\\s]|--|/\\*|\\*/\")\n52: \n53: # Inspired from\n54: # https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS\n55: EXPLAIN_OPTIONS_PATTERN = _lazy_re_compile(r\"[\\w\\-]+\")\n56: \n57: \n58: def get_field_names_from_opts(opts):\nCode replaced for brevity.\n65: \n66: \n67: \n68: def get_children_from_q(q):\nCode replaced for brevity.\n73: \n74: \n75: \n76: JoinInfo = namedtuple(\n77:     \"JoinInfo\",\n78:     (\"final_field\", \"targets\", \"opts\", \"joins\", \"path\", \"transform_function\"),\n79: )\n80: \n81: \n82: class RawQuery:\nCode replaced for brevity.\n152: \n153: \n154: \n155: ExplainInfo = namedtuple(\"ExplainInfo\", (\"format\", \"options\"))\n156: \n157: \n158: class Query(BaseExpression):\n159:     \"\"\"A single SQL query.\"\"\"\n160: \n161:     alias_prefix = \"T\"\n162:     empty_result_set_value = None\n163:     subq_aliases = frozenset([alias_prefix])\n164: \n165:     compiler = \"SQLCompiler\"\n166: \n167:     base_table_class = BaseTable\n168:     join_class = Join\n169: \n170:     default_cols = True\n171:     default_ordering = True\n172:     standard_ordering = True\n173: \n174:     filter_is_sticky = False\n175:     subquery = False\n176: \n177:     # SQL-related attributes.\n178:     # Select and related select clauses are expressions to use in the SELECT\n179:     # clause of the query. The select is used for cases where we want to set up\n180:     # the select clause to contain other than default fields (values(),\n181:     # subqueries...). Note that annotations go to annotations dictionary.\n182:     select = ()\n183:     # The group_by attribute can have one of the following forms:\n184:     #  - None: no group by at all in the query\n185:     #  - A tuple of expressions: group by (at least) those expressions.\n186:     #    String refs are also allowed for now.\n187:     #  - True: group by all select fields of the model\n188:     # See compiler.get_group_by() for details.\n189:     group_by = None\n190:     order_by = ()\n191:     low_mark = 0  # Used for offset/limit.\n192:     high_mark = None  # Used for offset/limit.\n193:     distinct = False\n194:     distinct_fields = ()\n195:     select_for_update = False\n196:     select_for_update_nowait = False\n197:     select_for_update_skip_locked = False\n198:     select_for_update_of = ()\n199:     select_for_no_key_update = False\n200:     select_related = False\n201:     # Arbitrary limit for select_related to prevents infinite recursion.\n202:     max_depth = 5\n203:     # Holds the selects defined by a call to values() or values_list()\n204:     # excluding annotation_select and extra_select.\n205:     values_select = ()\n206: \n207:     # SQL annotation-related attributes.\n208:     annotation_select_mask = None\n209:     _annotation_select_cache = None\n210: \n211:     # Set combination attributes.\n212:     combinator = None\n213:     combinator_all = False\n214:     combined_queries = ()\n215: \n216:     # These are for extensions. The contents are more or less appended verbatim\n217:     # to the appropriate clause.\n218:     extra_select_mask = None\n219:     _extra_select_cache = None\n220: \n221:     extra_tables = ()\n222:     extra_order_by = ()\n223: \n224:     # A tuple that is a set of model field names and either True, if these are\n225:     # the fields to defer, or False if these are the only fields to load.\n226:     deferred_loading = (frozenset(), True)\n227: \n228:     explain_info = None\n229: \n230:     def __init__(self, model, alias_cols=True):\n231:         self.model = model\n232:         self.alias_refcount = {}\n233:         # alias_map is the most important data structure regarding joins.\n234:         # It's used for recording which joins exist in the query and what\n235:         # types they are. The key is the alias of the joined table (possibly\n236:         # the table name) and the value is a Join-like object (see\n237:         # sql.datastructures.Join for more information).\n238:         self.alias_map = {}\n239:         # Whether to provide alias to columns during reference resolving.\n240:         self.alias_cols = alias_cols\n241:         # Sometimes the query contains references to aliases in outer queries (as\n242:         # a result of split_exclude). Correct alias quoting needs to know these\n243:         # aliases too.\n244:         # Map external tables to whether they are aliased.\n245:         self.external_aliases = {}\n246:         self.table_map = {}  # Maps table names to list of aliases.\n247:         self.used_aliases = set()\n248: \n249:         self.where = WhereNode()\n250:         # Maps alias -> Annotation Expression.\n251:         self.annotations = {}\n252:         # These are for extensions. The contents are more or less appended\n253:         # verbatim to the appropriate clause.\n254:         self.extra = {}  # Maps col_alias -> (col_sql, params).\n255: \n256:         self._filtered_relations = {}\n257: \n258:     @property\n259:     def output_field(self):\n260:         if len(self.select) == 1:\n261:             select = self.select[0]\n262:             return getattr(select, \"target\", None) or select.field\n263:         elif len(self.annotation_select) == 1:\n264:             return next(iter(self.annotation_select.values())).output_field\n265: \n266:     @property\n267:     def has_select_fields(self):\n268:         return bool(\n269:             self.select or self.annotation_select_mask or self.extra_select_mask\n270:         )\n271: \n272:     @cached_property\n273:     def base_table(self):\n274:         for alias in self.alias_map:\n275:             return alias\n276: \n277:     def __str__(self):\n278:         \"\"\"\n279:         Return the query as a string of SQL with the parameter values\n280:         substituted in (use sql_with_params() to see the unsubstituted string).\n281: \n282:         Parameter values won't necessarily be quoted correctly, since that is\n283:         done by the database interface at execution time.\n284:         \"\"\"\n285:         sql, params = self.sql_with_params()\n286:         return sql % params\n287: \n288:     def sql_with_params(self):\n289:         \"\"\"\n290:         Return the query as an SQL string and the parameters that will be\n291:         substituted into the query.\n292:         \"\"\"\n293:         return self.get_compiler(DEFAULT_DB_ALIAS).as_sql()\n294: \n295:     def __deepcopy__(self, memo):\n296:         \"\"\"Limit the amount of work when a Query is deepcopied.\"\"\"\n297:         result = self.clone()\n298:         memo[id(self)] = result\n299:         return result\n300: \n301:     def get_compiler(self, using=None, connection=None, elide_empty=True):\n302:         if using is None and connection is None:\n303:             raise ValueError(\"Need either using or connection\")\n304:         if using:\n305:             connection = connections[using]\n306:         return connection.ops.compiler(self.compiler)(\n307:             self, connection, using, elide_empty\n308:         )\n309: \n310:     def get_meta(self):\n311:         \"\"\"\n312:         Return the Options instance (the model._meta) from which to start\n313:         processing. Normally, this is self.model._meta, but it can be changed\n314:         by subclasses.\n315:         \"\"\"\n316:         if self.model:\n317:             return self.model._meta\n318: \n319:     def clone(self):\n320:         \"\"\"\n321:         Return a copy of the current Query. A lightweight alternative to\n322:         deepcopy().\n323:         \"\"\"\n324:         obj = Empty()\n325:         obj.__class__ = self.__class__\n326:         # Copy references to everything.\n327:         obj.__dict__ = self.__dict__.copy()\n328:         # Clone attributes that can't use shallow copy.\n329:         obj.alias_refcount = self.alias_refcount.copy()\n330:         obj.alias_map = self.alias_map.copy()\n331:         obj.external_aliases = self.external_aliases.copy()\n332:         obj.table_map = self.table_map.copy()\n333:         obj.where = self.where.clone()\n334:         obj.annotations = self.annotations.copy()\n335:         if self.annotation_select_mask is not None:\n336:             obj.annotation_select_mask = self.annotation_select_mask.copy()\n337:         if self.combined_queries:\n338:             obj.combined_queries = tuple(\n339:                 [query.clone() for query in self.combined_queries]\n340:             )\n341:         # _annotation_select_cache cannot be copied, as doing so breaks the\n342:         # (necessary) state in which both annotations and\n343:         # _annotation_select_cache point to the same underlying objects.\n344:         # It will get re-populated in the cloned queryset the next time it's\n345:         # used.\n346:         obj._annotation_select_cache = None\n347:         obj.extra = self.extra.copy()\n348:         if self.extra_select_mask is not None:\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/related_lookups.py",
      "suspect_lines": [
        96,
        108
      ]
    },
    {
      "filename": "/django/db/models/sql/query.py",
      "suspect_lines": [
        266,
        267,
        268,
        269,
        270,
        271
      ]
    }
  ]
}