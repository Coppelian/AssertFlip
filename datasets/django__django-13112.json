{
  "instance_id": "django__django-13112",
  "problem_statement": "makemigrations crashes for ForeignKey with mixed-case app name.\nDescription\n\t\nWhen i run \"python3 manage.py migrate\" on Django 3.1b1 shows me that error (Please, note that the code works well in 3.0)\nValueError: The field DJ_RegLogin.Content.category was declared with a lazy reference to 'dj_reglogin.category', but app 'dj_reglogin' isn't installed.\nmodel.py (Conflict Part)\nclass Category(models.Model):\n\ttitle = models.CharField(max_length=100, db_index=True)\n\tslug = models.SlugField(max_length=100, db_index=True)\n\tclass Meta:\n\t\tverbose_name = 'Category'\n\t\tverbose_name_plural = 'Categories'\n\tdef __str__(self):\n\t\treturn self.title\n\tdef get_absolute_url(self):\n\t\treturn reverse('view_blog_category', None, kwargs={'slug': self.slug})\nclass Content(models.Model):\n\ttitle = models.CharField(max_length=100, unique=True)\n\tslug = models.SlugField(max_length=100, unique=True)\n\tbody = RichTextField(config_name='default')\n\tposted = models.DateTimeField(db_index=True, auto_now_add=True)\n\tsites = models.ManyToManyField(Site)\n\tip = models.GenericIPAddressField(editable=False)\n\tcategory = models.ForeignKey(Category, on_delete=models.CASCADE)\n\tuser = models.ForeignKey(User, on_delete=models.CASCADE, null=False, blank=False, editable=False)\n\tstatus = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft')\n\tdef __str__(self):\n\t\treturn self.title\n\tdef get_absolute_url(self):\n\t\treturn reverse('view_blog_post', None, kwargs={'slug': self.slug})\nsettings.py (Related to issue part)\nINSTALLED_APPS = [\n\t'DJ_RegLogin',\n\t'django.contrib.admin',\n\t'django.contrib.auth',\n\t'django.contrib.contenttypes',\n\t'django.contrib.sessions',\n\t'django.contrib.messages',\n\t'django.contrib.staticfiles',\n\t'social_django',\n\t'ckeditor',\n\t'django.contrib.sites',\n\t'django.contrib.flatpages',\n\t'django.contrib.sitemaps',\n]\napps.py\nfrom django.apps import AppConfig\nclass DJ_RegLoginConfig(AppConfig):\n\tname = 'DJ_RegLogin'\n\tverbose_name = \"Contents\"\n",
  "localized_code": "[start of django/db/models/fields/related.py]\n1: import functools\n2: import inspect\n3: from functools import partial\n4: \n5: from django import forms\n6: from django.apps import apps\n7: from django.conf import SettingsReference, settings\n8: from django.core import checks, exceptions\n9: from django.db import connection, router\n10: from django.db.backends import utils\n11: from django.db.models import Q\n12: from django.db.models.constants import LOOKUP_SEP\n13: from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14: from django.db.models.query_utils import PathInfo\n15: from django.db.models.utils import make_model_tuple\n16: from django.utils.functional import cached_property\n17: from django.utils.translation import gettext_lazy as _\n18: \n19: from . import Field\n20: from .mixins import FieldCacheMixin\n21: from .related_descriptors import (\n22:     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,\n23:     ForwardOneToOneDescriptor, ManyToManyDescriptor,\n24:     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,\n25: )\n26: from .related_lookups import (\n27:     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,\n28:     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,\n29: )\n30: from .reverse_related import (\n31:     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,\n32: )\n33: \n34: RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n35: \n36: \n37: def resolve_relation(scope_model, relation):\n38:     \"\"\"\n39:     Transform relation into a model or fully-qualified model string of the form\n40:     \"app_label.ModelName\", relative to scope_model.\n41: \n42:     The relation argument can be:\n43:       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n44:         the model argument will be returned.\n45:       * A bare model name without an app_label, in which case scope_model's\n46:         app_label will be prepended.\n47:       * An \"app_label.ModelName\" string.\n48:       * A model class, which will be returned unchanged.\n49:     \"\"\"\n50:     # Check for recursive relations\n51:     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n52:         relation = scope_model\n53: \n54:     # Look for an \"app.Model\" relation\n55:     if isinstance(relation, str):\n56:         if \".\" not in relation:\n57:             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n58: \n59:     return relation\n60: \n61: \n62: def lazy_related_operation(function, model, *related_models, **kwargs):\nCode replaced for brevity.\n80: \n81: \n82: \n83: class RelatedField(FieldCacheMixin, Field):\nCode replaced for brevity.\n441: \n442: \n443: \n444: class ForeignObject(RelatedField):\n445:     \"\"\"\n446:     Abstraction of the ForeignKey relation to support multi-column relations.\n447:     \"\"\"\n448: \n449:     # Field flags\n450:     many_to_many = False\n451:     many_to_one = True\n452:     one_to_many = False\n453:     one_to_one = False\n454: \n455:     requires_unique_target = True\n456:     related_accessor_class = ReverseManyToOneDescriptor\n457:     forward_related_accessor_class = ForwardManyToOneDescriptor\n458:     rel_class = ForeignObjectRel\n459: \n460:     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,\n461:                  related_query_name=None, limit_choices_to=None, parent_link=False,\n462:                  swappable=True, **kwargs):\n463: \n464:         if rel is None:\n465:             rel = self.rel_class(\n466:                 self, to,\n467:                 related_name=related_name,\n468:                 related_query_name=related_query_name,\n469:                 limit_choices_to=limit_choices_to,\n470:                 parent_link=parent_link,\n471:                 on_delete=on_delete,\n472:             )\n473: \n474:         super().__init__(rel=rel, **kwargs)\n475: \n476:         self.from_fields = from_fields\n477:         self.to_fields = to_fields\n478:         self.swappable = swappable\n479: \n480:     def check(self, **kwargs):\n481:         return [\n482:             *super().check(**kwargs),\n483:             *self._check_to_fields_exist(),\n484:             *self._check_unique_target(),\n485:         ]\n486: \n487:     def _check_to_fields_exist(self):\n488:         # Skip nonexistent models.\n489:         if isinstance(self.remote_field.model, str):\n490:             return []\n491: \n492:         errors = []\n493:         for to_field in self.to_fields:\n494:             if to_field:\n495:                 try:\n496:                     self.remote_field.model._meta.get_field(to_field)\n497:                 except exceptions.FieldDoesNotExist:\n498:                     errors.append(\n499:                         checks.Error(\n500:                             \"The to_field '%s' doesn't exist on the related \"\n501:                             \"model '%s'.\"\n502:                             % (to_field, self.remote_field.model._meta.label),\n503:                             obj=self,\n504:                             id='fields.E312',\n505:                         )\n506:                     )\n507:         return errors\n508: \n509:     def _check_unique_target(self):\n510:         rel_is_string = isinstance(self.remote_field.model, str)\n511:         if rel_is_string or not self.requires_unique_target:\n512:             return []\n513: \n514:         try:\n515:             self.foreign_related_fields\n516:         except exceptions.FieldDoesNotExist:\n517:             return []\n518: \n519:         if not self.foreign_related_fields:\n520:             return []\n521: \n522:         unique_foreign_fields = {\n523:             frozenset([f.name])\n524:             for f in self.remote_field.model._meta.get_fields()\n525:             if getattr(f, 'unique', False)\n526:         }\n527:         unique_foreign_fields.update({\n528:             frozenset(ut)\n529:             for ut in self.remote_field.model._meta.unique_together\n530:         })\n531:         unique_foreign_fields.update({\n532:             frozenset(uc.fields)\n533:             for uc in self.remote_field.model._meta.total_unique_constraints\n534:         })\n535:         foreign_fields = {f.name for f in self.foreign_related_fields}\n536:         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n537: \n538:         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n539:             field_combination = ', '.join(\n540:                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n541:             )\n542:             model_name = self.remote_field.model.__name__\n543:             return [\n544:                 checks.Error(\n545:                     \"No subset of the fields %s on model '%s' is unique.\"\n546:                     % (field_combination, model_name),\n547:                     hint=(\n548:                         'Mark a single field as unique=True or add a set of '\n549:                         'fields to a unique constraint (via unique_together '\n550:                         'or a UniqueConstraint (without condition) in the '\n551:                         'model Meta.constraints).'\n552:                     ),\n553:                     obj=self,\n554:                     id='fields.E310',\n555:                 )\n556:             ]\n557:         elif not has_unique_constraint:\n558:             field_name = self.foreign_related_fields[0].name\n559:             model_name = self.remote_field.model.__name__\n560:             return [\n561:                 checks.Error(\n562:                     \"'%s.%s' must be unique because it is referenced by \"\n563:                     \"a foreign key.\" % (model_name, field_name),\n564:                     hint=(\n565:                         'Add unique=True to this field or add a '\n566:                         'UniqueConstraint (without condition) in the model '\n567:                         'Meta.constraints.'\n568:                     ),\n569:                     obj=self,\n570:                     id='fields.E311',\n571:                 )\n572:             ]\n573:         else:\n574:             return []\n575: \n576:     def deconstruct(self):\n577:         name, path, args, kwargs = super().deconstruct()\n578:         kwargs['on_delete'] = self.remote_field.on_delete\n579:         kwargs['from_fields'] = self.from_fields\n580:         kwargs['to_fields'] = self.to_fields\n581: \n582:         if self.remote_field.parent_link:\n583:             kwargs['parent_link'] = self.remote_field.parent_link\n584:         if isinstance(self.remote_field.model, str):\n585:             kwargs['to'] = self.remote_field.model.lower()\n586:         else:\n587:             kwargs['to'] = self.remote_field.model._meta.label_lower\n588:         # If swappable is True, then see if we're actually pointing to the target\n589:         # of a swap.\n590:         swappable_setting = self.swappable_setting\n591:         if swappable_setting is not None:\n592:             # If it's already a settings reference, error\n593:             if hasattr(kwargs['to'], \"setting_name\"):\n594:                 if kwargs['to'].setting_name != swappable_setting:\n595:                     raise ValueError(\n596:                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n597:                         \"that is swapped in place of more than one model (%s and %s)\"\n598:                         % (kwargs['to'].setting_name, swappable_setting)\n599:                     )\n600:             # Set it\n601:             kwargs['to'] = SettingsReference(\n602:                 kwargs['to'],\n603:                 swappable_setting,\n604:             )\n605:         return name, path, args, kwargs\n606: \n607:     def resolve_related_fields(self):\n608:         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n609:             raise ValueError('Foreign Object from and to fields must be the same non-zero length')\n610:         if isinstance(self.remote_field.model, str):\n611:             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)\n612:         related_fields = []\n613:         for index in range(len(self.from_fields)):\n614:             from_field_name = self.from_fields[index]\n615:             to_field_name = self.to_fields[index]\n616:             from_field = (\n617:                 self\n618:                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n619:                 else self.opts.get_field(from_field_name)\n620:             )\n621:             to_field = (self.remote_field.model._meta.pk if to_field_name is None\n622:                         else self.remote_field.model._meta.get_field(to_field_name))\n623:             related_fields.append((from_field, to_field))\n624:         return related_fields\n625: \n626:     @cached_property\n627:     def related_fields(self):\n628:         return self.resolve_related_fields()\n629: \n630:     @cached_property\n631:     def reverse_related_fields(self):\n632:         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n633: \n634:     @cached_property\n635:     def local_related_fields(self):\n636:         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n637: \n638:     @cached_property\n639:     def foreign_related_fields(self):\n640:         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n641: \n642:     def get_local_related_value(self, instance):\n643:         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n644: \n645:     def get_foreign_related_value(self, instance):\n646:         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n647: \n648:     @staticmethod\n649:     def get_instance_value_for_fields(instance, fields):\n650:         ret = []\n651:         opts = instance._meta\n652:         for field in fields:\n653:             # Gotcha: in some cases (like fixture loading) a model can have\n654:             # different values in parent_ptr_id and parent's id. So, use\n655:             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n656:             if field.primary_key:\n657:                 possible_parent_link = opts.get_ancestor_link(field.model)\n658:                 if (not possible_parent_link or\n659:                         possible_parent_link.primary_key or\n660:                         possible_parent_link.model._meta.abstract):\n661:                     ret.append(instance.pk)\n662:                     continue\n663:             ret.append(getattr(instance, field.attname))\n664:         return tuple(ret)\n665: \n666:     def get_attname_column(self):\n667:         attname, column = super().get_attname_column()\n668:         return attname, None\n669: \n670:     def get_joining_columns(self, reverse_join=False):\n671:         source = self.reverse_related_fields if reverse_join else self.related_fields\n672:         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)\n673: \n674:     def get_reverse_joining_columns(self):\n675:         return self.get_joining_columns(reverse_join=True)\n676: \n677:     def get_extra_descriptor_filter(self, instance):\n678:         \"\"\"\n679:         Return an extra filter condition for related object fetching when\n680:         user does 'instance.fieldname', that is the extra filter is used in\n681:         the descriptor of the field.\n682: \n683:         The filter should be either a dict usable in .filter(**kwargs) call or\n684:         a Q-object. The condition will be ANDed together with the relation's\n685:         joining columns.\n686: \n687:         A parallel method is get_extra_restriction() which is used in\n688:         JOIN and subquery conditions.\n689:         \"\"\"\n690:         return {}\n691: \n692:     def get_extra_restriction(self, where_class, alias, related_alias):\n693:         \"\"\"\n694:         Return a pair condition used for joining and subquery pushdown. The\n695:         condition is something that responds to as_sql(compiler, connection)\n696:         method.\n697: \n698:         Note that currently referring both the 'alias' and 'related_alias'\n699:         will not work in some conditions, like subquery pushdown.\n700: \n701:         A parallel method is get_extra_descriptor_filter() which is used in\n702:         instance.fieldname related object fetching.\n703:         \"\"\"\n704:         return None\n705: \n706:     def get_path_info(self, filtered_relation=None):\n707:         \"\"\"Get path from this field to the related model.\"\"\"\n708:         opts = self.remote_field.model._meta\n709:         from_opts = self.model._meta\n710:         return [PathInfo(\n711:             from_opts=from_opts,\n712:             to_opts=opts,\n713:             target_fields=self.foreign_related_fields,\n714:             join_field=self,\n715:             m2m=False,\n716:             direct=True,\n717:             filtered_relation=filtered_relation,\n718:         )]\n719: \n720:     def get_reverse_path_info(self, filtered_relation=None):\n721:         \"\"\"Get path from the related model to this field's model.\"\"\"\n722:         opts = self.model._meta\n723:         from_opts = self.remote_field.model._meta\n724:         return [PathInfo(\n725:             from_opts=from_opts,\n726:             to_opts=opts,\n727:             target_fields=(opts.pk,),\n728:             join_field=self.remote_field,\n729:             m2m=not self.unique,\n730:             direct=False,\n731:             filtered_relation=filtered_relation,\n732:         )]\n733: \n734:     @classmethod\n735:     @functools.lru_cache(maxsize=None)\n736:     def get_lookups(cls):\n737:         bases = inspect.getmro(cls)\n738:         bases = bases[:bases.index(ForeignObject) + 1]\n739:         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]\n740:         return cls.merge_dicts(class_lookups)\n741: \n742:     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n743:         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n744:         setattr(cls, self.name, self.forward_related_accessor_class(self))\n745: \n746:     def contribute_to_related_class(self, cls, related):\n747:         # Internal FK's - i.e., those with a related name ending with '+' -\n748:         # and swapped models don't get a related descriptor.\n749:         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n750:             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))\n751:             # While 'limit_choices_to' might be a callable, simply pass\n752:             # it along for later - this is too early because it's still\n753:             # model load time.\n754:             if self.remote_field.limit_choices_to:\n755:                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)\n756: \n757: \n758: ForeignObject.register_lookup(RelatedIn)\n759: ForeignObject.register_lookup(RelatedExact)\n760: ForeignObject.register_lookup(RelatedLessThan)\n761: ForeignObject.register_lookup(RelatedGreaterThan)\n762: ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n763: ForeignObject.register_lookup(RelatedLessThanOrEqual)\n764: ForeignObject.register_lookup(RelatedIsNull)\n765: \n766: \n767: class ForeignKey(ForeignObject):\nCode replaced for brevity.\n1020: \n1021: \n1022: \n1023: class OneToOneField(ForeignKey):\nCode replaced for brevity.\n1070: \n1071: \n1072: \n1073: def create_many_to_many_intermediary_model(field, klass):\nCode replaced for brevity.\n1117: \n1118: \n1119: \n1120: class ManyToManyField(RelatedField):\nCode replaced for brevity.\n1692: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/related.py",
      "suspect_lines": [
        585
      ]
    }
  ]
}