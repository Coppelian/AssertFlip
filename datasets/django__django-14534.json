{
  "instance_id": "django__django-14534",
  "problem_statement": "BoundWidget.id_for_label ignores id set by ChoiceWidget.options\nDescription\n\t\nIf you look at the implementation of BoundField.subwidgets\nclass BoundField:\n\t...\n\tdef subwidgets(self):\n\t\tid_ = self.field.widget.attrs.get('id') or self.auto_id\n\t\tattrs = {'id': id_} if id_ else {}\n\t\tattrs = self.build_widget_attrs(attrs)\n\t\treturn [\n\t\t\tBoundWidget(self.field.widget, widget, self.form.renderer)\n\t\t\tfor widget in self.field.widget.subwidgets(self.html_name, self.value(), attrs=attrs)\n\t\t]\none sees that self.field.widget.subwidgets(self.html_name, self.value(), attrs=attrs) returns a dict and assigns it to widget. Now widget['attrs']['id'] contains the \"id\" we would like to use when rendering the label of our CheckboxSelectMultiple.\nHowever BoundWidget.id_for_label() is implemented as\nclass BoundWidget:\n\t...\n\tdef id_for_label(self):\n\t\treturn 'id_%s_%s' % (self.data['name'], self.data['index'])\nignoring the id available through self.data['attrs']['id']. This re-implementation for rendering the \"id\" is confusing and presumably not intended. Nobody has probably realized that so far, because rarely the auto_id-argument is overridden when initializing a form. If however we do, one would assume that the method BoundWidget.id_for_label renders that string as specified through the auto_id format-string.\nBy changing the code from above to\nclass BoundWidget:\n\t...\n\tdef id_for_label(self):\n\t\treturn self.data['attrs']['id']\nthat function behaves as expected.\nPlease note that this error only occurs when rendering the subwidgets of a widget of type CheckboxSelectMultiple. This has nothing to do with the method BoundField.id_for_label().\n",
  "localized_code": "[start of django/forms/boundfield.py]\n1: import re\n2: \n3: from django.core.exceptions import ValidationError\n4: from django.forms.utils import flatatt, pretty_name\n5: from django.forms.widgets import Textarea, TextInput\n6: from django.utils.functional import cached_property\n7: from django.utils.html import conditional_escape, format_html, html_safe\n8: from django.utils.safestring import mark_safe\n9: from django.utils.translation import gettext_lazy as _\n10: \n11: __all__ = ('BoundField',)\n12: \n13: \n14: @html_safe\n15: class BoundField:\n16:     \"A Field plus data\"\n17:     def __init__(self, form, field, name):\n18:         self.form = form\n19:         self.field = field\n20:         self.name = name\n21:         self.html_name = form.add_prefix(name)\n22:         self.html_initial_name = form.add_initial_prefix(name)\n23:         self.html_initial_id = form.add_initial_prefix(self.auto_id)\n24:         if self.field.label is None:\n25:             self.label = pretty_name(name)\n26:         else:\n27:             self.label = self.field.label\n28:         self.help_text = field.help_text or ''\n29: \n30:     def __str__(self):\n31:         \"\"\"Render this field as an HTML widget.\"\"\"\n32:         if self.field.show_hidden_initial:\n33:             return self.as_widget() + self.as_hidden(only_initial=True)\n34:         return self.as_widget()\n35: \n36:     @cached_property\n37:     def subwidgets(self):\n38:         \"\"\"\n39:         Most widgets yield a single subwidget, but others like RadioSelect and\n40:         CheckboxSelectMultiple produce one subwidget for each choice.\n41: \n42:         This property is cached so that only one database query occurs when\n43:         rendering ModelChoiceFields.\n44:         \"\"\"\n45:         id_ = self.field.widget.attrs.get('id') or self.auto_id\n46:         attrs = {'id': id_} if id_ else {}\n47:         attrs = self.build_widget_attrs(attrs)\n48:         return [\n49:             BoundWidget(self.field.widget, widget, self.form.renderer)\n50:             for widget in self.field.widget.subwidgets(self.html_name, self.value(), attrs=attrs)\n51:         ]\n52: \n53:     def __bool__(self):\n54:         # BoundField evaluates to True even if it doesn't have subwidgets.\n55:         return True\n56: \n57:     def __iter__(self):\n58:         return iter(self.subwidgets)\n59: \n60:     def __len__(self):\n61:         return len(self.subwidgets)\n62: \n63:     def __getitem__(self, idx):\n64:         # Prevent unnecessary reevaluation when accessing BoundField's attrs\n65:         # from templates.\n66:         if not isinstance(idx, (int, slice)):\n67:             raise TypeError(\n68:                 'BoundField indices must be integers or slices, not %s.'\n69:                 % type(idx).__name__\n70:             )\n71:         return self.subwidgets[idx]\n72: \n73:     @property\n74:     def errors(self):\n75:         \"\"\"\n76:         Return an ErrorList (empty if there are no errors) for this field.\n77:         \"\"\"\n78:         return self.form.errors.get(self.name, self.form.error_class())\n79: \n80:     def as_widget(self, widget=None, attrs=None, only_initial=False):\n81:         \"\"\"\n82:         Render the field by rendering the passed widget, adding any HTML\n83:         attributes passed as attrs. If a widget isn't specified, use the\n84:         field's default widget.\n85:         \"\"\"\n86:         widget = widget or self.field.widget\n87:         if self.field.localize:\n88:             widget.is_localized = True\n89:         attrs = attrs or {}\n90:         attrs = self.build_widget_attrs(attrs, widget)\n91:         if self.auto_id and 'id' not in widget.attrs:\n92:             attrs.setdefault('id', self.html_initial_id if only_initial else self.auto_id)\n93:         return widget.render(\n94:             name=self.html_initial_name if only_initial else self.html_name,\n95:             value=self.value(),\n96:             attrs=attrs,\n97:             renderer=self.form.renderer,\n98:         )\n99: \n100:     def as_text(self, attrs=None, **kwargs):\n101:         \"\"\"\n102:         Return a string of HTML for representing this as an <input type=\"text\">.\n103:         \"\"\"\n104:         return self.as_widget(TextInput(), attrs, **kwargs)\n105: \n106:     def as_textarea(self, attrs=None, **kwargs):\n107:         \"\"\"Return a string of HTML for representing this as a <textarea>.\"\"\"\n108:         return self.as_widget(Textarea(), attrs, **kwargs)\n109: \n110:     def as_hidden(self, attrs=None, **kwargs):\n111:         \"\"\"\n112:         Return a string of HTML for representing this as an <input type=\"hidden\">.\n113:         \"\"\"\n114:         return self.as_widget(self.field.hidden_widget(), attrs, **kwargs)\n115: \n116:     @property\n117:     def data(self):\n118:         \"\"\"\n119:         Return the data for this BoundField, or None if it wasn't given.\n120:         \"\"\"\n121:         return self.form._widget_data_value(self.field.widget, self.html_name)\n122: \n123:     def value(self):\n124:         \"\"\"\n125:         Return the value for this BoundField, using the initial value if\n126:         the form is not bound or the data otherwise.\n127:         \"\"\"\n128:         data = self.initial\n129:         if self.form.is_bound:\n130:             data = self.field.bound_data(self.data, data)\n131:         return self.field.prepare_value(data)\n132: \n133:     def _has_changed(self):\n134:         field = self.field\n135:         if field.show_hidden_initial:\n136:             hidden_widget = field.hidden_widget()\n137:             initial_value = self.form._widget_data_value(\n138:                 hidden_widget, self.html_initial_name,\n139:             )\n140:             try:\n141:                 initial_value = field.to_python(initial_value)\n142:             except ValidationError:\n143:                 # Always assume data has changed if validation fails.\n144:                 return True\n145:         else:\n146:             initial_value = self.initial\n147:         return field.has_changed(initial_value, self.data)\n148: \n149:     def label_tag(self, contents=None, attrs=None, label_suffix=None):\n150:         \"\"\"\n151:         Wrap the given contents in a <label>, if the field has an ID attribute.\n152:         contents should be mark_safe'd to avoid HTML escaping. If contents\n153:         aren't given, use the field's HTML-escaped label.\n154: \n155:         If attrs are given, use them as HTML attributes on the <label> tag.\n156: \n157:         label_suffix overrides the form's label_suffix.\n158:         \"\"\"\n159:         contents = contents or self.label\n160:         if label_suffix is None:\n161:             label_suffix = (self.field.label_suffix if self.field.label_suffix is not None\n162:                             else self.form.label_suffix)\n163:         # Only add the suffix if the label does not end in punctuation.\n164:         # Translators: If found as last label character, these punctuation\n165:         # characters will prevent the default label_suffix to be appended to the label\n166:         if label_suffix and contents and contents[-1] not in _(':?.!'):\n167:             contents = format_html('{}{}', contents, label_suffix)\n168:         widget = self.field.widget\n169:         id_ = widget.attrs.get('id') or self.auto_id\n170:         if id_:\n171:             id_for_label = widget.id_for_label(id_)\n172:             if id_for_label:\n173:                 attrs = {**(attrs or {}), 'for': id_for_label}\n174:             if self.field.required and hasattr(self.form, 'required_css_class'):\n175:                 attrs = attrs or {}\n176:                 if 'class' in attrs:\n177:                     attrs['class'] += ' ' + self.form.required_css_class\n178:                 else:\n179:                     attrs['class'] = self.form.required_css_class\n180:             attrs = flatatt(attrs) if attrs else ''\n181:             contents = format_html('<label{}>{}</label>', attrs, contents)\n182:         else:\n183:             contents = conditional_escape(contents)\n184:         return mark_safe(contents)\n185: \n186:     def css_classes(self, extra_classes=None):\n187:         \"\"\"\n188:         Return a string of space-separated CSS classes for this field.\n189:         \"\"\"\n190:         if hasattr(extra_classes, 'split'):\n191:             extra_classes = extra_classes.split()\n192:         extra_classes = set(extra_classes or [])\n193:         if self.errors and hasattr(self.form, 'error_css_class'):\n194:             extra_classes.add(self.form.error_css_class)\n195:         if self.field.required and hasattr(self.form, 'required_css_class'):\n196:             extra_classes.add(self.form.required_css_class)\n197:         return ' '.join(extra_classes)\n198: \n199:     @property\n200:     def is_hidden(self):\n201:         \"\"\"Return True if this BoundField's widget is hidden.\"\"\"\n202:         return self.field.widget.is_hidden\n203: \n204:     @property\n205:     def auto_id(self):\n206:         \"\"\"\n207:         Calculate and return the ID attribute for this BoundField, if the\n208:         associated Form has specified auto_id. Return an empty string otherwise.\n209:         \"\"\"\n210:         auto_id = self.form.auto_id  # Boolean or string\n211:         if auto_id and '%s' in str(auto_id):\n212:             return auto_id % self.html_name\n213:         elif auto_id:\n214:             return self.html_name\n215:         return ''\n216: \n217:     @property\n218:     def id_for_label(self):\n219:         \"\"\"\n220:         Wrapper around the field widget's `id_for_label` method.\n221:         Useful, for example, for focusing on this field regardless of whether\n222:         it has a single widget or a MultiWidget.\n223:         \"\"\"\n224:         widget = self.field.widget\n225:         id_ = widget.attrs.get('id') or self.auto_id\n226:         return widget.id_for_label(id_)\n227: \n228:     @cached_property\n229:     def initial(self):\n230:         return self.form.get_initial_for_field(self.field, self.name)\n231: \n232:     def build_widget_attrs(self, attrs, widget=None):\n233:         widget = widget or self.field.widget\n234:         attrs = dict(attrs)  # Copy attrs to avoid modifying the argument.\n235:         if widget.use_required_attribute(self.initial) and self.field.required and self.form.use_required_attribute:\n236:             attrs['required'] = True\n237:         if self.field.disabled:\n238:             attrs['disabled'] = True\n239:         return attrs\n240: \n241:     @property\n242:     def widget_type(self):\n243:         return re.sub(r'widget$|input$', '', self.field.widget.__class__.__name__.lower())\n244: \n245: \n246: @html_safe\n247: class BoundWidget:\n248:     \"\"\"\n249:     A container class used for iterating over widgets. This is useful for\n250:     widgets that have choices. For example, the following can be used in a\n251:     template:\n252: \n253:     {% for radio in myform.beatles %}\n254:       <label for=\"{{ radio.id_for_label }}\">\n255:         {{ radio.choice_label }}\n256:         <span class=\"radio\">{{ radio.tag }}</span>\n257:       </label>\n258:     {% endfor %}\n259:     \"\"\"\n260:     def __init__(self, parent_widget, data, renderer):\n261:         self.parent_widget = parent_widget\n262:         self.data = data\n263:         self.renderer = renderer\n264: \n265:     def __str__(self):\n266:         return self.tag(wrap_label=True)\n267: \n268:     def tag(self, wrap_label=False):\n269:         context = {'widget': {**self.data, 'wrap_label': wrap_label}}\n270:         return self.parent_widget._render(self.template_name, context, self.renderer)\n271: \n272:     @property\n273:     def template_name(self):\n274:         if 'template_name' in self.data:\n275:             return self.data['template_name']\n276:         return self.parent_widget.template_name\n277: \n278:     @property\n279:     def id_for_label(self):\n280:         return 'id_%s_%s' % (self.data['name'], self.data['index'])\n281: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/forms/boundfield.py",
      "suspect_lines": [
        280
      ]
    }
  ]
}