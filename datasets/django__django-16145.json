{
  "instance_id": "django__django-16145",
  "problem_statement": "`runserver 0`'s \"Starting development server at <address>\" doesn't work\nDescription\n\t\nAccording to ​tutorial running \npython manage.py runserver 0:8000\nis the same as \npython manage.py runserver 0.0.0.0:8000\nbut it's output \n$ python manage.py runserver 0:8000\t\t\t\t\t\t\t\t\t Watching for file changes with StatReloader\t\t\t\t\t\t \n...\nStarting development server at http://0:8000/ \n...\nSo that you can't use link \"​http://0:8000/\" in your browser. Output should be \"Starting development server at ​http://0.0.0.0:8000/\" when providing \"0:8000\" in command line in order to stay consistent with docs.\n",
  "localized_code": "[start of django/core/management/commands/runserver.py]\n1: import errno\n2: import os\n3: import re\n4: import socket\n5: import sys\n6: from datetime import datetime\n7: \n8: from django.conf import settings\n9: from django.core.management.base import BaseCommand, CommandError\n10: from django.core.servers.basehttp import WSGIServer, get_internal_wsgi_application, run\n11: from django.utils import autoreload\n12: from django.utils.regex_helper import _lazy_re_compile\n13: \n14: naiveip_re = _lazy_re_compile(\n15:     r\"\"\"^(?:\n16: (?P<addr>\n17:     (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |         # IPv4 address\n18:     (?P<ipv6>\\[[a-fA-F0-9:]+\\]) |               # IPv6 address\n19:     (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) # FQDN\n20: ):)?(?P<port>\\d+)$\"\"\",\n21:     re.X,\n22: )\n23: \n24: \n25: class Command(BaseCommand):\n26:     help = \"Starts a lightweight web server for development.\"\n27: \n28:     # Validation is called explicitly each time the server is reloaded.\n29:     requires_system_checks = []\n30:     stealth_options = (\"shutdown_message\",)\n31:     suppressed_base_arguments = {\"--verbosity\", \"--traceback\"}\n32: \n33:     default_addr = \"127.0.0.1\"\n34:     default_addr_ipv6 = \"::1\"\n35:     default_port = \"8000\"\n36:     protocol = \"http\"\n37:     server_cls = WSGIServer\n38: \n39:     def add_arguments(self, parser):\n40:         parser.add_argument(\n41:             \"addrport\", nargs=\"?\", help=\"Optional port number, or ipaddr:port\"\n42:         )\n43:         parser.add_argument(\n44:             \"--ipv6\",\n45:             \"-6\",\n46:             action=\"store_true\",\n47:             dest=\"use_ipv6\",\n48:             help=\"Tells Django to use an IPv6 address.\",\n49:         )\n50:         parser.add_argument(\n51:             \"--nothreading\",\n52:             action=\"store_false\",\n53:             dest=\"use_threading\",\n54:             help=\"Tells Django to NOT use threading.\",\n55:         )\n56:         parser.add_argument(\n57:             \"--noreload\",\n58:             action=\"store_false\",\n59:             dest=\"use_reloader\",\n60:             help=\"Tells Django to NOT use the auto-reloader.\",\n61:         )\n62:         parser.add_argument(\n63:             \"--skip-checks\",\n64:             action=\"store_true\",\n65:             help=\"Skip system checks.\",\n66:         )\n67: \n68:     def execute(self, *args, **options):\n69:         if options[\"no_color\"]:\n70:             # We rely on the environment because it's currently the only\n71:             # way to reach WSGIRequestHandler. This seems an acceptable\n72:             # compromise considering `runserver` runs indefinitely.\n73:             os.environ[\"DJANGO_COLORS\"] = \"nocolor\"\n74:         super().execute(*args, **options)\n75: \n76:     def get_handler(self, *args, **options):\n77:         \"\"\"Return the default WSGI handler for the runner.\"\"\"\n78:         return get_internal_wsgi_application()\n79: \n80:     def handle(self, *args, **options):\n81:         if not settings.DEBUG and not settings.ALLOWED_HOSTS:\n82:             raise CommandError(\"You must set settings.ALLOWED_HOSTS if DEBUG is False.\")\n83: \n84:         self.use_ipv6 = options[\"use_ipv6\"]\n85:         if self.use_ipv6 and not socket.has_ipv6:\n86:             raise CommandError(\"Your Python does not support IPv6.\")\n87:         self._raw_ipv6 = False\n88:         if not options[\"addrport\"]:\n89:             self.addr = \"\"\n90:             self.port = self.default_port\n91:         else:\n92:             m = re.match(naiveip_re, options[\"addrport\"])\n93:             if m is None:\n94:                 raise CommandError(\n95:                     '\"%s\" is not a valid port number '\n96:                     \"or address:port pair.\" % options[\"addrport\"]\n97:                 )\n98:             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()\n99:             if not self.port.isdigit():\n100:                 raise CommandError(\"%r is not a valid port number.\" % self.port)\n101:             if self.addr:\n102:                 if _ipv6:\n103:                     self.addr = self.addr[1:-1]\n104:                     self.use_ipv6 = True\n105:                     self._raw_ipv6 = True\n106:                 elif self.use_ipv6 and not _fqdn:\n107:                     raise CommandError('\"%s\" is not a valid IPv6 address.' % self.addr)\n108:         if not self.addr:\n109:             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr\n110:             self._raw_ipv6 = self.use_ipv6\n111:         self.run(**options)\n112: \n113:     def run(self, **options):\n114:         \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n115:         use_reloader = options[\"use_reloader\"]\n116: \n117:         if use_reloader:\n118:             autoreload.run_with_reloader(self.inner_run, **options)\n119:         else:\n120:             self.inner_run(None, **options)\n121: \n122:     def inner_run(self, *args, **options):\n123:         # If an exception was silenced in ManagementUtility.execute in order\n124:         # to be raised in the child process, raise it now.\n125:         autoreload.raise_last_exception()\n126: \n127:         threading = options[\"use_threading\"]\n128:         # 'shutdown_message' is a stealth option.\n129:         shutdown_message = options.get(\"shutdown_message\", \"\")\n130:         quit_command = \"CTRL-BREAK\" if sys.platform == \"win32\" else \"CONTROL-C\"\n131: \n132:         if not options[\"skip_checks\"]:\n133:             self.stdout.write(\"Performing system checks...\\n\\n\")\n134:             self.check(display_num_errors=True)\n135:         # Need to check migrations here, so can't use the\n136:         # requires_migrations_check attribute.\n137:         self.check_migrations()\n138:         now = datetime.now().strftime(\"%B %d, %Y - %X\")\n139:         self.stdout.write(now)\n140:         self.stdout.write(\n141:             (\n142:                 \"Django version %(version)s, using settings %(settings)r\\n\"\n143:                 \"Starting development server at %(protocol)s://%(addr)s:%(port)s/\\n\"\n144:                 \"Quit the server with %(quit_command)s.\"\n145:             )\n146:             % {\n147:                 \"version\": self.get_version(),\n148:                 \"settings\": settings.SETTINGS_MODULE,\n149:                 \"protocol\": self.protocol,\n150:                 \"addr\": \"[%s]\" % self.addr if self._raw_ipv6 else self.addr,\n151:                 \"port\": self.port,\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/management/commands/runserver.py",
      "suspect_lines": [
        150
      ]
    }
  ]
}