{
  "instance_id": "django__django-13297",
  "problem_statement": "TemplateView.get_context_data()'s kwargs returns SimpleLazyObjects that causes a crash when filtering.\nDescription\n\t\nExample Code that works in 3.0, but not in 3.1:\nclass OfferView(TemplateView):\n\ttemplate_name = \"offers/offer.html\"\n\tdef get_context_data(self, **kwargs):\n\t\toffer_slug = kwargs.get(\"offer_slug\", \"\")\n\t\toffer = get_object_or_404(Account, slug=offer_slug)\n\t\treturn {\"offer\": offer, \"offer_slug\": offer_slug}\nIn order to make this work in 3.1, you have to explicitly convert the result of kwargs.get() to a string to get the SimpleLazyObject to resolve:\nclass OfferView(TemplateView):\n\ttemplate_name = \"offers/offer.html\"\n\tdef get_context_data(self, **kwargs):\n\t\toffer_slug = kwargs.get(\"offer_slug\", \"\")\n\t\toffer = get_object_or_404(Account, slug=str(offer_slug))\n\t\treturn {\"offer\": offer, \"offer_slug\": offer_slug}\nThe error generated if you don't is:\nError binding parameter 0 - probably unsupported type\nfrom django/db/backends/sqlite3/operations.py, line 144, in _quote_params_for_last_executed_query\nIn both cases, the urls.py looks like:\npath(\n\t\t\"/offers/<slug:offer_slug>/\",\n\t\tOfferView.as_view(),\n\t\tname=\"offer_view\",\n\t),\nWhen debugging, I found that offer_slug (coming in from kwargs.get) was of type 'SimpleLazyObject' in Django 3.1, and when I explicitly converted it to a string, get_object_or_404 behaved as expected.\nThis is using Python 3.7.8 with SQLite.\n",
  "localized_code": "[start of django/views/generic/base.py]\n1: import logging\n2: import warnings\n3: from functools import update_wrapper\n4: \n5: from django.core.exceptions import ImproperlyConfigured\n6: from django.http import (\n7:     HttpResponse, HttpResponseGone, HttpResponseNotAllowed,\n8:     HttpResponsePermanentRedirect, HttpResponseRedirect,\n9: )\n10: from django.template.response import TemplateResponse\n11: from django.urls import reverse\n12: from django.utils.decorators import classonlymethod\n13: from django.utils.deprecation import RemovedInDjango40Warning\n14: from django.utils.functional import SimpleLazyObject\n15: \n16: logger = logging.getLogger('django.request')\n17: \n18: \n19: class ContextMixin:\n20:     \"\"\"\n21:     A default context mixin that passes the keyword arguments received by\n22:     get_context_data() as the template context.\n23:     \"\"\"\n24:     extra_context = None\n25: \n26:     def get_context_data(self, **kwargs):\n27:         kwargs.setdefault('view', self)\n28:         if self.extra_context is not None:\n29:             kwargs.update(self.extra_context)\n30:         return kwargs\n31: \n32: \n33: class View:\n34:     \"\"\"\n35:     Intentionally simple parent class for all views. Only implements\n36:     dispatch-by-method and simple sanity checking.\n37:     \"\"\"\n38: \n39:     http_method_names = ['get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace']\n40: \n41:     def __init__(self, **kwargs):\n42:         \"\"\"\n43:         Constructor. Called in the URLconf; can contain helpful extra\n44:         keyword arguments, and other things.\n45:         \"\"\"\n46:         # Go through keyword arguments, and either save their values to our\n47:         # instance, or raise an error.\n48:         for key, value in kwargs.items():\n49:             setattr(self, key, value)\n50: \n51:     @classonlymethod\n52:     def as_view(cls, **initkwargs):\n53:         \"\"\"Main entry point for a request-response process.\"\"\"\n54:         for key in initkwargs:\n55:             if key in cls.http_method_names:\n56:                 raise TypeError(\n57:                     'The method name %s is not accepted as a keyword argument '\n58:                     'to %s().' % (key, cls.__name__)\n59:                 )\n60:             if not hasattr(cls, key):\n61:                 raise TypeError(\"%s() received an invalid keyword %r. as_view \"\n62:                                 \"only accepts arguments that are already \"\n63:                                 \"attributes of the class.\" % (cls.__name__, key))\n64: \n65:         def view(request, *args, **kwargs):\n66:             self = cls(**initkwargs)\n67:             self.setup(request, *args, **kwargs)\n68:             if not hasattr(self, 'request'):\n69:                 raise AttributeError(\n70:                     \"%s instance has no 'request' attribute. Did you override \"\n71:                     \"setup() and forget to call super()?\" % cls.__name__\n72:                 )\n73:             return self.dispatch(request, *args, **kwargs)\n74:         view.view_class = cls\n75:         view.view_initkwargs = initkwargs\n76: \n77:         # take name and docstring from class\n78:         update_wrapper(view, cls, updated=())\n79: \n80:         # and possible attributes set by decorators\n81:         # like csrf_exempt from dispatch\n82:         update_wrapper(view, cls.dispatch, assigned=())\n83:         return view\n84: \n85:     def setup(self, request, *args, **kwargs):\n86:         \"\"\"Initialize attributes shared by all view methods.\"\"\"\n87:         if hasattr(self, 'get') and not hasattr(self, 'head'):\n88:             self.head = self.get\n89:         self.request = request\n90:         self.args = args\n91:         self.kwargs = kwargs\n92: \n93:     def dispatch(self, request, *args, **kwargs):\n94:         # Try to dispatch to the right method; if a method doesn't exist,\n95:         # defer to the error handler. Also defer to the error handler if the\n96:         # request method isn't on the approved list.\n97:         if request.method.lower() in self.http_method_names:\n98:             handler = getattr(self, request.method.lower(), self.http_method_not_allowed)\n99:         else:\n100:             handler = self.http_method_not_allowed\n101:         return handler(request, *args, **kwargs)\n102: \n103:     def http_method_not_allowed(self, request, *args, **kwargs):\n104:         logger.warning(\n105:             'Method Not Allowed (%s): %s', request.method, request.path,\n106:             extra={'status_code': 405, 'request': request}\n107:         )\n108:         return HttpResponseNotAllowed(self._allowed_methods())\n109: \n110:     def options(self, request, *args, **kwargs):\n111:         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\n112:         response = HttpResponse()\n113:         response['Allow'] = ', '.join(self._allowed_methods())\n114:         response['Content-Length'] = '0'\n115:         return response\n116: \n117:     def _allowed_methods(self):\n118:         return [m.upper() for m in self.http_method_names if hasattr(self, m)]\n119: \n120: \n121: class TemplateResponseMixin:\nCode replaced for brevity.\n154: \n155: \n156: \n157: class TemplateView(TemplateResponseMixin, ContextMixin, View):\nCode replaced for brevity.\n164: \n165: \n166: \n167: # RemovedInDjango40Warning\n168: def _wrap_url_kwargs_with_deprecation_warning(url_kwargs):\n169:     context_kwargs = {}\n170:     for key, value in url_kwargs.items():\n171:         # Bind into function closure.\n172:         @SimpleLazyObject\n173:         def access_value(key=key, value=value):\n174:             warnings.warn(\n175:                 'TemplateView passing URL kwargs to the context is '\n176:                 'deprecated. Reference %s in your template through '\n177:                 'view.kwargs instead.' % key,\n178:                 RemovedInDjango40Warning, stacklevel=2,\n179:             )\n180:             return value\n181:         context_kwargs[key] = access_value\n182:     return context_kwargs\n183: \n184: \n185: class RedirectView(View):\nCode replaced for brevity.\n240: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/views/generic/base.py",
      "suspect_lines": [
        14,
        172,
        181
      ]
    }
  ]
}