{
  "instance_id": "django__django-16801",
  "problem_statement": "ImageField unnecessarily adds a post_init signal handler to the model\nDescription\n\t\nWhile debugging some performance issues in a Django app, I found a codepath where most of the time was being spent on initializing Django models after fetching from the DB. It turns out that 30% of the time was being spent on evaluating post_init signals because we were using ImageField. However, the post_init signal handler is a noop because we don't use the width_field / height_field.\nIf width_field and height_field are not set, removing the post_init signal should have no effect since the signal handler will return right away. Removing this signal handler gave us a 30-40% speedup on initializing models where ImageField was used.\n",
  "localized_code": "[start of django/db/models/fields/files.py]\n1: import datetime\n2: import posixpath\n3: \n4: from django import forms\n5: from django.core import checks\n6: from django.core.files.base import File\n7: from django.core.files.images import ImageFile\n8: from django.core.files.storage import Storage, default_storage\n9: from django.core.files.utils import validate_file_name\n10: from django.db.models import signals\n11: from django.db.models.fields import Field\n12: from django.db.models.query_utils import DeferredAttribute\n13: from django.db.models.utils import AltersData\n14: from django.utils.translation import gettext_lazy as _\n15: \n16: \n17: class FieldFile(File, AltersData):\n18:     def __init__(self, instance, field, name):\n19:         super().__init__(None, name)\n20:         self.instance = instance\n21:         self.field = field\n22:         self.storage = field.storage\n23:         self._committed = True\n24: \n25:     def __eq__(self, other):\n26:         # Older code may be expecting FileField values to be simple strings.\n27:         # By overriding the == operator, it can remain backwards compatibility.\n28:         if hasattr(other, \"name\"):\n29:             return self.name == other.name\n30:         return self.name == other\n31: \n32:     def __hash__(self):\n33:         return hash(self.name)\n34: \n35:     # The standard File contains most of the necessary properties, but\n36:     # FieldFiles can be instantiated without a name, so that needs to\n37:     # be checked for here.\n38: \n39:     def _require_file(self):\n40:         if not self:\n41:             raise ValueError(\n42:                 \"The '%s' attribute has no file associated with it.\" % self.field.name\n43:             )\n44: \n45:     def _get_file(self):\n46:         self._require_file()\n47:         if getattr(self, \"_file\", None) is None:\n48:             self._file = self.storage.open(self.name, \"rb\")\n49:         return self._file\n50: \n51:     def _set_file(self, file):\n52:         self._file = file\n53: \n54:     def _del_file(self):\n55:         del self._file\n56: \n57:     file = property(_get_file, _set_file, _del_file)\n58: \n59:     @property\n60:     def path(self):\n61:         self._require_file()\n62:         return self.storage.path(self.name)\n63: \n64:     @property\n65:     def url(self):\n66:         self._require_file()\n67:         return self.storage.url(self.name)\n68: \n69:     @property\n70:     def size(self):\n71:         self._require_file()\n72:         if not self._committed:\n73:             return self.file.size\n74:         return self.storage.size(self.name)\n75: \n76:     def open(self, mode=\"rb\"):\n77:         self._require_file()\n78:         if getattr(self, \"_file\", None) is None:\n79:             self.file = self.storage.open(self.name, mode)\n80:         else:\n81:             self.file.open(mode)\n82:         return self\n83: \n84:     # open() doesn't alter the file's contents, but it does reset the pointer\n85:     open.alters_data = True\n86: \n87:     # In addition to the standard File API, FieldFiles have extra methods\n88:     # to further manipulate the underlying file, as well as update the\n89:     # associated model instance.\n90: \n91:     def save(self, name, content, save=True):\n92:         name = self.field.generate_filename(self.instance, name)\n93:         self.name = self.storage.save(name, content, max_length=self.field.max_length)\n94:         setattr(self.instance, self.field.attname, self.name)\n95:         self._committed = True\n96: \n97:         # Save the object because it has changed, unless save is False\n98:         if save:\n99:             self.instance.save()\n100: \n101:     save.alters_data = True\n102: \n103:     def delete(self, save=True):\n104:         if not self:\n105:             return\n106:         # Only close the file if it's already open, which we know by the\n107:         # presence of self._file\n108:         if hasattr(self, \"_file\"):\n109:             self.close()\n110:             del self.file\n111: \n112:         self.storage.delete(self.name)\n113: \n114:         self.name = None\n115:         setattr(self.instance, self.field.attname, self.name)\n116:         self._committed = False\n117: \n118:         if save:\n119:             self.instance.save()\n120: \n121:     delete.alters_data = True\n122: \n123:     @property\n124:     def closed(self):\n125:         file = getattr(self, \"_file\", None)\n126:         return file is None or file.closed\n127: \n128:     def close(self):\n129:         file = getattr(self, \"_file\", None)\n130:         if file is not None:\n131:             file.close()\n132: \n133:     def __getstate__(self):\n134:         # FieldFile needs access to its associated model field, an instance and\n135:         # the file's name. Everything else will be restored later, by\n136:         # FileDescriptor below.\n137:         return {\n138:             \"name\": self.name,\n139:             \"closed\": False,\n140:             \"_committed\": True,\n141:             \"_file\": None,\n142:             \"instance\": self.instance,\n143:             \"field\": self.field,\n144:         }\n145: \n146:     def __setstate__(self, state):\n147:         self.__dict__.update(state)\n148:         self.storage = self.field.storage\n149: \n150: \n151: class FileDescriptor(DeferredAttribute):\nCode replaced for brevity.\n221: \n222: \n223: \n224:     # the instance will always return an instance of attr_class.\nCode replaced for brevity.\n356: \n357: \n358: \n359: class ImageFileDescriptor(FileDescriptor):\nCode replaced for brevity.\n379: \n380: \n381: \n382: class ImageFieldFile(ImageFile, FieldFile):\nCode replaced for brevity.\n387: \n388: \n389: \n390: class ImageField(FileField):\n391:     attr_class = ImageFieldFile\n392:     descriptor_class = ImageFileDescriptor\n393:     description = _(\"Image\")\n394: \n395:     def __init__(\n396:         self,\n397:         verbose_name=None,\n398:         name=None,\n399:         width_field=None,\n400:         height_field=None,\n401:         **kwargs,\n402:     ):\n403:         self.width_field, self.height_field = width_field, height_field\n404:         super().__init__(verbose_name, name, **kwargs)\n405: \n406:     def check(self, **kwargs):\n407:         return [\n408:             *super().check(**kwargs),\n409:             *self._check_image_library_installed(),\n410:         ]\n411: \n412:     def _check_image_library_installed(self):\n413:         try:\n414:             from PIL import Image  # NOQA\n415:         except ImportError:\n416:             return [\n417:                 checks.Error(\n418:                     \"Cannot use ImageField because Pillow is not installed.\",\n419:                     hint=(\n420:                         \"Get Pillow at https://pypi.org/project/Pillow/ \"\n421:                         'or run command \"python -m pip install Pillow\".'\n422:                     ),\n423:                     obj=self,\n424:                     id=\"fields.E210\",\n425:                 )\n426:             ]\n427:         else:\n428:             return []\n429: \n430:     def deconstruct(self):\n431:         name, path, args, kwargs = super().deconstruct()\n432:         if self.width_field:\n433:             kwargs[\"width_field\"] = self.width_field\n434:         if self.height_field:\n435:             kwargs[\"height_field\"] = self.height_field\n436:         return name, path, args, kwargs\n437: \n438:     def contribute_to_class(self, cls, name, **kwargs):\n439:         super().contribute_to_class(cls, name, **kwargs)\n440:         # Attach update_dimension_fields so that dimension fields declared\n441:         # after their corresponding image field don't stay cleared by\n442:         # Model.__init__, see bug #11196.\n443:         # Only run post-initialization dimension update on non-abstract models\n444:         if not cls._meta.abstract:\n445:             signals.post_init.connect(self.update_dimension_fields, sender=cls)\n446: \n447:     def update_dimension_fields(self, instance, force=False, *args, **kwargs):\n448:         \"\"\"\n449:         Update field's width and height fields, if defined.\n450: \n451:         This method is hooked up to model's post_init signal to update\n452:         dimensions after instantiating a model instance.  However, dimensions\n453:         won't be updated if the dimensions fields are already populated.  This\n454:         avoids unnecessary recalculation when loading an object from the\n455:         database.\n456: \n457:         Dimensions can be forced to update with force=True, which is how\n458:         ImageFileDescriptor.__set__ calls this method.\n459:         \"\"\"\n460:         # Nothing to update if the field doesn't have dimension fields or if\n461:         # the field is deferred.\n462:         has_dimension_fields = self.width_field or self.height_field\n463:         if not has_dimension_fields or self.attname not in instance.__dict__:\n464:             return\n465: \n466:         # getattr will call the ImageFileDescriptor's __get__ method, which\n467:         # coerces the assigned value into an instance of self.attr_class\n468:         # (ImageFieldFile in this case).\n469:         file = getattr(instance, self.attname)\n470: \n471:         # Nothing to update if we have no file and not being forced to update.\n472:         if not file and not force:\n473:             return\n474: \n475:         dimension_fields_filled = not (\n476:             (self.width_field and not getattr(instance, self.width_field))\n477:             or (self.height_field and not getattr(instance, self.height_field))\n478:         )\n479:         # When both dimension fields have values, we are most likely loading\n480:         # data from the database or updating an image field that already had\n481:         # an image stored.  In the first case, we don't want to update the\n482:         # dimension fields because we are already getting their values from the\n483:         # database.  In the second case, we do want to update the dimensions\n484:         # fields and will skip this return because force will be True since we\n485:         # were called from ImageFileDescriptor.__set__.\n486:         if dimension_fields_filled and not force:\n487:             return\n488: \n489:         # file should be an instance of ImageFieldFile or should be None.\n490:         if file:\n491:             width = file.width\n492:             height = file.height\n493:         else:\n494:             # No file, so clear dimensions fields.\n495:             width = None\n496:             height = None\n497: \n498:         # Update the width and height fields.\n499:         if self.width_field:\n500:             setattr(instance, self.width_field, width)\n501:         if self.height_field:\n502:             setattr(instance, self.height_field, height)\n503: \n504:     def formfield(self, **kwargs):\n505:         return super().formfield(\n506:             **{\n507:                 \"form_class\": forms.ImageField,\n508:                 **kwargs,\n509:             }\n510:         )\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/files.py",
      "suspect_lines": [
        444,
        460,
        461,
        462,
        463
      ]
    }
  ]
}