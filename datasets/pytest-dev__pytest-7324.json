{
  "instance_id": "pytest-dev__pytest-7324",
  "problem_statement": "Pytest crashes the interpreter on debug build for 3.8+\nShort reproducer\r\n```py\r\n>>> Expression.compile(\"False\")\r\npython: Python/compile.c:3559: compiler_nameop: Assertion `!_PyUnicode_EqualToASCIIString(name, \"None\") && !_PyUnicode_EqualToASCIIString(name, \"True\") && !_PyUnicode_EqualToASCIIString(name, \"False\")' failed.\r\n[1]    29440 abort (core dumped)  python\r\n```\r\n\r\nRelated issue for improvement of this behavior: [bpo-40870](https://bugs.python.org/issue40870)\n",
  "localized_code": "[start of src/_pytest/mark/expression.py]\n1: r\"\"\"\n2: Evaluate match expressions, as used by `-k` and `-m`.\n3: \n4: The grammar is:\n5: \n6: expression: expr? EOF\n7: expr:       and_expr ('or' and_expr)*\n8: and_expr:   not_expr ('and' not_expr)*\n9: not_expr:   'not' not_expr | '(' expr ')' | ident\n10: ident:      (\\w|:|\\+|-|\\.|\\[|\\])+\n11: \n12: The semantics are:\n13: \n14: - Empty expression evaluates to False.\n15: - ident evaluates to True of False according to a provided matcher function.\n16: - or/and/not evaluate according to the usual boolean semantics.\n17: \"\"\"\n18: import ast\n19: import enum\n20: import re\n21: import types\n22: from typing import Callable\n23: from typing import Iterator\n24: from typing import Mapping\n25: from typing import Optional\n26: from typing import Sequence\n27: \n28: import attr\n29: \n30: from _pytest.compat import TYPE_CHECKING\n31: \n32: if TYPE_CHECKING:\n33:     from typing import NoReturn\n34: \n35: \n36: __all__ = [\n37:     \"Expression\",\n38:     \"ParseError\",\n39: ]\n40: \n41: \n42: class TokenType(enum.Enum):\n43:     LPAREN = \"left parenthesis\"\n44:     RPAREN = \"right parenthesis\"\n45:     OR = \"or\"\n46:     AND = \"and\"\n47:     NOT = \"not\"\n48:     IDENT = \"identifier\"\n49:     EOF = \"end of input\"\n50: \n51: \n52: @attr.s(frozen=True, slots=True)\n53: class Token:\nCode replaced for brevity.\n56: \n57: \n58: \n59: class ParseError(Exception):\nCode replaced for brevity.\n71: \n72: \n73: \n74: class Scanner:\nCode replaced for brevity.\n127: \n128: \n129: \n130: def expression(s: Scanner) -> ast.Expression:\nCode replaced for brevity.\n136: \n137: \n138: \n139: def expr(s: Scanner) -> ast.expr:\nCode replaced for brevity.\n144: \n145: \n146: \n147: def and_expr(s: Scanner) -> ast.expr:\nCode replaced for brevity.\n152: \n153: \n154: \n155: def not_expr(s: Scanner) -> ast.expr:\n156:     if s.accept(TokenType.NOT):\n157:         return ast.UnaryOp(ast.Not(), not_expr(s))\n158:     if s.accept(TokenType.LPAREN):\n159:         ret = expr(s)\n160:         s.accept(TokenType.RPAREN, reject=True)\n161:         return ret\n162:     ident = s.accept(TokenType.IDENT)\n163:     if ident:\n164:         return ast.Name(ident.value, ast.Load())\n165:     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n166: \n167: \n168: class MatcherAdapter(Mapping[str, bool]):\n169:     \"\"\"Adapts a matcher function to a locals mapping as required by eval().\"\"\"\n170: \n171:     def __init__(self, matcher: Callable[[str], bool]) -> None:\n172:         self.matcher = matcher\n173: \n174:     def __getitem__(self, key: str) -> bool:\n175:         return self.matcher(key)\n176: \n177:     def __iter__(self) -> Iterator[str]:\n178:         raise NotImplementedError()\n179: \n180:     def __len__(self) -> int:\n181:         raise NotImplementedError()\n182: \n183: \n184: class Expression:\nCode replaced for brevity.\n218: \n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/mark/expression.py",
      "suspect_lines": [
        164,
        175
      ]
    }
  ]
}