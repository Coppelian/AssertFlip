{
  "instance_id": "django__django-12713",
  "problem_statement": "Allow overridding widget in formfield_for_manytomany().\nDescription\n\t \n\t\t(last modified by Mariusz Felisiak)\n\t \nIt does not work when I set widget param to function formfield_for_manytomany().\nThis is different from the formfield_for_foreignkey() function.\n",
  "localized_code": "[start of django/contrib/admin/options.py]\n1: import copy\n2: import json\n3: import operator\n4: import re\n5: from functools import partial, reduce, update_wrapper\n6: from urllib.parse import quote as urlquote\n7: \n8: from django import forms\n9: from django.conf import settings\n10: from django.contrib import messages\n11: from django.contrib.admin import helpers, widgets\n12: from django.contrib.admin.checks import (\n13:     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,\n14: )\n15: from django.contrib.admin.exceptions import DisallowedModelAdminToField\n16: from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n17: from django.contrib.admin.utils import (\n18:     NestedObjects, construct_change_message, flatten_fieldsets,\n19:     get_deleted_objects, lookup_needs_distinct, model_format_dict,\n20:     model_ngettext, quote, unquote,\n21: )\n22: from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n23: from django.contrib.admin.widgets import (\n24:     AutocompleteSelect, AutocompleteSelectMultiple,\n25: )\n26: from django.contrib.auth import get_permission_codename\n27: from django.core.exceptions import (\n28:     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,\n29: )\n30: from django.core.paginator import Paginator\n31: from django.db import models, router, transaction\n32: from django.db.models.constants import LOOKUP_SEP\n33: from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n34: from django.forms.models import (\n35:     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,\n36:     modelform_factory, modelformset_factory,\n37: )\n38: from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n39: from django.http import HttpResponseRedirect\n40: from django.http.response import HttpResponseBase\n41: from django.template.response import SimpleTemplateResponse, TemplateResponse\n42: from django.urls import reverse\n43: from django.utils.decorators import method_decorator\n44: from django.utils.html import format_html\n45: from django.utils.http import urlencode\n46: from django.utils.safestring import mark_safe\n47: from django.utils.text import capfirst, format_lazy, get_text_list\n48: from django.utils.translation import gettext as _, ngettext\n49: from django.views.decorators.csrf import csrf_protect\n50: from django.views.generic import RedirectView\n51: \n52: IS_POPUP_VAR = '_popup'\n53: TO_FIELD_VAR = '_to_field'\n54: \n55: \n56: HORIZONTAL, VERTICAL = 1, 2\n57: \n58: \n59:     # it cannot import models from other applications at the module level.\nCode replaced for brevity.\n63: \n64: \n65: \n66: def get_ul_class(radio_style):\nCode replaced for brevity.\n67: \n68: \n69: \n70: class IncorrectLookupParameters(Exception):\n71:     pass\n72: \n73: \n74: # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n75: # by adding to ModelAdmin.formfield_overrides.\n76: \n77: FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n78:     models.DateTimeField: {\n79:         'form_class': forms.SplitDateTimeField,\n80:         'widget': widgets.AdminSplitDateTime\n81:     },\n82:     models.DateField: {'widget': widgets.AdminDateWidget},\n83:     models.TimeField: {'widget': widgets.AdminTimeWidget},\n84:     models.TextField: {'widget': widgets.AdminTextareaWidget},\n85:     models.URLField: {'widget': widgets.AdminURLFieldWidget},\n86:     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},\n87:     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},\n88:     models.CharField: {'widget': widgets.AdminTextInputWidget},\n89:     models.ImageField: {'widget': widgets.AdminFileWidget},\n90:     models.FileField: {'widget': widgets.AdminFileWidget},\n91:     models.EmailField: {'widget': widgets.AdminEmailInputWidget},\n92:     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},\n93: }\n94: \n95: csrf_protect_m = method_decorator(csrf_protect)\n96: \n97: \n98: class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n99:     \"\"\"Functionality common to both ModelAdmin and InlineAdmin.\"\"\"\n100: \n101:     autocomplete_fields = ()\n102:     raw_id_fields = ()\n103:     fields = None\n104:     exclude = None\n105:     fieldsets = None\n106:     form = forms.ModelForm\n107:     filter_vertical = ()\n108:     filter_horizontal = ()\n109:     radio_fields = {}\n110:     prepopulated_fields = {}\n111:     formfield_overrides = {}\n112:     readonly_fields = ()\n113:     ordering = None\n114:     sortable_by = None\n115:     view_on_site = True\n116:     show_full_result_count = True\n117:     checks_class = BaseModelAdminChecks\n118: \n119:     def check(self, **kwargs):\n120:         return self.checks_class().check(self, **kwargs)\n121: \n122:     def __init__(self):\n123:         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides\n124:         # rather than simply overwriting.\n125:         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)\n126:         for k, v in self.formfield_overrides.items():\n127:             overrides.setdefault(k, {}).update(v)\n128:         self.formfield_overrides = overrides\n129: \n130:     def formfield_for_dbfield(self, db_field, request, **kwargs):\n131:         \"\"\"\n132:         Hook for specifying the form Field instance for a given database Field\n133:         instance.\n134: \n135:         If kwargs are given, they're passed to the form Field's constructor.\n136:         \"\"\"\n137:         # If the field specifies choices, we don't need to look for special\n138:         # admin widgets - we just need to use a select widget of some kind.\n139:         if db_field.choices:\n140:             return self.formfield_for_choice_field(db_field, request, **kwargs)\n141: \n142:         # ForeignKey or ManyToManyFields\n143:         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):\n144:             # Combine the field kwargs with any options for formfield_overrides.\n145:             # Make sure the passed in **kwargs override anything in\n146:             # formfield_overrides because **kwargs is more specific, and should\n147:             # always win.\n148:             if db_field.__class__ in self.formfield_overrides:\n149:                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}\n150: \n151:             # Get the correct formfield.\n152:             if isinstance(db_field, models.ForeignKey):\n153:                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)\n154:             elif isinstance(db_field, models.ManyToManyField):\n155:                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)\n156: \n157:             # For non-raw_id fields, wrap the widget with a wrapper that adds\n158:             # extra HTML -- the \"add other\" interface -- to the end of the\n159:             # rendered output. formfield can be None if it came from a\n160:             # OneToOneField with parent_link=True or a M2M intermediary.\n161:             if formfield and db_field.name not in self.raw_id_fields:\n162:                 related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)\n163:                 wrapper_kwargs = {}\n164:                 if related_modeladmin:\n165:                     wrapper_kwargs.update(\n166:                         can_add_related=related_modeladmin.has_add_permission(request),\n167:                         can_change_related=related_modeladmin.has_change_permission(request),\n168:                         can_delete_related=related_modeladmin.has_delete_permission(request),\n169:                         can_view_related=related_modeladmin.has_view_permission(request),\n170:                     )\n171:                 formfield.widget = widgets.RelatedFieldWidgetWrapper(\n172:                     formfield.widget, db_field.remote_field, self.admin_site, **wrapper_kwargs\n173:                 )\n174: \n175:             return formfield\n176: \n177:         # If we've got overrides for the formfield defined, use 'em. **kwargs\n178:         # passed to formfield_for_dbfield override the defaults.\n179:         for klass in db_field.__class__.mro():\n180:             if klass in self.formfield_overrides:\n181:                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}\n182:                 return db_field.formfield(**kwargs)\n183: \n184:         # For any other type of field, just call its formfield() method.\n185:         return db_field.formfield(**kwargs)\n186: \n187:     def formfield_for_choice_field(self, db_field, request, **kwargs):\n188:         \"\"\"\n189:         Get a form Field for a database Field that has declared choices.\n190:         \"\"\"\n191:         # If the field is named as a radio_field, use a RadioSelect\n192:         if db_field.name in self.radio_fields:\n193:             # Avoid stomping on custom widget/choices arguments.\n194:             if 'widget' not in kwargs:\n195:                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n196:                     'class': get_ul_class(self.radio_fields[db_field.name]),\n197:                 })\n198:             if 'choices' not in kwargs:\n199:                 kwargs['choices'] = db_field.get_choices(\n200:                     include_blank=db_field.blank,\n201:                     blank_choice=[('', _('None'))]\n202:                 )\n203:         return db_field.formfield(**kwargs)\n204: \n205:     def get_field_queryset(self, db, db_field, request):\n206:         \"\"\"\n207:         If the ModelAdmin specifies ordering, the queryset should respect that\n208:         ordering.  Otherwise don't specify the queryset, let the field decide\n209:         (return None in that case).\n210:         \"\"\"\n211:         related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n212:         if related_admin is not None:\n213:             ordering = related_admin.get_ordering(request)\n214:             if ordering is not None and ordering != ():\n215:                 return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)\n216:         return None\n217: \n218:     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n219:         \"\"\"\n220:         Get a form Field for a ForeignKey.\n221:         \"\"\"\n222:         db = kwargs.get('using')\n223: \n224:         if 'widget' not in kwargs:\n225:             if db_field.name in self.get_autocomplete_fields(request):\n226:                 kwargs['widget'] = AutocompleteSelect(db_field.remote_field, self.admin_site, using=db)\n227:             elif db_field.name in self.raw_id_fields:\n228:                 kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n229:             elif db_field.name in self.radio_fields:\n230:                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n231:                     'class': get_ul_class(self.radio_fields[db_field.name]),\n232:                 })\n233:                 kwargs['empty_label'] = _('None') if db_field.blank else None\n234: \n235:         if 'queryset' not in kwargs:\n236:             queryset = self.get_field_queryset(db, db_field, request)\n237:             if queryset is not None:\n238:                 kwargs['queryset'] = queryset\n239: \n240:         return db_field.formfield(**kwargs)\n241: \n242:     def formfield_for_manytomany(self, db_field, request, **kwargs):\n243:         \"\"\"\n244:         Get a form Field for a ManyToManyField.\n245:         \"\"\"\n246:         # If it uses an intermediary model that isn't auto created, don't show\n247:         # a field in admin.\n248:         if not db_field.remote_field.through._meta.auto_created:\n249:             return None\n250:         db = kwargs.get('using')\n251: \n252:         autocomplete_fields = self.get_autocomplete_fields(request)\n253:         if db_field.name in autocomplete_fields:\n254:             kwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\n255:         elif db_field.name in self.raw_id_fields:\n256:             kwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n257:         elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n258:             kwargs['widget'] = widgets.FilteredSelectMultiple(\n259:                 db_field.verbose_name,\n260:                 db_field.name in self.filter_vertical\n261:             )\n262: \n263:         if 'queryset' not in kwargs:\n264:             queryset = self.get_field_queryset(db, db_field, request)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/options.py",
      "suspect_lines": [
        252,
        253,
        254,
        255,
        256,
        257,
        258,
        259,
        260,
        261,
        262
      ]
    }
  ]
}