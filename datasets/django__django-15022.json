{
  "instance_id": "django__django-15022",
  "problem_statement": "Unnecessary joins in admin changelist query\nDescription\n\t\nDjango 1.2.5\nModels:\nclass Client(models.Model):\n\tname = models.CharField(_('name'), max_length=256)\n\tname2 = models.CharField(_('unofficial or obsolete name'), max_length=256, blank=True, null=True)\n\tcontact_person = models.CharField(_('contact person'), max_length=256, blank=True, null=True)\n\t...\nclass ClientOffice(models.Model):\n\tname = models.CharField(_('name'), max_length=256)\n\tname2 = models.CharField(_('unofficial or obsolete name'), max_length=256, blank=True, null=True)\n\t...\n\tclient = models.ForeignKey(Client, verbose_name=_('client'))\n\t...\nand admin options like these:\nclass ClientAdmin(admin.ModelAdmin):\n\tsearch_fields = ('name', 'name2', 'contact_person', 'clientoffice__name', 'clientoffice__name2')\n\t...\nNumbers:\n>>> Client.objects.count()\n10907\n>>> ClientOffice.objects.count()\n16952\nNow, if we try searching for clients in admin by a search query containig several words (>3), got django/admin stalled.\nThe problem is going to be that each word in the search query leads to additional JOIN in final SQL query beacause of qs = qs.filter(...) pattern. The attached patch is for Django 1.2.5, but adopting for the current SVN trunk is trivial.\n",
  "localized_code": "[start of django/contrib/admin/options.py]\n1: import copy\n2: import json\n3: import re\n4: from functools import partial, update_wrapper\n5: from urllib.parse import quote as urlquote\n6: \n7: from django import forms\n8: from django.conf import settings\n9: from django.contrib import messages\n10: from django.contrib.admin import helpers, widgets\n11: from django.contrib.admin.checks import (\n12:     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,\n13: )\n14: from django.contrib.admin.decorators import display\n15: from django.contrib.admin.exceptions import DisallowedModelAdminToField\n16: from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n17: from django.contrib.admin.utils import (\n18:     NestedObjects, construct_change_message, flatten_fieldsets,\n19:     get_deleted_objects, lookup_spawns_duplicates, model_format_dict,\n20:     model_ngettext, quote, unquote,\n21: )\n22: from django.contrib.admin.widgets import (\n23:     AutocompleteSelect, AutocompleteSelectMultiple,\n24: )\n25: from django.contrib.auth import get_permission_codename\n26: from django.core.exceptions import (\n27:     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,\n28: )\n29: from django.core.paginator import Paginator\n30: from django.db import models, router, transaction\n31: from django.db.models.constants import LOOKUP_SEP\n32: from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n33: from django.forms.models import (\n34:     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,\n35:     modelform_factory, modelformset_factory,\n36: )\n37: from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n38: from django.http import HttpResponseRedirect\n39: from django.http.response import HttpResponseBase\n40: from django.template.response import SimpleTemplateResponse, TemplateResponse\n41: from django.urls import reverse\n42: from django.utils.decorators import method_decorator\n43: from django.utils.html import format_html\n44: from django.utils.http import urlencode\n45: from django.utils.safestring import mark_safe\n46: from django.utils.text import (\n47:     capfirst, format_lazy, get_text_list, smart_split, unescape_string_literal,\n48: )\n49: from django.utils.translation import gettext as _, ngettext\n50: from django.views.decorators.csrf import csrf_protect\n51: from django.views.generic import RedirectView\n52: \n53: IS_POPUP_VAR = '_popup'\n54: TO_FIELD_VAR = '_to_field'\n55: \n56: \n57: HORIZONTAL, VERTICAL = 1, 2\n58: \n59: \n60:     # it cannot import models from other applications at the module level.\nCode replaced for brevity.\n64: \n65: \n66: \n67: def get_ul_class(radio_style):\nCode replaced for brevity.\n68: \n69: \n70: \n71: class IncorrectLookupParameters(Exception):\n72:     pass\n73: \n74: \n75: # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n76: # by adding to ModelAdmin.formfield_overrides.\n77: \n78: FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n79:     models.DateTimeField: {\n80:         'form_class': forms.SplitDateTimeField,\n81:         'widget': widgets.AdminSplitDateTime\n82:     },\n83:     models.DateField: {'widget': widgets.AdminDateWidget},\n84:     models.TimeField: {'widget': widgets.AdminTimeWidget},\n85:     models.TextField: {'widget': widgets.AdminTextareaWidget},\n86:     models.URLField: {'widget': widgets.AdminURLFieldWidget},\n87:     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},\n88:     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},\n89:     models.CharField: {'widget': widgets.AdminTextInputWidget},\n90:     models.ImageField: {'widget': widgets.AdminFileWidget},\n91:     models.FileField: {'widget': widgets.AdminFileWidget},\n92:     models.EmailField: {'widget': widgets.AdminEmailInputWidget},\n93:     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},\n94: }\n95: \n96: csrf_protect_m = method_decorator(csrf_protect)\n97: \n98: \n99: class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\nCode replaced for brevity.\n547: \n548: \n549: \n550: class ModelAdmin(BaseModelAdmin):\n551:     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n552: \n553:     list_display = ('__str__',)\n554:     list_display_links = ()\n555:     list_filter = ()\n556:     list_select_related = False\n557:     list_per_page = 100\n558:     list_max_show_all = 200\n559:     list_editable = ()\n560:     search_fields = ()\n561:     search_help_text = None\n562:     date_hierarchy = None\n563:     save_as = False\n564:     save_as_continue = True\n565:     save_on_top = False\n566:     paginator = Paginator\n567:     preserve_filters = True\n568:     inlines = []\n569: \n570:     # Custom templates (designed to be over-ridden in subclasses)\n571:     add_form_template = None\n572:     change_form_template = None\n573:     change_list_template = None\n574:     delete_confirmation_template = None\n575:     delete_selected_confirmation_template = None\n576:     object_history_template = None\n577:     popup_response_template = None\n578: \n579:     # Actions\n580:     actions = []\n581:     action_form = helpers.ActionForm\n582:     actions_on_top = True\n583:     actions_on_bottom = False\n584:     actions_selection_counter = True\n585:     checks_class = ModelAdminChecks\n586: \n587:     def __init__(self, model, admin_site):\n588:         self.model = model\n589:         self.opts = model._meta\n590:         self.admin_site = admin_site\n591:         super().__init__()\n592: \n593:     def __str__(self):\n594:         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n595: \n596:     def __repr__(self):\n597:         return (\n598:             f'<{self.__class__.__qualname__}: model={self.model.__qualname__} '\n599:             f'site={self.admin_site!r}>'\n600:         )\n601: \n602:     def get_inline_instances(self, request, obj=None):\n603:         inline_instances = []\n604:         for inline_class in self.get_inlines(request, obj):\n605:             inline = inline_class(self.model, self.admin_site)\n606:             if request:\n607:                 if not (inline.has_view_or_change_permission(request, obj) or\n608:                         inline.has_add_permission(request, obj) or\n609:                         inline.has_delete_permission(request, obj)):\n610:                     continue\n611:                 if not inline.has_add_permission(request, obj):\n612:                     inline.max_num = 0\n613:             inline_instances.append(inline)\n614: \n615:         return inline_instances\n616: \n617:     def get_urls(self):\n618:         from django.urls import path\n619: \n620:         def wrap(view):\n621:             def wrapper(*args, **kwargs):\n622:                 return self.admin_site.admin_view(view)(*args, **kwargs)\n623:             wrapper.model_admin = self\n624:             return update_wrapper(wrapper, view)\n625: \n626:         info = self.model._meta.app_label, self.model._meta.model_name\n627: \n628:         return [\n629:             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),\n630:             path('add/', wrap(self.add_view), name='%s_%s_add' % info),\n631:             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),\n632:             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),\n633:             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),\n634:             # For backwards compatibility (was the change url before 1.9)\n635:             path('<path:object_id>/', wrap(RedirectView.as_view(\n636:                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)\n637:             ))),\n638:         ]\n639: \n640:     @property\n641:     def urls(self):\n642:         return self.get_urls()\n643: \n644:     @property\n645:     def media(self):\n646:         extra = '' if settings.DEBUG else '.min'\n647:         js = [\n648:             'vendor/jquery/jquery%s.js' % extra,\n649:             'jquery.init.js',\n650:             'core.js',\n651:             'admin/RelatedObjectLookups.js',\n652:             'actions.js',\n653:             'urlify.js',\n654:             'prepopulate.js',\n655:             'vendor/xregexp/xregexp%s.js' % extra,\n656:         ]\n657:         return forms.Media(js=['admin/js/%s' % url for url in js])\n658: \n659:     def get_model_perms(self, request):\n660:         \"\"\"\n661:         Return a dict of all perms for this model. This dict has the keys\n662:         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n663:         for each of those actions.\n664:         \"\"\"\n665:         return {\n666:             'add': self.has_add_permission(request),\n667:             'change': self.has_change_permission(request),\n668:             'delete': self.has_delete_permission(request),\n669:             'view': self.has_view_permission(request),\n670:         }\n671: \n672:     def _get_form_for_get_fields(self, request, obj):\n673:         return self.get_form(request, obj, fields=None)\n674: \n675:     def get_form(self, request, obj=None, change=False, **kwargs):\n676:         \"\"\"\n677:         Return a Form class for use in the admin add view. This is used by\n678:         add_view and change_view.\n679:         \"\"\"\n680:         if 'fields' in kwargs:\n681:             fields = kwargs.pop('fields')\n682:         else:\n683:             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n684:         excluded = self.get_exclude(request, obj)\n685:         exclude = [] if excluded is None else list(excluded)\n686:         readonly_fields = self.get_readonly_fields(request, obj)\n687:         exclude.extend(readonly_fields)\n688:         # Exclude all fields if it's a change form and the user doesn't have\n689:         # the change permission.\n690:         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):\n691:             exclude.extend(fields)\n692:         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n693:             # Take the custom ModelForm's Meta.exclude into account only if the\n694:             # ModelAdmin doesn't define its own.\n695:             exclude.extend(self.form._meta.exclude)\n696:         # if exclude is an empty list we pass None to be consistent with the\n697:         # default on modelform_factory\n698:         exclude = exclude or None\n699: \n700:         # Remove declared form fields which are in readonly_fields.\n701:         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)\n702:         form = type(self.form.__name__, (self.form,), new_attrs)\n703: \n704:         defaults = {\n705:             'form': form,\n706:             'fields': fields,\n707:             'exclude': exclude,\n708:             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n709:             **kwargs,\n710:         }\n711: \n712:         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n713:             defaults['fields'] = forms.ALL_FIELDS\n714: \n715:         try:\n716:             return modelform_factory(self.model, **defaults)\n717:         except FieldError as e:\n718:             raise FieldError(\n719:                 '%s. Check fields/fieldsets/exclude attributes of class %s.'\n720:                 % (e, self.__class__.__name__)\n721:             )\n722: \n723:     def get_changelist(self, request, **kwargs):\n724:         \"\"\"\n725:         Return the ChangeList class for use on the changelist page.\n726:         \"\"\"\n727:         from django.contrib.admin.views.main import ChangeList\n728:         return ChangeList\n729: \n730:     def get_changelist_instance(self, request):\n731:         \"\"\"\n732:         Return a `ChangeList` instance based on `request`. May raise\n733:         `IncorrectLookupParameters`.\n734:         \"\"\"\n735:         list_display = self.get_list_display(request)\n736:         list_display_links = self.get_list_display_links(request, list_display)\n737:         # Add the action checkboxes if any actions are available.\n738:         if self.get_actions(request):\n739:             list_display = ['action_checkbox', *list_display]\n740:         sortable_by = self.get_sortable_by(request)\n741:         ChangeList = self.get_changelist(request)\n742:         return ChangeList(\n743:             request,\n744:             self.model,\n745:             list_display,\n746:             list_display_links,\n747:             self.get_list_filter(request),\n748:             self.date_hierarchy,\n749:             self.get_search_fields(request),\n750:             self.get_list_select_related(request),\n751:             self.list_per_page,\n752:             self.list_max_show_all,\n753:             self.list_editable,\n754:             self,\n755:             sortable_by,\n756:             self.search_help_text,\n757:         )\n758: \n759:     def get_object(self, request, object_id, from_field=None):\n760:         \"\"\"\n761:         Return an instance matching the field and value provided, the primary\n762:         key is used if no field is provided. Return ``None`` if no match is\n763:         found or the object_id fails validation.\n764:         \"\"\"\n765:         queryset = self.get_queryset(request)\n766:         model = queryset.model\n767:         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)\n768:         try:\n769:             object_id = field.to_python(object_id)\n770:             return queryset.get(**{field.name: object_id})\n771:         except (model.DoesNotExist, ValidationError, ValueError):\n772:             return None\n773: \n774:     def get_changelist_form(self, request, **kwargs):\n775:         \"\"\"\n776:         Return a Form class for use in the Formset on the changelist page.\n777:         \"\"\"\n778:         defaults = {\n779:             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n780:             **kwargs,\n781:         }\n782:         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):\n783:             defaults['fields'] = forms.ALL_FIELDS\n784: \n785:         return modelform_factory(self.model, **defaults)\n786: \n787:     def get_changelist_formset(self, request, **kwargs):\n788:         \"\"\"\n789:         Return a FormSet class for use on the changelist page if list_editable\n790:         is used.\n791:         \"\"\"\n792:         defaults = {\n793:             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n794:             **kwargs,\n795:         }\n796:         return modelformset_factory(\n797:             self.model, self.get_changelist_form(request), extra=0,\n798:             fields=self.list_editable, **defaults\n799:         )\n800: \n801:     def get_formsets_with_inlines(self, request, obj=None):\n802:         \"\"\"\n803:         Yield formsets and the corresponding inlines.\n804:         \"\"\"\n805:         for inline in self.get_inline_instances(request, obj):\n806:             yield inline.get_formset(request, obj), inline\n807: \n808:     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):\n809:         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n810: \n811:     def log_addition(self, request, obj, message):\n812:         \"\"\"\n813:         Log that an object has been successfully added.\n814: \n815:         The default implementation creates an admin LogEntry object.\n816:         \"\"\"\n817:         from django.contrib.admin.models import ADDITION, LogEntry\n818:         return LogEntry.objects.log_action(\n819:             user_id=request.user.pk,\n820:             content_type_id=get_content_type_for_model(obj).pk,\n821:             object_id=obj.pk,\n822:             object_repr=str(obj),\n823:             action_flag=ADDITION,\n824:             change_message=message,\n825:         )\n826: \n827:     def log_change(self, request, obj, message):\n828:         \"\"\"\n829:         Log that an object has been successfully changed.\n830: \n831:         The default implementation creates an admin LogEntry object.\n832:         \"\"\"\n833:         from django.contrib.admin.models import CHANGE, LogEntry\n834:         return LogEntry.objects.log_action(\n835:             user_id=request.user.pk,\n836:             content_type_id=get_content_type_for_model(obj).pk,\n837:             object_id=obj.pk,\n838:             object_repr=str(obj),\n839:             action_flag=CHANGE,\n840:             change_message=message,\n841:         )\n842: \n843:     def log_deletion(self, request, obj, object_repr):\n844:         \"\"\"\n845:         Log that an object will be deleted. Note that this method must be\n846:         called before the deletion.\n847: \n848:         The default implementation creates an admin LogEntry object.\n849:         \"\"\"\n850:         from django.contrib.admin.models import DELETION, LogEntry\n851:         return LogEntry.objects.log_action(\n852:             user_id=request.user.pk,\n853:             content_type_id=get_content_type_for_model(obj).pk,\n854:             object_id=obj.pk,\n855:             object_repr=object_repr,\n856:             action_flag=DELETION,\n857:         )\n858: \n859:     @display(description=mark_safe('<input type=\"checkbox\" id=\"action-toggle\">'))\n860:     def action_checkbox(self, obj):\n861:         \"\"\"\n862:         A list_display column containing a checkbox widget.\n863:         \"\"\"\n864:         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n865: \n866:     @staticmethod\n867:     def _get_action_description(func, name):\n868:         return getattr(func, 'short_description', capfirst(name.replace('_', ' ')))\n869: \n870:     def _get_base_actions(self):\n871:         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n872:         actions = []\n873:         base_actions = (self.get_action(action) for action in self.actions or [])\n874:         # get_action might have returned None, so filter any of those out.\n875:         base_actions = [action for action in base_actions if action]\n876:         base_action_names = {name for _, name, _ in base_actions}\n877: \n878:         # Gather actions from the admin site first\n879:         for (name, func) in self.admin_site.actions:\n880:             if name in base_action_names:\n881:                 continue\n882:             description = self._get_action_description(func, name)\n883:             actions.append((func, name, description))\n884:         # Add actions from this ModelAdmin.\n885:         actions.extend(base_actions)\n886:         return actions\n887: \n888:     def _filter_actions_by_permissions(self, request, actions):\n889:         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n890:         filtered_actions = []\n891:         for action in actions:\n892:             callable = action[0]\n893:             if not hasattr(callable, 'allowed_permissions'):\n894:                 filtered_actions.append(action)\n895:                 continue\n896:             permission_checks = (\n897:                 getattr(self, 'has_%s_permission' % permission)\n898:                 for permission in callable.allowed_permissions\n899:             )\n900:             if any(has_permission(request) for has_permission in permission_checks):\n901:                 filtered_actions.append(action)\n902:         return filtered_actions\n903: \n904:     def get_actions(self, request):\n905:         \"\"\"\n906:         Return a dictionary mapping the names of all actions for this\n907:         ModelAdmin to a tuple of (callable, name, description) for each action.\n908:         \"\"\"\n909:         # If self.actions is set to None that means actions are disabled on\n910:         # this page.\n911:         if self.actions is None or IS_POPUP_VAR in request.GET:\n912:             return {}\n913:         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n914:         return {name: (func, name, desc) for func, name, desc in actions}\n915: \n916:     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n917:         \"\"\"\n918:         Return a list of choices for use in a form object.  Each choice is a\n919:         tuple (name, description).\n920:         \"\"\"\n921:         choices = [] + default_choices\n922:         for func, name, description in self.get_actions(request).values():\n923:             choice = (name, description % model_format_dict(self.opts))\n924:             choices.append(choice)\n925:         return choices\n926: \n927:     def get_action(self, action):\n928:         \"\"\"\n929:         Return a given action from a parameter, which can either be a callable,\n930:         or the name of a method on the ModelAdmin.  Return is a tuple of\n931:         (callable, name, description).\n932:         \"\"\"\n933:         # If the action is a callable, just use it.\n934:         if callable(action):\n935:             func = action\n936:             action = action.__name__\n937: \n938:         # Next, look for a method. Grab it off self.__class__ to get an unbound\n939:         # method instead of a bound one; this ensures that the calling\n940:         # conventions are the same for functions and methods.\n941:         elif hasattr(self.__class__, action):\n942:             func = getattr(self.__class__, action)\n943: \n944:         # Finally, look for a named method on the admin site\n945:         else:\n946:             try:\n947:                 func = self.admin_site.get_action(action)\n948:             except KeyError:\n949:                 return None\n950: \n951:         description = self._get_action_description(func, action)\n952:         return func, action, description\n953: \n954:     def get_list_display(self, request):\n955:         \"\"\"\n956:         Return a sequence containing the fields to be displayed on the\n957:         changelist.\n958:         \"\"\"\n959:         return self.list_display\n960: \n961:     def get_list_display_links(self, request, list_display):\n962:         \"\"\"\n963:         Return a sequence containing the fields to be displayed as links\n964:         on the changelist. The list_display parameter is the list of fields\n965:         returned by get_list_display().\n966:         \"\"\"\n967:         if self.list_display_links or self.list_display_links is None or not list_display:\n968:             return self.list_display_links\n969:         else:\n970:             # Use only the first item in list_display as link\n971:             return list(list_display)[:1]\n972: \n973:     def get_list_filter(self, request):\n974:         \"\"\"\n975:         Return a sequence containing the fields to be displayed as filters in\n976:         the right sidebar of the changelist page.\n977:         \"\"\"\n978:         return self.list_filter\n979: \n980:     def get_list_select_related(self, request):\n981:         \"\"\"\n982:         Return a list of fields to add to the select_related() part of the\n983:         changelist items query.\n984:         \"\"\"\n985:         return self.list_select_related\n986: \n987:     def get_search_fields(self, request):\n988:         \"\"\"\n989:         Return a sequence containing the fields to be searched whenever\n990:         somebody submits a search query.\n991:         \"\"\"\n992:         return self.search_fields\n993: \n994:     def get_search_results(self, request, queryset, search_term):\n995:         \"\"\"\n996:         Return a tuple containing a queryset to implement the search\n997:         and a boolean indicating if the results may contain duplicates.\n998:         \"\"\"\n999:         # Apply keyword searches.\n1000:         def construct_search(field_name):\n1001:             if field_name.startswith('^'):\n1002:                 return \"%s__istartswith\" % field_name[1:]\n1003:             elif field_name.startswith('='):\n1004:                 return \"%s__iexact\" % field_name[1:]\n1005:             elif field_name.startswith('@'):\n1006:                 return \"%s__search\" % field_name[1:]\n1007:             # Use field_name if it includes a lookup.\n1008:             opts = queryset.model._meta\n1009:             lookup_fields = field_name.split(LOOKUP_SEP)\n1010:             # Go through the fields, following all relations.\n1011:             prev_field = None\n1012:             for path_part in lookup_fields:\n1013:                 if path_part == 'pk':\n1014:                     path_part = opts.pk.name\n1015:                 try:\n1016:                     field = opts.get_field(path_part)\n1017:                 except FieldDoesNotExist:\n1018:                     # Use valid query lookups.\n1019:                     if prev_field and prev_field.get_lookup(path_part):\n1020:                         return field_name\n1021:                 else:\n1022:                     prev_field = field\n1023:                     if hasattr(field, 'path_infos'):\n1024:                         # Update opts to follow the relation.\n1025:                         opts = field.path_infos[-1].to_opts\n1026:             # Otherwise, use the field with icontains.\n1027:             return \"%s__icontains\" % field_name\n1028: \n1029:         may_have_duplicates = False\n1030:         search_fields = self.get_search_fields(request)\n1031:         if search_fields and search_term:\n1032:             orm_lookups = [construct_search(str(search_field))\n1033:                            for search_field in search_fields]\n1034:             for bit in smart_split(search_term):\n1035:                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n1036:                     bit = unescape_string_literal(bit)\n1037:                 or_queries = models.Q(\n1038:                     *((orm_lookup, bit) for orm_lookup in orm_lookups),\n1039:                     _connector=models.Q.OR,\n1040:                 )\n1041:                 queryset = queryset.filter(or_queries)\n1042:             may_have_duplicates |= any(\n1043:                 lookup_spawns_duplicates(self.opts, search_spec)\n1044:                 for search_spec in orm_lookups\n1045:             )\n1046:         return queryset, may_have_duplicates\n1047: \n1048:     def get_preserved_filters(self, request):\n1049:         \"\"\"\n1050:         Return the preserved filters querystring.\n1051:         \"\"\"\n1052:         match = request.resolver_match\n1053:         if self.preserve_filters and match:\n1054:             opts = self.model._meta\n1055:             current_url = '%s:%s' % (match.app_name, match.url_name)\n1056:             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)\n1057:             if current_url == changelist_url:\n1058:                 preserved_filters = request.GET.urlencode()\n1059:             else:\n1060:                 preserved_filters = request.GET.get('_changelist_filters')\n1061: \n1062:             if preserved_filters:\n1063:                 return urlencode({'_changelist_filters': preserved_filters})\n1064:         return ''\n1065: \n1066:     def construct_change_message(self, request, form, formsets, add=False):\n1067:         \"\"\"\n1068:         Construct a JSON structure describing changes from a changed object.\n1069:         \"\"\"\n1070:         return construct_change_message(form, formsets, add)\n1071: \n1072:     def message_user(self, request, message, level=messages.INFO, extra_tags='',\n1073:                      fail_silently=False):\n1074:         \"\"\"\n1075:         Send a message to the user. The default implementation\n1076:         posts a message using the django.contrib.messages backend.\n1077: \n1078:         Exposes almost the same API as messages.add_message(), but accepts the\n1079:         positional arguments in a different order to maintain backwards\n1080:         compatibility. For convenience, it accepts the `level` argument as\n1081:         a string rather than the usual level number.\n1082:         \"\"\"\n1083:         if not isinstance(level, int):\n1084:             # attempt to get the level if passed a string\n1085:             try:\n1086:                 level = getattr(messages.constants, level.upper())\n1087:             except AttributeError:\n1088:                 levels = messages.constants.DEFAULT_TAGS.values()\n1089:                 levels_repr = ', '.join('`%s`' % level for level in levels)\n1090:                 raise ValueError(\n1091:                     'Bad message level string: `%s`. Possible values are: %s'\n1092:                     % (level, levels_repr)\n1093:                 )\n1094: \n1095:         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)\n1096: \n1097:     def save_form(self, request, form, change):\n1098:         \"\"\"\n1099:         Given a ModelForm return an unsaved instance. ``change`` is True if\n1100:         the object is being changed, and False if it's being added.\n1101:         \"\"\"\n1102:         return form.save(commit=False)\n1103: \n1104:     def save_model(self, request, obj, form, change):\n1105:         \"\"\"\n1106:         Given a model instance save it to the database.\n1107:         \"\"\"\n1108:         obj.save()\n1109: \n1110:     def delete_model(self, request, obj):\n1111:         \"\"\"\n1112:         Given a model instance delete it from the database.\n1113:         \"\"\"\n1114:         obj.delete()\n1115: \n1116:     def delete_queryset(self, request, queryset):\n1117:         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1118:         queryset.delete()\n1119: \n1120:     def save_formset(self, request, form, formset, change):\n1121:         \"\"\"\n1122:         Given an inline formset save it to the database.\n1123:         \"\"\"\n1124:         formset.save()\n1125: \n1126:     def save_related(self, request, form, formsets, change):\n1127:         \"\"\"\n1128:         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1129:         list of inline formsets and a boolean value based on whether the\n1130:         parent is being added or changed, save the related objects to the\n1131:         database. Note that at this point save_form() and save_model() have\n1132:         already been called.\n1133:         \"\"\"\n1134:         form.save_m2m()\n1135:         for formset in formsets:\n1136:             self.save_formset(request, form, formset, change=change)\n1137: \n1138:     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):\n1139:         opts = self.model._meta\n1140:         app_label = opts.app_label\n1141:         preserved_filters = self.get_preserved_filters(request)\n1142:         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)\n1143:         view_on_site_url = self.get_view_on_site_url(obj)\n1144:         has_editable_inline_admin_formsets = False\n1145:         for inline in context['inline_admin_formsets']:\n1146:             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:\n1147:                 has_editable_inline_admin_formsets = True\n1148:                 break\n1149:         context.update({\n1150:             'add': add,\n1151:             'change': change,\n1152:             'has_view_permission': self.has_view_permission(request, obj),\n1153:             'has_add_permission': self.has_add_permission(request),\n1154:             'has_change_permission': self.has_change_permission(request, obj),\n1155:             'has_delete_permission': self.has_delete_permission(request, obj),\n1156:             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,\n1157:             'has_file_field': context['adminform'].form.is_multipart() or any(\n1158:                 admin_formset.formset.is_multipart()\n1159:                 for admin_formset in context['inline_admin_formsets']\n1160:             ),\n1161:             'has_absolute_url': view_on_site_url is not None,\n1162:             'absolute_url': view_on_site_url,\n1163:             'form_url': form_url,\n1164:             'opts': opts,\n1165:             'content_type_id': get_content_type_for_model(self.model).pk,\n1166:             'save_as': self.save_as,\n1167:             'save_on_top': self.save_on_top,\n1168:             'to_field_var': TO_FIELD_VAR,\n1169:             'is_popup_var': IS_POPUP_VAR,\n1170:             'app_label': app_label,\n1171:         })\n1172:         if add and self.add_form_template is not None:\n1173:             form_template = self.add_form_template\n1174:         else:\n1175:             form_template = self.change_form_template\n1176: \n1177:         request.current_app = self.admin_site.name\n1178: \n1179:         return TemplateResponse(request, form_template or [\n1180:             \"admin/%s/%s/change_form.html\" % (app_label, opts.model_name),\n1181:             \"admin/%s/change_form.html\" % app_label,\n1182:             \"admin/change_form.html\"\n1183:         ], context)\n1184: \n1185:     def response_add(self, request, obj, post_url_continue=None):\n1186:         \"\"\"\n1187:         Determine the HttpResponse for the add_view stage.\n1188:         \"\"\"\n1189:         opts = obj._meta\n1190:         preserved_filters = self.get_preserved_filters(request)\n1191:         obj_url = reverse(\n1192:             'admin:%s_%s_change' % (opts.app_label, opts.model_name),\n1193:             args=(quote(obj.pk),),\n1194:             current_app=self.admin_site.name,\n1195:         )\n1196:         # Add a link to the object's change form if the user can edit the obj.\n1197:         if self.has_change_permission(request, obj):\n1198:             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1199:         else:\n1200:             obj_repr = str(obj)\n1201:         msg_dict = {\n1202:             'name': opts.verbose_name,\n1203:             'obj': obj_repr,\n1204:         }\n1205:         # Here, we distinguish between different save types by checking for\n1206:         # the presence of keys in request.POST.\n1207: \n1208:         if IS_POPUP_VAR in request.POST:\n1209:             to_field = request.POST.get(TO_FIELD_VAR)\n1210:             if to_field:\n1211:                 attr = str(to_field)\n1212:             else:\n1213:                 attr = obj._meta.pk.attname\n1214:             value = obj.serializable_value(attr)\n1215:             popup_response_data = json.dumps({\n1216:                 'value': str(value),\n1217:                 'obj': str(obj),\n1218:             })\n1219:             return TemplateResponse(request, self.popup_response_template or [\n1220:                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1221:                 'admin/%s/popup_response.html' % opts.app_label,\n1222:                 'admin/popup_response.html',\n1223:             ], {\n1224:                 'popup_response_data': popup_response_data,\n1225:             })\n1226: \n1227:         elif \"_continue\" in request.POST or (\n1228:                 # Redirecting after \"Save as new\".\n1229:                 \"_saveasnew\" in request.POST and self.save_as_continue and\n1230:                 self.has_change_permission(request, obj)\n1231:         ):\n1232:             msg = _('The {name} “{obj}” was added successfully.')\n1233:             if self.has_change_permission(request, obj):\n1234:                 msg += ' ' + _('You may edit it again below.')\n1235:             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1236:             if post_url_continue is None:\n1237:                 post_url_continue = obj_url\n1238:             post_url_continue = add_preserved_filters(\n1239:                 {'preserved_filters': preserved_filters, 'opts': opts},\n1240:                 post_url_continue\n1241:             )\n1242:             return HttpResponseRedirect(post_url_continue)\n1243: \n1244:         elif \"_addanother\" in request.POST:\n1245:             msg = format_html(\n1246:                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),\n1247:                 **msg_dict\n1248:             )\n1249:             self.message_user(request, msg, messages.SUCCESS)\n1250:             redirect_url = request.path\n1251:             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1252:             return HttpResponseRedirect(redirect_url)\n1253: \n1254:         else:\n1255:             msg = format_html(\n1256:                 _('The {name} “{obj}” was added successfully.'),\n1257:                 **msg_dict\n1258:             )\n1259:             self.message_user(request, msg, messages.SUCCESS)\n1260:             return self.response_post_save_add(request, obj)\n1261: \n1262:     def response_change(self, request, obj):\n1263:         \"\"\"\n1264:         Determine the HttpResponse for the change_view stage.\n1265:         \"\"\"\n1266: \n1267:         if IS_POPUP_VAR in request.POST:\n1268:             opts = obj._meta\n1269:             to_field = request.POST.get(TO_FIELD_VAR)\n1270:             attr = str(to_field) if to_field else opts.pk.attname\n1271:             value = request.resolver_match.kwargs['object_id']\n1272:             new_value = obj.serializable_value(attr)\n1273:             popup_response_data = json.dumps({\n1274:                 'action': 'change',\n1275:                 'value': str(value),\n1276:                 'obj': str(obj),\n1277:                 'new_value': str(new_value),\n1278:             })\n1279:             return TemplateResponse(request, self.popup_response_template or [\n1280:                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1281:                 'admin/%s/popup_response.html' % opts.app_label,\n1282:                 'admin/popup_response.html',\n1283:             ], {\n1284:                 'popup_response_data': popup_response_data,\n1285:             })\n1286: \n1287:         opts = self.model._meta\n1288:         preserved_filters = self.get_preserved_filters(request)\n1289: \n1290:         msg_dict = {\n1291:             'name': opts.verbose_name,\n1292:             'obj': format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1293:         }\n1294:         if \"_continue\" in request.POST:\n1295:             msg = format_html(\n1296:                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),\n1297:                 **msg_dict\n1298:             )\n1299:             self.message_user(request, msg, messages.SUCCESS)\n1300:             redirect_url = request.path\n1301:             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1302:             return HttpResponseRedirect(redirect_url)\n1303: \n1304:         elif \"_saveasnew\" in request.POST:\n1305:             msg = format_html(\n1306:                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),\n1307:                 **msg_dict\n1308:             )\n1309:             self.message_user(request, msg, messages.SUCCESS)\n1310:             redirect_url = reverse('admin:%s_%s_change' %\n1311:                                    (opts.app_label, opts.model_name),\n1312:                                    args=(obj.pk,),\n1313:                                    current_app=self.admin_site.name)\n1314:             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1315:             return HttpResponseRedirect(redirect_url)\n1316: \n1317:         elif \"_addanother\" in request.POST:\n1318:             msg = format_html(\n1319:                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),\n1320:                 **msg_dict\n1321:             )\n1322:             self.message_user(request, msg, messages.SUCCESS)\n1323:             redirect_url = reverse('admin:%s_%s_add' %\n1324:                                    (opts.app_label, opts.model_name),\n1325:                                    current_app=self.admin_site.name)\n1326:             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1327:             return HttpResponseRedirect(redirect_url)\n1328: \n1329:         else:\n1330:             msg = format_html(\n1331:                 _('The {name} “{obj}” was changed successfully.'),\n1332:                 **msg_dict\n1333:             )\n1334:             self.message_user(request, msg, messages.SUCCESS)\n1335:             return self.response_post_save_change(request, obj)\n1336: \n1337:     def _response_post_save(self, request, obj):\n1338:         opts = self.model._meta\n1339:         if self.has_view_or_change_permission(request):\n1340:             post_url = reverse('admin:%s_%s_changelist' %\n1341:                                (opts.app_label, opts.model_name),\n1342:                                current_app=self.admin_site.name)\n1343:             preserved_filters = self.get_preserved_filters(request)\n1344:             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)\n1345:         else:\n1346:             post_url = reverse('admin:index',\n1347:                                current_app=self.admin_site.name)\n1348:         return HttpResponseRedirect(post_url)\n1349: \n1350:     def response_post_save_add(self, request, obj):\n1351:         \"\"\"\n1352:         Figure out where to redirect after the 'Save' button has been pressed\n1353:         when adding a new object.\n1354:         \"\"\"\n1355:         return self._response_post_save(request, obj)\n1356: \n1357:     def response_post_save_change(self, request, obj):\n1358:         \"\"\"\n1359:         Figure out where to redirect after the 'Save' button has been pressed\n1360:         when editing an existing object.\n1361:         \"\"\"\n1362:         return self._response_post_save(request, obj)\n1363: \n1364:     def response_action(self, request, queryset):\n1365:         \"\"\"\n1366:         Handle an admin action. This is called if a request is POSTed to the\n1367:         changelist; it returns an HttpResponse if the action was handled, and\n1368:         None otherwise.\n1369:         \"\"\"\n1370: \n1371:         # There can be multiple action forms on the page (at the top\n1372:         # and bottom of the change list, for example). Get the action\n1373:         # whose button was pushed.\n1374:         try:\n1375:             action_index = int(request.POST.get('index', 0))\n1376:         except ValueError:\n1377:             action_index = 0\n1378: \n1379:         # Construct the action form.\n1380:         data = request.POST.copy()\n1381:         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1382:         data.pop(\"index\", None)\n1383: \n1384:         # Use the action whose button was pushed\n1385:         try:\n1386:             data.update({'action': data.getlist('action')[action_index]})\n1387:         except IndexError:\n1388:             # If we didn't get an action from the chosen form that's invalid\n1389:             # POST data, so by deleting action it'll fail the validation check\n1390:             # below. So no need to do anything here\n1391:             pass\n1392: \n1393:         action_form = self.action_form(data, auto_id=None)\n1394:         action_form.fields['action'].choices = self.get_action_choices(request)\n1395: \n1396:         # If the form's valid we can handle the action.\n1397:         if action_form.is_valid():\n1398:             action = action_form.cleaned_data['action']\n1399:             select_across = action_form.cleaned_data['select_across']\n1400:             func = self.get_actions(request)[action][0]\n1401: \n1402:             # Get the list of selected PKs. If nothing's selected, we can't\n1403:             # perform an action on it, so bail. Except we want to perform\n1404:             # the action explicitly on all objects.\n1405:             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1406:             if not selected and not select_across:\n1407:                 # Reminder that something needs to be selected or nothing will happen\n1408:                 msg = _(\"Items must be selected in order to perform \"\n1409:                         \"actions on them. No items have been changed.\")\n1410:                 self.message_user(request, msg, messages.WARNING)\n1411:                 return None\n1412: \n1413:             if not select_across:\n1414:                 # Perform the action only on the selected objects\n1415:                 queryset = queryset.filter(pk__in=selected)\n1416: \n1417:             response = func(self, request, queryset)\n1418: \n1419:             # Actions may return an HttpResponse-like object, which will be\n1420:             # used as the response from the POST. If not, we'll be a good\n1421:             # little HTTP citizen and redirect back to the changelist page.\n1422:             if isinstance(response, HttpResponseBase):\n1423:                 return response\n1424:             else:\n1425:                 return HttpResponseRedirect(request.get_full_path())\n1426:         else:\n1427:             msg = _(\"No action selected.\")\n1428:             self.message_user(request, msg, messages.WARNING)\n1429:             return None\n1430: \n1431:     def response_delete(self, request, obj_display, obj_id):\n1432:         \"\"\"\n1433:         Determine the HttpResponse for the delete_view stage.\n1434:         \"\"\"\n1435:         opts = self.model._meta\n1436: \n1437:         if IS_POPUP_VAR in request.POST:\n1438:             popup_response_data = json.dumps({\n1439:                 'action': 'delete',\n1440:                 'value': str(obj_id),\n1441:             })\n1442:             return TemplateResponse(request, self.popup_response_template or [\n1443:                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1444:                 'admin/%s/popup_response.html' % opts.app_label,\n1445:                 'admin/popup_response.html',\n1446:             ], {\n1447:                 'popup_response_data': popup_response_data,\n1448:             })\n1449: \n1450:         self.message_user(\n1451:             request,\n1452:             _('The %(name)s “%(obj)s” was deleted successfully.') % {\n1453:                 'name': opts.verbose_name,\n1454:                 'obj': obj_display,\n1455:             },\n1456:             messages.SUCCESS,\n1457:         )\n1458: \n1459:         if self.has_change_permission(request, None):\n1460:             post_url = reverse(\n1461:                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),\n1462:                 current_app=self.admin_site.name,\n1463:             )\n1464:             preserved_filters = self.get_preserved_filters(request)\n1465:             post_url = add_preserved_filters(\n1466:                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url\n1467:             )\n1468:         else:\n1469:             post_url = reverse('admin:index', current_app=self.admin_site.name)\n1470:         return HttpResponseRedirect(post_url)\n1471: \n1472:     def render_delete_form(self, request, context):\n1473:         opts = self.model._meta\n1474:         app_label = opts.app_label\n1475: \n1476:         request.current_app = self.admin_site.name\n1477:         context.update(\n1478:             to_field_var=TO_FIELD_VAR,\n1479:             is_popup_var=IS_POPUP_VAR,\n1480:             media=self.media,\n1481:         )\n1482: \n1483:         return TemplateResponse(\n1484:             request,\n1485:             self.delete_confirmation_template or [\n1486:                 \"admin/{}/{}/delete_confirmation.html\".format(app_label, opts.model_name),\n1487:                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1488:                 \"admin/delete_confirmation.html\",\n1489:             ],\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/options.py",
      "suspect_lines": [
        1041
      ]
    }
  ]
}