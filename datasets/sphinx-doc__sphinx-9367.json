{
  "instance_id": "sphinx-doc__sphinx-9367",
  "problem_statement": "1-element tuple rendered incorrectly\n**Describe the bug**\r\nThis is a followup to #7964 which has been addressed in #8265.\r\n\r\nHowever the special case of a 1-element tuple is still not handled correctly.\r\n\r\n`(1,)` is rendered as `(1)`, but should keep the trailing comma.\r\n\r\n**To Reproduce**\r\nAdd a testcase\r\n```\r\n    (\"(1,)\", \"(1,)\"),                           # Tuple (single element)\r\n```\r\nat https://github.com/sphinx-doc/sphinx/blob/e0b1e1002b500acc63dfd0806f8095dd6b27037b/tests/test_pycode_ast.py#L57\r\n\r\n\n",
  "localized_code": "[start of sphinx/pycode/ast.py]\n1: \"\"\"\n2:     sphinx.pycode.ast\n3:     ~~~~~~~~~~~~~~~~~\n4: \n5:     Helpers for AST (Abstract Syntax Tree).\n6: \n7:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import sys\n12: from typing import Dict, List, Optional, Type, overload\n13: \n14: if sys.version_info > (3, 8):\n15:     import ast\n16: else:\n17:     try:\n18:         # use typed_ast module if installed\n19:         from typed_ast import ast3 as ast\n20:     except ImportError:\n21:         import ast  # type: ignore\n22: \n23: \n24: OPERATORS: Dict[Type[ast.AST], str] = {\n25:     ast.Add: \"+\",\n26:     ast.And: \"and\",\n27:     ast.BitAnd: \"&\",\n28:     ast.BitOr: \"|\",\n29:     ast.BitXor: \"^\",\n30:     ast.Div: \"/\",\n31:     ast.FloorDiv: \"//\",\n32:     ast.Invert: \"~\",\n33:     ast.LShift: \"<<\",\n34:     ast.MatMult: \"@\",\n35:     ast.Mult: \"*\",\n36:     ast.Mod: \"%\",\n37:     ast.Not: \"not\",\n38:     ast.Pow: \"**\",\n39:     ast.Or: \"or\",\n40:     ast.RShift: \">>\",\n41:     ast.Sub: \"-\",\n42:     ast.UAdd: \"+\",\n43:     ast.USub: \"-\",\n44: }\n45: \n46: \n47: def parse(code: str, mode: str = 'exec') -> \"ast.AST\":\n48:     \"\"\"Parse the *code* using built-in ast or typed_ast.\n49: \n50:     This enables \"type_comments\" feature if possible.\n51:     \"\"\"\n52:     try:\n53:         # type_comments parameter is available on py38+\n54:         return ast.parse(code, mode=mode, type_comments=True)  # type: ignore\n55:     except SyntaxError:\n56:         # Some syntax error found. To ignore invalid type comments, retry parsing without\n57:         # type_comments parameter (refs: https://github.com/sphinx-doc/sphinx/issues/8652).\n58:         return ast.parse(code, mode=mode)\n59:     except TypeError:\n60:         # fallback to ast module.\n61:         # typed_ast is used to parse type_comments if installed.\n62:         return ast.parse(code, mode=mode)\n63: \n64: \n65: @overload\n66: def unparse(node: None, code: str = '') -> None:\n67:     ...\n68: \n69: \n70: @overload\n71: def unparse(node: ast.AST, code: str = '') -> str:\n72:     ...\n73: \n74: \n75: def unparse(node: Optional[ast.AST], code: str = '') -> Optional[str]:\nCode replaced for brevity.\n81: \n82: \n83: \n84: # a greatly cut-down version of `ast._Unparser`\n85: class _UnparseVisitor(ast.NodeVisitor):\n86:     def __init__(self, code: str = '') -> None:\n87:         self.code = code\n88: \n89:     def _visit_op(self, node: ast.AST) -> str:\n90:         return OPERATORS[node.__class__]\n91:     for _op in OPERATORS:\n92:         locals()['visit_{}'.format(_op.__name__)] = _visit_op\n93: \n94:     def visit_arg(self, node: ast.arg) -> str:\n95:         if node.annotation:\n96:             return \"%s: %s\" % (node.arg, self.visit(node.annotation))\n97:         else:\n98:             return node.arg\n99: \n100:     def _visit_arg_with_default(self, arg: ast.arg, default: Optional[ast.AST]) -> str:\n101:         \"\"\"Unparse a single argument to a string.\"\"\"\n102:         name = self.visit(arg)\n103:         if default:\n104:             if arg.annotation:\n105:                 name += \" = %s\" % self.visit(default)\n106:             else:\n107:                 name += \"=%s\" % self.visit(default)\n108:         return name\n109: \n110:     def visit_arguments(self, node: ast.arguments) -> str:\n111:         defaults: List[Optional[ast.expr]] = list(node.defaults)\n112:         positionals = len(node.args)\n113:         posonlyargs = 0\n114:         if hasattr(node, \"posonlyargs\"):  # for py38+\n115:             posonlyargs += len(node.posonlyargs)  # type:ignore\n116:             positionals += posonlyargs\n117:         for _ in range(len(defaults), positionals):\n118:             defaults.insert(0, None)\n119: \n120:         kw_defaults: List[Optional[ast.expr]] = list(node.kw_defaults)\n121:         for _ in range(len(kw_defaults), len(node.kwonlyargs)):\n122:             kw_defaults.insert(0, None)\n123: \n124:         args: List[str] = []\n125:         if hasattr(node, \"posonlyargs\"):  # for py38+\n126:             for i, arg in enumerate(node.posonlyargs):  # type: ignore\n127:                 args.append(self._visit_arg_with_default(arg, defaults[i]))\n128: \n129:             if node.posonlyargs:  # type: ignore\n130:                 args.append('/')\n131: \n132:         for i, arg in enumerate(node.args):\n133:             args.append(self._visit_arg_with_default(arg, defaults[i + posonlyargs]))\n134: \n135:         if node.vararg:\n136:             args.append(\"*\" + self.visit(node.vararg))\n137: \n138:         if node.kwonlyargs and not node.vararg:\n139:             args.append('*')\n140:         for i, arg in enumerate(node.kwonlyargs):\n141:             args.append(self._visit_arg_with_default(arg, kw_defaults[i]))\n142: \n143:         if node.kwarg:\n144:             args.append(\"**\" + self.visit(node.kwarg))\n145: \n146:         return \", \".join(args)\n147: \n148:     def visit_Attribute(self, node: ast.Attribute) -> str:\n149:         return \"%s.%s\" % (self.visit(node.value), node.attr)\n150: \n151:     def visit_BinOp(self, node: ast.BinOp) -> str:\n152:         return \" \".join(self.visit(e) for e in [node.left, node.op, node.right])\n153: \n154:     def visit_BoolOp(self, node: ast.BoolOp) -> str:\n155:         op = \" %s \" % self.visit(node.op)\n156:         return op.join(self.visit(e) for e in node.values)\n157: \n158:     def visit_Call(self, node: ast.Call) -> str:\n159:         args = ([self.visit(e) for e in node.args] +\n160:                 [\"%s=%s\" % (k.arg, self.visit(k.value)) for k in node.keywords])\n161:         return \"%s(%s)\" % (self.visit(node.func), \", \".join(args))\n162: \n163:     def visit_Constant(self, node: ast.Constant) -> str:  # type: ignore\n164:         if node.value is Ellipsis:\n165:             return \"...\"\n166:         elif isinstance(node.value, (int, float, complex)):\n167:             if self.code and sys.version_info > (3, 8):\n168:                 return ast.get_source_segment(self.code, node)  # type: ignore\n169:             else:\n170:                 return repr(node.value)\n171:         else:\n172:             return repr(node.value)\n173: \n174:     def visit_Dict(self, node: ast.Dict) -> str:\n175:         keys = (self.visit(k) for k in node.keys)\n176:         values = (self.visit(v) for v in node.values)\n177:         items = (k + \": \" + v for k, v in zip(keys, values))\n178:         return \"{\" + \", \".join(items) + \"}\"\n179: \n180:     def visit_Index(self, node: ast.Index) -> str:\n181:         return self.visit(node.value)\n182: \n183:     def visit_Lambda(self, node: ast.Lambda) -> str:\n184:         return \"lambda %s: ...\" % self.visit(node.args)\n185: \n186:     def visit_List(self, node: ast.List) -> str:\n187:         return \"[\" + \", \".join(self.visit(e) for e in node.elts) + \"]\"\n188: \n189:     def visit_Name(self, node: ast.Name) -> str:\n190:         return node.id\n191: \n192:     def visit_Set(self, node: ast.Set) -> str:\n193:         return \"{\" + \", \".join(self.visit(e) for e in node.elts) + \"}\"\n194: \n195:     def visit_Subscript(self, node: ast.Subscript) -> str:\n196:         def is_simple_tuple(value: ast.AST) -> bool:\n197:             return (\n198:                 isinstance(value, ast.Tuple) and\n199:                 bool(value.elts) and\n200:                 not any(isinstance(elt, ast.Starred) for elt in value.elts)\n201:             )\n202: \n203:         if is_simple_tuple(node.slice):\n204:             elts = \", \".join(self.visit(e) for e in node.slice.elts)  # type: ignore\n205:             return \"%s[%s]\" % (self.visit(node.value), elts)\n206:         elif isinstance(node.slice, ast.Index) and is_simple_tuple(node.slice.value):\n207:             elts = \", \".join(self.visit(e) for e in node.slice.value.elts)  # type: ignore\n208:             return \"%s[%s]\" % (self.visit(node.value), elts)\n209:         else:\n210:             return \"%s[%s]\" % (self.visit(node.value), self.visit(node.slice))\n211: \n212:     def visit_UnaryOp(self, node: ast.UnaryOp) -> str:\n213:         return \"%s %s\" % (self.visit(node.op), self.visit(node.operand))\n214: \n215:     def visit_Tuple(self, node: ast.Tuple) -> str:\n216:         if node.elts:\n217:             return \"(\" + \", \".join(self.visit(e) for e in node.elts) + \")\"\n218:         else:\n219:             return \"()\"\n220: \n221:     if sys.version_info < (3, 8):\n222:         # these ast nodes were deprecated in python 3.8\n223:         def visit_Bytes(self, node: ast.Bytes) -> str:\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/pycode/ast.py",
      "suspect_lines": [
        216,
        217,
        218
      ]
    }
  ]
}