{
  "instance_id": "django__django-14787",
  "problem_statement": "method_decorator() should preserve wrapper assignments\nDescription\n\t\nthe function that is passed to the decorator is a partial object and does not have any of the attributes expected from a function i.e. __name__, __module__ etc...\nconsider the following case\ndef logger(func):\n\t@wraps(func)\n\tdef inner(*args, **kwargs):\n\t\ttry:\n\t\t\tresult = func(*args, **kwargs)\n\t\texcept Exception as e:\n\t\t\tresult = str(e)\n\t\tfinally:\n\t\t\tlogger.debug(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\n\treturn inner\nclass Test:\n\t@method_decorator(logger)\n\tdef hello_world(self):\n\t\treturn \"hello\"\nTest().test_method()\nThis results in the following exception\nAttributeError: 'functools.partial' object has no attribute '__name__'\n",
  "localized_code": "[start of django/utils/decorators.py]\n1: \"Functions that help with dynamically creating decorators for views.\"\n2: \n3: from functools import partial, update_wrapper, wraps\n4: \n5: \n6: class classonlymethod(classmethod):\n7:     def __get__(self, instance, cls=None):\n8:         if instance is not None:\n9:             raise AttributeError(\"This method is available only on the class, not on instances.\")\n10:         return super().__get__(instance, cls)\n11: \n12: \n13: def _update_method_wrapper(_wrapper, decorator):\n14:     # _multi_decorate()'s bound_method isn't available in this scope. Cheat by\n15:     # using it on a dummy function.\n16:     @decorator\n17:     def dummy(*args, **kwargs):\n18:         pass\n19:     update_wrapper(_wrapper, dummy)\n20: \n21: \n22: def _multi_decorate(decorators, method):\n23:     \"\"\"\n24:     Decorate `method` with one or more function decorators. `decorators` can be\n25:     a single decorator or an iterable of decorators.\n26:     \"\"\"\n27:     if hasattr(decorators, '__iter__'):\n28:         # Apply a list/tuple of decorators if 'decorators' is one. Decorator\n29:         # functions are applied so that the call order is the same as the\n30:         # order in which they appear in the iterable.\n31:         decorators = decorators[::-1]\n32:     else:\n33:         decorators = [decorators]\n34: \n35:     def _wrapper(self, *args, **kwargs):\n36:         # bound_method has the signature that 'decorator' expects i.e. no\n37:         # 'self' argument, but it's a closure over self so it can call\n38:         # 'func'. Also, wrap method.__get__() in a function because new\n39:         # attributes can't be set on bound method objects, only on functions.\n40:         bound_method = partial(method.__get__(self, type(self)))\n41:         for dec in decorators:\n42:             bound_method = dec(bound_method)\n43:         return bound_method(*args, **kwargs)\n44: \n45:     # Copy any attributes that a decorator adds to the function it decorates.\n46:     for dec in decorators:\n47:         _update_method_wrapper(_wrapper, dec)\n48:     # Preserve any existing attributes of 'method', including the name.\n49:     update_wrapper(_wrapper, method)\n50:     return _wrapper\n51: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/decorators.py",
      "suspect_lines": [
        40
      ]
    }
  ]
}