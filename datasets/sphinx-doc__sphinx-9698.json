{
  "instance_id": "sphinx-doc__sphinx-9698",
  "problem_statement": "An index entry with parens was registered for `py:method` directive with `:property:` option\n### Describe the bug\n\nAn index entry with parens was registered for `py:method` directive with `:property:` option. It should not have parens.\r\n\n\n### How to Reproduce\n\n```\r\n# index.rst\r\n\r\n.. py:method:: Foo.bar\r\n   :property:\r\n\r\n.. py:property:: Foo.baz\r\n```\n\n### Expected behavior\n\nAn index entry for the property should not have parens.\n\n### Your project\n\nN/A\n\n### Screenshots\n\n<img width=\"528\" alt=\"スクリーンショット 2021-10-03 13 00 53\" src=\"https://user-images.githubusercontent.com/748828/135739148-7f404a37-159b-4032-ac68-efb0aaacb726.png\">\r\n\n\n### OS\n\nMac\n\n### Python version\n\n3.9.6\n\n### Sphinx version\n\nHEAD of 4.x\n\n### Sphinx extensions\n\n_No response_\n\n### Extra tools\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "localized_code": "[start of sphinx/domains/python.py]\n1: \"\"\"\n2:     sphinx.domains.python\n3:     ~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     The Python domain.\n6: \n7:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import builtins\n12: import inspect\n13: import re\n14: import sys\n15: import typing\n16: import warnings\n17: from inspect import Parameter\n18: from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Optional, Tuple, Type, cast\n19: \n20: from docutils import nodes\n21: from docutils.nodes import Element, Node\n22: from docutils.parsers.rst import directives\n23: from docutils.parsers.rst.states import Inliner\n24: \n25: from sphinx import addnodes\n26: from sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\n27: from sphinx.application import Sphinx\n28: from sphinx.builders import Builder\n29: from sphinx.deprecation import RemovedInSphinx50Warning\n30: from sphinx.directives import ObjectDescription\n31: from sphinx.domains import Domain, Index, IndexEntry, ObjType\n32: from sphinx.environment import BuildEnvironment\n33: from sphinx.locale import _, __\n34: from sphinx.pycode.ast import ast\n35: from sphinx.pycode.ast import parse as ast_parse\n36: from sphinx.roles import XRefRole\n37: from sphinx.util import logging\n38: from sphinx.util.docfields import Field, GroupedField, TypedField\n39: from sphinx.util.docutils import SphinxDirective\n40: from sphinx.util.inspect import signature_from_str\n41: from sphinx.util.nodes import find_pending_xref_condition, make_id, make_refnode\n42: from sphinx.util.typing import OptionSpec, TextlikeNode\n43: \n44: logger = logging.getLogger(__name__)\n45: \n46: \n47: # REs for Python signatures\n48: py_sig_re = re.compile(\n49:     r'''^ ([\\w.]*\\.)?            # class name(s)\n50:           (\\w+)  \\s*             # thing name\n51:           (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n52:            (?:\\s* -> \\s* (.*))?  #           return annotation\n53:           )? $                   # and nothing more\n54:           ''', re.VERBOSE)\n55: \n56: \n57: pairindextypes = {\n58:     'module':    _('module'),\n59:     'keyword':   _('keyword'),\n60:     'operator':  _('operator'),\n61:     'object':    _('object'),\n62:     'exception': _('exception'),\n63:     'statement': _('statement'),\n64:     'builtin':   _('built-in function'),\n65: }\n66: \n67: \n68: class ObjectEntry(NamedTuple):\nCode replaced for brevity.\n72: \n73: \n74: \n75: class ModuleEntry(NamedTuple):\nCode replaced for brevity.\n80: \n81: \n82: \n83: def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\nCode replaced for brevity.\n107: \n108: \n109: \n110: def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\nCode replaced for brevity.\n208: \n209: \n210: \n211: def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\nCode replaced for brevity.\n258: \n259: \n260: \n261: def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\nCode replaced for brevity.\n307: \n308: \n309: \n310: # This override allows our inline type specifiers to behave like :class: link\n311: # when it comes to handling \".\" and \"~\" prefixes.\n312: class PyXrefMixin:\nCode replaced for brevity.\n367: \n368: \n369: \n370: class PyField(PyXrefMixin, Field):\nCode replaced for brevity.\n380: \n381: \n382: \n383: class PyGroupedField(PyXrefMixin, GroupedField):\n384:     pass\n385: \n386: \n387: class PyTypedField(PyXrefMixin, TypedField):\nCode replaced for brevity.\n397: \n398: \n399: \n400: class PyObject(ObjectDescription[Tuple[str, str]]):\nCode replaced for brevity.\n618: \n619: \n620: \n621: class PyFunction(PyObject):\nCode replaced for brevity.\n656: \n657: \n658: \n659: class PyDecoratorFunction(PyFunction):\nCode replaced for brevity.\n673: \n674: \n675: \n676: class PyVariable(PyObject):\nCode replaced for brevity.\n710: \n711: \n712: \n713: class PyClasslike(PyObject):\nCode replaced for brevity.\n740: \n741: \n742: \n743: class PyMethod(PyObject):\n744:     \"\"\"Description of a method.\"\"\"\n745: \n746:     option_spec: OptionSpec = PyObject.option_spec.copy()\n747:     option_spec.update({\n748:         'abstractmethod': directives.flag,\n749:         'async': directives.flag,\n750:         'classmethod': directives.flag,\n751:         'final': directives.flag,\n752:         'property': directives.flag,\n753:         'staticmethod': directives.flag,\n754:     })\n755: \n756:     def needs_arglist(self) -> bool:\n757:         if 'property' in self.options:\n758:             return False\n759:         else:\n760:             return True\n761: \n762:     def get_signature_prefix(self, sig: str) -> List[nodes.Node]:\n763:         prefix: List[nodes.Node] = []\n764:         if 'final' in self.options:\n765:             prefix.append(nodes.Text('final'))\n766:             prefix.append(addnodes.desc_sig_space())\n767:         if 'abstractmethod' in self.options:\n768:             prefix.append(nodes.Text('abstract'))\n769:             prefix.append(addnodes.desc_sig_space())\n770:         if 'async' in self.options:\n771:             prefix.append(nodes.Text('async'))\n772:             prefix.append(addnodes.desc_sig_space())\n773:         if 'classmethod' in self.options:\n774:             prefix.append(nodes.Text('classmethod'))\n775:             prefix.append(addnodes.desc_sig_space())\n776:         if 'property' in self.options:\n777:             prefix.append(nodes.Text('property'))\n778:             prefix.append(addnodes.desc_sig_space())\n779:         if 'staticmethod' in self.options:\n780:             prefix.append(nodes.Text('static'))\n781:             prefix.append(addnodes.desc_sig_space())\n782:         return prefix\n783: \n784:     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n785:         name, cls = name_cls\n786:         try:\n787:             clsname, methname = name.rsplit('.', 1)\n788:             if modname and self.env.config.add_module_names:\n789:                 clsname = '.'.join([modname, clsname])\n790:         except ValueError:\n791:             if modname:\n792:                 return _('%s() (in module %s)') % (name, modname)\n793:             else:\n794:                 return '%s()' % name\n795: \n796:         if 'classmethod' in self.options:\n797:             return _('%s() (%s class method)') % (methname, clsname)\n798:         elif 'property' in self.options:\n799:             return _('%s() (%s property)') % (methname, clsname)\n800:         elif 'staticmethod' in self.options:\n801:             return _('%s() (%s static method)') % (methname, clsname)\n802:         else:\n803:             return _('%s() (%s method)') % (methname, clsname)\n804: \n805: \n806: class PyClassMethod(PyMethod):\nCode replaced for brevity.\n815: \n816: \n817: \n818: class PyStaticMethod(PyMethod):\nCode replaced for brevity.\n827: \n828: \n829: \n830: class PyDecoratorMethod(PyMethod):\nCode replaced for brevity.\n843: \n844: \n845: \n846: class PyAttribute(PyObject):\nCode replaced for brevity.\n888: \n889: \n890: \n891: class PyProperty(PyObject):\nCode replaced for brevity.\n939: \n940: \n941: \n942: class PyDecoratorMixin:\nCode replaced for brevity.\n962: \n963: \n964: \n965: class PyModule(SphinxDirective):\nCode replaced for brevity.\n1025: \n1026: \n1027: \n1028: class PyCurrentModule(SphinxDirective):\nCode replaced for brevity.\n1046: \n1047: \n1048: \n1049: class PyXRefRole(XRefRole):\nCode replaced for brevity.\n1069: \n1070: \n1071: \n1072: def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\nCode replaced for brevity.\n1084: \n1085: \n1086: \n1087: class PythonModuleIndex(Index):\nCode replaced for brevity.\n1156: \n1157: \n1158: \n1159: class PythonDomain(Domain):\nCode replaced for brevity.\n1428: \n1429: \n1430: \n1431:                      node: pending_xref, contnode: Element) -> Element:\nCode replaced for brevity.\n1453: \n1454: \n1455: \n1456: def setup(app: Sphinx) -> Dict[str, Any]:\nCode replaced for brevity.\n1469: \n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/domains/python.py",
      "suspect_lines": [
        799
      ]
    }
  ]
}