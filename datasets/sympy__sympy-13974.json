{
  "instance_id": "sympy__sympy-13974",
  "problem_statement": "Evaluating powers of `TensorProduct`\nPowers of tensor product expressions are not possible to evaluate with either `expand(tensorproduct=True)` method nor the `tensor_product_simp`function.\r\n\r\nThis is an example session showing the issue\r\n```\r\nIn [1]: from sympy import *\r\n        from sympy.physics.quantum import TensorProduct as tp\r\n        from sympy.physics.quantum import tensor_product_simp as tps\r\n        from sympy.physics.paulialgebra import Pauli\r\n        a = Symbol('a', commutative=False)\r\n\r\nIn [2]: t1 = tp(1,1)*tp(1,1)\r\n        t1\r\nOut[2]: 1x1**2\r\n\r\nIn [3]: tps(t1)\r\nOut[3]: 1x1**2\r\n\r\nIn [4]: t1.expand(tensorproduct=True)\r\nOut[4]: 1x1**2\r\n\r\nIn [5]: tps(tp(1,1)*tp(1,a)).subs(a, 1)\r\nOut[5]: 1x1\r\n\r\nIn [6]: t2 = tp(1,Pauli(3))*tp(1,Pauli(3))\r\n        t2\r\nOut[6]: 1xsigma3**2\r\n\r\nIn [7]: tps(t2)\r\nOut[7]: 1xsigma3**2\r\n\r\nIn [8]: t2.expand(tensorproduct=True)\r\nOut[8]: 1xsigma3**2\r\n\r\nIn [9]: tps(tp(1,Pauli(3))*tp(1,a)).subs(a, Pauli(3))\r\nOut[9]: 1x1\r\n```\r\nwhere `[5]` and `[9]` shows expected result for `t1` and `t2` respectively.\n",
  "localized_code": "[start of sympy/physics/quantum/tensorproduct.py]\n1: \"\"\"Abstract tensor product.\"\"\"\n2: \n3: from __future__ import print_function, division\n4: \n5: from sympy import Expr, Add, Mul, Matrix, Pow, sympify\n6: from sympy.core.compatibility import range\n7: from sympy.core.trace import Tr\n8: from sympy.printing.pretty.stringpict import prettyForm\n9: \n10: from sympy.physics.quantum.qexpr import QuantumError\n11: from sympy.physics.quantum.dagger import Dagger\n12: from sympy.physics.quantum.commutator import Commutator\n13: from sympy.physics.quantum.anticommutator import AntiCommutator\n14: from sympy.physics.quantum.state import Ket, Bra\n15: from sympy.physics.quantum.matrixutils import (\n16:     numpy_ndarray,\n17:     scipy_sparse_matrix,\n18:     matrix_tensor_product\n19: )\n20: \n21: __all__ = [\n22:     'TensorProduct',\n23:     'tensor_product_simp'\n24: ]\n25: \n26: #-----------------------------------------------------------------------------\n27: # Tensor product\n28: #-----------------------------------------------------------------------------\n29: \n30: _combined_printing = False\n31: \n32: \n33: def combined_tensor_printing(combined):\n34:     \"\"\"Set flag controlling whether tensor products of states should be\n35:     printed as a combined bra/ket or as an explicit tensor product of different\n36:     bra/kets. This is a global setting for all TensorProduct class instances.\n37: \n38:     Parameters\n39:     ----------\n40:     combine : bool\n41:         When true, tensor product states are combined into one ket/bra, and\n42:         when false explicit tensor product notation is used between each\n43:         ket/bra.\n44:     \"\"\"\n45:     global _combined_printing\n46:     _combined_printing = combined\n47: \n48: \n49: class TensorProduct(Expr):\n50:     \"\"\"The tensor product of two or more arguments.\n51: \n52:     For matrices, this uses ``matrix_tensor_product`` to compute the Kronecker\n53:     or tensor product matrix. For other objects a symbolic ``TensorProduct``\n54:     instance is returned. The tensor product is a non-commutative\n55:     multiplication that is used primarily with operators and states in quantum\n56:     mechanics.\n57: \n58:     Currently, the tensor product distinguishes between commutative and non-\n59:     commutative arguments.  Commutative arguments are assumed to be scalars and\n60:     are pulled out in front of the ``TensorProduct``. Non-commutative arguments\n61:     remain in the resulting ``TensorProduct``.\n62: \n63:     Parameters\n64:     ==========\n65: \n66:     args : tuple\n67:         A sequence of the objects to take the tensor product of.\n68: \n69:     Examples\n70:     ========\n71: \n72:     Start with a simple tensor product of sympy matrices::\n73: \n74:         >>> from sympy import I, Matrix, symbols\n75:         >>> from sympy.physics.quantum import TensorProduct\n76: \n77:         >>> m1 = Matrix([[1,2],[3,4]])\n78:         >>> m2 = Matrix([[1,0],[0,1]])\n79:         >>> TensorProduct(m1, m2)\n80:         Matrix([\n81:         [1, 0, 2, 0],\n82:         [0, 1, 0, 2],\n83:         [3, 0, 4, 0],\n84:         [0, 3, 0, 4]])\n85:         >>> TensorProduct(m2, m1)\n86:         Matrix([\n87:         [1, 2, 0, 0],\n88:         [3, 4, 0, 0],\n89:         [0, 0, 1, 2],\n90:         [0, 0, 3, 4]])\n91: \n92:     We can also construct tensor products of non-commutative symbols:\n93: \n94:         >>> from sympy import Symbol\n95:         >>> A = Symbol('A',commutative=False)\n96:         >>> B = Symbol('B',commutative=False)\n97:         >>> tp = TensorProduct(A, B)\n98:         >>> tp\n99:         AxB\n100: \n101:     We can take the dagger of a tensor product (note the order does NOT reverse\n102:     like the dagger of a normal product):\n103: \n104:         >>> from sympy.physics.quantum import Dagger\n105:         >>> Dagger(tp)\n106:         Dagger(A)xDagger(B)\n107: \n108:     Expand can be used to distribute a tensor product across addition:\n109: \n110:         >>> C = Symbol('C',commutative=False)\n111:         >>> tp = TensorProduct(A+B,C)\n112:         >>> tp\n113:         (A + B)xC\n114:         >>> tp.expand(tensorproduct=True)\n115:         AxC + BxC\n116:     \"\"\"\n117:     is_commutative = False\n118: \n119:     def __new__(cls, *args):\n120:         if isinstance(args[0], (Matrix, numpy_ndarray, scipy_sparse_matrix)):\n121:             return matrix_tensor_product(*args)\n122:         c_part, new_args = cls.flatten(sympify(args))\n123:         c_part = Mul(*c_part)\n124:         if len(new_args) == 0:\n125:             return c_part\n126:         elif len(new_args) == 1:\n127:             return c_part * new_args[0]\n128:         else:\n129:             tp = Expr.__new__(cls, *new_args)\n130:             return c_part * tp\n131: \n132:     @classmethod\n133:     def flatten(cls, args):\n134:         # TODO: disallow nested TensorProducts.\n135:         c_part = []\n136:         nc_parts = []\n137:         for arg in args:\n138:             cp, ncp = arg.args_cnc()\n139:             c_part.extend(list(cp))\n140:             nc_parts.append(Mul._from_args(ncp))\n141:         return c_part, nc_parts\n142: \n143:     def _eval_adjoint(self):\n144:         return TensorProduct(*[Dagger(i) for i in self.args])\n145: \n146:     def _eval_rewrite(self, pattern, rule, **hints):\n147:         sargs = self.args\n148:         terms = [t._eval_rewrite(pattern, rule, **hints) for t in sargs]\n149:         return TensorProduct(*terms).expand(tensorproduct=True)\n150: \n151:     def _sympystr(self, printer, *args):\n152:         from sympy.printing.str import sstr\n153:         length = len(self.args)\n154:         s = ''\n155:         for i in range(length):\n156:             if isinstance(self.args[i], (Add, Pow, Mul)):\n157:                 s = s + '('\n158:             s = s + sstr(self.args[i])\n159:             if isinstance(self.args[i], (Add, Pow, Mul)):\n160:                 s = s + ')'\n161:             if i != length - 1:\n162:                 s = s + 'x'\n163:         return s\n164: \n165:     def _pretty(self, printer, *args):\n166: \n167:         if (_combined_printing and\n168:                 (all([isinstance(arg, Ket) for arg in self.args]) or\n169:                  all([isinstance(arg, Bra) for arg in self.args]))):\n170: \n171:             length = len(self.args)\n172:             pform = printer._print('', *args)\n173:             for i in range(length):\n174:                 next_pform = printer._print('', *args)\n175:                 length_i = len(self.args[i].args)\n176:                 for j in range(length_i):\n177:                     part_pform = printer._print(self.args[i].args[j], *args)\n178:                     next_pform = prettyForm(*next_pform.right(part_pform))\n179:                     if j != length_i - 1:\n180:                         next_pform = prettyForm(*next_pform.right(', '))\n181: \n182:                 if len(self.args[i].args) > 1:\n183:                     next_pform = prettyForm(\n184:                         *next_pform.parens(left='{', right='}'))\n185:                 pform = prettyForm(*pform.right(next_pform))\n186:                 if i != length - 1:\n187:                     pform = prettyForm(*pform.right(',' + ' '))\n188: \n189:             pform = prettyForm(*pform.left(self.args[0].lbracket))\n190:             pform = prettyForm(*pform.right(self.args[0].rbracket))\n191:             return pform\n192: \n193:         length = len(self.args)\n194:         pform = printer._print('', *args)\n195:         for i in range(length):\n196:             next_pform = printer._print(self.args[i], *args)\n197:             if isinstance(self.args[i], (Add, Mul)):\n198:                 next_pform = prettyForm(\n199:                     *next_pform.parens(left='(', right=')')\n200:                 )\n201:             pform = prettyForm(*pform.right(next_pform))\n202:             if i != length - 1:\n203:                 if printer._use_unicode:\n204:                     pform = prettyForm(*pform.right(u'\\N{N-ARY CIRCLED TIMES OPERATOR}' + u' '))\n205:                 else:\n206:                     pform = prettyForm(*pform.right('x' + ' '))\n207:         return pform\n208: \n209:     def _latex(self, printer, *args):\n210: \n211:         if (_combined_printing and\n212:                 (all([isinstance(arg, Ket) for arg in self.args]) or\n213:                  all([isinstance(arg, Bra) for arg in self.args]))):\n214: \n215:             def _label_wrap(label, nlabels):\n216:                 return label if nlabels == 1 else r\"\\left\\{%s\\right\\}\" % label\n217: \n218:             s = r\", \".join([_label_wrap(arg._print_label_latex(printer, *args),\n219:                                         len(arg.args)) for arg in self.args])\n220: \n221:             return r\"{%s%s%s}\" % (self.args[0].lbracket_latex, s,\n222:                                   self.args[0].rbracket_latex)\n223: \n224:         length = len(self.args)\n225:         s = ''\n226:         for i in range(length):\n227:             if isinstance(self.args[i], (Add, Mul)):\n228:                 s = s + '\\\\left('\n229:             # The extra {} brackets are needed to get matplotlib's latex\n230:             # rendered to render this properly.\n231:             s = s + '{' + printer._print(self.args[i], *args) + '}'\n232:             if isinstance(self.args[i], (Add, Mul)):\n233:                 s = s + '\\\\right)'\n234:             if i != length - 1:\n235:                 s = s + '\\\\otimes '\n236:         return s\n237: \n238:     def doit(self, **hints):\n239:         return TensorProduct(*[item.doit(**hints) for item in self.args])\n240: \n241:     def _eval_expand_tensorproduct(self, **hints):\n242:         \"\"\"Distribute TensorProducts across addition.\"\"\"\n243:         args = self.args\n244:         add_args = []\n245:         stop = False\n246:         for i in range(len(args)):\n247:             if isinstance(args[i], Add):\n248:                 for aa in args[i].args:\n249:                     tp = TensorProduct(*args[:i] + (aa,) + args[i + 1:])\n250:                     if isinstance(tp, TensorProduct):\n251:                         tp = tp._eval_expand_tensorproduct()\n252:                     add_args.append(tp)\n253:                 break\n254: \n255:         if add_args:\n256:             return Add(*add_args)\n257:         else:\n258:             return self\n259: \n260:     def _eval_trace(self, **kwargs):\n261:         indices = kwargs.get('indices', None)\n262:         exp = tensor_product_simp(self)\n263: \n264:         if indices is None or len(indices) == 0:\n265:             return Mul(*[Tr(arg).doit() for arg in exp.args])\n266:         else:\n267:             return Mul(*[Tr(value).doit() if idx in indices else value\n268:                          for idx, value in enumerate(exp.args)])\n269: \n270: \n271: def tensor_product_simp_Mul(e):\n272:     \"\"\"Simplify a Mul with TensorProducts.\n273: \n274:     Current the main use of this is to simplify a ``Mul`` of ``TensorProduct``s\n275:     to a ``TensorProduct`` of ``Muls``. It currently only works for relatively\n276:     simple cases where the initial ``Mul`` only has scalars and raw\n277:     ``TensorProduct``s, not ``Add``, ``Pow``, ``Commutator``s of\n278:     ``TensorProduct``s.\n279: \n280:     Parameters\n281:     ==========\n282: \n283:     e : Expr\n284:         A ``Mul`` of ``TensorProduct``s to be simplified.\n285: \n286:     Returns\n287:     =======\n288: \n289:     e : Expr\n290:         A ``TensorProduct`` of ``Mul``s.\n291: \n292:     Examples\n293:     ========\n294: \n295:     This is an example of the type of simplification that this function\n296:     performs::\n297: \n298:         >>> from sympy.physics.quantum.tensorproduct import \\\n299:                     tensor_product_simp_Mul, TensorProduct\n300:         >>> from sympy import Symbol\n301:         >>> A = Symbol('A',commutative=False)\n302:         >>> B = Symbol('B',commutative=False)\n303:         >>> C = Symbol('C',commutative=False)\n304:         >>> D = Symbol('D',commutative=False)\n305:         >>> e = TensorProduct(A,B)*TensorProduct(C,D)\n306:         >>> e\n307:         AxB*CxD\n308:         >>> tensor_product_simp_Mul(e)\n309:         (A*C)x(B*D)\n310: \n311:     \"\"\"\n312:     # TODO: This won't work with Muls that have other composites of\n313:     # TensorProducts, like an Add, Pow, Commutator, etc.\n314:     # TODO: This only works for the equivalent of single Qbit gates.\n315:     if not isinstance(e, Mul):\n316:         return e\n317:     c_part, nc_part = e.args_cnc()\n318:     n_nc = len(nc_part)\n319:     if n_nc == 0 or n_nc == 1:\n320:         return e\n321:     elif e.has(TensorProduct):\n322:         current = nc_part[0]\n323:         if not isinstance(current, TensorProduct):\n324:             raise TypeError('TensorProduct expected, got: %r' % current)\n325:         n_terms = len(current.args)\n326:         new_args = list(current.args)\n327:         for next in nc_part[1:]:\n328:             # TODO: check the hilbert spaces of next and current here.\n329:             if isinstance(next, TensorProduct):\n330:                 if n_terms != len(next.args):\n331:                     raise QuantumError(\n332:                         'TensorProducts of different lengths: %r and %r' %\n333:                         (current, next)\n334:                     )\n335:                 for i in range(len(new_args)):\n336:                     new_args[i] = new_args[i] * next.args[i]\n337:             else:\n338:                 # this won't quite work as we don't want next in the\n339:                 # TensorProduct\n340:                 for i in range(len(new_args)):\n341:                     new_args[i] = new_args[i] * next\n342:             current = next\n343:         return Mul(*c_part) * TensorProduct(*new_args)\n344:     else:\n345:         return e\n346: \n347: \n348: def tensor_product_simp(e, **hints):\n349:     \"\"\"Try to simplify and combine TensorProducts.\n350: \n351:     In general this will try to pull expressions inside of ``TensorProducts``.\n352:     It currently only works for relatively simple cases where the products have\n353:     only scalars, raw ``TensorProducts``, not ``Add``, ``Pow``, ``Commutators``\n354:     of ``TensorProducts``. It is best to see what it does by showing examples.\n355: \n356:     Examples\n357:     ========\n358: \n359:     >>> from sympy.physics.quantum import tensor_product_simp\n360:     >>> from sympy.physics.quantum import TensorProduct\n361:     >>> from sympy import Symbol\n362:     >>> A = Symbol('A',commutative=False)\n363:     >>> B = Symbol('B',commutative=False)\n364:     >>> C = Symbol('C',commutative=False)\n365:     >>> D = Symbol('D',commutative=False)\n366: \n367:     First see what happens to products of tensor products:\n368: \n369:     >>> e = TensorProduct(A,B)*TensorProduct(C,D)\n370:     >>> e\n371:     AxB*CxD\n372:     >>> tensor_product_simp(e)\n373:     (A*C)x(B*D)\n374: \n375:     This is the core logic of this function, and it works inside, powers, sums,\n376:     commutators and anticommutators as well:\n377: \n378:     >>> tensor_product_simp(e**2)\n379:     (A*C)x(B*D)**2\n380: \n381:     \"\"\"\n382:     if isinstance(e, Add):\n383:         return Add(*[tensor_product_simp(arg) for arg in e.args])\n384:     elif isinstance(e, Pow):\n385:         return tensor_product_simp(e.base) ** e.exp\n386:     elif isinstance(e, Mul):\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/physics/quantum/tensorproduct.py",
      "suspect_lines": [
        313,
        319,
        324,
        338,
        339,
        340,
        341,
        385
      ]
    }
  ]
}