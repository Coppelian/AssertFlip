{
  "instance_id": "django__django-13346",
  "problem_statement": "On MySQL, Oracle, and SQLite, __in lookup doesn't work on key transforms.\nDescription\n\t\nI am currently rewriting our app where we will start using models.JSONField instead of django_mysql.models.JSONField. I noticed that the __in operator is not reacting the same way is it does on other fields.\nfirst_filter = {â€˜our_field__key__in': [0]}\nfirst_items = OurModel.objects.filter(**first_filter)\nlen(first_items)\n0\nsecond_filter = {'our_field__key': 0}\nsecond_items = OurModel.objects.filter(**second_filter)\nlen(second_items )\n312\nI would expect that both filters would give me the same queryset but this is not the case.\n",
  "localized_code": "[start of django/db/models/fields/json.py]\n1: import json\n2: \n3: from django import forms\n4: from django.core import checks, exceptions\n5: from django.db import NotSupportedError, connections, router\n6: from django.db.models import lookups\n7: from django.db.models.lookups import PostgresOperatorLookup, Transform\n8: from django.utils.translation import gettext_lazy as _\n9: \n10: from . import Field\n11: from .mixins import CheckFieldDefaultMixin\n12: \n13: __all__ = ['JSONField']\n14: \n15: \n16: class JSONField(CheckFieldDefaultMixin, Field):\n17:     empty_strings_allowed = False\n18:     description = _('A JSON object')\n19:     default_error_messages = {\n20:         'invalid': _('Value must be valid JSON.'),\n21:     }\n22:     _default_hint = ('dict', '{}')\n23: \n24:     def __init__(\n25:         self, verbose_name=None, name=None, encoder=None, decoder=None,\n26:         **kwargs,\n27:     ):\n28:         if encoder and not callable(encoder):\n29:             raise ValueError('The encoder parameter must be a callable object.')\n30:         if decoder and not callable(decoder):\n31:             raise ValueError('The decoder parameter must be a callable object.')\n32:         self.encoder = encoder\n33:         self.decoder = decoder\n34:         super().__init__(verbose_name, name, **kwargs)\n35: \n36:     def check(self, **kwargs):\n37:         errors = super().check(**kwargs)\n38:         databases = kwargs.get('databases') or []\n39:         errors.extend(self._check_supported(databases))\n40:         return errors\n41: \n42:     def _check_supported(self, databases):\n43:         errors = []\n44:         for db in databases:\n45:             if not router.allow_migrate_model(db, self.model):\n46:                 continue\n47:             connection = connections[db]\n48:             if not (\n49:                 'supports_json_field' in self.model._meta.required_db_features or\n50:                 connection.features.supports_json_field\n51:             ):\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/json.py",
      "suspect_lines": []
    }
  ]
}