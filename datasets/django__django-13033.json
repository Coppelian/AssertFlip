{
  "instance_id": "django__django-13033",
  "problem_statement": "Self referencing foreign key doesn't correctly order by a relation \"_id\" field.\nDescription\n\t\nInitially discovered on 2.2.10 but verified still happens on 3.0.6. Given the following models:\nclass OneModel(models.Model):\n\tclass Meta:\n\t\tordering = (\"-id\",)\n\tid = models.BigAutoField(primary_key=True)\n\troot = models.ForeignKey(\"OneModel\", on_delete=models.CASCADE, null=True)\n\toneval = models.BigIntegerField(null=True)\nclass TwoModel(models.Model):\n\tid = models.BigAutoField(primary_key=True)\n\trecord = models.ForeignKey(OneModel, on_delete=models.CASCADE)\n\ttwoval = models.BigIntegerField(null=True)\nThe following queryset gives unexpected results and appears to be an incorrect SQL query:\nqs = TwoModel.objects.filter(record__oneval__in=[1,2,3])\nqs = qs.order_by(\"record__root_id\")\nprint(qs.query)\nSELECT \"orion_twomodel\".\"id\", \"orion_twomodel\".\"record_id\", \"orion_twomodel\".\"twoval\" FROM \"orion_twomodel\" INNER JOIN \"orion_onemodel\" ON (\"orion_twomodel\".\"record_id\" = \"orion_onemodel\".\"id\") LEFT OUTER JOIN \"orion_onemodel\" T3 ON (\"orion_onemodel\".\"root_id\" = T3.\"id\") WHERE \"orion_onemodel\".\"oneval\" IN (1, 2, 3) ORDER BY T3.\"id\" DESC\nThe query has an unexpected DESCENDING sort. That appears to come from the default sort order on the OneModel class, but I would expect the order_by() to take prececence. The the query has two JOINS, which is unnecessary. It appears that, since OneModel.root is a foreign key to itself, that is causing it to do the unnecessary extra join. In fact, testing a model where root is a foreign key to a third model doesn't show the problem behavior.\nNote also that the queryset with order_by(\"record__root\") gives the exact same SQL.\nThis queryset gives correct results and what looks like a pretty optimal SQL:\nqs = TwoModel.objects.filter(record__oneval__in=[1,2,3])\nqs = qs.order_by(\"record__root__id\")\nprint(qs.query)\nSELECT \"orion_twomodel\".\"id\", \"orion_twomodel\".\"record_id\", \"orion_twomodel\".\"twoval\" FROM \"orion_twomodel\" INNER JOIN \"orion_onemodel\" ON (\"orion_twomodel\".\"record_id\" = \"orion_onemodel\".\"id\") WHERE \"orion_onemodel\".\"oneval\" IN (1, 2, 3) ORDER BY \"orion_onemodel\".\"root_id\" ASC\nSo is this a potential bug or a misunderstanding on my part?\nAnother queryset that works around the issue and gives a reasonable SQL query and expected results:\nqs = TwoModel.objects.filter(record__oneval__in=[1,2,3])\nqs = qs.annotate(root_id=F(\"record__root_id\"))\nqs = qs.order_by(\"root_id\")\nprint(qs.query)\nSELECT \"orion_twomodel\".\"id\", \"orion_twomodel\".\"record_id\", \"orion_twomodel\".\"twoval\" FROM \"orion_twomodel\" INNER JOIN \"orion_onemodel\" ON (\"orion_twomodel\".\"record_id\" = \"orion_onemodel\".\"id\") WHERE \"orion_onemodel\".\"oneval\" IN (1, 2, 3) ORDER BY \"orion_onemodel\".\"zero_id\" ASC\nASCENDING sort, and a single INNER JOIN, as I'd expect. That actually works for my use because I need that output column anyway.\nOne final oddity; with the original queryset but the inverted sort order_by():\nqs = TwoModel.objects.filter(record__oneval__in=[1,2,3])\nqs = qs.order_by(\"-record__root_id\")\nprint(qs.query)\nSELECT \"orion_twomodel\".\"id\", \"orion_twomodel\".\"record_id\", \"orion_twomodel\".\"twoval\" FROM \"orion_twomodel\" INNER JOIN \"orion_onemodel\" ON (\"orion_twomodel\".\"record_id\" = \"orion_onemodel\".\"id\") LEFT OUTER JOIN \"orion_onemodel\" T3 ON (\"orion_onemodel\".\"root_id\" = T3.\"id\") WHERE \"orion_onemodel\".\"oneval\" IN (1, 2, 3) ORDER BY T3.\"id\" ASC\nOne gets the query with the two JOINs but an ASCENDING sort order. I was not under the impression that sort orders are somehow relative to the class level sort order, eg: does specifing order_by(\"-record__root_id\") invert the class sort order? Testing that on a simple case doesn't show that behavior at all.\nThanks for any assistance and clarification.\n",
  "localized_code": "[start of django/db/models/sql/compiler.py]\n1: import collections\n2: import re\n3: from functools import partial\n4: from itertools import chain\n5: \n6: from django.core.exceptions import EmptyResultSet, FieldError\n7: from django.db import DatabaseError, NotSupportedError\n8: from django.db.models.constants import LOOKUP_SEP\n9: from django.db.models.expressions import F, OrderBy, Random, RawSQL, Ref, Value\n10: from django.db.models.functions import Cast\n11: from django.db.models.query_utils import Q, select_related_descend\n12: from django.db.models.sql.constants import (\n13:     CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS, ORDER_DIR, SINGLE,\n14: )\n15: from django.db.models.sql.query import Query, get_order_dir\n16: from django.db.transaction import TransactionManagementError\n17: from django.utils.functional import cached_property\n18: from django.utils.hashable import make_hashable\n19: from django.utils.regex_helper import _lazy_re_compile\n20: \n21: \n22: class SQLCompiler:\n23:     # Multiline ordering SQL clause may appear from RawSQL.\n24:     ordering_parts = _lazy_re_compile(\n25:         r'^(.*)\\s(?:ASC|DESC).*',\n26:         re.MULTILINE | re.DOTALL,\n27:     )\n28: \n29:     def __init__(self, query, connection, using):\n30:         self.query = query\n31:         self.connection = connection\n32:         self.using = using\n33:         self.quote_cache = {'*': '*'}\n34:         # The select, klass_info, and annotations are needed by QuerySet.iterator()\n35:         # these are set as a side-effect of executing the query. Note that we calculate\n36:         # separately a list of extra select columns needed for grammatical correctness\n37:         # of the query, but these columns are not included in self.select.\n38:         self.select = None\n39:         self.annotation_col_map = None\n40:         self.klass_info = None\n41:         self._meta_ordering = None\n42: \n43:     def setup_query(self):\n44:         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n45:             self.query.get_initial_alias()\n46:         self.select, self.klass_info, self.annotation_col_map = self.get_select()\n47:         self.col_count = len(self.select)\n48: \n49:     def pre_sql_setup(self):\n50:         \"\"\"\n51:         Do any necessary class setup immediately prior to producing SQL. This\n52:         is for things that can't necessarily be done in __init__ because we\n53:         might not have all the pieces in place at that time.\n54:         \"\"\"\n55:         self.setup_query()\n56:         order_by = self.get_order_by()\n57:         self.where, self.having = self.query.where.split_having()\n58:         extra_select = self.get_extra_select(order_by, self.select)\n59:         self.has_extra_select = bool(extra_select)\n60:         group_by = self.get_group_by(self.select + extra_select, order_by)\n61:         return extra_select, order_by, group_by\n62: \n63:     def get_group_by(self, select, order_by):\n64:         \"\"\"\n65:         Return a list of 2-tuples of form (sql, params).\n66: \n67:         The logic of what exactly the GROUP BY clause contains is hard\n68:         to describe in other words than \"if it passes the test suite,\n69:         then it is correct\".\n70:         \"\"\"\n71:         # Some examples:\n72:         #     SomeModel.objects.annotate(Count('somecol'))\n73:         #     GROUP BY: all fields of the model\n74:         #\n75:         #    SomeModel.objects.values('name').annotate(Count('somecol'))\n76:         #    GROUP BY: name\n77:         #\n78:         #    SomeModel.objects.annotate(Count('somecol')).values('name')\n79:         #    GROUP BY: all cols of the model\n80:         #\n81:         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n82:         #    GROUP BY: name, pk\n83:         #\n84:         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n85:         #    GROUP BY: name, pk\n86:         #\n87:         # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n88:         # can't be ever restricted to a smaller set, but additional columns in\n89:         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n90:         # the end result is that it is impossible to force the query to have\n91:         # a chosen GROUP BY clause - you can almost do this by using the form:\n92:         #     .values(*wanted_cols).annotate(AnAggregate())\n93:         # but any later annotations, extra selects, values calls that\n94:         # refer some column outside of the wanted_cols, order_by, or even\n95:         # filter calls can alter the GROUP BY clause.\n96: \n97:         # The query.group_by is either None (no GROUP BY at all), True\n98:         # (group by select fields), or a list of expressions to be added\n99:         # to the group by.\n100:         if self.query.group_by is None:\n101:             return []\n102:         expressions = []\n103:         if self.query.group_by is not True:\n104:             # If the group by is set to a list (by .values() call most likely),\n105:             # then we need to add everything in it to the GROUP BY clause.\n106:             # Backwards compatibility hack for setting query.group_by. Remove\n107:             # when  we have public API way of forcing the GROUP BY clause.\n108:             # Converts string references to expressions.\n109:             for expr in self.query.group_by:\n110:                 if not hasattr(expr, 'as_sql'):\n111:                     expressions.append(self.query.resolve_ref(expr))\n112:                 else:\n113:                     expressions.append(expr)\n114:         # Note that even if the group_by is set, it is only the minimal\n115:         # set to group by. So, we need to add cols in select, order_by, and\n116:         # having into the select in any case.\n117:         ref_sources = {\n118:             expr.source for expr in expressions if isinstance(expr, Ref)\n119:         }\n120:         for expr, _, _ in select:\n121:             # Skip members of the select clause that are already included\n122:             # by reference.\n123:             if expr in ref_sources:\n124:                 continue\n125:             cols = expr.get_group_by_cols()\n126:             for col in cols:\n127:                 expressions.append(col)\n128:         for expr, (sql, params, is_ref) in order_by:\n129:             # Skip References to the select clause, as all expressions in the\n130:             # select clause are already part of the group by.\n131:             if not is_ref:\n132:                 expressions.extend(expr.get_group_by_cols())\n133:         having_group_by = self.having.get_group_by_cols() if self.having else ()\n134:         for expr in having_group_by:\n135:             expressions.append(expr)\n136:         result = []\n137:         seen = set()\n138:         expressions = self.collapse_group_by(expressions, having_group_by)\n139: \n140:         for expr in expressions:\n141:             sql, params = self.compile(expr)\n142:             sql, params = expr.select_format(self, sql, params)\n143:             params_hash = make_hashable(params)\n144:             if (sql, params_hash) not in seen:\n145:                 result.append((sql, params))\n146:                 seen.add((sql, params_hash))\n147:         return result\n148: \n149:     def collapse_group_by(self, expressions, having):\n150:         # If the DB can group by primary key, then group by the primary key of\n151:         # query's main model. Note that for PostgreSQL the GROUP BY clause must\n152:         # include the primary key of every table, but for MySQL it is enough to\n153:         # have the main table's primary key.\n154:         if self.connection.features.allows_group_by_pk:\n155:             # Determine if the main model's primary key is in the query.\n156:             pk = None\n157:             for expr in expressions:\n158:                 # Is this a reference to query's base table primary key? If the\n159:                 # expression isn't a Col-like, then skip the expression.\n160:                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and\n161:                         getattr(expr, 'alias', None) == self.query.base_table):\n162:                     pk = expr\n163:                     break\n164:             # If the main model's primary key is in the query, group by that\n165:             # field, HAVING expressions, and expressions associated with tables\n166:             # that don't have a primary key included in the grouped columns.\n167:             if pk:\n168:                 pk_aliases = {\n169:                     expr.alias for expr in expressions\n170:                     if hasattr(expr, 'target') and expr.target.primary_key\n171:                 }\n172:                 expressions = [pk] + [\n173:                     expr for expr in expressions\n174:                     if expr in having or (\n175:                         getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases\n176:                     )\n177:                 ]\n178:         elif self.connection.features.allows_group_by_selected_pks:\n179:             # Filter out all expressions associated with a table's primary key\n180:             # present in the grouped columns. This is done by identifying all\n181:             # tables that have their primary key included in the grouped\n182:             # columns and removing non-primary key columns referring to them.\n183:             # Unmanaged models are excluded because they could be representing\n184:             # database views on which the optimization might not be allowed.\n185:             pks = {\n186:                 expr for expr in expressions\n187:                 if (\n188:                     hasattr(expr, 'target') and\n189:                     expr.target.primary_key and\n190:                     self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)\n191:                 )\n192:             }\n193:             aliases = {expr.alias for expr in pks}\n194:             expressions = [\n195:                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases\n196:             ]\n197:         return expressions\n198: \n199:     def get_select(self):\n200:         \"\"\"\n201:         Return three values:\n202:         - a list of 3-tuples of (expression, (sql, params), alias)\n203:         - a klass_info structure,\n204:         - a dictionary of annotations\n205: \n206:         The (sql, params) is what the expression will produce, and alias is the\n207:         \"AS alias\" for the column (possibly None).\n208: \n209:         The klass_info structure contains the following information:\n210:         - The base model of the query.\n211:         - Which columns for that model are present in the query (by\n212:           position of the select clause).\n213:         - related_klass_infos: [f, klass_info] to descent into\n214: \n215:         The annotations is a dictionary of {'attname': column position} values.\n216:         \"\"\"\n217:         select = []\n218:         klass_info = None\n219:         annotations = {}\n220:         select_idx = 0\n221:         for alias, (sql, params) in self.query.extra_select.items():\n222:             annotations[alias] = select_idx\n223:             select.append((RawSQL(sql, params), alias))\n224:             select_idx += 1\n225:         assert not (self.query.select and self.query.default_cols)\n226:         if self.query.default_cols:\n227:             cols = self.get_default_columns()\n228:         else:\n229:             # self.query.select is a special case. These columns never go to\n230:             # any model.\n231:             cols = self.query.select\n232:         if cols:\n233:             select_list = []\n234:             for col in cols:\n235:                 select_list.append(select_idx)\n236:                 select.append((col, None))\n237:                 select_idx += 1\n238:             klass_info = {\n239:                 'model': self.query.model,\n240:                 'select_fields': select_list,\n241:             }\n242:         for alias, annotation in self.query.annotation_select.items():\n243:             annotations[alias] = select_idx\n244:             select.append((annotation, alias))\n245:             select_idx += 1\n246: \n247:         if self.query.select_related:\n248:             related_klass_infos = self.get_related_selections(select)\n249:             klass_info['related_klass_infos'] = related_klass_infos\n250: \n251:             def get_select_from_parent(klass_info):\n252:                 for ki in klass_info['related_klass_infos']:\n253:                     if ki['from_parent']:\n254:                         ki['select_fields'] = (klass_info['select_fields'] +\n255:                                                ki['select_fields'])\n256:                     get_select_from_parent(ki)\n257:             get_select_from_parent(klass_info)\n258: \n259:         ret = []\n260:         for col, alias in select:\n261:             try:\n262:                 sql, params = self.compile(col)\n263:             except EmptyResultSet:\n264:                 # Select a predicate that's always False.\n265:                 sql, params = '0', ()\n266:             else:\n267:                 sql, params = col.select_format(self, sql, params)\n268:             ret.append((col, (sql, params), alias))\n269:         return ret, klass_info, annotations\n270: \n271:     def get_order_by(self):\n272:         \"\"\"\n273:         Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n274:         ORDER BY clause.\n275: \n276:         The order_by clause can alter the select clause (for example it\n277:         can add aliases to clauses that do not yet have one, or it can\n278:         add totally new select clauses).\n279:         \"\"\"\n280:         if self.query.extra_order_by:\n281:             ordering = self.query.extra_order_by\n282:         elif not self.query.default_ordering:\n283:             ordering = self.query.order_by\n284:         elif self.query.order_by:\n285:             ordering = self.query.order_by\n286:         elif self.query.get_meta().ordering:\n287:             ordering = self.query.get_meta().ordering\n288:             self._meta_ordering = ordering\n289:         else:\n290:             ordering = []\n291:         if self.query.standard_ordering:\n292:             asc, desc = ORDER_DIR['ASC']\n293:         else:\n294:             asc, desc = ORDER_DIR['DESC']\n295: \n296:         order_by = []\n297:         for field in ordering:\n298:             if hasattr(field, 'resolve_expression'):\n299:                 if isinstance(field, Value):\n300:                     # output_field must be resolved for constants.\n301:                     field = Cast(field, field.output_field)\n302:                 if not isinstance(field, OrderBy):\n303:                     field = field.asc()\n304:                 if not self.query.standard_ordering:\n305:                     field = field.copy()\n306:                     field.reverse_ordering()\n307:                 order_by.append((field, False))\n308:                 continue\n309:             if field == '?':  # random\n310:                 order_by.append((OrderBy(Random()), False))\n311:                 continue\n312: \n313:             col, order = get_order_dir(field, asc)\n314:             descending = order == 'DESC'\n315: \n316:             if col in self.query.annotation_select:\n317:                 # Reference to expression in SELECT clause\n318:                 order_by.append((\n319:                     OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),\n320:                     True))\n321:                 continue\n322:             if col in self.query.annotations:\n323:                 # References to an expression which is masked out of the SELECT\n324:                 # clause.\n325:                 expr = self.query.annotations[col]\n326:                 if isinstance(expr, Value):\n327:                     # output_field must be resolved for constants.\n328:                     expr = Cast(expr, expr.output_field)\n329:                 order_by.append((OrderBy(expr, descending=descending), False))\n330:                 continue\n331: \n332:             if '.' in field:\n333:                 # This came in through an extra(order_by=...) addition. Pass it\n334:                 # on verbatim.\n335:                 table, col = col.split('.', 1)\n336:                 order_by.append((\n337:                     OrderBy(\n338:                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),\n339:                         descending=descending\n340:                     ), False))\n341:                 continue\n342: \n343:             if not self.query.extra or col not in self.query.extra:\n344:                 # 'col' is of the form 'field' or 'field1__field2' or\n345:                 # '-field1__field2__field', etc.\n346:                 order_by.extend(self.find_ordering_name(\n347:                     field, self.query.get_meta(), default_order=asc))\n348:             else:\n349:                 if col not in self.query.extra_select:\n350:                     order_by.append((\n351:                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),\n352:                         False))\n353:                 else:\n354:                     order_by.append((\n355:                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),\n356:                         True))\n357:         result = []\n358:         seen = set()\n359: \n360:         for expr, is_ref in order_by:\n361:             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n362:             if self.query.combinator:\n363:                 src = resolved.get_source_expressions()[0]\n364:                 expr_src = expr.get_source_expressions()[0]\n365:                 # Relabel order by columns to raw numbers if this is a combined\n366:                 # query; necessary since the columns can't be referenced by the\n367:                 # fully qualified name and the simple column names may collide.\n368:                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n369:                     if is_ref and col_alias == src.refs:\n370:                         src = src.source\n371:                     elif col_alias and not (\n372:                         isinstance(expr_src, F) and col_alias == expr_src.name\n373:                     ):\n374:                         continue\n375:                     if src == sel_expr:\n376:                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n377:                         break\n378:                 else:\n379:                     if col_alias:\n380:                         raise DatabaseError('ORDER BY term does not match any column in the result set.')\n381:                     # Add column used in ORDER BY clause without an alias to\n382:                     # the selected columns.\n383:                     self.query.add_select_col(src)\n384:                     resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n385:             sql, params = self.compile(resolved)\n386:             # Don't add the same column twice, but the order direction is\n387:             # not taken into account so we strip it. When this entire method\n388:             # is refactored into expressions, then we can check each part as we\n389:             # generate it.\n390:             without_ordering = self.ordering_parts.search(sql)[1]\n391:             params_hash = make_hashable(params)\n392:             if (without_ordering, params_hash) in seen:\n393:                 continue\n394:             seen.add((without_ordering, params_hash))\n395:             result.append((resolved, (sql, params, is_ref)))\n396:         return result\n397: \n398:     def get_extra_select(self, order_by, select):\n399:         extra_select = []\n400:         if self.query.distinct and not self.query.distinct_fields:\n401:             select_sql = [t[1] for t in select]\n402:             for expr, (sql, params, is_ref) in order_by:\n403:                 without_ordering = self.ordering_parts.search(sql)[1]\n404:                 if not is_ref and (without_ordering, params) not in select_sql:\n405:                     extra_select.append((expr, (without_ordering, params), None))\n406:         return extra_select\n407: \n408:     def quote_name_unless_alias(self, name):\n409:         \"\"\"\n410:         A wrapper around connection.ops.quote_name that doesn't quote aliases\n411:         for table names. This avoids problems with some SQL dialects that treat\n412:         quoted strings specially (e.g. PostgreSQL).\n413:         \"\"\"\n414:         if name in self.quote_cache:\n415:             return self.quote_cache[name]\n416:         if ((name in self.query.alias_map and name not in self.query.table_map) or\n417:                 name in self.query.extra_select or (\n418:                     self.query.external_aliases.get(name) and name not in self.query.table_map)):\n419:             self.quote_cache[name] = name\n420:             return name\n421:         r = self.connection.ops.quote_name(name)\n422:         self.quote_cache[name] = r\n423:         return r\n424: \n425:     def compile(self, node):\n426:         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n427:         if vendor_impl:\n428:             sql, params = vendor_impl(self, self.connection)\n429:         else:\n430:             sql, params = node.as_sql(self, self.connection)\n431:         return sql, params\n432: \n433:     def get_combinator_sql(self, combinator, all):\n434:         features = self.connection.features\n435:         compilers = [\n436:             query.get_compiler(self.using, self.connection)\n437:             for query in self.query.combined_queries if not query.is_empty()\n438:         ]\n439:         if not features.supports_slicing_ordering_in_compound:\n440:             for query, compiler in zip(self.query.combined_queries, compilers):\n441:                 if query.low_mark or query.high_mark:\n442:                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')\n443:                 if compiler.get_order_by():\n444:                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')\n445:         parts = ()\n446:         for compiler in compilers:\n447:             try:\n448:                 # If the columns list is limited, then all combined queries\n449:                 # must have the same columns list. Set the selects defined on\n450:                 # the query on all combined queries, if not already set.\n451:                 if not compiler.query.values_select and self.query.values_select:\n452:                     compiler.query = compiler.query.clone()\n453:                     compiler.query.set_values((\n454:                         *self.query.extra_select,\n455:                         *self.query.values_select,\n456:                         *self.query.annotation_select,\n457:                     ))\n458:                 part_sql, part_args = compiler.as_sql()\n459:                 if compiler.query.combinator:\n460:                     # Wrap in a subquery if wrapping in parentheses isn't\n461:                     # supported.\n462:                     if not features.supports_parentheses_in_compound:\n463:                         part_sql = 'SELECT * FROM ({})'.format(part_sql)\n464:                     # Add parentheses when combining with compound query if not\n465:                     # already added for all compound queries.\n466:                     elif not features.supports_slicing_ordering_in_compound:\n467:                         part_sql = '({})'.format(part_sql)\n468:                 parts += ((part_sql, part_args),)\n469:             except EmptyResultSet:\n470:                 # Omit the empty queryset with UNION and with DIFFERENCE if the\n471:                 # first queryset is nonempty.\n472:                 if combinator == 'union' or (combinator == 'difference' and parts):\n473:                     continue\n474:                 raise\n475:         if not parts:\n476:             raise EmptyResultSet\n477:         combinator_sql = self.connection.ops.set_operators[combinator]\n478:         if all and combinator == 'union':\n479:             combinator_sql += ' ALL'\n480:         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'\n481:         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))\n482:         result = [' {} '.format(combinator_sql).join(sql_parts)]\n483:         params = []\n484:         for part in args_parts:\n485:             params.extend(part)\n486:         return result, params\n487: \n488:     def as_sql(self, with_limits=True, with_col_aliases=False):\n489:         \"\"\"\n490:         Create the SQL for this query. Return the SQL string and list of\n491:         parameters.\n492: \n493:         If 'with_limits' is False, any limit/offset information is not included\n494:         in the query.\n495:         \"\"\"\n496:         refcounts_before = self.query.alias_refcount.copy()\n497:         try:\n498:             extra_select, order_by, group_by = self.pre_sql_setup()\n499:             for_update_part = None\n500:             # Is a LIMIT/OFFSET clause needed?\n501:             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n502:             combinator = self.query.combinator\n503:             features = self.connection.features\n504:             if combinator:\n505:                 if not getattr(features, 'supports_select_{}'.format(combinator)):\n506:                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n507:                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n508:             else:\n509:                 distinct_fields, distinct_params = self.get_distinct()\n510:                 # This must come after 'select', 'ordering', and 'distinct'\n511:                 # (see docstring of get_from_clause() for details).\n512:                 from_, f_params = self.get_from_clause()\n513:                 where, w_params = self.compile(self.where) if self.where is not None else (\"\", [])\n514:                 having, h_params = self.compile(self.having) if self.having is not None else (\"\", [])\n515:                 result = ['SELECT']\n516:                 params = []\n517: \n518:                 if self.query.distinct:\n519:                     distinct_result, distinct_params = self.connection.ops.distinct_sql(\n520:                         distinct_fields,\n521:                         distinct_params,\n522:                     )\n523:                     result += distinct_result\n524:                     params += distinct_params\n525: \n526:                 out_cols = []\n527:                 col_idx = 1\n528:                 for _, (s_sql, s_params), alias in self.select + extra_select:\n529:                     if alias:\n530:                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n531:                     elif with_col_aliases:\n532:                         s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n533:                         col_idx += 1\n534:                     params.extend(s_params)\n535:                     out_cols.append(s_sql)\n536: \n537:                 result += [', '.join(out_cols), 'FROM', *from_]\n538:                 params.extend(f_params)\n539: \n540:                 if self.query.select_for_update and self.connection.features.has_select_for_update:\n541:                     if self.connection.get_autocommit():\n542:                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n543: \n544:                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:\n545:                         raise NotSupportedError(\n546:                             'LIMIT/OFFSET is not supported with '\n547:                             'select_for_update on this database backend.'\n548:                         )\n549:                     nowait = self.query.select_for_update_nowait\n550:                     skip_locked = self.query.select_for_update_skip_locked\n551:                     of = self.query.select_for_update_of\n552:                     no_key = self.query.select_for_no_key_update\n553:                     # If it's a NOWAIT/SKIP LOCKED/OF/NO KEY query but the\n554:                     # backend doesn't support it, raise NotSupportedError to\n555:                     # prevent a possible deadlock.\n556:                     if nowait and not self.connection.features.has_select_for_update_nowait:\n557:                         raise NotSupportedError('NOWAIT is not supported on this database backend.')\n558:                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:\n559:                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n560:                     elif of and not self.connection.features.has_select_for_update_of:\n561:                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n562:                     elif no_key and not self.connection.features.has_select_for_no_key_update:\n563:                         raise NotSupportedError(\n564:                             'FOR NO KEY UPDATE is not supported on this '\n565:                             'database backend.'\n566:                         )\n567:                     for_update_part = self.connection.ops.for_update_sql(\n568:                         nowait=nowait,\n569:                         skip_locked=skip_locked,\n570:                         of=self.get_select_for_update_of_arguments(),\n571:                         no_key=no_key,\n572:                     )\n573: \n574:                 if for_update_part and self.connection.features.for_update_after_from:\n575:                     result.append(for_update_part)\n576: \n577:                 if where:\n578:                     result.append('WHERE %s' % where)\n579:                     params.extend(w_params)\n580: \n581:                 grouping = []\n582:                 for g_sql, g_params in group_by:\n583:                     grouping.append(g_sql)\n584:                     params.extend(g_params)\n585:                 if grouping:\n586:                     if distinct_fields:\n587:                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n588:                     order_by = order_by or self.connection.ops.force_no_ordering()\n589:                     result.append('GROUP BY %s' % ', '.join(grouping))\n590:                     if self._meta_ordering:\n591:                         order_by = None\n592:                 if having:\n593:                     result.append('HAVING %s' % having)\n594:                     params.extend(h_params)\n595: \n596:             if self.query.explain_query:\n597:                 result.insert(0, self.connection.ops.explain_query_prefix(\n598:                     self.query.explain_format,\n599:                     **self.query.explain_options\n600:                 ))\n601: \n602:             if order_by:\n603:                 ordering = []\n604:                 for _, (o_sql, o_params, _) in order_by:\n605:                     ordering.append(o_sql)\n606:                     params.extend(o_params)\n607:                 result.append('ORDER BY %s' % ', '.join(ordering))\n608: \n609:             if with_limit_offset:\n610:                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n611: \n612:             if for_update_part and not self.connection.features.for_update_after_from:\n613:                 result.append(for_update_part)\n614: \n615:             if self.query.subquery and extra_select:\n616:                 # If the query is used as a subquery, the extra selects would\n617:                 # result in more columns than the left-hand side expression is\n618:                 # expecting. This can happen when a subquery uses a combination\n619:                 # of order_by() and distinct(), forcing the ordering expressions\n620:                 # to be selected as well. Wrap the query in another subquery\n621:                 # to exclude extraneous selects.\n622:                 sub_selects = []\n623:                 sub_params = []\n624:                 for index, (select, _, alias) in enumerate(self.select, start=1):\n625:                     if not alias and with_col_aliases:\n626:                         alias = 'col%d' % index\n627:                     if alias:\n628:                         sub_selects.append(\"%s.%s\" % (\n629:                             self.connection.ops.quote_name('subquery'),\n630:                             self.connection.ops.quote_name(alias),\n631:                         ))\n632:                     else:\n633:                         select_clone = select.relabeled_clone({select.alias: 'subquery'})\n634:                         subselect, subparams = select_clone.as_sql(self, self.connection)\n635:                         sub_selects.append(subselect)\n636:                         sub_params.extend(subparams)\n637:                 return 'SELECT %s FROM (%s) subquery' % (\n638:                     ', '.join(sub_selects),\n639:                     ' '.join(result),\n640:                 ), tuple(sub_params + params)\n641: \n642:             return ' '.join(result), tuple(params)\n643:         finally:\n644:             # Finally do cleanup - get rid of the joins we created above.\n645:             self.query.reset_refcounts(refcounts_before)\n646: \n647:     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n648:         \"\"\"\n649:         Compute the default columns for selecting every field in the base\n650:         model. Will sometimes be called to pull in related models (e.g. via\n651:         select_related), in which case \"opts\" and \"start_alias\" will be given\n652:         to provide a starting point for the traversal.\n653: \n654:         Return a list of strings, quoted appropriately for use in SQL\n655:         directly, as well as a set of aliases used in the select statement (if\n656:         'as_pairs' is True, return a list of (alias, col_name) pairs instead\n657:         of strings as the first component and None as the second component).\n658:         \"\"\"\n659:         result = []\n660:         if opts is None:\n661:             opts = self.query.get_meta()\n662:         only_load = self.deferred_to_columns()\n663:         start_alias = start_alias or self.query.get_initial_alias()\n664:         # The 'seen_models' is used to optimize checking the needed parent\n665:         # alias for a given field. This also includes None -> start_alias to\n666:         # be used by local fields.\n667:         seen_models = {None: start_alias}\n668: \n669:         for field in opts.concrete_fields:\n670:             model = field.model._meta.concrete_model\n671:             # A proxy model will have a different model and concrete_model. We\n672:             # will assign None if the field belongs to this model.\n673:             if model == opts.model:\n674:                 model = None\n675:             if from_parent and model is not None and issubclass(\n676:                     from_parent._meta.concrete_model, model._meta.concrete_model):\n677:                 # Avoid loading data for already loaded parents.\n678:                 # We end up here in the case select_related() resolution\n679:                 # proceeds from parent model to child model. In that case the\n680:                 # parent model data is already present in the SELECT clause,\n681:                 # and we want to avoid reloading the same data again.\n682:                 continue\n683:             if field.model in only_load and field.attname not in only_load[field.model]:\n684:                 continue\n685:             alias = self.query.join_parent_model(opts, model, start_alias,\n686:                                                  seen_models)\n687:             column = field.get_col(alias)\n688:             result.append(column)\n689:         return result\n690: \n691:     def get_distinct(self):\n692:         \"\"\"\n693:         Return a quoted list of fields to use in DISTINCT ON part of the query.\n694: \n695:         This method can alter the tables in the query, and thus it must be\n696:         called before get_from_clause().\n697:         \"\"\"\n698:         result = []\n699:         params = []\n700:         opts = self.query.get_meta()\n701: \n702:         for name in self.query.distinct_fields:\n703:             parts = name.split(LOOKUP_SEP)\n704:             _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)\n705:             targets, alias, _ = self.query.trim_joins(targets, joins, path)\n706:             for target in targets:\n707:                 if name in self.query.annotation_select:\n708:                     result.append(name)\n709:                 else:\n710:                     r, p = self.compile(transform_function(target, alias))\n711:                     result.append(r)\n712:                     params.append(p)\n713:         return result, params\n714: \n715:     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n716:                            already_seen=None):\n717:         \"\"\"\n718:         Return the table alias (the name might be ambiguous, the alias will\n719:         not be) and column name for ordering by the given 'name' parameter.\n720:         The 'name' is of the form 'field1__field2__...__fieldN'.\n721:         \"\"\"\n722:         name, order = get_order_dir(name, default_order)\n723:         descending = order == 'DESC'\n724:         pieces = name.split(LOOKUP_SEP)\n725:         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n726: \n727:         # If we get to this point and the field is a relation to another model,\n728:         # append the default ordering for that model unless it is the pk\n729:         # shortcut or the attribute name of the field that is specified.\n730:         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n731:             # Firstly, avoid infinite loops.\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/sql/compiler.py",
      "suspect_lines": [
        730
      ]
    }
  ]
}