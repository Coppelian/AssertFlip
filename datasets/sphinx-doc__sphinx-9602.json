{
  "instance_id": "sphinx-doc__sphinx-9602",
  "problem_statement": "Nitpick flags Literal annotation values as missing py:class\n### Describe the bug\n\nWhen a value is present in a type annotation as `Literal`, sphinx will treat the value as a `py:class`. With nitpick enabled, values like `Literal[True]` end up failing, because `True` is not a class.\r\n\r\nThis is a problem for builds which want to use `-n -W` to catch doc errors.\n\n### How to Reproduce\n\nSetup a simple function which uses Literal, then attempt to autodoc it. e.g.\r\n```python\r\nimport typing\r\n@typing.overload\r\ndef foo(x: \"typing.Literal[True]\") -> int: ...\r\n@typing.overload\r\ndef foo(x: \"typing.Literal[False]\") -> str: ...\r\ndef foo(x: bool):\r\n    \"\"\"a func\"\"\"\r\n    return 1 if x else \"foo\"\r\n```\r\n\r\nI've pushed an example [failing project](https://github.com/sirosen/repro/tree/master/sphinxdoc/literal) to [my repro repo](https://github.com/sirosen/repro). Just run `./doc.sh` with `sphinx-build` available to see the failing build.\n\n### Expected behavior\n\n`Literal[True]` (or whatever literal value) should be present in the type annotation but should not trigger the nitpick warning.\n\n### Your project\n\nhttps://github.com/sirosen/repro/tree/master/sphinxdoc/literal\n\n### Screenshots\n\n_No response_\n\n### OS\n\nLinux\n\n### Python version\n\n3.8, 3.9\n\n### Sphinx version\n\n4.1.2\n\n### Sphinx extensions\n\nautodoc\n\n### Extra tools\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "localized_code": "[start of sphinx/domains/python.py]\n1: \"\"\"\n2:     sphinx.domains.python\n3:     ~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     The Python domain.\n6: \n7:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import builtins\n12: import inspect\n13: import re\n14: import sys\n15: import typing\n16: import warnings\n17: from inspect import Parameter\n18: from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Optional, Tuple, Type, cast\n19: \n20: from docutils import nodes\n21: from docutils.nodes import Element, Node\n22: from docutils.parsers.rst import directives\n23: from docutils.parsers.rst.states import Inliner\n24: \n25: from sphinx import addnodes\n26: from sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\n27: from sphinx.application import Sphinx\n28: from sphinx.builders import Builder\n29: from sphinx.deprecation import RemovedInSphinx50Warning\n30: from sphinx.directives import ObjectDescription\n31: from sphinx.domains import Domain, Index, IndexEntry, ObjType\n32: from sphinx.environment import BuildEnvironment\n33: from sphinx.locale import _, __\n34: from sphinx.pycode.ast import ast\n35: from sphinx.pycode.ast import parse as ast_parse\n36: from sphinx.roles import XRefRole\n37: from sphinx.util import logging\n38: from sphinx.util.docfields import Field, GroupedField, TypedField\n39: from sphinx.util.docutils import SphinxDirective\n40: from sphinx.util.inspect import signature_from_str\n41: from sphinx.util.nodes import find_pending_xref_condition, make_id, make_refnode\n42: from sphinx.util.typing import OptionSpec, TextlikeNode\n43: \n44: logger = logging.getLogger(__name__)\n45: \n46: \n47: # REs for Python signatures\n48: py_sig_re = re.compile(\n49:     r'''^ ([\\w.]*\\.)?            # class name(s)\n50:           (\\w+)  \\s*             # thing name\n51:           (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n52:            (?:\\s* -> \\s* (.*))?  #           return annotation\n53:           )? $                   # and nothing more\n54:           ''', re.VERBOSE)\n55: \n56: \n57: pairindextypes = {\n58:     'module':    _('module'),\n59:     'keyword':   _('keyword'),\n60:     'operator':  _('operator'),\n61:     'object':    _('object'),\n62:     'exception': _('exception'),\n63:     'statement': _('statement'),\n64:     'builtin':   _('built-in function'),\n65: }\n66: \n67: \n68: class ObjectEntry(NamedTuple):\nCode replaced for brevity.\n72: \n73: \n74: \n75: class ModuleEntry(NamedTuple):\nCode replaced for brevity.\n80: \n81: \n82: \n83: def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\nCode replaced for brevity.\n107: \n108: \n109: \n110: def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\n111:     \"\"\"Parse type annotation.\"\"\"\n112:     def unparse(node: ast.AST) -> List[Node]:\n113:         if isinstance(node, ast.Attribute):\n114:             return [nodes.Text(\"%s.%s\" % (unparse(node.value)[0], node.attr))]\n115:         elif isinstance(node, ast.BinOp):\n116:             result: List[Node] = unparse(node.left)\n117:             result.extend(unparse(node.op))\n118:             result.extend(unparse(node.right))\n119:             return result\n120:         elif isinstance(node, ast.BitOr):\n121:             return [nodes.Text(' '), addnodes.desc_sig_punctuation('', '|'), nodes.Text(' ')]\n122:         elif isinstance(node, ast.Constant):  # type: ignore\n123:             if node.value is Ellipsis:\n124:                 return [addnodes.desc_sig_punctuation('', \"...\")]\n125:             else:\n126:                 return [nodes.Text(node.value)]\n127:         elif isinstance(node, ast.Expr):\n128:             return unparse(node.value)\n129:         elif isinstance(node, ast.Index):\n130:             return unparse(node.value)\n131:         elif isinstance(node, ast.List):\n132:             result = [addnodes.desc_sig_punctuation('', '[')]\n133:             if node.elts:\n134:                 # check if there are elements in node.elts to only pop the\n135:                 # last element of result if the for-loop was run at least\n136:                 # once\n137:                 for elem in node.elts:\n138:                     result.extend(unparse(elem))\n139:                     result.append(addnodes.desc_sig_punctuation('', ', '))\n140:                 result.pop()\n141:             result.append(addnodes.desc_sig_punctuation('', ']'))\n142:             return result\n143:         elif isinstance(node, ast.Module):\n144:             return sum((unparse(e) for e in node.body), [])\n145:         elif isinstance(node, ast.Name):\n146:             return [nodes.Text(node.id)]\n147:         elif isinstance(node, ast.Subscript):\n148:             result = unparse(node.value)\n149:             result.append(addnodes.desc_sig_punctuation('', '['))\n150:             result.extend(unparse(node.slice))\n151:             result.append(addnodes.desc_sig_punctuation('', ']'))\n152:             return result\n153:         elif isinstance(node, ast.Tuple):\n154:             if node.elts:\n155:                 result = []\n156:                 for elem in node.elts:\n157:                     result.extend(unparse(elem))\n158:                     result.append(addnodes.desc_sig_punctuation('', ', '))\n159:                 result.pop()\n160:             else:\n161:                 result = [addnodes.desc_sig_punctuation('', '('),\n162:                           addnodes.desc_sig_punctuation('', ')')]\n163: \n164:             return result\n165:         else:\n166:             if sys.version_info < (3, 8):\n167:                 if isinstance(node, ast.Ellipsis):\n168:                     return [addnodes.desc_sig_punctuation('', \"...\")]\n169:                 elif isinstance(node, ast.NameConstant):\n170:                     return [nodes.Text(node.value)]\n171: \n172:             raise SyntaxError  # unsupported syntax\n173: \n174:     if env is None:\n175:         warnings.warn(\"The env parameter for _parse_annotation becomes required now.\",\n176:                       RemovedInSphinx50Warning, stacklevel=2)\n177: \n178:     try:\n179:         tree = ast_parse(annotation)\n180:         result = unparse(tree)\n181:         for i, node in enumerate(result):\n182:             if isinstance(node, nodes.Text) and node.strip():\n183:                 result[i] = type_to_xref(str(node), env)\n184:         return result\n185:     except SyntaxError:\n186:         return [type_to_xref(annotation, env)]\n187: \n188: \n189: def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\nCode replaced for brevity.\n236: \n237: \n238: \n239: def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\nCode replaced for brevity.\n284: \n285: \n286: \n287: # This override allows our inline type specifiers to behave like :class: link\n288: # when it comes to handling \".\" and \"~\" prefixes.\n289: class PyXrefMixin:\nCode replaced for brevity.\n344: \n345: \n346: \n347: class PyField(PyXrefMixin, Field):\nCode replaced for brevity.\n357: \n358: \n359: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/domains/python.py",
      "suspect_lines": [
        126,
        182
      ]
    }
  ]
}