{
  "instance_id": "sphinx-doc__sphinx-9281",
  "problem_statement": "Python Enum values (used to show default values in function signatures) are rendered ugly.\nPython Enum values (used to show default values in function signatures) are rendered ugly.\r\n\r\n**To Reproduce**\r\n\r\nI made a minimal example to show the issue:\r\n\r\nhttps://github.com/sidneycadot/sphinx_issue_ugly_enum\r\n\r\n```\r\n$ git clone git@github.com:sidneycadot/sphinx_issue_ugly_enum.git\r\n$ cd sphinx_issue_ugly_enum/\r\n$ make html\r\n$ firefox build/html/index.html \r\n```\r\n\r\n**Expected behavior**\r\n\r\nI would hope the signature rendered as:\r\n\r\n    ugly_enum_func(e: ugly_enum.MyEnum = MyEnum.ValueA) → None\r\n\r\nUnfortunately, it renders as:\r\n\r\n    ugly_enum_func(e: ugly_enum.MyEnum = <MyEnum.ValueA: 10>) → None\r\n\r\n**Environment info**\r\n\r\n- Python version: 3.9.5\r\n- Sphinx version: 4.0.2\r\n- Sphinx extensions: autodoc\r\n\n",
  "localized_code": "[start of sphinx/util/inspect.py]\n1: \"\"\"\n2:     sphinx.util.inspect\n3:     ~~~~~~~~~~~~~~~~~~~\n4: \n5:     Helpers for inspecting Python modules.\n6: \n7:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import builtins\n12: import contextlib\n13: import enum\n14: import inspect\n15: import re\n16: import sys\n17: import types\n18: import typing\n19: import warnings\n20: from functools import partial, partialmethod\n21: from importlib import import_module\n22: from inspect import Parameter, isclass, ismethod, ismethoddescriptor, ismodule  # NOQA\n23: from io import StringIO\n24: from types import ModuleType\n25: from typing import Any, Callable, Dict, Mapping, Optional, Sequence, Tuple, Type, cast\n26: \n27: from sphinx.deprecation import RemovedInSphinx50Warning\n28: from sphinx.pycode.ast import ast  # for py36-37\n29: from sphinx.pycode.ast import unparse as ast_unparse\n30: from sphinx.util import logging\n31: from sphinx.util.typing import ForwardRef\n32: from sphinx.util.typing import stringify as stringify_annotation\n33: \n34: if sys.version_info > (3, 7):\n35:     from types import ClassMethodDescriptorType, MethodDescriptorType, WrapperDescriptorType\n36: else:\n37:     ClassMethodDescriptorType = type(object.__init__)\n38:     MethodDescriptorType = type(str.join)\n39:     WrapperDescriptorType = type(dict.__dict__['fromkeys'])\n40: \n41: if False:\n42:     # For type annotation\n43:     from typing import Type  # NOQA\n44: \n45: logger = logging.getLogger(__name__)\n46: \n47: memory_address_re = re.compile(r' at 0x[0-9a-f]{8,16}(?=>)', re.IGNORECASE)\n48: \n49: \n50: # Copied from the definition of inspect.getfullargspec from Python master,\n51: # and modified to remove the use of special flags that break decorated\n52: # callables and bound methods in the name of backwards compatibility. Used\n53: # under the terms of PSF license v2, which requires the above statement\n54: # and the following:\n55: #\n56: #   Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n57: #   2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017 Python Software\n58: #   Foundation; All Rights Reserved\n59: def getargspec(func: Callable) -> Any:\nCode replaced for brevity.\n110: \n111: \n112: \n113: def unwrap(obj: Any) -> Any:\nCode replaced for brevity.\n123: \n124: \n125: \n126: def unwrap_all(obj: Any, *, stop: Callable = None) -> Any:\nCode replaced for brevity.\n143: \n144: \n145: \n146: def getall(obj: Any) -> Optional[Sequence[str]]:\nCode replaced for brevity.\n159: \n160: \n161: \n162: def getannotations(obj: Any) -> Mapping[str, Any]:\nCode replaced for brevity.\n168: \n169: \n170: \n171: def getglobals(obj: Any) -> Mapping[str, Any]:\nCode replaced for brevity.\n177: \n178: \n179: \n180: def getmro(obj: Any) -> Tuple[Type, ...]:\nCode replaced for brevity.\n186: \n187: \n188: \n189: def getslots(obj: Any) -> Optional[Dict]:\nCode replaced for brevity.\n209: \n210: \n211: \n212: def isNewType(obj: Any) -> bool:\nCode replaced for brevity.\n219: \n220: \n221: \n222: def isenumclass(x: Any) -> bool:\nCode replaced for brevity.\n224: \n225: \n226: \n227: def isenumattribute(x: Any) -> bool:\nCode replaced for brevity.\n229: \n230: \n231: \n232: def unpartial(obj: Any) -> Any:\nCode replaced for brevity.\n240: \n241: \n242: \n243: def ispartial(obj: Any) -> bool:\nCode replaced for brevity.\n245: \n246: \n247: \n248: def isclassmethod(obj: Any) -> bool:\nCode replaced for brevity.\n255: \n256: \n257: \n258: def isstaticmethod(obj: Any, cls: Any = None, name: str = None) -> bool:\nCode replaced for brevity.\n274: \n275: \n276: \n277: def isdescriptor(x: Any) -> bool:\nCode replaced for brevity.\n282: \n283: \n284: \n285: def isabstractmethod(obj: Any) -> bool:\nCode replaced for brevity.\n287: \n288: \n289: \n290: def is_cython_function_or_method(obj: Any) -> bool:\nCode replaced for brevity.\n295: \n296: \n297: \n298: def isattributedescriptor(obj: Any) -> bool:\nCode replaced for brevity.\n326: \n327: \n328: \n329: def is_singledispatch_function(obj: Any) -> bool:\nCode replaced for brevity.\n337: \n338: \n339: \n340: def is_singledispatch_method(obj: Any) -> bool:\nCode replaced for brevity.\n346: \n347: \n348: \n349: def isfunction(obj: Any) -> bool:\nCode replaced for brevity.\n351: \n352: \n353: \n354: def isbuiltin(obj: Any) -> bool:\nCode replaced for brevity.\n356: \n357: \n358: \n359: def isroutine(obj: Any) -> bool:\nCode replaced for brevity.\n361: \n362: \n363: \n364: def iscoroutinefunction(obj: Any) -> bool:\nCode replaced for brevity.\n383: \n384: \n385: \n386: def isproperty(obj: Any) -> bool:\nCode replaced for brevity.\n393: \n394: \n395: \n396: def isgenericalias(obj: Any) -> bool:\nCode replaced for brevity.\n408: \n409: \n410: \n411: def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\nCode replaced for brevity.\n430: \n431: \n432: \n433: def object_description(object: Any) -> str:\n434:     \"\"\"A repr() implementation that returns text safe to use in reST context.\"\"\"\n435:     if isinstance(object, dict):\n436:         try:\n437:             sorted_keys = sorted(object)\n438:         except Exception:\n439:             pass  # Cannot sort dict keys, fall back to generic repr\n440:         else:\n441:             items = (\"%s: %s\" %\n442:                      (object_description(key), object_description(object[key]))\n443:                      for key in sorted_keys)\n444:             return \"{%s}\" % \", \".join(items)\n445:     if isinstance(object, set):\n446:         try:\n447:             sorted_values = sorted(object)\n448:         except TypeError:\n449:             pass  # Cannot sort set values, fall back to generic repr\n450:         else:\n451:             return \"{%s}\" % \", \".join(object_description(x) for x in sorted_values)\n452:     if isinstance(object, frozenset):\n453:         try:\n454:             sorted_values = sorted(object)\n455:         except TypeError:\n456:             pass  # Cannot sort frozenset values, fall back to generic repr\n457:         else:\n458:             return \"frozenset({%s})\" % \", \".join(object_description(x)\n459:                                                  for x in sorted_values)\n460:     try:\n461:         s = repr(object)\n462:     except Exception as exc:\n463:         raise ValueError from exc\n464:     # Strip non-deterministic memory addresses such as\n465:     # ``<__main__.A at 0x7f68cb685710>``\n466:     s = memory_address_re.sub('', s)\n467:     return s.replace('\\n', ' ')\n468: \n469: \n470: def is_builtin_class_method(obj: Any, attr_name: str) -> bool:\nCode replaced for brevity.\n490: \n491: \n492: \n493: class DefaultValue:\nCode replaced for brevity.\n503: \n504: \n505: \n506: class TypeAliasForwardRef:\nCode replaced for brevity.\n519: \n520: \n521: \n522: class TypeAliasModule:\nCode replaced for brevity.\n552: \n553: \n554: \n555: class TypeAliasNamespace(Dict[str, Any]):\nCode replaced for brevity.\n575: \n576: \n577: \n578: def _should_unwrap(subject: Callable) -> bool:\nCode replaced for brevity.\n586: \n587: \n588: \n589:               type_aliases: Dict = {}) -> inspect.Signature:\nCode replaced for brevity.\n659: \n660: \n661: \n662:                        ) -> inspect.Signature:\nCode replaced for brevity.\n706: \n707: \n708: \n709:                         show_return_annotation: bool = True) -> str:\nCode replaced for brevity.\n758: \n759: \n760: \n761: def signature_from_str(signature: str) -> inspect.Signature:\nCode replaced for brevity.\n767: \n768: \n769: \n770: def signature_from_ast(node: ast.FunctionDef, code: str = '') -> inspect.Signature:\nCode replaced for brevity.\n824: \n825: \n826: \n827:            allow_inherited: bool = False, cls: Any = None, name: str = None) -> str:\nCode replaced for brevity.\n862: \n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/util/inspect.py",
      "suspect_lines": [
        445,
        452
      ]
    }
  ]
}