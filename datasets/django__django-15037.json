{
  "instance_id": "django__django-15037",
  "problem_statement": "Foreign key to a specific field is not handled in inspectdb\nDescription\n\t \n\t\t(last modified by Tim Graham)\n\t \nif you have a DB like that\nCREATE TABLE foo ( id serial primary key, other_id int UNIQUE);\nCREATE TABLE bar (\n\tid serial primary key, other_id int,\n\tconstraint myconst \n\tFOREIGN KEY(other_id) references foo(other_id)\n);\nthe generated model for the bar table will have the other_id be a FK to foo and not foo(other_id).\nI'm attaching a potential fix for this. Sorry I had no time for the UTs.\n",
  "localized_code": "[start of django/core/management/commands/inspectdb.py]\n1: import keyword\n2: import re\n3: \n4: from django.core.management.base import BaseCommand, CommandError\n5: from django.db import DEFAULT_DB_ALIAS, connections\n6: from django.db.models.constants import LOOKUP_SEP\n7: \n8: \n9: class Command(BaseCommand):\n10:     help = \"Introspects the database tables in the given database and outputs a Django model module.\"\n11:     requires_system_checks = []\n12:     stealth_options = ('table_name_filter',)\n13:     db_module = 'django.db'\n14: \n15:     def add_arguments(self, parser):\n16:         parser.add_argument(\n17:             'table', nargs='*', type=str,\n18:             help='Selects what tables or views should be introspected.',\n19:         )\n20:         parser.add_argument(\n21:             '--database', default=DEFAULT_DB_ALIAS,\n22:             help='Nominates a database to introspect. Defaults to using the \"default\" database.',\n23:         )\n24:         parser.add_argument(\n25:             '--include-partitions', action='store_true', help='Also output models for partition tables.',\n26:         )\n27:         parser.add_argument(\n28:             '--include-views', action='store_true', help='Also output models for database views.',\n29:         )\n30: \n31:     def handle(self, **options):\n32:         try:\n33:             for line in self.handle_inspection(options):\n34:                 self.stdout.write(line)\n35:         except NotImplementedError:\n36:             raise CommandError(\"Database inspection isn't supported for the currently selected database backend.\")\n37: \n38:     def handle_inspection(self, options):\n39:         connection = connections[options['database']]\n40:         # 'table_name_filter' is a stealth option\n41:         table_name_filter = options.get('table_name_filter')\n42: \n43:         def table2model(table_name):\n44:             return re.sub(r'[^a-zA-Z0-9]', '', table_name.title())\n45: \n46:         with connection.cursor() as cursor:\n47:             yield \"# This is an auto-generated Django model module.\"\n48:             yield \"# You'll have to do the following manually to clean this up:\"\n49:             yield \"#   * Rearrange models' order\"\n50:             yield \"#   * Make sure each model has one field with primary_key=True\"\n51:             yield \"#   * Make sure each ForeignKey and OneToOneField has `on_delete` set to the desired behavior\"\n52:             yield (\n53:                 \"#   * Remove `managed = False` lines if you wish to allow \"\n54:                 \"Django to create, modify, and delete the table\"\n55:             )\n56:             yield \"# Feel free to rename the models, but don't rename db_table values or field names.\"\n57:             yield 'from %s import models' % self.db_module\n58:             known_models = []\n59:             table_info = connection.introspection.get_table_list(cursor)\n60: \n61:             # Determine types of tables and/or views to be introspected.\n62:             types = {'t'}\n63:             if options['include_partitions']:\n64:                 types.add('p')\n65:             if options['include_views']:\n66:                 types.add('v')\n67: \n68:             for table_name in (options['table'] or sorted(info.name for info in table_info if info.type in types)):\n69:                 if table_name_filter is not None and callable(table_name_filter):\n70:                     if not table_name_filter(table_name):\n71:                         continue\n72:                 try:\n73:                     try:\n74:                         relations = connection.introspection.get_relations(cursor, table_name)\n75:                     except NotImplementedError:\n76:                         relations = {}\n77:                     try:\n78:                         constraints = connection.introspection.get_constraints(cursor, table_name)\n79:                     except NotImplementedError:\n80:                         constraints = {}\n81:                     primary_key_column = connection.introspection.get_primary_key_column(cursor, table_name)\n82:                     unique_columns = [\n83:                         c['columns'][0] for c in constraints.values()\n84:                         if c['unique'] and len(c['columns']) == 1\n85:                     ]\n86:                     table_description = connection.introspection.get_table_description(cursor, table_name)\n87:                 except Exception as e:\n88:                     yield \"# Unable to inspect table '%s'\" % table_name\n89:                     yield \"# The error was: %s\" % e\n90:                     continue\n91: \n92:                 yield ''\n93:                 yield ''\n94:                 yield 'class %s(models.Model):' % table2model(table_name)\n95:                 known_models.append(table2model(table_name))\n96:                 used_column_names = []  # Holds column names used in the table so far\n97:                 column_to_field_name = {}  # Maps column names to names of model fields\n98:                 for row in table_description:\n99:                     comment_notes = []  # Holds Field notes, to be displayed in a Python comment.\n100:                     extra_params = {}  # Holds Field parameters such as 'db_column'.\n101:                     column_name = row.name\n102:                     is_relation = column_name in relations\n103: \n104:                     att_name, params, notes = self.normalize_col_name(\n105:                         column_name, used_column_names, is_relation)\n106:                     extra_params.update(params)\n107:                     comment_notes.extend(notes)\n108: \n109:                     used_column_names.append(att_name)\n110:                     column_to_field_name[column_name] = att_name\n111: \n112:                     # Add primary_key and unique, if necessary.\n113:                     if column_name == primary_key_column:\n114:                         extra_params['primary_key'] = True\n115:                     elif column_name in unique_columns:\n116:                         extra_params['unique'] = True\n117: \n118:                     if is_relation:\n119:                         if extra_params.pop('unique', False) or extra_params.get('primary_key'):\n120:                             rel_type = 'OneToOneField'\n121:                         else:\n122:                             rel_type = 'ForeignKey'\n123:                         rel_to = (\n124:                             \"self\" if relations[column_name][1] == table_name\n125:                             else table2model(relations[column_name][1])\n126:                         )\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/management/commands/inspectdb.py",
      "suspect_lines": [
        124,
        125
      ]
    }
  ]
}