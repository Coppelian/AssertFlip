{
  "instance_id": "pydata__xarray-6461",
  "problem_statement": "xr.where with scalar as second argument fails with keep_attrs=True\n### What happened?\n\n``` python\r\nimport xarray as xr\r\n\r\nxr.where(xr.DataArray([1, 2, 3]) > 0, 1, 0)\r\n```\r\n\r\nfails with\r\n\r\n```\r\n   1809 if keep_attrs is True:\r\n   1810     # keep the attributes of x, the second parameter, by default to\r\n   1811     # be consistent with the `where` method of `DataArray` and `Dataset`\r\n-> 1812     keep_attrs = lambda attrs, context: attrs[1]\r\n   1814 # alignment for three arguments is complicated, so don't support it yet\r\n   1815 return apply_ufunc(\r\n   1816     duck_array_ops.where,\r\n   1817     cond,\r\n   (...)\r\n   1823     keep_attrs=keep_attrs,\r\n   1824 )\r\n\r\nIndexError: list index out of range\r\n```\r\n\r\nThe workaround is to pass `keep_attrs=False`\n\n### What did you expect to happen?\n\n_No response_\n\n### Minimal Complete Verifiable Example\n\n_No response_\n\n### Relevant log output\n\n_No response_\n\n### Anything else we need to know?\n\n_No response_\n\n### Environment\n\nxarray 2022.3.0\n",
  "localized_code": "[start of xarray/core/computation.py]\n1: \"\"\"\n2: Functions for applying functions that act on arrays to xarray's labeled data.\n3: \"\"\"\n4: from __future__ import annotations\n5: \n6: import functools\n7: import itertools\n8: import operator\n9: import warnings\n10: from collections import Counter\n11: from typing import (\n12:     TYPE_CHECKING,\n13:     AbstractSet,\n14:     Any,\n15:     Callable,\n16:     Hashable,\n17:     Iterable,\n18:     Mapping,\n19:     Sequence,\n20: )\n21: \n22: import numpy as np\n23: \n24: from . import dtypes, duck_array_ops, utils\n25: from .alignment import align, deep_align\n26: from .indexes import Index, filter_indexes_from_coords\n27: from .merge import merge_attrs, merge_coordinates_without_align\n28: from .options import OPTIONS, _get_keep_attrs\n29: from .pycompat import is_duck_dask_array\n30: from .utils import is_dict_like\n31: from .variable import Variable\n32: \n33: if TYPE_CHECKING:\n34:     from .coordinates import Coordinates\n35:     from .dataarray import DataArray\n36:     from .dataset import Dataset\n37:     from .types import T_Xarray\n38: \n39: _NO_FILL_VALUE = utils.ReprObject(\"<no-fill-value>\")\n40: _DEFAULT_NAME = utils.ReprObject(\"<default-name>\")\n41: _JOINS_WITHOUT_FILL_VALUES = frozenset({\"inner\", \"exact\"})\n42: \n43: \n44: def _first_of_type(args, kind):\n45:     \"\"\"Return either first object of type 'kind' or raise if not found.\"\"\"\n46:     for arg in args:\n47:         if isinstance(arg, kind):\n48:             return arg\n49:     raise ValueError(\"This should be unreachable.\")\n50: \n51: \n52: def _all_of_type(args, kind):\nCode replaced for brevity.\n54: \n55: \n56: \n57: class _UFuncSignature:\nCode replaced for brevity.\n181: \n182: \n183: \n184:     # https://github.com/blaze/blaze/issues/458#issuecomment-51936356\nCode replaced for brevity.\n193: \n194: \n195: \n196: def _get_coords_list(args) -> list[Coordinates]:\nCode replaced for brevity.\n205: \n206: \n207: \n208: ) -> tuple[list[dict[Any, Variable]], list[dict[Any, Index]]]:\nCode replaced for brevity.\n260: \n261: \n262: \n263: ):\nCode replaced for brevity.\n318: \n319: \n320: \n321: def ordered_set_union(all_keys: list[Iterable]) -> Iterable:\nCode replaced for brevity.\n322: \n323: \n324: \n325: def ordered_set_intersection(all_keys: list[Iterable]) -> Iterable:\nCode replaced for brevity.\n329: \n330: \n331: \n332: def assert_and_return_exact_match(all_keys):\nCode replaced for brevity.\n340: \n341: \n342: \n343: _JOINERS: dict[str, Callable] = {\n344:     \"inner\": ordered_set_intersection,\n345:     \"outer\": ordered_set_union,\n346:     \"left\": operator.itemgetter(0),\n347:     \"right\": operator.itemgetter(-1),\n348:     \"exact\": assert_and_return_exact_match,\n349: }\n350: \n351: \n352: def join_dict_keys(objects: Iterable[Mapping | Any], how: str = \"inner\") -> Iterable:\nCode replaced for brevity.\n355: \n356: \n357: \n358: ) -> list[list]:\nCode replaced for brevity.\n364: \n365: \n366: \n367: def _as_variables_or_variable(arg):\nCode replaced for brevity.\n374: \n375: \n376: \n377: ) -> tuple[dict[Hashable, Variable], ...]:\nCode replaced for brevity.\n384: \n385: \n386: \n387: ):\nCode replaced for brevity.\n404: \n405: \n406: \n407: ) -> Dataset:\nCode replaced for brevity.\n420: \n421: \n422: \n423: ):\nCode replaced for brevity.\n478: \n479: \n480: \n481: def _iter_over_selections(obj, dim, values):\nCode replaced for brevity.\n493: \n494: \n495: \n496: def apply_groupby_func(func, *args):\nCode replaced for brevity.\n539: \n540: \n541: \n542: ) -> dict[Hashable, int]:\nCode replaced for brevity.\n564: \n565: \n566: \n567: SLICE_NONE = slice(None)\n568: \n569: \n570: ) -> Any:\nCode replaced for brevity.\n621: \n622: \n623: \n624: def _vectorize(func, signature, output_dtypes, exclude_dims):\nCode replaced for brevity.\n634: \n635: \n636: \n637: ):\nCode replaced for brevity.\n796: \n797: \n798: \n799: def apply_array_ufunc(func, *args, dask=\"forbidden\"):\nCode replaced for brevity.\n819: \n820: \n821: \n822: ) -> Any:\nCode replaced for brevity.\n1192: \n1193: \n1194: \n1195: def cov(da_a, da_b, dim=None, ddof=1):\nCode replaced for brevity.\n1272: \n1273: \n1274: \n1275: def corr(da_a, da_b, dim=None):\nCode replaced for brevity.\n1350: \n1351: \n1352: \n1353: def _cov_corr(da_a, da_b, dim=None, ddof=0, method=None):\nCode replaced for brevity.\n1387: \n1388: \n1389: \n1390: ) -> DataArray | Variable:\nCode replaced for brevity.\n1595: \n1596: \n1597: \n1598: def dot(*arrays, dims=None, **kwargs):\nCode replaced for brevity.\n1740: \n1741: \n1742: \n1743: def where(cond, x, y, keep_attrs=None):\n1744:     \"\"\"Return elements from `x` or `y` depending on `cond`.\n1745: \n1746:     Performs xarray-like broadcasting across input arguments.\n1747: \n1748:     All dimension coordinates on `x` and `y`  must be aligned with each\n1749:     other and with `cond`.\n1750: \n1751:     Parameters\n1752:     ----------\n1753:     cond : scalar, array, Variable, DataArray or Dataset\n1754:         When True, return values from `x`, otherwise returns values from `y`.\n1755:     x : scalar, array, Variable, DataArray or Dataset\n1756:         values to choose from where `cond` is True\n1757:     y : scalar, array, Variable, DataArray or Dataset\n1758:         values to choose from where `cond` is False\n1759:     keep_attrs : bool or str or callable, optional\n1760:         How to treat attrs. If True, keep the attrs of `x`.\n1761: \n1762:     Returns\n1763:     -------\n1764:     Dataset, DataArray, Variable or array\n1765:         In priority order: Dataset, DataArray, Variable or array, whichever\n1766:         type appears as an input argument.\n1767: \n1768:     Examples\n1769:     --------\n1770:     >>> x = xr.DataArray(\n1771:     ...     0.1 * np.arange(10),\n1772:     ...     dims=[\"lat\"],\n1773:     ...     coords={\"lat\": np.arange(10)},\n1774:     ...     name=\"sst\",\n1775:     ... )\n1776:     >>> x\n1777:     <xarray.DataArray 'sst' (lat: 10)>\n1778:     array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n1779:     Coordinates:\n1780:       * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n1781: \n1782:     >>> xr.where(x < 0.5, x, x * 100)\n1783:     <xarray.DataArray 'sst' (lat: 10)>\n1784:     array([ 0. ,  0.1,  0.2,  0.3,  0.4, 50. , 60. , 70. , 80. , 90. ])\n1785:     Coordinates:\n1786:       * lat      (lat) int64 0 1 2 3 4 5 6 7 8 9\n1787: \n1788:     >>> y = xr.DataArray(\n1789:     ...     0.1 * np.arange(9).reshape(3, 3),\n1790:     ...     dims=[\"lat\", \"lon\"],\n1791:     ...     coords={\"lat\": np.arange(3), \"lon\": 10 + np.arange(3)},\n1792:     ...     name=\"sst\",\n1793:     ... )\n1794:     >>> y\n1795:     <xarray.DataArray 'sst' (lat: 3, lon: 3)>\n1796:     array([[0. , 0.1, 0.2],\n1797:            [0.3, 0.4, 0.5],\n1798:            [0.6, 0.7, 0.8]])\n1799:     Coordinates:\n1800:       * lat      (lat) int64 0 1 2\n1801:       * lon      (lon) int64 10 11 12\n1802: \n1803:     >>> xr.where(y.lat < 1, y, -1)\n1804:     <xarray.DataArray (lat: 3, lon: 3)>\n1805:     array([[ 0. ,  0.1,  0.2],\n1806:            [-1. , -1. , -1. ],\n1807:            [-1. , -1. , -1. ]])\n1808:     Coordinates:\n1809:       * lat      (lat) int64 0 1 2\n1810:       * lon      (lon) int64 10 11 12\n1811: \n1812:     >>> cond = xr.DataArray([True, False], dims=[\"x\"])\n1813:     >>> x = xr.DataArray([1, 2], dims=[\"y\"])\n1814:     >>> xr.where(cond, x, 0)\n1815:     <xarray.DataArray (x: 2, y: 2)>\n1816:     array([[1, 2],\n1817:            [0, 0]])\n1818:     Dimensions without coordinates: x, y\n1819: \n1820:     See Also\n1821:     --------\n1822:     numpy.where : corresponding numpy function\n1823:     Dataset.where, DataArray.where :\n1824:         equivalent methods\n1825:     \"\"\"\n1826:     if keep_attrs is None:\n1827:         keep_attrs = _get_keep_attrs(default=False)\n1828: \n1829:     if keep_attrs is True:\n1830:         # keep the attributes of x, the second parameter, by default to\n1831:         # be consistent with the `where` method of `DataArray` and `Dataset`\n1832:         keep_attrs = lambda attrs, context: attrs[1]\n1833: \n1834:     # alignment for three arguments is complicated, so don't support it yet\n1835:     return apply_ufunc(\n1836:         duck_array_ops.where,\n1837:         cond,\n1838:         x,\n1839:         y,\n1840:         join=\"exact\",\n1841:         dataset_join=\"exact\",\n1842:         dask=\"allowed\",\n1843:         keep_attrs=keep_attrs,\n1844:     )\n1845: \n1846: \n1847: def polyval(coord, coeffs, degree_dim=\"degree\"):\nCode replaced for brevity.\n1876: \n1877: \n1878: \n1879: ):\nCode replaced for brevity.\n1939: \n1940: \n1941: \n1942: def unify_chunks(*objects: T_Xarray) -> tuple[T_Xarray, ...]:\nCode replaced for brevity.\n1997: \n\n",
  "line_level_localization": [
    {
      "filename": "/xarray/core/computation.py",
      "suspect_lines": [
        1828,
        1832
      ]
    }
  ]
}