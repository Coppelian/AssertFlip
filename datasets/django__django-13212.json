{
  "instance_id": "django__django-13212",
  "problem_statement": "Make validators include the provided value in ValidationError\nDescription\n\t\nIt is sometimes desirable to include the provide value in a custom error message. For example:\n“blah” is not a valid email.\nBy making built-in validators provide value to ValidationError, one can override an error message and use a %(value)s placeholder.\nThis placeholder value matches an example already in the docs:\n​https://docs.djangoproject.com/en/3.0/ref/validators/#writing-validators\n",
  "localized_code": "[start of django/core/validators.py]\n1: import ipaddress\n2: import re\n3: import warnings\n4: from pathlib import Path\n5: from urllib.parse import urlsplit, urlunsplit\n6: \n7: from django.core.exceptions import ValidationError\n8: from django.utils.deconstruct import deconstructible\n9: from django.utils.deprecation import RemovedInDjango41Warning\n10: from django.utils.encoding import punycode\n11: from django.utils.ipv6 import is_valid_ipv6_address\n12: from django.utils.regex_helper import _lazy_re_compile\n13: from django.utils.translation import gettext_lazy as _, ngettext_lazy\n14: \n15: # These values, if given to validate(), will trigger the self.required check.\n16: EMPTY_VALUES = (None, '', [], (), {})\n17: \n18: \n19: @deconstructible\n20: class RegexValidator:\n21:     regex = ''\n22:     message = _('Enter a valid value.')\n23:     code = 'invalid'\n24:     inverse_match = False\n25:     flags = 0\n26: \n27:     def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):\n28:         if regex is not None:\n29:             self.regex = regex\n30:         if message is not None:\n31:             self.message = message\n32:         if code is not None:\n33:             self.code = code\n34:         if inverse_match is not None:\n35:             self.inverse_match = inverse_match\n36:         if flags is not None:\n37:             self.flags = flags\n38:         if self.flags and not isinstance(self.regex, str):\n39:             raise TypeError(\"If the flags are set, regex must be a regular expression string.\")\n40: \n41:         self.regex = _lazy_re_compile(self.regex, self.flags)\n42: \n43:     def __call__(self, value):\n44:         \"\"\"\n45:         Validate that the input contains (or does *not* contain, if\n46:         inverse_match is True) a match for the regular expression.\n47:         \"\"\"\n48:         regex_matches = self.regex.search(str(value))\n49:         invalid_input = regex_matches if self.inverse_match else not regex_matches\n50:         if invalid_input:\n51:             raise ValidationError(self.message, code=self.code)\n52: \n53:     def __eq__(self, other):\n54:         return (\n55:             isinstance(other, RegexValidator) and\n56:             self.regex.pattern == other.regex.pattern and\n57:             self.regex.flags == other.regex.flags and\n58:             (self.message == other.message) and\n59:             (self.code == other.code) and\n60:             (self.inverse_match == other.inverse_match)\n61:         )\n62: \n63: \n64: @deconstructible\n65: class URLValidator(RegexValidator):\n66:     ul = '\\u00a1-\\uffff'  # Unicode letters range (must not be a raw string).\n67: \n68:     # IP patterns\n69:     ipv4_re = r'(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}'\n70:     ipv6_re = r'\\[[0-9a-f:.]+\\]'  # (simple regex, validated later)\n71: \n72:     # Host patterns\n73:     hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'\n74:     # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1\n75:     domain_re = r'(?:\\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'\n76:     tld_re = (\n77:         r'\\.'                                # dot\n78:         r'(?!-)'                             # can't start with a dash\n79:         r'(?:[a-z' + ul + '-]{2,63}'         # domain label\n80:         r'|xn--[a-z0-9]{1,59})'              # or punycode label\n81:         r'(?<!-)'                            # can't end with a dash\n82:         r'\\.?'                               # may have a trailing dot\n83:     )\n84:     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n85: \n86:     regex = _lazy_re_compile(\n87:         r'^(?:[a-z0-9.+-]*)://'  # scheme is validated separately\n88:         r'(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?'  # user:pass authentication\n89:         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n90:         r'(?::\\d{2,5})?'  # port\n91:         r'(?:[/?#][^\\s]*)?'  # resource path\n92:         r'\\Z', re.IGNORECASE)\n93:     message = _('Enter a valid URL.')\n94:     schemes = ['http', 'https', 'ftp', 'ftps']\n95: \n96:     def __init__(self, schemes=None, **kwargs):\n97:         super().__init__(**kwargs)\n98:         if schemes is not None:\n99:             self.schemes = schemes\n100: \n101:     def __call__(self, value):\n102:         if not isinstance(value, str):\n103:             raise ValidationError(self.message, code=self.code)\n104:         # Check if the scheme is valid.\n105:         scheme = value.split('://')[0].lower()\n106:         if scheme not in self.schemes:\n107:             raise ValidationError(self.message, code=self.code)\n108: \n109:         # Then check full URL\n110:         try:\n111:             super().__call__(value)\n112:         except ValidationError as e:\n113:             # Trivial case failed. Try for possible IDN domain\n114:             if value:\n115:                 try:\n116:                     scheme, netloc, path, query, fragment = urlsplit(value)\n117:                 except ValueError:  # for example, \"Invalid IPv6 URL\"\n118:                     raise ValidationError(self.message, code=self.code)\n119:                 try:\n120:                     netloc = punycode(netloc)  # IDN -> ACE\n121:                 except UnicodeError:  # invalid domain part\n122:                     raise e\n123:                 url = urlunsplit((scheme, netloc, path, query, fragment))\n124:                 super().__call__(url)\n125:             else:\n126:                 raise\n127:         else:\n128:             # Now verify IPv6 in the netloc part\n129:             host_match = re.search(r'^\\[(.+)\\](?::\\d{2,5})?$', urlsplit(value).netloc)\n130:             if host_match:\n131:                 potential_ip = host_match[1]\n132:                 try:\n133:                     validate_ipv6_address(potential_ip)\n134:                 except ValidationError:\n135:                     raise ValidationError(self.message, code=self.code)\n136: \n137:         # The maximum length of a full host name is 253 characters per RFC 1034\n138:         # section 3.1. It's defined to be 255 bytes or less, but this includes\n139:         # one byte for the length of the name and one byte for the trailing dot\n140:         # that's used to indicate absolute names in DNS.\n141:         if len(urlsplit(value).netloc) > 253:\n142:             raise ValidationError(self.message, code=self.code)\n143: \n144: \n145: integer_validator = RegexValidator(\n146:     _lazy_re_compile(r'^-?\\d+\\Z'),\n147:     message=_('Enter a valid integer.'),\n148:     code='invalid',\n149: )\n150: \n151: \n152: def validate_integer(value):\n153:     return integer_validator(value)\n154: \n155: \n156: @deconstructible\n157: class EmailValidator:\n158:     message = _('Enter a valid email address.')\n159:     code = 'invalid'\n160:     user_regex = _lazy_re_compile(\n161:         r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\\Z\"  # dot-atom\n162:         r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"\\Z)',  # quoted-string\n163:         re.IGNORECASE)\n164:     domain_regex = _lazy_re_compile(\n165:         # max length for domain name labels is 63 characters per RFC 1034\n166:         r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\\Z',\n167:         re.IGNORECASE)\n168:     literal_regex = _lazy_re_compile(\n169:         # literal form, ipv4 or ipv6 address (SMTP 4.1.3)\n170:         r'\\[([A-f0-9:.]+)\\]\\Z',\n171:         re.IGNORECASE)\n172:     domain_allowlist = ['localhost']\n173: \n174:     @property\n175:     def domain_whitelist(self):\n176:         warnings.warn(\n177:             'The domain_whitelist attribute is deprecated in favor of '\n178:             'domain_allowlist.',\n179:             RemovedInDjango41Warning,\n180:             stacklevel=2,\n181:         )\n182:         return self.domain_allowlist\n183: \n184:     @domain_whitelist.setter\n185:     def domain_whitelist(self, allowlist):\n186:         warnings.warn(\n187:             'The domain_whitelist attribute is deprecated in favor of '\n188:             'domain_allowlist.',\n189:             RemovedInDjango41Warning,\n190:             stacklevel=2,\n191:         )\n192:         self.domain_allowlist = allowlist\n193: \n194:     def __init__(self, message=None, code=None, allowlist=None, *, whitelist=None):\n195:         if whitelist is not None:\n196:             allowlist = whitelist\n197:             warnings.warn(\n198:                 'The whitelist argument is deprecated in favor of allowlist.',\n199:                 RemovedInDjango41Warning,\n200:                 stacklevel=2,\n201:             )\n202:         if message is not None:\n203:             self.message = message\n204:         if code is not None:\n205:             self.code = code\n206:         if allowlist is not None:\n207:             self.domain_allowlist = allowlist\n208: \n209:     def __call__(self, value):\n210:         if not value or '@' not in value:\n211:             raise ValidationError(self.message, code=self.code)\n212: \n213:         user_part, domain_part = value.rsplit('@', 1)\n214: \n215:         if not self.user_regex.match(user_part):\n216:             raise ValidationError(self.message, code=self.code)\n217: \n218:         if (domain_part not in self.domain_allowlist and\n219:                 not self.validate_domain_part(domain_part)):\n220:             # Try for possible IDN domain-part\n221:             try:\n222:                 domain_part = punycode(domain_part)\n223:             except UnicodeError:\n224:                 pass\n225:             else:\n226:                 if self.validate_domain_part(domain_part):\n227:                     return\n228:             raise ValidationError(self.message, code=self.code)\n229: \n230:     def validate_domain_part(self, domain_part):\n231:         if self.domain_regex.match(domain_part):\n232:             return True\n233: \n234:         literal_match = self.literal_regex.match(domain_part)\n235:         if literal_match:\n236:             ip_address = literal_match[1]\n237:             try:\n238:                 validate_ipv46_address(ip_address)\n239:                 return True\n240:             except ValidationError:\n241:                 pass\n242:         return False\n243: \n244:     def __eq__(self, other):\n245:         return (\n246:             isinstance(other, EmailValidator) and\n247:             (self.domain_allowlist == other.domain_allowlist) and\n248:             (self.message == other.message) and\n249:             (self.code == other.code)\n250:         )\n251: \n252: \n253: validate_email = EmailValidator()\n254: \n255: slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\\Z')\n256: validate_slug = RegexValidator(\n257:     slug_re,\n258:     # Translators: \"letters\" means latin letters: a-z and A-Z.\n259:     _('Enter a valid “slug” consisting of letters, numbers, underscores or hyphens.'),\n260:     'invalid'\n261: )\n262: \n263: slug_unicode_re = _lazy_re_compile(r'^[-\\w]+\\Z')\n264: validate_unicode_slug = RegexValidator(\n265:     slug_unicode_re,\n266:     _('Enter a valid “slug” consisting of Unicode letters, numbers, underscores, or hyphens.'),\n267:     'invalid'\n268: )\n269: \n270: \n271: def validate_ipv4_address(value):\n272:     try:\n273:         ipaddress.IPv4Address(value)\n274:     except ValueError:\n275:         raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')\n276: \n277: \n278: def validate_ipv6_address(value):\n279:     if not is_valid_ipv6_address(value):\n280:         raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')\n281: \n282: \n283: def validate_ipv46_address(value):\n284:     try:\n285:         validate_ipv4_address(value)\n286:     except ValidationError:\n287:         try:\n288:             validate_ipv6_address(value)\n289:         except ValidationError:\n290:             raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')\n291: \n292: \n293: ip_address_validator_map = {\n294:     'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),\n295:     'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),\n296:     'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),\n297: }\n298: \n299: \n300:     \"\"\"\nCode replaced for brevity.\n312: \n313: \n314: \n315:     regexp =\nCode replaced for brevity.\n320: \n321: \n322: \n323: validate_comma_separated_integer_list = int_list_validator(\n324:     message=_('Enter only digits separated by commas.'),\n325: )\n326: \n327: \n328: @deconstructible\n329:     message\nCode replaced for brevity.\n358: \n359: \n360: \n361: @deconstructible\n362:     message\nCode replaced for brevity.\n367: \n368: \n369: \n370: @deconstructible\n371:     message\nCode replaced for brevity.\n376: \n377: \n378: \n379: @deconstructible\n380:     message\nCode replaced for brevity.\n391: \n392: \n393: \n394: @deconstructible\n395:     message\nCode replaced for brevity.\n406: \n407: \n408: \n409: @deconstructible\n410: class DecimalValidator:\n411:     \"\"\"\n412:     Validate that the input does not exceed the maximum number of digits\n413:     expected, otherwise raise ValidationError.\n414:     \"\"\"\n415:     messages = {\n416:         'invalid': _('Enter a number.'),\n417:         'max_digits': ngettext_lazy(\n418:             'Ensure that there are no more than %(max)s digit in total.',\n419:             'Ensure that there are no more than %(max)s digits in total.',\n420:             'max'\n421:         ),\n422:         'max_decimal_places': ngettext_lazy(\n423:             'Ensure that there are no more than %(max)s decimal place.',\n424:             'Ensure that there are no more than %(max)s decimal places.',\n425:             'max'\n426:         ),\n427:         'max_whole_digits': ngettext_lazy(\n428:             'Ensure that there are no more than %(max)s digit before the decimal point.',\n429:             'Ensure that there are no more than %(max)s digits before the decimal point.',\n430:             'max'\n431:         ),\n432:     }\n433: \n434:     def __init__(self, max_digits, decimal_places):\n435:         self.max_digits = max_digits\n436:         self.decimal_places = decimal_places\n437: \n438:     def __call__(self, value):\n439:         digit_tuple, exponent = value.as_tuple()[1:]\n440:         if exponent in {'F', 'n', 'N'}:\n441:             raise ValidationError(self.messages['invalid'])\n442:         if exponent >= 0:\n443:             # A positive exponent adds that many trailing zeros.\n444:             digits = len(digit_tuple) + exponent\n445:             decimals = 0\n446:         else:\n447:             # If the absolute value of the negative exponent is larger than the\n448:             # number of digits, then it's the same as the number of digits,\n449:             # because it'll consume all of the digits in digit_tuple and then\n450:             # add abs(exponent) - len(digit_tuple) leading zeros after the\n451:             # decimal point.\n452:             if abs(exponent) > len(digit_tuple):\n453:                 digits = decimals = abs(exponent)\n454:             else:\n455:                 digits = len(digit_tuple)\n456:                 decimals = abs(exponent)\n457:         whole_digits = digits - decimals\n458: \n459:         if self.max_digits is not None and digits > self.max_digits:\n460:             raise ValidationError(\n461:                 self.messages['max_digits'],\n462:                 code='max_digits',\n463:                 params={'max': self.max_digits},\n464:             )\n465:         if self.decimal_places is not None and decimals > self.decimal_places:\n466:             raise ValidationError(\n467:                 self.messages['max_decimal_places'],\n468:                 code='max_decimal_places',\n469:                 params={'max': self.decimal_places},\n470:             )\n471:         if (self.max_digits is not None and self.decimal_places is not None and\n472:                 whole_digits > (self.max_digits - self.decimal_places)):\n473:             raise ValidationError(\n474:                 self.messages['max_whole_digits'],\n475:                 code='max_whole_digits',\n476:                 params={'max': (self.max_digits - self.decimal_places)},\n477:             )\n478: \n479:     def __eq__(self, other):\n480:         return (\n481:             isinstance(other, self.__class__) and\n482:             self.max_digits == other.max_digits and\n483:             self.decimal_places == other.decimal_places\n484:         )\n485: \n486: \n487: @deconstructible\n488: class FileExtensionValidator:\n489:     message = _(\n490:         'File extension “%(extension)s” is not allowed. '\n491:         'Allowed extensions are: %(allowed_extensions)s.'\n492:     )\n493:     code = 'invalid_extension'\n494: \n495:     def __init__(self, allowed_extensions=None, message=None, code=None):\n496:         if allowed_extensions is not None:\n497:             allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]\n498:         self.allowed_extensions = allowed_extensions\n499:         if message is not None:\n500:             self.message = message\n501:         if code is not None:\n502:             self.code = code\n503: \n504:     def __call__(self, value):\n505:         extension = Path(value.name).suffix[1:].lower()\n506:         if self.allowed_extensions is not None and extension not in self.allowed_extensions:\n507:             raise ValidationError(\n508:                 self.message,\n509:                 code=self.code,\n510:                 params={\n511:                     'extension': extension,\n512:                     'allowed_extensions': ', '.join(self.allowed_extensions)\n513:                 }\n514:             )\n515: \n516:     def __eq__(self, other):\n517:         return (\n518:             isinstance(other, self.__class__) and\n519:             self.allowed_extensions == other.allowed_extensions and\n520:             self.message == other.message and\n521:             self.code == other.code\n522:         )\n523: \n524: \n525:     try:\nCode replaced for brevity.\n532: \n533: \n534: \n535:     return FileE\nCode replaced for brevity.\n536: \n537: \n538: \n539: @deconstructible\n540: class ProhibitNullCharactersValidator:\n541:     \"\"\"Validate that the string doesn't contain the null character.\"\"\"\n542:     message = _('Null characters are not allowed.')\n543:     code = 'null_characters_not_allowed'\n544: \n545:     def __init__(self, message=None, code=None):\n546:         if message is not None:\n547:             self.message = message\n548:         if code is not None:\n549:             self.code = code\n550: \n551:     def __call__(self, value):\n552:         if '\\x00' in str(value):\n553:             raise ValidationError(self.message, code=self.code)\n554: \n555:     def __eq__(self, other):\n556:         return (\n557:             isinstance(other, self.__class__) and\n558:             self.message == other.message and\n559:             self.code == other.code\n560:         )\n\n[start of django/forms/fields.py]\n1: \"\"\"\n2: Field classes.\n3: \"\"\"\n4: \n5: import copy\n6: import datetime\n7: import json\n8: import math\n9: import operator\n10: import os\n11: import re\n12: import uuid\n13: from decimal import Decimal, DecimalException\n14: from io import BytesIO\n15: from urllib.parse import urlsplit, urlunsplit\n16: \n17: from django.core import validators\n18: from django.core.exceptions import ValidationError\n19: from django.forms.boundfield import BoundField\n20: from django.forms.utils import from_current_timezone, to_current_timezone\n21: from django.forms.widgets import (\n22:     FILE_INPUT_CONTRADICTION, CheckboxInput, ClearableFileInput, DateInput,\n23:     DateTimeInput, EmailInput, FileInput, HiddenInput, MultipleHiddenInput,\n24:     NullBooleanSelect, NumberInput, Select, SelectMultiple,\n25:     SplitDateTimeWidget, SplitHiddenDateTimeWidget, Textarea, TextInput,\n26:     TimeInput, URLInput,\n27: )\n28: from django.utils import formats\n29: from django.utils.dateparse import parse_datetime, parse_duration\n30: from django.utils.duration import duration_string\n31: from django.utils.ipv6 import clean_ipv6_address\n32: from django.utils.regex_helper import _lazy_re_compile\n33: from django.utils.translation import gettext_lazy as _, ngettext_lazy\n34: \n35: __all__ = (\n36:     'Field', 'CharField', 'IntegerField',\n37:     'DateField', 'TimeField', 'DateTimeField', 'DurationField',\n38:     'RegexField', 'EmailField', 'FileField', 'ImageField', 'URLField',\n39:     'BooleanField', 'NullBooleanField', 'ChoiceField', 'MultipleChoiceField',\n40:     'ComboField', 'MultiValueField', 'FloatField', 'DecimalField',\n41:     'SplitDateTimeField', 'GenericIPAddressField', 'FilePathField',\n42:     'JSONField', 'SlugField', 'TypedChoiceField', 'TypedMultipleChoiceField',\n43:     'UUIDField',\n44: )\n45: \n46: \n47: class Field:\n48:     widget = TextInput  # Default widget to use when rendering this type of Field.\n49:     hidden_widget = HiddenInput  # Default widget to use when rendering this as \"hidden\".\n50:     default_validators = []  # Default set of validators\n51:     # Add an 'invalid' entry to default_error_message if you want a specific\n52:     # field error message not raised by the field validators.\n53:     default_error_messages = {\n54:         'required': _('This field is required.'),\n55:     }\n56:     empty_values = list(validators.EMPTY_VALUES)\n57: \n58:     def __init__(self, *, required=True, widget=None, label=None, initial=None,\n59:                  help_text='', error_messages=None, show_hidden_initial=False,\n60:                  validators=(), localize=False, disabled=False, label_suffix=None):\n61:         # required -- Boolean that specifies whether the field is required.\n62:         #             True by default.\n63:         # widget -- A Widget class, or instance of a Widget class, that should\n64:         #           be used for this Field when displaying it. Each Field has a\n65:         #           default Widget that it'll use if you don't specify this. In\n66:         #           most cases, the default widget is TextInput.\n67:         # label -- A verbose name for this field, for use in displaying this\n68:         #          field in a form. By default, Django will use a \"pretty\"\n69:         #          version of the form field name, if the Field is part of a\n70:         #          Form.\n71:         # initial -- A value to use in this Field's initial display. This value\n72:         #            is *not* used as a fallback if data isn't given.\n73:         # help_text -- An optional string to use as \"help text\" for this Field.\n74:         # error_messages -- An optional dictionary to override the default\n75:         #                   messages that the field will raise.\n76:         # show_hidden_initial -- Boolean that specifies if it is needed to render a\n77:         #                        hidden widget with initial value after widget.\n78:         # validators -- List of additional validators to use\n79:         # localize -- Boolean that specifies if the field should be localized.\n80:         # disabled -- Boolean that specifies whether the field is disabled, that\n81:         #             is its widget is shown in the form but not editable.\n82:         # label_suffix -- Suffix to be added to the label. Overrides\n83:         #                 form's label_suffix.\n84:         self.required, self.label, self.initial = required, label, initial\n85:         self.show_hidden_initial = show_hidden_initial\n86:         self.help_text = help_text\n87:         self.disabled = disabled\n88:         self.label_suffix = label_suffix\n89:         widget = widget or self.widget\n90:         if isinstance(widget, type):\n91:             widget = widget()\n92:         else:\n93:             widget = copy.deepcopy(widget)\n94: \n95:         # Trigger the localization machinery if needed.\n96:         self.localize = localize\n97:         if self.localize:\n98:             widget.is_localized = True\n99: \n100:         # Let the widget know whether it should display as required.\n101:         widget.is_required = self.required\n102: \n103:         # Hook into self.widget_attrs() for any Field-specific HTML attributes.\n104:         extra_attrs = self.widget_attrs(widget)\n105:         if extra_attrs:\n106:             widget.attrs.update(extra_attrs)\n107: \n108:         self.widget = widget\n109: \n110:         messages = {}\n111:         for c in reversed(self.__class__.__mro__):\n112:             messages.update(getattr(c, 'default_error_messages', {}))\n113:         messages.update(error_messages or {})\n114:         self.error_messages = messages\n115: \n116:         self.validators = [*self.default_validators, *validators]\n117: \n118:         super().__init__()\n119: \n120:     def prepare_value(self, value):\n121:         return value\n122: \n123:     def to_python(self, value):\n124:         return value\n125: \n126:     def validate(self, value):\n127:         if value in self.empty_values and self.required:\n128:             raise ValidationError(self.error_messages['required'], code='required')\n129: \n130:     def run_validators(self, value):\n131:         if value in self.empty_values:\n132:             return\n133:         errors = []\n134:         for v in self.validators:\n135:             try:\n136:                 v(value)\n137:             except ValidationError as e:\n138:                 if hasattr(e, 'code') and e.code in self.error_messages:\n139:                     e.message = self.error_messages[e.code]\n140:                 errors.extend(e.error_list)\n141:         if errors:\n142:             raise ValidationError(errors)\n143: \n144:     def clean(self, value):\n145:         \"\"\"\n146:         Validate the given value and return its \"cleaned\" value as an\n147:         appropriate Python object. Raise ValidationError for any errors.\n148:         \"\"\"\n149:         value = self.to_python(value)\n150:         self.validate(value)\n151:         self.run_validators(value)\n152:         return value\n153: \n154:     def bound_data(self, data, initial):\n155:         \"\"\"\n156:         Return the value that should be shown for this field on render of a\n157:         bound form, given the submitted POST data for the field and the initial\n158:         data, if any.\n159: \n160:         For most fields, this will simply be data; FileFields need to handle it\n161:         a bit differently.\n162:         \"\"\"\n163:         if self.disabled:\n164:             return initial\n165:         return data\n166: \n167:     def widget_attrs(self, widget):\n168:         \"\"\"\n169:         Given a Widget instance (*not* a Widget class), return a dictionary of\n170:         any HTML attributes that should be added to the Widget, based on this\n171:         Field.\n172:         \"\"\"\n173:         return {}\n174: \n175:     def has_changed(self, initial, data):\n176:         \"\"\"Return True if data differs from initial.\"\"\"\n177:         # Always return False if the field is disabled since self.bound_data\n178:         # always uses the initial value in this case.\n179:         if self.disabled:\n180:             return False\n181:         try:\n182:             data = self.to_python(data)\n183:             if hasattr(self, '_coerce'):\n184:                 return self._coerce(data) != self._coerce(initial)\n185:         except ValidationError:\n186:             return True\n187:         # For purposes of seeing whether something has changed, None is\n188:         # the same as an empty string, if the data or initial value we get\n189:         # is None, replace it with ''.\n190:         initial_value = initial if initial is not None else ''\n191:         data_value = data if data is not None else ''\n192:         return initial_value != data_value\n193: \n194:     def get_bound_field(self, form, field_name):\n195:         \"\"\"\n196:         Return a BoundField instance that will be used when accessing the form\n197:         field in a template.\n198:         \"\"\"\n199:         return BoundField(form, self, field_name)\n200: \n201:     def __deepcopy__(self, memo):\n202:         result = copy.copy(self)\n203:         memo[id(self)] = result\n204:         result.widget = copy.deepcopy(self.widget, memo)\n205:         result.error_messages = self.error_messages.copy()\n206:         result.validators = self.validators[:]\n207:         return result\n208: \n209: \n210: class CharField(Field):\nCode replaced for brevity.\n241: \n242: \n243: \n244: class IntegerField(Field):\nCode replaced for brevity.\n287: \n288: \n289: \n290: class FloatField(IntegerField):\nCode replaced for brevity.\n322: \n323: \n324: \n325: class DecimalField(IntegerField):\n326:     default_error_messages = {\n327:         'invalid': _('Enter a number.'),\n328:     }\n329: \n330:     def __init__(self, *, max_value=None, min_value=None, max_digits=None, decimal_places=None, **kwargs):\n331:         self.max_digits, self.decimal_places = max_digits, decimal_places\n332:         super().__init__(max_value=max_value, min_value=min_value, **kwargs)\n333:         self.validators.append(validators.DecimalValidator(max_digits, decimal_places))\n334: \n335:     def to_python(self, value):\n336:         \"\"\"\n337:         Validate that the input is a decimal number. Return a Decimal\n338:         instance or None for empty values. Ensure that there are no more\n339:         than max_digits in the number and no more than decimal_places digits\n340:         after the decimal point.\n341:         \"\"\"\n342:         if value in self.empty_values:\n343:             return None\n344:         if self.localize:\n345:             value = formats.sanitize_separators(value)\n346:         value = str(value).strip()\n347:         try:\n348:             value = Decimal(value)\n349:         except DecimalException:\n350:             raise ValidationError(self.error_messages['invalid'], code='invalid')\n351:         return value\n352: \n353:     def validate(self, value):\n354:         super().validate(value)\n355:         if value in self.empty_values:\n356:             return\n357:         if not value.is_finite():\n358:             raise ValidationError(self.error_messages['invalid'], code='invalid')\n359: \n360:     def widget_attrs(self, widget):\n361:         attrs = super().widget_attrs(widget)\n362:         if isinstance(widget, NumberInput) and 'step' not in widget.attrs:\n363:             if self.decimal_places is not None:\n364:                 # Use exponential notation for small values since they might\n365:                 # be parsed as 0 otherwise. ref #20765\n366:                 step = str(Decimal(1).scaleb(-self.decimal_places)).lower()\n367:             else:\n368:                 step = 'any'\n369:             attrs.setdefault('step', step)\n370:         return attrs\n371: \n372: \n373: class BaseTemporalField(Field):\nCode replaced for brevity.\n391: \n392: \n393: \n394: class DateField(BaseTemporalField):\nCode replaced for brevity.\n415: \n416: \n417: \n418: class TimeField(BaseTemporalField):\nCode replaced for brevity.\n437: \n438: \n439: \n440: class DateTimeFormatsIterator:\nCode replaced for brevity.\n443: \n444: \n445: \n446: class DateTimeField(BaseTemporalField):\nCode replaced for brevity.\n479: \n480: \n481: \n482: class DurationField(Field):\nCode replaced for brevity.\n507: \n508: \n509: \n510: class RegexField(CharField):\nCode replaced for brevity.\n531: \n532: \n533: \n534: class EmailField(CharField):\nCode replaced for brevity.\n539: \n540: \n541: \n542: class FileField(Field):\nCode replaced for brevity.\n606: \n607: \n608: \n609: class ImageField(FileField):\nCode replaced for brevity.\n665: \n666: \n667: \n668: class URLField(CharField):\nCode replaced for brevity.\n707: \n708: \n709: \n710: class BooleanField(Field):\nCode replaced for brevity.\n734: \n735: \n736: \n737: class NullBooleanField(BooleanField):\nCode replaced for brevity.\n761: \n762: \n763: \n764: class CallableChoiceIterator:\nCode replaced for brevity.\n769: \n770: \n771: \n772: class ChoiceField(Field):\nCode replaced for brevity.\n831: \n832: \n833: \n834: class TypedChoiceField(ChoiceField):\nCode replaced for brevity.\n858: \n859: \n860: \n861: class MultipleChoiceField(ChoiceField):\nCode replaced for brevity.\n900: \n901: \n902: \n903: class TypedMultipleChoiceField(MultipleChoiceField):\nCode replaced for brevity.\n936: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/validators.py",
      "suspect_lines": [
        51,
        103,
        107,
        118,
        135,
        142,
        211,
        216,
        228,
        275,
        280,
        290,
        441,
        463,
        469,
        476,
        512,
        553
      ]
    },
    {
      "filename": "/django/forms/fields.py",
      "suspect_lines": [
        353,
        354,
        355,
        356,
        357,
        358,
        359
      ]
    }
  ]
}