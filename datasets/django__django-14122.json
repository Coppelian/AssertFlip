{
  "instance_id": "django__django-14122",
  "problem_statement": "Meta.ordering fields must not be included in GROUP BY clause\nDescription\n\t\nThis continues (closed) [1] ticket.\nI beleave it was not properly fixed in commit [0ddb4ebf].\nWhile commit [0ddb4ebf] removes ORDER BY when Meta.ordering is used it still does populates GROUP BY with Meta.ordering fields thus leads to wrong aggregation.\nPR with test case was added at [2].\n[1] https://code.djangoproject.com/ticket/14357\n[2] ​​https://github.com/django/django/pull/14122\n",
  "localized_code": "[start of django/db/models/sql/compiler.py]\n1: import collections\n2: import re\n3: from functools import partial\n4: from itertools import chain\n5: \n6: from django.core.exceptions import EmptyResultSet, FieldError\n7: from django.db import DatabaseError, NotSupportedError\n8: from django.db.models.constants import LOOKUP_SEP\n9: from django.db.models.expressions import F, OrderBy, RawSQL, Ref, Value\n10: from django.db.models.functions import Cast, Random\n11: from django.db.models.query_utils import Q, select_related_descend\n12: from django.db.models.sql.constants import (\n13:     CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS, ORDER_DIR, SINGLE,\n14: )\n15: from django.db.models.sql.query import Query, get_order_dir\n16: from django.db.transaction import TransactionManagementError\n17: from django.utils.functional import cached_property\n18: from django.utils.hashable import make_hashable\n19: from django.utils.regex_helper import _lazy_re_compile\n20: \n21: \n22: class SQLCompiler:\n23:     # Multiline ordering SQL clause may appear from RawSQL.\n24:     ordering_parts = _lazy_re_compile(\n25:         r'^(.*)\\s(?:ASC|DESC).*',\n26:         re.MULTILINE | re.DOTALL,\n27:     )\n28: \n29:     def __init__(self, query, connection, using):\n30:         self.query = query\n31:         self.connection = connection\n32:         self.using = using\n33:         self.quote_cache = {'*': '*'}\n34:         # The select, klass_info, and annotations are needed by QuerySet.iterator()\n35:         # these are set as a side-effect of executing the query. Note that we calculate\n36:         # separately a list of extra select columns needed for grammatical correctness\n37:         # of the query, but these columns are not included in self.select.\n38:         self.select = None\n39:         self.annotation_col_map = None\n40:         self.klass_info = None\n41:         self._meta_ordering = None\n42: \n43:     def setup_query(self):\n44:         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):\n45:             self.query.get_initial_alias()\n46:         self.select, self.klass_info, self.annotation_col_map = self.get_select()\n47:         self.col_count = len(self.select)\n48: \n49:     def pre_sql_setup(self):\n50:         \"\"\"\n51:         Do any necessary class setup immediately prior to producing SQL. This\n52:         is for things that can't necessarily be done in __init__ because we\n53:         might not have all the pieces in place at that time.\n54:         \"\"\"\n55:         self.setup_query()\n56:         order_by = self.get_order_by()\n57:         self.where, self.having = self.query.where.split_having()\n58:         extra_select = self.get_extra_select(order_by, self.select)\n59:         self.has_extra_select = bool(extra_select)\n60:         group_by = self.get_group_by(self.select + extra_select, order_by)\n61:         return extra_select, order_by, group_by\n62: \n63:     def get_group_by(self, select, order_by):\n64:         \"\"\"\n65:         Return a list of 2-tuples of form (sql, params).\n66: \n67:         The logic of what exactly the GROUP BY clause contains is hard\n68:         to describe in other words than \"if it passes the test suite,\n69:         then it is correct\".\n70:         \"\"\"\n71:         # Some examples:\n72:         #     SomeModel.objects.annotate(Count('somecol'))\n73:         #     GROUP BY: all fields of the model\n74:         #\n75:         #    SomeModel.objects.values('name').annotate(Count('somecol'))\n76:         #    GROUP BY: name\n77:         #\n78:         #    SomeModel.objects.annotate(Count('somecol')).values('name')\n79:         #    GROUP BY: all cols of the model\n80:         #\n81:         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')\n82:         #    GROUP BY: name, pk\n83:         #\n84:         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')\n85:         #    GROUP BY: name, pk\n86:         #\n87:         # In fact, the self.query.group_by is the minimal set to GROUP BY. It\n88:         # can't be ever restricted to a smaller set, but additional columns in\n89:         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately\n90:         # the end result is that it is impossible to force the query to have\n91:         # a chosen GROUP BY clause - you can almost do this by using the form:\n92:         #     .values(*wanted_cols).annotate(AnAggregate())\n93:         # but any later annotations, extra selects, values calls that\n94:         # refer some column outside of the wanted_cols, order_by, or even\n95:         # filter calls can alter the GROUP BY clause.\n96: \n97:         # The query.group_by is either None (no GROUP BY at all), True\n98:         # (group by select fields), or a list of expressions to be added\n99:         # to the group by.\n100:         if self.query.group_by is None:\n101:             return []\n102:         expressions = []\n103:         if self.query.group_by is not True:\n104:             # If the group by is set to a list (by .values() call most likely),\n105:             # then we need to add everything in it to the GROUP BY clause.\n106:             # Backwards compatibility hack for setting query.group_by. Remove\n107:             # when  we have public API way of forcing the GROUP BY clause.\n108:             # Converts string references to expressions.\n109:             for expr in self.query.group_by:\n110:                 if not hasattr(expr, 'as_sql'):\n111:                     expressions.append(self.query.resolve_ref(expr))\n112:                 else:\n113:                     expressions.append(expr)\n114:         # Note that even if the group_by is set, it is only the minimal\n115:         # set to group by. So, we need to add cols in select, order_by, and\n116:         # having into the select in any case.\n117:         ref_sources = {\n118:             expr.source for expr in expressions if isinstance(expr, Ref)\n119:         }\n120:         for expr, _, _ in select:\n121:             # Skip members of the select clause that are already included\n122:             # by reference.\n123:             if expr in ref_sources:\n124:                 continue\n125:             cols = expr.get_group_by_cols()\n126:             for col in cols:\n127:                 expressions.append(col)\n128:         for expr, (sql, params, is_ref) in order_by:\n129:             # Skip References to the select clause, as all expressions in the\n130:             # select clause are already part of the group by.\n131:             if not is_ref:\n132:                 expressions.extend(expr.get_group_by_cols())\n133:         having_group_by = self.having.get_group_by_cols() if self.having else ()\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/sql/compiler.py",
      "suspect_lines": [
        128,
        129,
        130,
        131,
        132
      ]
    }
  ]
}