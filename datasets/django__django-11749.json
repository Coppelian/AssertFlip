{
  "instance_id": "django__django-11749",
  "problem_statement": "call_command fails when argument of required mutually exclusive group is passed in kwargs.\nDescription\n\t\nThis error \ndjango.core.management.base.CommandError: Error: one of the arguments --shop-id --shop is required\nis raised when I run \ncall_command('my_command', shop_id=1)\nthe argument 'shop_id' is part of a required mutually exclusive group:\nshop = parser.add_mutually_exclusive_group(required=True)\nshop.add_argument('--shop-id', nargs='?', type=int, default=None, dest='shop_id')\nshop.add_argument('--shop', nargs='?', type=str, default=None, dest='shop_name')\nHowever, everything is fine when I call this command in this way:\ncall_command('my_command, '--shop-id=1')\nIn django sources I found that only those keyword arguments of call_command are passed to the parser that are defined as required:\n# Any required arguments which are passed in via '**options' must be passed\n# to parse_args().\nparse_args += [\n\t'{}={}'.format(min(opt.option_strings), arg_options[opt.dest])\n\tfor opt in parser._actions if opt.required and opt.dest in options\n]\nbut in this special case both of them individually are not required, they are actually part of a group that is required. And the code of call_command does nothing with groups defined in the parser.\n",
  "localized_code": "[start of django/core/management/__init__.py]\n1: import functools\n2: import os\n3: import pkgutil\n4: import sys\n5: from argparse import _SubParsersAction\n6: from collections import defaultdict\n7: from difflib import get_close_matches\n8: from importlib import import_module\n9: \n10: import django\n11: from django.apps import apps\n12: from django.conf import settings\n13: from django.core.exceptions import ImproperlyConfigured\n14: from django.core.management.base import (\n15:     BaseCommand, CommandError, CommandParser, handle_default_options,\n16: )\n17: from django.core.management.color import color_style\n18: from django.utils import autoreload\n19: \n20: \n21: def find_commands(management_dir):\n22:     \"\"\"\n23:     Given a path to a management directory, return a list of all the command\n24:     names that are available.\n25:     \"\"\"\n26:     command_dir = os.path.join(management_dir, 'commands')\n27:     return [name for _, name, is_pkg in pkgutil.iter_modules([command_dir])\n28:             if not is_pkg and not name.startswith('_')]\n29: \n30: \n31: def load_command_class(app_name, name):\n32:     \"\"\"\n33:     Given a command name and an application name, return the Command\n34:     class instance. Allow all errors raised by the import process\n35:     (ImportError, AttributeError) to propagate.\n36:     \"\"\"\n37:     module = import_module('%s.management.commands.%s' % (app_name, name))\n38:     return module.Command()\n39: \n40: \n41: @functools.lru_cache(maxsize=None)\n42: def get_commands():\n43:     \"\"\"\n44:     Return a dictionary mapping command names to their callback applications.\n45: \n46:     Look for a management.commands package in django.core, and in each\n47:     installed application -- if a commands package exists, register all\n48:     commands in that package.\n49: \n50:     Core commands are always included. If a settings module has been\n51:     specified, also include user-defined commands.\n52: \n53:     The dictionary is in the format {command_name: app_name}. Key-value\n54:     pairs from this dictionary can then be used in calls to\n55:     load_command_class(app_name, command_name)\n56: \n57:     If a specific version of a command must be loaded (e.g., with the\n58:     startapp command), the instantiated module can be placed in the\n59:     dictionary in place of the application name.\n60: \n61:     The dictionary is cached on the first call and reused on subsequent\n62:     calls.\n63:     \"\"\"\n64:     commands = {name: 'django.core' for name in find_commands(__path__[0])}\n65: \n66:     if not settings.configured:\n67:         return commands\n68: \n69:     for app_config in reversed(list(apps.get_app_configs())):\n70:         path = os.path.join(app_config.path, 'management')\n71:         commands.update({name: app_config.name for name in find_commands(path)})\n72: \n73:     return commands\n74: \n75: \n76: def call_command(command_name, *args, **options):\n77:     \"\"\"\n78:     Call the given command, with the given options and args/kwargs.\n79: \n80:     This is the primary API you should use for calling specific commands.\n81: \n82:     `command_name` may be a string or a command object. Using a string is\n83:     preferred unless the command object is required for further processing or\n84:     testing.\n85: \n86:     Some examples:\n87:         call_command('migrate')\n88:         call_command('shell', plain=True)\n89:         call_command('sqlmigrate', 'myapp')\n90: \n91:         from django.core.management.commands import flush\n92:         cmd = flush.Command()\n93:         call_command(cmd, verbosity=0, interactive=False)\n94:         # Do something with cmd ...\n95:     \"\"\"\n96:     if isinstance(command_name, BaseCommand):\n97:         # Command object passed in.\n98:         command = command_name\n99:         command_name = command.__class__.__module__.split('.')[-1]\n100:     else:\n101:         # Load the command object by name.\n102:         try:\n103:             app_name = get_commands()[command_name]\n104:         except KeyError:\n105:             raise CommandError(\"Unknown command: %r\" % command_name)\n106: \n107:         if isinstance(app_name, BaseCommand):\n108:             # If the command is already loaded, use it directly.\n109:             command = app_name\n110:         else:\n111:             command = load_command_class(app_name, command_name)\n112: \n113:     # Simulate argument parsing to get the option defaults (see #10080 for details).\n114:     parser = command.create_parser('', command_name)\n115:     # Use the `dest` option name from the parser option\n116:     opt_mapping = {\n117:         min(s_opt.option_strings).lstrip('-').replace('-', '_'): s_opt.dest\n118:         for s_opt in parser._actions if s_opt.option_strings\n119:     }\n120:     arg_options = {opt_mapping.get(key, key): value for key, value in options.items()}\n121:     parse_args = [str(a) for a in args]\n122: \n123:     def get_actions(parser):\n124:         # Parser actions and actions from sub-parser choices.\n125:         for opt in parser._actions:\n126:             if isinstance(opt, _SubParsersAction):\n127:                 for sub_opt in opt.choices.values():\n128:                     yield from get_actions(sub_opt)\n129:             else:\n130:                 yield opt\n131: \n132:     parser_actions = list(get_actions(parser))\n133:     # Any required arguments which are passed in via **options must be passed\n134:     # to parse_args().\n135:     parse_args += [\n136:         '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])\n137:         for opt in parser_actions if opt.required and opt.dest in options\n138:     ]\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/management/__init__.py",
      "suspect_lines": [
        137
      ]
    }
  ]
}