{
  "instance_id": "sympy__sympy-24443",
  "problem_statement": "`_check_homomorphism` is broken on PermutationGroups\n```python\r\nIn [1]: from sympy.combinatorics import *\r\n   ...: from sympy.combinatorics.homomorphisms import homomorphism\r\n   ...: D3 = DihedralGroup(3)\r\n   ...: T = homomorphism(D3, D3, D3.generators, D3.generators)\r\n\r\nValueError: The given images do not define a homomorphism\r\n```\r\n\r\nThe issue is in the internal `_image()` function, where it handles the case of a `PermutationGroup`:\r\n\r\nhttps://github.com/sympy/sympy/blob/809c53c077485ca48a206cee78340389cb83b7f1/sympy/combinatorics/homomorphisms.py#L336-L337\r\n\r\nWhen `r[i]` is an inverted generator, the `in gens` test fails.\r\n\r\nI think the whole thing can be greatly simplified.\n",
  "localized_code": "[start of sympy/combinatorics/homomorphisms.py]\n1: import itertools\n2: from sympy.combinatorics.fp_groups import FpGroup, FpSubgroup, simplify_presentation\n3: from sympy.combinatorics.free_groups import FreeGroup\n4: from sympy.combinatorics.perm_groups import PermutationGroup\n5: from sympy.core.numbers import igcd\n6: from sympy.ntheory.factor_ import totient\n7: from sympy.core.singleton import S\n8: \n9: class GroupHomomorphism:\n10:     '''\n11:     A class representing group homomorphisms. Instantiate using `homomorphism()`.\n12: \n13:     References\n14:     ==========\n15: \n16:     .. [1] Holt, D., Eick, B. and O'Brien, E. (2005). Handbook of computational group theory.\n17: \n18:     '''\n19: \n20:     def __init__(self, domain, codomain, images):\n21:         self.domain = domain\n22:         self.codomain = codomain\n23:         self.images = images\n24:         self._inverses = None\n25:         self._kernel = None\n26:         self._image = None\n27: \n28:     def _invs(self):\n29:         '''\n30:         Return a dictionary with `{gen: inverse}` where `gen` is a rewriting\n31:         generator of `codomain` (e.g. strong generator for permutation groups)\n32:         and `inverse` is an element of its preimage\n33: \n34:         '''\n35:         image = self.image()\n36:         inverses = {}\n37:         for k in list(self.images.keys()):\n38:             v = self.images[k]\n39:             if not (v in inverses\n40:                     or v.is_identity):\n41:                 inverses[v] = k\n42:         if isinstance(self.codomain, PermutationGroup):\n43:             gens = image.strong_gens\n44:         else:\n45:             gens = image.generators\n46:         for g in gens:\n47:             if g in inverses or g.is_identity:\n48:                 continue\n49:             w = self.domain.identity\n50:             if isinstance(self.codomain, PermutationGroup):\n51:                 parts = image._strong_gens_slp[g][::-1]\n52:             else:\n53:                 parts = g\n54:             for s in parts:\n55:                 if s in inverses:\n56:                     w = w*inverses[s]\n57:                 else:\n58:                     w = w*inverses[s**-1]**-1\n59:             inverses[g] = w\n60: \n61:         return inverses\n62: \n63:     def invert(self, g):\n64:         '''\n65:         Return an element of the preimage of ``g`` or of each element\n66:         of ``g`` if ``g`` is a list.\n67: \n68:         Explanation\n69:         ===========\n70: \n71:         If the codomain is an FpGroup, the inverse for equal\n72:         elements might not always be the same unless the FpGroup's\n73:         rewriting system is confluent. However, making a system\n74:         confluent can be time-consuming. If it's important, try\n75:         `self.codomain.make_confluent()` first.\n76: \n77:         '''\n78:         from sympy.combinatorics import Permutation\n79:         from sympy.combinatorics.free_groups import FreeGroupElement\n80:         if isinstance(g, (Permutation, FreeGroupElement)):\n81:             if isinstance(self.codomain, FpGroup):\n82:                 g = self.codomain.reduce(g)\n83:             if self._inverses is None:\n84:                 self._inverses = self._invs()\n85:             image = self.image()\n86:             w = self.domain.identity\n87:             if isinstance(self.codomain, PermutationGroup):\n88:                 gens = image.generator_product(g)[::-1]\n89:             else:\n90:                 gens = g\n91:             # the following can't be \"for s in gens:\"\n92:             # because that would be equivalent to\n93:             # \"for s in gens.array_form:\" when g is\n94:             # a FreeGroupElement. On the other hand,\n95:             # when you call gens by index, the generator\n96:             # (or inverse) at position i is returned.\n97:             for i in range(len(gens)):\n98:                 s = gens[i]\n99:                 if s.is_identity:\n100:                     continue\n101:                 if s in self._inverses:\n102:                     w = w*self._inverses[s]\n103:                 else:\n104:                     w = w*self._inverses[s**-1]**-1\n105:             return w\n106:         elif isinstance(g, list):\n107:             return [self.invert(e) for e in g]\n108: \n109:     def kernel(self):\n110:         '''\n111:         Compute the kernel of `self`.\n112: \n113:         '''\n114:         if self._kernel is None:\n115:             self._kernel = self._compute_kernel()\n116:         return self._kernel\n117: \n118:     def _compute_kernel(self):\n119:         G = self.domain\n120:         G_order = G.order()\n121:         if G_order is S.Infinity:\n122:             raise NotImplementedError(\n123:                 \"Kernel computation is not implemented for infinite groups\")\n124:         gens = []\n125:         if isinstance(G, PermutationGroup):\n126:             K = PermutationGroup(G.identity)\n127:         else:\n128:             K = FpSubgroup(G, gens, normal=True)\n129:         i = self.image().order()\n130:         while K.order()*i != G_order:\n131:             r = G.random()\n132:             k = r*self.invert(self(r))**-1\n133:             if k not in K:\n134:                 gens.append(k)\n135:                 if isinstance(G, PermutationGroup):\n136:                     K = PermutationGroup(gens)\n137:                 else:\n138:                     K = FpSubgroup(G, gens, normal=True)\n139:         return K\n140: \n141:     def image(self):\n142:         '''\n143:         Compute the image of `self`.\n144: \n145:         '''\n146:         if self._image is None:\n147:             values = list(set(self.images.values()))\n148:             if isinstance(self.codomain, PermutationGroup):\n149:                 self._image = self.codomain.subgroup(values)\n150:             else:\n151:                 self._image = FpSubgroup(self.codomain, values)\n152:         return self._image\n153: \n154:     def _apply(self, elem):\n155:         '''\n156:         Apply `self` to `elem`.\n157: \n158:         '''\n159:         if elem not in self.domain:\n160:             if isinstance(elem, (list, tuple)):\n161:                 return [self._apply(e) for e in elem]\n162:             raise ValueError(\"The supplied element does not belong to the domain\")\n163:         if elem.is_identity:\n164:             return self.codomain.identity\n165:         else:\n166:             images = self.images\n167:             value = self.codomain.identity\n168:             if isinstance(self.domain, PermutationGroup):\n169:                 gens = self.domain.generator_product(elem, original=True)\n170:                 for g in gens:\n171:                     if g in self.images:\n172:                         value = images[g]*value\n173:                     else:\n174:                         value = images[g**-1]**-1*value\n175:             else:\n176:                 i = 0\n177:                 for _, p in elem.array_form:\n178:                     if p < 0:\n179:                         g = elem[i]**-1\n180:                     else:\n181:                         g = elem[i]\n182:                     value = value*images[g]**p\n183:                     i += abs(p)\n184:         return value\n185: \n186:     def __call__(self, elem):\n187:         return self._apply(elem)\n188: \n189:     def is_injective(self):\n190:         '''\n191:         Check if the homomorphism is injective\n192: \n193:         '''\n194:         return self.kernel().order() == 1\n195: \n196:     def is_surjective(self):\n197:         '''\n198:         Check if the homomorphism is surjective\n199: \n200:         '''\n201:         im = self.image().order()\n202:         oth = self.codomain.order()\n203:         if im is S.Infinity and oth is S.Infinity:\n204:             return None\n205:         else:\n206:             return im == oth\n207: \n208:     def is_isomorphism(self):\n209:         '''\n210:         Check if `self` is an isomorphism.\n211: \n212:         '''\n213:         return self.is_injective() and self.is_surjective()\n214: \n215:     def is_trivial(self):\n216:         '''\n217:         Check is `self` is a trivial homomorphism, i.e. all elements\n218:         are mapped to the identity.\n219: \n220:         '''\n221:         return self.image().order() == 1\n222: \n223:     def compose(self, other):\n224:         '''\n225:         Return the composition of `self` and `other`, i.e.\n226:         the homomorphism phi such that for all g in the domain\n227:         of `other`, phi(g) = self(other(g))\n228: \n229:         '''\n230:         if not other.image().is_subgroup(self.domain):\n231:             raise ValueError(\"The image of `other` must be a subgroup of \"\n232:                     \"the domain of `self`\")\n233:         images = {g: self(other(g)) for g in other.images}\n234:         return GroupHomomorphism(other.domain, self.codomain, images)\n235: \n236:     def restrict_to(self, H):\n237:         '''\n238:         Return the restriction of the homomorphism to the subgroup `H`\n239:         of the domain.\n240: \n241:         '''\n242:         if not isinstance(H, PermutationGroup) or not H.is_subgroup(self.domain):\n243:             raise ValueError(\"Given H is not a subgroup of the domain\")\n244:         domain = H\n245:         images = {g: self(g) for g in H.generators}\n246:         return GroupHomomorphism(domain, self.codomain, images)\n247: \n248:     def invert_subgroup(self, H):\n249:         '''\n250:         Return the subgroup of the domain that is the inverse image\n251:         of the subgroup ``H`` of the homomorphism image\n252: \n253:         '''\n254:         if not H.is_subgroup(self.image()):\n255:             raise ValueError(\"Given H is not a subgroup of the image\")\n256:         gens = []\n257:         P = PermutationGroup(self.image().identity)\n258:         for h in H.generators:\n259:             h_i = self.invert(h)\n260:             if h_i not in P:\n261:                 gens.append(h_i)\n262:                 P = PermutationGroup(gens)\n263:             for k in self.kernel().generators:\n264:                 if k*h_i not in P:\n265:                     gens.append(k*h_i)\n266:                     P = PermutationGroup(gens)\n267:         return P\n268: \n269: def homomorphism(domain, codomain, gens, images=(), check=True):\nCode replaced for brevity.\n308: \n309: \n310: def _check_homomorphism(domain, codomain, images):\n311:     if hasattr(domain, 'relators'):\n312:         rels = domain.relators\n313:     else:\n314:         gens = domain.presentation().generators\n315:         rels = domain.presentation().relators\n316:     identity = codomain.identity\n317: \n318:     def _image(r):\n319:         if r.is_identity:\n320:             return identity\n321:         else:\n322:             w = identity\n323:             r_arr = r.array_form\n324:             i = 0\n325:             j = 0\n326:             # i is the index for r and j is for\n327:             # r_arr. r_arr[j] is the tuple (sym, p)\n328:             # where sym is the generator symbol\n329:             # and p is the power to which it is\n330:             # raised while r[i] is a generator\n331:             # (not just its symbol) or the inverse of\n332:             # a generator - hence the need for\n333:             # both indices\n334:             while i < len(r):\n335:                 power = r_arr[j][1]\n336:                 if isinstance(domain, PermutationGroup) and r[i] in gens:\n337:                     s = domain.generators[gens.index(r[i])]\n338:                 else:\n339:                     s = r[i]\n340:                 if s in images:\n341:                     w = w*images[s]**power\n342:                 elif s**-1 in images:\n343:                     w = w*images[s**-1]**power\n344:                 i += abs(power)\n345:                 j += 1\n346:             return w\n347: \n348:     for r in rels:\n349:         if isinstance(codomain, FpGroup):\n350:             s = codomain.equals(_image(r), identity)\n351:             if s is None:\n352:                 # only try to make the rewriting system\n353:                 # confluent when it can't determine the\n354:                 # truth of equality otherwise\n355:                 success = codomain.make_confluent()\n356:                 s = codomain.equals(_image(r), identity)\n357:                 if s is None and not success:\n358:                     raise RuntimeError(\"Can't determine if the images \"\n359:                         \"define a homomorphism. Try increasing \"\n360:                         \"the maximum number of rewriting rules \"\n361:                         \"(group._rewriting_system.set_max(new_value); \"\n362:                         \"the current value is stored in group._rewriting\"\n363:                         \"_system.maxeqns)\")\n364:         else:\n365:             s = _image(r).is_identity\n366:         if not s:\n367:             return False\n368:     return True\n369: \n370: def orbit_homomorphism(group, omega):\nCode replaced for brevity.\n388: \n389: \n390: def block_homomorphism(group, blocks):\nCode replaced for brevity.\n424: \n425: \n426: def group_isomorphism(G, H, isomorphism=True):\nCode replaced for brevity.\n540: \n541: \n542: def is_isomorphic(G, H):\nCode replaced for brevity.\n560: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/combinatorics/homomorphisms.py",
      "suspect_lines": [
        311,
        312,
        313,
        314,
        315,
        319,
        320,
        321,
        322,
        323,
        324,
        325,
        326,
        327,
        328,
        329,
        330,
        331,
        332,
        333,
        334,
        335,
        336,
        337,
        338,
        339,
        340,
        341,
        342,
        343,
        344,
        345,
        346
      ]
    }
  ]
}