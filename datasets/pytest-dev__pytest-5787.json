{
  "instance_id": "pytest-dev__pytest-5787",
  "problem_statement": "exception serialization should include chained exceptions\ngiven some simple tests:\r\n```\r\ndef test_chained_exception_with_from():\r\n    try:\r\n        try:\r\n            raise ValueError(11)\r\n        except Exception as e1:\r\n            raise ValueError(12) from e1\r\n    except Exception as e2:\r\n        raise ValueError(13) from e2\r\n\r\n\r\ndef test_chained_exception_without_from():\r\n    try:\r\n        try:\r\n            raise ValueError(21)\r\n        except Exception:\r\n            raise ValueError(22)\r\n    except Exception:\r\n        raise ValueError(23)\r\n```\r\nwhen run without xdist it displays whole exception trace nicely :\r\n```\r\n================ FAILURES ==========================\r\n__________________________ test_chained_exception_with_from _______________________\r\n\r\n    def test_chained_exception_with_from():\r\n        try:\r\n            try:\r\n>               raise ValueError(11)\r\nE               ValueError: 11\r\n\r\nbasic/test_basic.py:80: ValueError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\n    def test_chained_exception_with_from():\r\n        try:\r\n            try:\r\n                raise ValueError(11)\r\n            except Exception as e1:\r\n>               raise ValueError(12) from e1\r\nE               ValueError: 12\r\n\r\nbasic/test_basic.py:82: ValueError\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\n    def test_chained_exception_with_from():\r\n        try:\r\n            try:\r\n                raise ValueError(11)\r\n            except Exception as e1:\r\n                raise ValueError(12) from e1\r\n        except Exception as e2:\r\n>           raise ValueError(13) from e2\r\nE           ValueError: 13\r\n\r\nbasic/test_basic.py:84: ValueError\r\n\r\n\r\n_____________________ test_chained_exception_without_from ____________________________\r\n\r\n    def test_chained_exception_without_from():\r\n        try:\r\n            try:\r\n>               raise ValueError(21)\r\nE               ValueError: 21\r\n\r\nbasic/test_basic.py:90: ValueError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\n    def test_chained_exception_without_from():\r\n        try:\r\n            try:\r\n                raise ValueError(21)\r\n            except Exception:\r\n>               raise ValueError(22)\r\nE               ValueError: 22\r\n\r\nbasic/test_basic.py:92: ValueError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\n    def test_chained_exception_without_from():\r\n        try:\r\n            try:\r\n                raise ValueError(21)\r\n            except Exception:\r\n                raise ValueError(22)\r\n        except Exception:\r\n>           raise ValueError(23)\r\nE           ValueError: 23\r\n\r\nbasic/test_basic.py:94: ValueError\r\n\r\n```\r\n\r\nbut when run with xdist (`-n auto`), it just displays the last one:\r\n```\r\n============ FAILURES ================\r\n_____________ test_chained_exception_with_from _______________________________\r\n[gw0] linux -- Python 3.6.7 /home/mulawa/developement/omcp/has/test/py/.tox/sct/bin/python3.6\r\n\r\n    def test_chained_exception_with_from():\r\n        try:\r\n            try:\r\n                raise ValueError(11)\r\n            except Exception as e1:\r\n                raise ValueError(12) from e1\r\n        except Exception as e2:\r\n>           raise ValueError(13) from e2\r\nE           ValueError: 13\r\n\r\nbasic/test_basic.py:84: ValueError\r\n\r\n____________ test_chained_exception_without_from ____________\r\n[gw1] linux -- Python 3.6.7 /home/mulawa/developement/omcp/has/test/py/.tox/sct/bin/python3.6\r\n\r\n    def test_chained_exception_without_from():\r\n        try:\r\n            try:\r\n                raise ValueError(21)\r\n            except Exception:\r\n                raise ValueError(22)\r\n        except Exception:\r\n>           raise ValueError(23)\r\nE           ValueError: 23\r\n\r\nbasic/test_basic.py:94: ValueError\r\n\r\n```\r\n\r\nmy setup:\r\n```\r\npytest           4.0.2       \r\npytest-xdist     1.25.0\r\n```\n",
  "localized_code": "[start of src/_pytest/reports.py]\n1: from pprint import pprint\n2: from typing import Optional\n3: \n4: import py\n5: \n6: from _pytest._code.code import ExceptionInfo\n7: from _pytest._code.code import ReprEntry\n8: from _pytest._code.code import ReprEntryNative\n9: from _pytest._code.code import ReprExceptionInfo\n10: from _pytest._code.code import ReprFileLocation\n11: from _pytest._code.code import ReprFuncArgs\n12: from _pytest._code.code import ReprLocals\n13: from _pytest._code.code import ReprTraceback\n14: from _pytest._code.code import TerminalRepr\n15: from _pytest.outcomes import skip\n16: from _pytest.pathlib import Path\n17: \n18: \n19: def getslaveinfoline(node):\n20:     try:\n21:         return node._slaveinfocache\n22:     except AttributeError:\n23:         d = node.slaveinfo\n24:         ver = \"%s.%s.%s\" % d[\"version_info\"][:3]\n25:         node._slaveinfocache = s = \"[{}] {} -- Python {} {}\".format(\n26:             d[\"id\"], d[\"sysplatform\"], ver, d[\"executable\"]\n27:         )\n28:         return s\n29: \n30: \n31: class BaseReport:\n32:     when = None  # type: Optional[str]\n33:     location = None\n34: \n35:     def __init__(self, **kw):\n36:         self.__dict__.update(kw)\n37: \n38:     def toterminal(self, out):\n39:         if hasattr(self, \"node\"):\n40:             out.line(getslaveinfoline(self.node))\n41: \n42:         longrepr = self.longrepr\n43:         if longrepr is None:\n44:             return\n45: \n46:         if hasattr(longrepr, \"toterminal\"):\n47:             longrepr.toterminal(out)\n48:         else:\n49:             try:\n50:                 out.line(longrepr)\n51:             except UnicodeEncodeError:\n52:                 out.line(\"<unprintable longrepr>\")\n53: \n54:     def get_sections(self, prefix):\n55:         for name, content in self.sections:\n56:             if name.startswith(prefix):\n57:                 yield prefix, content\n58: \n59:     @property\n60:     def longreprtext(self):\n61:         \"\"\"\n62:         Read-only property that returns the full string representation\n63:         of ``longrepr``.\n64: \n65:         .. versionadded:: 3.0\n66:         \"\"\"\n67:         tw = py.io.TerminalWriter(stringio=True)\n68:         tw.hasmarkup = False\n69:         self.toterminal(tw)\n70:         exc = tw.stringio.getvalue()\n71:         return exc.strip()\n72: \n73:     @property\n74:     def caplog(self):\n75:         \"\"\"Return captured log lines, if log capturing is enabled\n76: \n77:         .. versionadded:: 3.5\n78:         \"\"\"\n79:         return \"\\n\".join(\n80:             content for (prefix, content) in self.get_sections(\"Captured log\")\n81:         )\n82: \n83:     @property\n84:     def capstdout(self):\n85:         \"\"\"Return captured text from stdout, if capturing is enabled\n86: \n87:         .. versionadded:: 3.0\n88:         \"\"\"\n89:         return \"\".join(\n90:             content for (prefix, content) in self.get_sections(\"Captured stdout\")\n91:         )\n92: \n93:     @property\n94:     def capstderr(self):\n95:         \"\"\"Return captured text from stderr, if capturing is enabled\n96: \n97:         .. versionadded:: 3.0\n98:         \"\"\"\n99:         return \"\".join(\n100:             content for (prefix, content) in self.get_sections(\"Captured stderr\")\n101:         )\n102: \n103:     passed = property(lambda x: x.outcome == \"passed\")\n104:     failed = property(lambda x: x.outcome == \"failed\")\n105:     skipped = property(lambda x: x.outcome == \"skipped\")\n106: \n107:     @property\n108:     def fspath(self):\n109:         return self.nodeid.split(\"::\")[0]\n110: \n111:     @property\n112:     def count_towards_summary(self):\n113:         \"\"\"\n114:         **Experimental**\n115: \n116:         Returns True if this report should be counted towards the totals shown at the end of the\n117:         test session: \"1 passed, 1 failure, etc\".\n118: \n119:         .. note::\n120: \n121:             This function is considered **experimental**, so beware that it is subject to changes\n122:             even in patch releases.\n123:         \"\"\"\n124:         return True\n125: \n126:     @property\n127:     def head_line(self):\n128:         \"\"\"\n129:         **Experimental**\n130: \n131:         Returns the head line shown with longrepr output for this report, more commonly during\n132:         traceback representation during failures::\n133: \n134:             ________ Test.foo ________\n135: \n136: \n137:         In the example above, the head_line is \"Test.foo\".\n138: \n139:         .. note::\n140: \n141:             This function is considered **experimental**, so beware that it is subject to changes\n142:             even in patch releases.\n143:         \"\"\"\n144:         if self.location is not None:\n145:             fspath, lineno, domain = self.location\n146:             return domain\n147: \n148:     def _get_verbose_word(self, config):\n149:         _category, _short, verbose = config.hook.pytest_report_teststatus(\n150:             report=self, config=config\n151:         )\n152:         return verbose\n153: \n154:     def _to_json(self):\n155:         \"\"\"\n156:         This was originally the serialize_report() function from xdist (ca03269).\n157: \n158:         Returns the contents of this report as a dict of builtin entries, suitable for\n159:         serialization.\n160: \n161:         Experimental method.\n162:         \"\"\"\n163: \n164:         def disassembled_report(rep):\n165:             reprtraceback = rep.longrepr.reprtraceback.__dict__.copy()\n166:             reprcrash = rep.longrepr.reprcrash.__dict__.copy()\n167: \n168:             new_entries = []\n169:             for entry in reprtraceback[\"reprentries\"]:\n170:                 entry_data = {\n171:                     \"type\": type(entry).__name__,\n172:                     \"data\": entry.__dict__.copy(),\n173:                 }\n174:                 for key, value in entry_data[\"data\"].items():\n175:                     if hasattr(value, \"__dict__\"):\n176:                         entry_data[\"data\"][key] = value.__dict__.copy()\n177:                 new_entries.append(entry_data)\n178: \n179:             reprtraceback[\"reprentries\"] = new_entries\n180: \n181:             return {\n182:                 \"reprcrash\": reprcrash,\n183:                 \"reprtraceback\": reprtraceback,\n184:                 \"sections\": rep.longrepr.sections,\n185:             }\n186: \n187:         d = self.__dict__.copy()\n188:         if hasattr(self.longrepr, \"toterminal\"):\n189:             if hasattr(self.longrepr, \"reprtraceback\") and hasattr(\n190:                 self.longrepr, \"reprcrash\"\n191:             ):\n192:                 d[\"longrepr\"] = disassembled_report(self)\n193:             else:\n194:                 d[\"longrepr\"] = str(self.longrepr)\n195:         else:\n196:             d[\"longrepr\"] = self.longrepr\n197:         for name in d:\n198:             if isinstance(d[name], (py.path.local, Path)):\n199:                 d[name] = str(d[name])\n200:             elif name == \"result\":\n201:                 d[name] = None  # for now\n202:         return d\n203: \n204:     @classmethod\n205:     def _from_json(cls, reportdict):\n206:         \"\"\"\n207:         This was originally the serialize_report() function from xdist (ca03269).\n208: \n209:         Factory method that returns either a TestReport or CollectReport, depending on the calling\n210:         class. It's the callers responsibility to know which class to pass here.\n211: \n212:         Experimental method.\n213:         \"\"\"\n214:         if reportdict[\"longrepr\"]:\n215:             if (\n216:                 \"reprcrash\" in reportdict[\"longrepr\"]\n217:                 and \"reprtraceback\" in reportdict[\"longrepr\"]\n218:             ):\n219: \n220:                 reprtraceback = reportdict[\"longrepr\"][\"reprtraceback\"]\n221:                 reprcrash = reportdict[\"longrepr\"][\"reprcrash\"]\n222: \n223:                 unserialized_entries = []\n224:                 reprentry = None\n225:                 for entry_data in reprtraceback[\"reprentries\"]:\n226:                     data = entry_data[\"data\"]\n227:                     entry_type = entry_data[\"type\"]\n228:                     if entry_type == \"ReprEntry\":\n229:                         reprfuncargs = None\n230:                         reprfileloc = None\n231:                         reprlocals = None\n232:                         if data[\"reprfuncargs\"]:\n233:                             reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n234:                         if data[\"reprfileloc\"]:\n235:                             reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n236:                         if data[\"reprlocals\"]:\n237:                             reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n238: \n239:                         reprentry = ReprEntry(\n240:                             lines=data[\"lines\"],\n241:                             reprfuncargs=reprfuncargs,\n242:                             reprlocals=reprlocals,\n243:                             filelocrepr=reprfileloc,\n244:                             style=data[\"style\"],\n245:                         )\n246:                     elif entry_type == \"ReprEntryNative\":\n247:                         reprentry = ReprEntryNative(data[\"lines\"])\n248:                     else:\n249:                         _report_unserialization_failure(entry_type, cls, reportdict)\n250:                     unserialized_entries.append(reprentry)\n251:                 reprtraceback[\"reprentries\"] = unserialized_entries\n252: \n253:                 exception_info = ReprExceptionInfo(\n254:                     reprtraceback=ReprTraceback(**reprtraceback),\n255:                     reprcrash=ReprFileLocation(**reprcrash),\n256:                 )\n257: \n258:                 for section in reportdict[\"longrepr\"][\"sections\"]:\n259:                     exception_info.addsection(*section)\n260:                 reportdict[\"longrepr\"] = exception_info\n261: \n262:         return cls(**reportdict)\n263: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/src/_pytest/reports.py",
      "suspect_lines": [
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        187,
        188,
        189,
        190,
        191,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        255,
        256,
        257,
        258,
        259,
        260,
        261,
        262
      ]
    }
  ]
}