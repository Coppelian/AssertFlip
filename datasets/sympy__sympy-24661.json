{
  "instance_id": "sympy__sympy-24661",
  "problem_statement": "The evaluate=False parameter to `parse_expr` is ignored for relationals\nSee also #22305 and #22098\r\n\r\nThis inequality evaluates even though `evaluate=False` is given:\r\n```python\r\nIn [14]: parse_expr('1 < 2', evaluate=False)\r\nOut[14]: True\r\n```\r\nThe result that should be returned is:\r\n```python\r\nIn [15]: Lt(1, 2, evaluate=False)\r\nOut[15]: 1 < 2\r\n```\n",
  "localized_code": "[start of sympy/parsing/sympy_parser.py]\n1: \"\"\"Transform a string with Python-like source code into SymPy expression. \"\"\"\n2: \n3: from tokenize import (generate_tokens, untokenize, TokenError,\n4:     NUMBER, STRING, NAME, OP, ENDMARKER, ERRORTOKEN, NEWLINE)\n5: \n6: from keyword import iskeyword\n7: \n8: import ast\n9: import unicodedata\n10: from io import StringIO\n11: import builtins\n12: import types\n13: from typing import Tuple as tTuple, Dict as tDict, Any, Callable, \\\n14:     List, Optional, Union as tUnion\n15: \n16: from sympy.assumptions.ask import AssumptionKeys\n17: from sympy.core.basic import Basic\n18: from sympy.core import Symbol\n19: from sympy.core.function import Function\n20: from sympy.utilities.misc import func_name\n21: from sympy.functions.elementary.miscellaneous import Max, Min\n22: \n23: \n24: null = ''\n25: \n26: TOKEN = tTuple[int, str]\n27: DICT = tDict[str, Any]\n28: TRANS = Callable[[List[TOKEN], DICT, DICT], List[TOKEN]]\n29: \n30: def _token_splittable(token_name: str) -> bool:\n31:     \"\"\"\n32:     Predicate for whether a token name can be split into multiple tokens.\n33: \n34:     A token is splittable if it does not contain an underscore character and\n35:     it is not the name of a Greek letter. This is used to implicitly convert\n36:     expressions like 'xyz' into 'x*y*z'.\n37:     \"\"\"\n38:     if '_' in token_name:\n39:         return False\n40:     try:\n41:         return not unicodedata.lookup('GREEK SMALL LETTER ' + token_name)\n42:     except KeyError:\n43:         return len(token_name) > 1\n44: \n45: \n46: def _token_callable(token: TOKEN, local_dict: DICT, global_dict: DICT, nextToken=None):\n47:     \"\"\"\n48:     Predicate for whether a token name represents a callable function.\n49: \n50:     Essentially wraps ``callable``, but looks up the token name in the\n51:     locals and globals.\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/parsing/sympy_parser.py",
      "suspect_lines": []
    }
  ]
}