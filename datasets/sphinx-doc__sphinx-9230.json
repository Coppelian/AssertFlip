{
  "instance_id": "sphinx-doc__sphinx-9230",
  "problem_statement": "Doc rendering is incorrect when :param has datatype dict(str,str)\n**Describe the bug**\r\nI have a parameter defined under docstring of a method as:-\r\n:param dict(str, str) opc_meta: (optional)\r\n\r\nWhich is being incorrectly rendered in the generated docs as:-\r\nstr) opc_meta (dict(str,) –(optional) \r\n\r\n**To Reproduce**\r\nCreate any method with the docstring containg the above param\r\n\r\n**Expected behavior**\r\nThe param should be rendered in the generated docs as:-\r\nopc_meta (dict(str,str)) – (optional) \r\n\r\n**Your project**\r\n[sphinxTest.zip](https://github.com/sphinx-doc/sphinx/files/6468074/sphinxTest.zip)\r\n\r\n\r\n**Screenshots**\r\n<img width=\"612\" alt=\"Screen Shot 2021-05-12 at 12 30 50 PM\" src=\"https://user-images.githubusercontent.com/8617566/118020143-5f59a280-b31f-11eb-8dc2-5280d5c4896b.png\">\r\n<img width=\"681\" alt=\"Screen Shot 2021-05-12 at 12 32 25 PM\" src=\"https://user-images.githubusercontent.com/8617566/118020154-62549300-b31f-11eb-953d-9287f9cc27ff.png\">\r\n\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.0\r\n- Sphinx version: 4.0.1\r\n- Sphinx extensions:  [\"sphinx.ext.autodoc\", \"sphinx.ext.autosummary\", \"sphinx.ext.intersphinx\", \"autodocsumm\"]\r\n- Extra tools: Browser Firefox.\r\n\r\n**Additional context**\r\nN/A\r\n\r\n\n",
  "localized_code": "[start of sphinx/util/docfields.py]\n1: \"\"\"\n2:     sphinx.util.docfields\n3:     ~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     \"Doc fields\" are reST field lists in object descriptions that will\n6:     be domain-specifically transformed to a more appealing presentation.\n7: \n8:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n9:     :license: BSD, see LICENSE for details.\n10: \"\"\"\n11: \n12: from typing import TYPE_CHECKING, Any, Dict, List, Tuple, Type, Union, cast\n13: \n14: from docutils import nodes\n15: from docutils.nodes import Node\n16: \n17: from sphinx import addnodes\n18: from sphinx.environment import BuildEnvironment\n19: from sphinx.util.typing import TextlikeNode\n20: \n21: if TYPE_CHECKING:\n22:     from sphinx.directive import ObjectDescription\n23: \n24: \n25: def _is_single_paragraph(node: nodes.field_body) -> bool:\n26:     \"\"\"True if the node only contains one paragraph (and system messages).\"\"\"\n27:     if len(node) == 0:\n28:         return False\n29:     elif len(node) > 1:\n30:         for subnode in node[1:]:  # type: Node\n31:             if not isinstance(subnode, nodes.system_message):\n32:                 return False\n33:     if isinstance(node[0], nodes.paragraph):\n34:         return True\n35:     return False\n36: \n37: \n38: class Field:\n39:     \"\"\"A doc field that is never grouped.  It can have an argument or not, the\n40:     argument can be linked using a specified *rolename*.  Field should be used\n41:     for doc fields that usually don't occur more than once.\n42: \n43:     The body can be linked using a specified *bodyrolename* if the content is\n44:     just a single inline or text node.\n45: \n46:     Example::\n47: \n48:        :returns: description of the return value\n49:        :rtype: description of the return type\n50:     \"\"\"\n51:     is_grouped = False\n52:     is_typed = False\n53: \n54:     def __init__(self, name: str, names: Tuple[str, ...] = (), label: str = None,\n55:                  has_arg: bool = True, rolename: str = None, bodyrolename: str = None) -> None:\n56:         self.name = name\n57:         self.names = names\n58:         self.label = label\n59:         self.has_arg = has_arg\n60:         self.rolename = rolename\n61:         self.bodyrolename = bodyrolename\n62: \n63:     def make_xref(self, rolename: str, domain: str, target: str,\n64:                   innernode: Type[TextlikeNode] = addnodes.literal_emphasis,\n65:                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n66:         if not rolename:\n67:             return contnode or innernode(target, target)\n68:         refnode = addnodes.pending_xref('', refdomain=domain, refexplicit=False,\n69:                                         reftype=rolename, reftarget=target)\n70:         refnode += contnode or innernode(target, target)\n71:         if env:\n72:             env.get_domain(domain).process_field_xref(refnode)\n73:         return refnode\n74: \n75:     def make_xrefs(self, rolename: str, domain: str, target: str,\n76:                    innernode: Type[TextlikeNode] = addnodes.literal_emphasis,\n77:                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n78:         return [self.make_xref(rolename, domain, target, innernode, contnode, env)]\n79: \n80:     def make_entry(self, fieldarg: str, content: List[Node]) -> Tuple[str, List[Node]]:\n81:         return (fieldarg, content)\n82: \n83:     def make_field(self, types: Dict[str, List[Node]], domain: str,\n84:                    item: Tuple, env: BuildEnvironment = None) -> nodes.field:\n85:         fieldarg, content = item\n86:         fieldname = nodes.field_name('', self.label)\n87:         if fieldarg:\n88:             fieldname += nodes.Text(' ')\n89:             fieldname.extend(self.make_xrefs(self.rolename, domain,\n90:                                              fieldarg, nodes.Text, env=env))\n91: \n92:         if len(content) == 1 and (\n93:                 isinstance(content[0], nodes.Text) or\n94:                 (isinstance(content[0], nodes.inline) and len(content[0]) == 1 and\n95:                  isinstance(content[0][0], nodes.Text))):\n96:             content = self.make_xrefs(self.bodyrolename, domain,\n97:                                       content[0].astext(), contnode=content[0], env=env)\n98:         fieldbody = nodes.field_body('', nodes.paragraph('', '', *content))\n99:         return nodes.field('', fieldname, fieldbody)\n100: \n101: \n102: class GroupedField(Field):\nCode replaced for brevity.\n141: \n142: \n143: \n144: class TypedField(GroupedField):\nCode replaced for brevity.\n204: \n205: \n206: \n207: class DocFieldTransformer:\n208:     \"\"\"\n209:     Transforms field lists in \"doc field\" syntax into better-looking\n210:     equivalents, using the field type definitions given on a domain.\n211:     \"\"\"\n212:     typemap: Dict[str, Tuple[Field, bool]]\n213: \n214:     def __init__(self, directive: \"ObjectDescription\") -> None:\n215:         self.directive = directive\n216: \n217:         self.typemap = directive.get_field_type_map()\n218: \n219:     def transform_all(self, node: addnodes.desc_content) -> None:\n220:         \"\"\"Transform all field list children of a node.\"\"\"\n221:         # don't traverse, only handle field lists that are immediate children\n222:         for child in node:\n223:             if isinstance(child, nodes.field_list):\n224:                 self.transform(child)\n225: \n226:     def transform(self, node: nodes.field_list) -> None:\n227:         \"\"\"Transform a single field list *node*.\"\"\"\n228:         typemap = self.typemap\n229: \n230:         entries: List[Union[nodes.field, Tuple[Field, Any]]] = []\n231:         groupindices: Dict[str, int] = {}\n232:         types: Dict[str, Dict] = {}\n233: \n234:         # step 1: traverse all fields and collect field types and content\n235:         for field in cast(List[nodes.field], node):\n236:             assert len(field) == 2\n237:             field_name = cast(nodes.field_name, field[0])\n238:             field_body = cast(nodes.field_body, field[1])\n239:             try:\n240:                 # split into field type and argument\n241:                 fieldtype_name, fieldarg = field_name.astext().split(None, 1)\n242:             except ValueError:\n243:                 # maybe an argument-less field type?\n244:                 fieldtype_name, fieldarg = field_name.astext(), ''\n245:             typedesc, is_typefield = typemap.get(fieldtype_name, (None, None))\n246: \n247:             # collect the content, trying not to keep unnecessary paragraphs\n248:             if _is_single_paragraph(field_body):\n249:                 paragraph = cast(nodes.paragraph, field_body[0])\n250:                 content = paragraph.children\n251:             else:\n252:                 content = field_body.children\n253: \n254:             # sort out unknown fields\n255:             if typedesc is None or typedesc.has_arg != bool(fieldarg):\n256:                 # either the field name is unknown, or the argument doesn't\n257:                 # match the spec; capitalize field name and be done with it\n258:                 new_fieldname = fieldtype_name[0:1].upper() + fieldtype_name[1:]\n259:                 if fieldarg:\n260:                     new_fieldname += ' ' + fieldarg\n261:                 field_name[0] = nodes.Text(new_fieldname)\n262:                 entries.append(field)\n263: \n264:                 # but if this has a type then we can at least link it\n265:                 if (typedesc and is_typefield and content and\n266:                         len(content) == 1 and isinstance(content[0], nodes.Text)):\n267:                     typed_field = cast(TypedField, typedesc)\n268:                     target = content[0].astext()\n269:                     xrefs = typed_field.make_xrefs(\n270:                         typed_field.typerolename,\n271:                         self.directive.domain,\n272:                         target,\n273:                         contnode=content[0],\n274:                         env=self.directive.state.document.settings.env\n275:                     )\n276:                     if _is_single_paragraph(field_body):\n277:                         paragraph = cast(nodes.paragraph, field_body[0])\n278:                         paragraph.clear()\n279:                         paragraph.extend(xrefs)\n280:                     else:\n281:                         field_body.clear()\n282:                         field_body += nodes.paragraph('', '', *xrefs)\n283: \n284:                 continue\n285: \n286:             typename = typedesc.name\n287: \n288:             # if the field specifies a type, put it in the types collection\n289:             if is_typefield:\n290:                 # filter out only inline nodes; others will result in invalid\n291:                 # markup being written out\n292:                 content = [n for n in content if isinstance(n, nodes.Inline) or\n293:                            isinstance(n, nodes.Text)]\n294:                 if content:\n295:                     types.setdefault(typename, {})[fieldarg] = content\n296:                 continue\n297: \n298:             # also support syntax like ``:param type name:``\n299:             if typedesc.is_typed:\n300:                 try:\n301:                     argtype, argname = fieldarg.split(None, 1)\n302:                 except ValueError:\n303:                     pass\n304:                 else:\n305:                     types.setdefault(typename, {})[argname] = \\\n306:                         [nodes.Text(argtype)]\n307:                     fieldarg = argname\n308: \n309:             translatable_content = nodes.inline(field_body.rawsource,\n310:                                                 translatable=True)\n311:             translatable_content.document = field_body.parent.document\n312:             translatable_content.source = field_body.parent.source\n313:             translatable_content.line = field_body.parent.line\n314:             translatable_content += content\n315: \n316:             # grouped entries need to be collected in one entry, while others\n317:             # get one entry per field\n318:             if typedesc.is_grouped:\n319:                 if typename in groupindices:\n320:                     group = cast(Tuple[Field, List], entries[groupindices[typename]])\n321:                 else:\n322:                     groupindices[typename] = len(entries)\n323:                     group = (typedesc, [])\n324:                     entries.append(group)\n325:                 new_entry = typedesc.make_entry(fieldarg, [translatable_content])\n326:                 group[1].append(new_entry)\n327:             else:\n328:                 new_entry = typedesc.make_entry(fieldarg, [translatable_content])\n329:                 entries.append((typedesc, new_entry))\n330: \n331:         # step 2: all entries are collected, construct the new field list\n332:         new_list = nodes.field_list()\n333:         for entry in entries:\n334:             if isinstance(entry, nodes.field):\n335:                 # pass-through old field\n336:                 new_list += entry\n337:             else:\n338:                 fieldtype, items = entry\n339:                 fieldtypes = types.get(fieldtype.name, {})\n340:                 env = self.directive.state.document.settings.env\n341:                 new_list += fieldtype.make_field(fieldtypes, self.directive.domain,\n342:                                                  items, env=env)\n343: \n344:         node.replace_self(new_list)\n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/util/docfields.py",
      "suspect_lines": [
        301
      ]
    }
  ]
}