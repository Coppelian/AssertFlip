{
  "instance_id": "matplotlib__matplotlib-22865",
  "problem_statement": "[Bug]: Colorbar with drawedges=True and extend='both' does not draw edges at extremities\n### Bug summary\n\nWhen creating a matplotlib colorbar, it is possible to set drawedges to True which separates the colors of the colorbar with black lines. However, when the colorbar is extended using extend='both', the black lines at the extremities do not show up.\n\n### Code for reproduction\n\n```python\nimport matplotlib as mpl\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt  \r\nfrom matplotlib.colors import from_levels_and_colors\r\n\r\nmy_cmap = mpl.cm.viridis\r\nbounds = np.arange(10)\r\nnb_colors = len(bounds) + 1\r\ncolors = my_cmap(np.linspace(100, 255, nb_colors).astype(int))\r\nmy_cmap, my_norm = from_levels_and_colors(bounds, colors, extend='both')\r\n\r\nplt.figure(figsize=(5, 1))\r\nax = plt.subplot(111)\r\ncbar = mpl.colorbar.ColorbarBase(ax, cmap=my_cmap, norm=my_norm, orientation='horizontal', drawedges=True)\r\nplt.subplots_adjust(left=0.05, bottom=0.4, right=0.95, top=0.9)\r\nplt.show()\n```\n\n\n### Actual outcome\n\n![image](https://user-images.githubusercontent.com/34058459/164254401-7516988d-1efb-4887-a631-de9a68357685.png)\r\n\n\n### Expected outcome\n\n![image](https://user-images.githubusercontent.com/34058459/164254881-92c167b7-aa13-4972-9955-48221b38b866.png)\r\n\n\n### Additional information\n\n_No response_\n\n### Operating system\n\n_No response_\n\n### Matplotlib Version\n\n3.5.1\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n_No response_\n\n### Jupyter version\n\n_No response_\n\n### Installation\n\n_No response_\n",
  "localized_code": "[start of lib/matplotlib/colorbar.py]\n1: \"\"\"\n2: Colorbars are a visualization of the mapping from scalar values to colors.\n3: In Matplotlib they are drawn into a dedicated `~.axes.Axes`.\n4: \n5: .. note::\n6:    Colorbars are typically created through `.Figure.colorbar` or its pyplot\n7:    wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with\n8:    `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for\n9:    non-`.GridSpec`-positioned axes).\n10: \n11:    End-users most likely won't need to directly use this module's API.\n12: \"\"\"\n13: \n14: import logging\n15: import textwrap\n16: \n17: import numpy as np\n18: \n19: import matplotlib as mpl\n20: from matplotlib import _api, cbook, collections, cm, colors, contour, ticker\n21: import matplotlib.artist as martist\n22: import matplotlib.patches as mpatches\n23: import matplotlib.path as mpath\n24: import matplotlib.scale as mscale\n25: import matplotlib.spines as mspines\n26: import matplotlib.transforms as mtransforms\n27: from matplotlib import _docstring\n28: \n29: _log = logging.getLogger(__name__)\n30: \n31: _make_axes_kw_doc = \"\"\"\n32: location : None or {'left', 'right', 'top', 'bottom'}\n33:     The location, relative to the parent axes, where the colorbar axes\n34:     is created.  It also determines the *orientation* of the colorbar\n35:     (colorbars on the left and right are vertical, colorbars at the top\n36:     and bottom are horizontal).  If None, the location will come from the\n37:     *orientation* if it is set (vertical colorbars on the right, horizontal\n38:     ones at the bottom), or default to 'right' if *orientation* is unset.\n39: \n40: orientation : None or {'vertical', 'horizontal'}\n41:     The orientation of the colorbar.  It is preferable to set the *location*\n42:     of the colorbar, as that also determines the *orientation*; passing\n43:     incompatible values for *location* and *orientation* raises an exception.\n44: \n45: fraction : float, default: 0.15\n46:     Fraction of original axes to use for colorbar.\n47: \n48: shrink : float, default: 1.0\n49:     Fraction by which to multiply the size of the colorbar.\n50: \n51: aspect : float, default: 20\n52:     Ratio of long to short dimensions.\n53: \n54: pad : float, default: 0.05 if vertical, 0.15 if horizontal\n55:     Fraction of original axes between colorbar and new image axes.\n56: \n57: anchor : (float, float), optional\n58:     The anchor point of the colorbar axes.\n59:     Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal.\n60: \n61: panchor : (float, float), or *False*, optional\n62:     The anchor point of the colorbar parent axes. If *False*, the parent\n63:     axes' anchor will be unchanged.\n64:     Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.\n65: \"\"\"\n66: \n67: _colormap_kw_doc = \"\"\"\n68: extend : {'neither', 'both', 'min', 'max'}\n69:     Make pointed end(s) for out-of-range values (unless 'neither').  These are\n70:     set for a given colormap using the colormap set_under and set_over methods.\n71: \n72: extendfrac : {*None*, 'auto', length, lengths}\n73:     If set to *None*, both the minimum and maximum triangular colorbar\n74:     extensions will have a length of 5% of the interior colorbar length (this\n75:     is the default setting).\n76: \n77:     If set to 'auto', makes the triangular colorbar extensions the same lengths\n78:     as the interior boxes (when *spacing* is set to 'uniform') or the same\n79:     lengths as the respective adjacent interior boxes (when *spacing* is set to\n80:     'proportional').\n81: \n82:     If a scalar, indicates the length of both the minimum and maximum\n83:     triangular colorbar extensions as a fraction of the interior colorbar\n84:     length.  A two-element sequence of fractions may also be given, indicating\n85:     the lengths of the minimum and maximum colorbar extensions respectively as\n86:     a fraction of the interior colorbar length.\n87: \n88: extendrect : bool\n89:     If *False* the minimum and maximum colorbar extensions will be triangular\n90:     (the default).  If *True* the extensions will be rectangular.\n91: \n92: spacing : {'uniform', 'proportional'}\n93:     For discrete colorbars (`.BoundaryNorm` or contours), 'uniform' gives each\n94:     color the same space; 'proportional' makes the space proportional to the\n95:     data interval.\n96: \n97: ticks : None or list of ticks or Locator\n98:     If None, ticks are determined automatically from the input.\n99: \n100: format : None or str or Formatter\n101:     If None, `~.ticker.ScalarFormatter` is used.\n102:     Format strings, e.g., ``\"%4.2e\"`` or ``\"{x:.2e}\"``, are supported.\n103:     An alternative `~.ticker.Formatter` may be given instead.\n104: \n105: drawedges : bool\n106:     Whether to draw lines at color boundaries.\n107: \n108: label : str\n109:     The label on the colorbar's long axis.\n110: \n111: boundaries, values : None or a sequence\n112:     If unset, the colormap will be displayed on a 0-1 scale.\n113:     If sequences, *values* must have a length 1 less than *boundaries*.  For\n114:     each region delimited by adjacent entries in *boundaries*, the color mapped\n115:     to the corresponding value in values will be used.\n116:     Normally only useful for indexed colors (i.e. ``norm=NoNorm()``) or other\n117:     unusual circumstances.\n118: \"\"\"\n119: \n120: _docstring.interpd.update(colorbar_doc=\"\"\"\n121: Add a colorbar to a plot.\n122: \n123: Parameters\n124: ----------\n125: mappable\n126:     The `matplotlib.cm.ScalarMappable` (i.e., `~matplotlib.image.AxesImage`,\n127:     `~matplotlib.contour.ContourSet`, etc.) described by this colorbar.\n128:     This argument is mandatory for the `.Figure.colorbar` method but optional\n129:     for the `.pyplot.colorbar` function, which sets the default to the current\n130:     image.\n131: \n132:     Note that one can create a `.ScalarMappable` \"on-the-fly\" to generate\n133:     colorbars not attached to a previously drawn artist, e.g. ::\n134: \n135:         fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)\n136: \n137: cax : `~matplotlib.axes.Axes`, optional\n138:     Axes into which the colorbar will be drawn.\n139: \n140: ax : `~matplotlib.axes.Axes`, list of Axes, optional\n141:     One or more parent axes from which space for a new colorbar axes will be\n142:     stolen, if *cax* is None.  This has no effect if *cax* is set.\n143: \n144: use_gridspec : bool, optional\n145:     If *cax* is ``None``, a new *cax* is created as an instance of Axes.  If\n146:     *ax* is an instance of Subplot and *use_gridspec* is ``True``, *cax* is\n147:     created as an instance of Subplot using the :mod:`.gridspec` module.\n148: \n149: Returns\n150: -------\n151: colorbar : `~matplotlib.colorbar.Colorbar`\n152: \n153: Notes\n154: -----\n155: Additional keyword arguments are of two kinds:\n156: \n157:   axes properties:\n158: %s\n159:   colorbar properties:\n160: %s\n161: \n162: If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is included\n163: automatically.\n164: \n165: The *shrink* kwarg provides a simple way to scale the colorbar with respect\n166: to the axes. Note that if *cax* is specified, it determines the size of the\n167: colorbar and *shrink* and *aspect* kwargs are ignored.\n168: \n169: For more precise control, you can manually specify the positions of\n170: the axes objects in which the mappable and the colorbar are drawn.  In\n171: this case, do not use any of the axes properties kwargs.\n172: \n173: It is known that some vector graphics viewers (svg and pdf) renders white gaps\n174: between segments of the colorbar.  This is due to bugs in the viewers, not\n175: Matplotlib.  As a workaround, the colorbar can be rendered with overlapping\n176: segments::\n177: \n178:     cbar = colorbar()\n179:     cbar.solids.set_edgecolor(\"face\")\n180:     draw()\n181: \n182: However this has negative consequences in other circumstances, e.g. with\n183: semi-transparent images (alpha < 1) and colorbar extensions; therefore, this\n184: workaround is not used by default (see issue #1188).\n185: \"\"\" % (textwrap.indent(_make_axes_kw_doc, \"    \"),\n186:        textwrap.indent(_colormap_kw_doc, \"    \")))\n187: \n188: \n189:     # set_xticks and set_yticks by Colorbar.__init__.\nCode replaced for brevity.\n192: \n193: \n194: \n195: class _ColorbarSpine(mspines.Spine):\nCode replaced for brevity.\n216: \n217: \n218: \n219: class _ColorbarAxesLocator:\nCode replaced for brevity.\n268: \n269: \n270: \n271: @_docstring.Substitution(_colormap_kw_doc)\n272: class Colorbar:\n273:     r\"\"\"\n274:     Draw a colorbar in an existing axes.\n275: \n276:     Typically, colorbars are created using `.Figure.colorbar` or\n277:     `.pyplot.colorbar` and associated with `.ScalarMappable`\\s (such as an\n278:     `.AxesImage` generated via `~.axes.Axes.imshow`).\n279: \n280:     In order to draw a colorbar not associated with other elements in the\n281:     figure, e.g. when showing a colormap by itself, one can create an empty\n282:     `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable*\n283:     to `Colorbar`.\n284: \n285:     Useful public methods are :meth:`set_label` and :meth:`add_lines`.\n286: \n287:     Attributes\n288:     ----------\n289:     ax : `~matplotlib.axes.Axes`\n290:         The `~.axes.Axes` instance in which the colorbar is drawn.\n291:     lines : list\n292:         A list of `.LineCollection` (empty if no lines were drawn).\n293:     dividers : `.LineCollection`\n294:         A LineCollection (empty if *drawedges* is ``False``).\n295: \n296:     Parameters\n297:     ----------\n298:     ax : `~matplotlib.axes.Axes`\n299:         The `~.axes.Axes` instance in which the colorbar is drawn.\n300: \n301:     mappable : `.ScalarMappable`\n302:         The mappable whose colormap and norm will be used.\n303: \n304:         To show the under- and over- value colors, the mappable's norm should\n305:         be specified as ::\n306: \n307:             norm = colors.Normalize(clip=False)\n308: \n309:         To show the colors versus index instead of on a 0-1 scale, use::\n310: \n311:             norm=colors.NoNorm()\n312: \n313:     cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap`\n314:         The colormap to use.  This parameter is ignored, unless *mappable* is\n315:         None.\n316: \n317:     norm : `~matplotlib.colors.Normalize`\n318:         The normalization to use.  This parameter is ignored, unless *mappable*\n319:         is None.\n320: \n321:     alpha : float\n322:         The colorbar transparency between 0 (transparent) and 1 (opaque).\n323: \n324:     orientation : {'vertical', 'horizontal'}\n325: \n326:     ticklocation : {'auto', 'left', 'right', 'top', 'bottom'}\n327: \n328:     drawedges : bool\n329: \n330:     filled : bool\n331:     %s\n332:     \"\"\"\n333: \n334:     n_rasterize = 50  # rasterize solids if number of colors >= n_rasterize\n335: \n336:     @_api.delete_parameter(\"3.6\", \"filled\")\n337:     def __init__(self, ax, mappable=None, *, cmap=None,\n338:                  norm=None,\n339:                  alpha=None,\n340:                  values=None,\n341:                  boundaries=None,\n342:                  orientation='vertical',\n343:                  ticklocation='auto',\n344:                  extend=None,\n345:                  spacing='uniform',  # uniform or proportional\n346:                  ticks=None,\n347:                  format=None,\n348:                  drawedges=False,\n349:                  filled=True,\n350:                  extendfrac=None,\n351:                  extendrect=False,\n352:                  label='',\n353:                  ):\n354: \n355:         if mappable is None:\n356:             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n357: \n358:         # Ensure the given mappable's norm has appropriate vmin and vmax\n359:         # set even if mappable.draw has not yet been called.\n360:         if mappable.get_array() is not None:\n361:             mappable.autoscale_None()\n362: \n363:         self.mappable = mappable\n364:         cmap = mappable.cmap\n365:         norm = mappable.norm\n366: \n367:         if isinstance(mappable, contour.ContourSet):\n368:             cs = mappable\n369:             alpha = cs.get_alpha()\n370:             boundaries = cs._levels\n371:             values = cs.cvalues\n372:             extend = cs.extend\n373:             filled = cs.filled\n374:             if ticks is None:\n375:                 ticks = ticker.FixedLocator(cs.levels, nbins=10)\n376:         elif isinstance(mappable, martist.Artist):\n377:             alpha = mappable.get_alpha()\n378: \n379:         mappable.colorbar = self\n380:         mappable.colorbar_cid = mappable.callbacks.connect(\n381:             'changed', self.update_normal)\n382: \n383:         _api.check_in_list(\n384:             ['vertical', 'horizontal'], orientation=orientation)\n385:         _api.check_in_list(\n386:             ['auto', 'left', 'right', 'top', 'bottom'],\n387:             ticklocation=ticklocation)\n388:         _api.check_in_list(\n389:             ['uniform', 'proportional'], spacing=spacing)\n390: \n391:         self.ax = ax\n392:         self.ax._axes_locator = _ColorbarAxesLocator(self)\n393: \n394:         if extend is None:\n395:             if (not isinstance(mappable, contour.ContourSet)\n396:                     and getattr(cmap, 'colorbar_extend', False) is not False):\n397:                 extend = cmap.colorbar_extend\n398:             elif hasattr(norm, 'extend'):\n399:                 extend = norm.extend\n400:             else:\n401:                 extend = 'neither'\n402:         self.alpha = None\n403:         # Call set_alpha to handle array-like alphas properly\n404:         self.set_alpha(alpha)\n405:         self.cmap = cmap\n406:         self.norm = norm\n407:         self.values = values\n408:         self.boundaries = boundaries\n409:         self.extend = extend\n410:         self._inside = _api.check_getitem(\n411:             {'neither': slice(0, None), 'both': slice(1, -1),\n412:              'min': slice(1, None), 'max': slice(0, -1)},\n413:             extend=extend)\n414:         self.spacing = spacing\n415:         self.orientation = orientation\n416:         self.drawedges = drawedges\n417:         self._filled = filled\n418:         self.extendfrac = extendfrac\n419:         self.extendrect = extendrect\n420:         self._extend_patches = []\n421:         self.solids = None\n422:         self.solids_patches = []\n423:         self.lines = []\n424: \n425:         for spine in self.ax.spines.values():\n426:             spine.set_visible(False)\n427:         self.outline = self.ax.spines['outline'] = _ColorbarSpine(self.ax)\n428:         self._short_axis().set_visible(False)\n429:         # Only kept for backcompat; remove after deprecation of .patch elapses.\n430:         self._patch = mpatches.Polygon(\n431:             np.empty((0, 2)),\n432:             color=mpl.rcParams['axes.facecolor'], linewidth=0.01, zorder=-1)\n433:         ax.add_artist(self._patch)\n434: \n435:         self.dividers = collections.LineCollection(\n436:             [],\n437:             colors=[mpl.rcParams['axes.edgecolor']],\n438:             linewidths=[0.5 * mpl.rcParams['axes.linewidth']])\n439:         self.ax.add_collection(self.dividers)\n440: \n441:         self._locator = None\n442:         self._minorlocator = None\n443:         self._formatter = None\n444:         self._minorformatter = None\n445:         self.__scale = None  # linear, log10 for now.  Hopefully more?\n446: \n447:         if ticklocation == 'auto':\n448:             ticklocation = 'bottom' if orientation == 'horizontal' else 'right'\n449:         self.ticklocation = ticklocation\n450: \n451:         self.set_label(label)\n452:         self._reset_locator_formatter_scale()\n453: \n454:         if np.iterable(ticks):\n455:             self._locator = ticker.FixedLocator(ticks, nbins=len(ticks))\n456:         else:\n457:             self._locator = ticks  # Handle default in _ticker()\n458: \n459:         if isinstance(format, str):\n460:             # Check format between FormatStrFormatter and StrMethodFormatter\n461:             try:\n462:                 self._formatter = ticker.FormatStrFormatter(format)\n463:                 _ = self._formatter(0)\n464:             except TypeError:\n465:                 self._formatter = ticker.StrMethodFormatter(format)\n466:         else:\n467:             self._formatter = format  # Assume it is a Formatter or None\n468:         self._draw_all()\n469: \n470:         if isinstance(mappable, contour.ContourSet) and not mappable.filled:\n471:             self.add_lines(mappable)\n472: \n473:         # Link the Axes and Colorbar for interactive use\n474:         self.ax._colorbar = self\n475:         # Don't navigate on any of these types of mappables\n476:         if (isinstance(self.norm, (colors.BoundaryNorm, colors.NoNorm)) or\n477:                 isinstance(self.mappable, contour.ContourSet)):\n478:             self.ax.set_navigate(False)\n479: \n480:         # These are the functions that set up interactivity on this colorbar\n481:         self._interactive_funcs = [\"_get_view\", \"_set_view\",\n482:                                    \"_set_view_from_bbox\", \"drag_pan\"]\n483:         for x in self._interactive_funcs:\n484:             setattr(self.ax, x, getattr(self, x))\n485:         # Set the cla function to the cbar's method to override it\n486:         self.ax.cla = self._cbar_cla\n487:         # Callbacks for the extend calculations to handle inverting the axis\n488:         self._extend_cid1 = self.ax.callbacks.connect(\n489:             \"xlim_changed\", self._do_extends)\n490:         self._extend_cid2 = self.ax.callbacks.connect(\n491:             \"ylim_changed\", self._do_extends)\n492: \n493:     @property\n494:     def locator(self):\n495:         \"\"\"Major tick `.Locator` for the colorbar.\"\"\"\n496:         return self._long_axis().get_major_locator()\n497: \n498:     @locator.setter\n499:     def locator(self, loc):\n500:         self._long_axis().set_major_locator(loc)\n501:         self._locator = loc\n502: \n503:     @property\n504:     def minorlocator(self):\n505:         \"\"\"Minor tick `.Locator` for the colorbar.\"\"\"\n506:         return self._long_axis().get_minor_locator()\n507: \n508:     @minorlocator.setter\n509:     def minorlocator(self, loc):\n510:         self._long_axis().set_minor_locator(loc)\n511:         self._minorlocator = loc\n512: \n513:     @property\n514:     def formatter(self):\n515:         \"\"\"Major tick label `.Formatter` for the colorbar.\"\"\"\n516:         return self._long_axis().get_major_formatter()\n517: \n518:     @formatter.setter\n519:     def formatter(self, fmt):\n520:         self._long_axis().set_major_formatter(fmt)\n521:         self._formatter = fmt\n522: \n523:     @property\n524:     def minorformatter(self):\n525:         \"\"\"Minor tick `.Formatter` for the colorbar.\"\"\"\n526:         return self._long_axis().get_minor_formatter()\n527: \n528:     @minorformatter.setter\n529:     def minorformatter(self, fmt):\n530:         self._long_axis().set_minor_formatter(fmt)\n531:         self._minorformatter = fmt\n532: \n533:     def _cbar_cla(self):\n534:         \"\"\"Function to clear the interactive colorbar state.\"\"\"\n535:         for x in self._interactive_funcs:\n536:             delattr(self.ax, x)\n537:         # We now restore the old cla() back and can call it directly\n538:         del self.ax.cla\n539:         self.ax.cla()\n540: \n541:     # Also remove ._patch after deprecation elapses.\n542:     patch = _api.deprecate_privatize_attribute(\"3.5\", alternative=\"ax\")\n543: \n544:     filled = _api.deprecate_privatize_attribute(\"3.6\")\n545: \n546:     def update_normal(self, mappable):\n547:         \"\"\"\n548:         Update solid patches, lines, etc.\n549: \n550:         This is meant to be called when the norm of the image or contour plot\n551:         to which this colorbar belongs changes.\n552: \n553:         If the norm on the mappable is different than before, this resets the\n554:         locator and formatter for the axis, so if these have been customized,\n555:         they will need to be customized again.  However, if the norm only\n556:         changes values of *vmin*, *vmax* or *cmap* then the old formatter\n557:         and locator will be preserved.\n558:         \"\"\"\n559:         _log.debug('colorbar update normal %r %r', mappable.norm, self.norm)\n560:         self.mappable = mappable\n561:         self.set_alpha(mappable.get_alpha())\n562:         self.cmap = mappable.cmap\n563:         if mappable.norm != self.norm:\n564:             self.norm = mappable.norm\n565:             self._reset_locator_formatter_scale()\n566: \n567:         self._draw_all()\n568:         if isinstance(self.mappable, contour.ContourSet):\n569:             CS = self.mappable\n570:             if not CS.filled:\n571:                 self.add_lines(CS)\n572:         self.stale = True\n573: \n574:     @_api.deprecated(\"3.6\", alternative=\"fig.draw_without_rendering()\")\n575:     def draw_all(self):\n576:         \"\"\"\n577:         Calculate any free parameters based on the current cmap and norm,\n578:         and do all the drawing.\n579:         \"\"\"\n580:         self._draw_all()\n581: \n582:     def _draw_all(self):\n583:         \"\"\"\n584:         Calculate any free parameters based on the current cmap and norm,\n585:         and do all the drawing.\n586:         \"\"\"\n587:         if self.orientation == 'vertical':\n588:             if mpl.rcParams['ytick.minor.visible']:\n589:                 self.minorticks_on()\n590:         else:\n591:             if mpl.rcParams['xtick.minor.visible']:\n592:                 self.minorticks_on()\n593:         self._long_axis().set(label_position=self.ticklocation,\n594:                               ticks_position=self.ticklocation)\n595:         self._short_axis().set_ticks([])\n596:         self._short_axis().set_ticks([], minor=True)\n597: \n598:         # Set self._boundaries and self._values, including extensions.\n599:         # self._boundaries are the edges of each square of color, and\n600:         # self._values are the value to map into the norm to get the\n601:         # color:\n602:         self._process_values()\n603:         # Set self.vmin and self.vmax to first and last boundary, excluding\n604:         # extensions:\n605:         self.vmin, self.vmax = self._boundaries[self._inside][[0, -1]]\n606:         # Compute the X/Y mesh.\n607:         X, Y = self._mesh()\n608:         # draw the extend triangles, and shrink the inner axes to accommodate.\n609:         # also adds the outline path to self.outline spine:\n610:         self._do_extends()\n611:         lower, upper = self.vmin, self.vmax\n612:         if self._long_axis().get_inverted():\n613:             # If the axis is inverted, we need to swap the vmin/vmax\n614:             lower, upper = upper, lower\n615:         if self.orientation == 'vertical':\n616:             self.ax.set_xlim(0, 1)\n617:             self.ax.set_ylim(lower, upper)\n618:         else:\n619:             self.ax.set_ylim(0, 1)\n620:             self.ax.set_xlim(lower, upper)\n621: \n622:         # set up the tick locators and formatters.  A bit complicated because\n623:         # boundary norms + uniform spacing requires a manual locator.\n624:         self.update_ticks()\n625: \n626:         if self._filled:\n627:             ind = np.arange(len(self._values))\n628:             if self._extend_lower():\n629:                 ind = ind[1:]\n630:             if self._extend_upper():\n631:                 ind = ind[:-1]\n632:             self._add_solids(X, Y, self._values[ind, np.newaxis])\n633: \n634:     def _add_solids(self, X, Y, C):\n635:         \"\"\"Draw the colors; optionally add separators.\"\"\"\n636:         # Cleanup previously set artists.\n637:         if self.solids is not None:\n638:             self.solids.remove()\n639:         for solid in self.solids_patches:\n640:             solid.remove()\n641:         # Add new artist(s), based on mappable type.  Use individual patches if\n642:         # hatching is needed, pcolormesh otherwise.\n643:         mappable = getattr(self, 'mappable', None)\n644:         if (isinstance(mappable, contour.ContourSet)\n645:                 and any(hatch is not None for hatch in mappable.hatches)):\n646:             self._add_solids_patches(X, Y, C, mappable)\n647:         else:\n648:             self.solids = self.ax.pcolormesh(\n649:                 X, Y, C, cmap=self.cmap, norm=self.norm, alpha=self.alpha,\n650:                 edgecolors='none', shading='flat')\n651:             if not self.drawedges:\n652:                 if len(self._y) >= self.n_rasterize:\n653:                     self.solids.set_rasterized(True)\n654:         self.dividers.set_segments(\n655:             np.dstack([X, Y])[1:-1] if self.drawedges else [])\n656: \n657:     def _add_solids_patches(self, X, Y, C, mappable):\n658:         hatches = mappable.hatches * len(C)  # Have enough hatches.\n659:         patches = []\n660:         for i in range(len(X) - 1):\n661:             xy = np.array([[X[i, 0], Y[i, 0]],\n662:                            [X[i, 1], Y[i, 0]],\n663:                            [X[i + 1, 1], Y[i + 1, 0]],\n664:                            [X[i + 1, 0], Y[i + 1, 1]]])\n665:             patch = mpatches.PathPatch(mpath.Path(xy),\n666:                                        facecolor=self.cmap(self.norm(C[i][0])),\n667:                                        hatch=hatches[i], linewidth=0,\n668:                                        antialiased=False, alpha=self.alpha)\n669:             self.ax.add_patch(patch)\n670:             patches.append(patch)\n671:         self.solids_patches = patches\n672: \n673:     def _do_extends(self, ax=None):\n674:         \"\"\"\n675:         Add the extend tri/rectangles on the outside of the axes.\n676: \n677:         ax is unused, but required due to the callbacks on xlim/ylim changed\n678:         \"\"\"\n679:         # Clean up any previous extend patches\n680:         for patch in self._extend_patches:\n681:             patch.remove()\n682:         self._extend_patches = []\n683:         # extend lengths are fraction of the *inner* part of colorbar,\n684:         # not the total colorbar:\n685:         _, extendlen = self._proportional_y()\n686:         bot = 0 - (extendlen[0] if self._extend_lower() else 0)\n687:         top = 1 + (extendlen[1] if self._extend_upper() else 0)\n688: \n689:         # xyout is the outline of the colorbar including the extend patches:\n690:         if not self.extendrect:\n691:             # triangle:\n692:             xyout = np.array([[0, 0], [0.5, bot], [1, 0],\n693:                               [1, 1], [0.5, top], [0, 1], [0, 0]])\n694:         else:\n695:             # rectangle:\n696:             xyout = np.array([[0, 0], [0, bot], [1, bot], [1, 0],\n697:                               [1, 1], [1, top], [0, top], [0, 1],\n698:                               [0, 0]])\n699: \n700:         if self.orientation == 'horizontal':\n701:             xyout = xyout[:, ::-1]\n702: \n703:         # xyout is the path for the spine:\n704:         self.outline.set_xy(xyout)\n705:         if not self._filled:\n706:             return\n707: \n708:         # Make extend triangles or rectangles filled patches.  These are\n709:         # defined in the outer parent axes' coordinates:\n710:         mappable = getattr(self, 'mappable', None)\n711:         if (isinstance(mappable, contour.ContourSet)\n712:                 and any(hatch is not None for hatch in mappable.hatches)):\n713:             hatches = mappable.hatches\n714:         else:\n715:             hatches = [None]\n716: \n717:         if self._extend_lower():\n718:             if not self.extendrect:\n719:                 # triangle\n720:                 xy = np.array([[0, 0], [0.5, bot], [1, 0]])\n721:             else:\n722:                 # rectangle\n723:                 xy = np.array([[0, 0], [0, bot], [1., bot], [1, 0]])\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/colorbar.py",
      "suspect_lines": [
        654,
        655
      ]
    }
  ]
}