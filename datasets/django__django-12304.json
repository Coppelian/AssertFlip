{
  "instance_id": "django__django-12304",
  "problem_statement": "Enumeration Types are not usable in templates.\nDescription\n\t \n\t\t(last modified by Mariusz Felisiak)\n\t \nThe new â€‹enumeration types are great but can't be used in Django templates due to their being callable. For example this doesn't work:\n{% if student.year_in_school == YearInSchool.FRESHMAN %}\nThis is because YearInSchool, being a class, is callable, and Django Templates always call callables with no arguments. The call fails because the required value argument is missing.\nThe easy solution would be to declare do_not_call_in_templates = True on the various Choices classes.\n",
  "localized_code": "[start of django/db/models/enums.py]\n1: import enum\n2: \n3: from django.utils.functional import Promise\n4: \n5: __all__ = ['Choices', 'IntegerChoices', 'TextChoices']\n6: \n7: \n8: class ChoicesMeta(enum.EnumMeta):\n9:     \"\"\"A metaclass for creating a enum choices.\"\"\"\n10: \n11:     def __new__(metacls, classname, bases, classdict):\n12:         labels = []\n13:         for key in classdict._member_names:\n14:             value = classdict[key]\n15:             if (\n16:                 isinstance(value, (list, tuple)) and\n17:                 len(value) > 1 and\n18:                 isinstance(value[-1], (Promise, str))\n19:             ):\n20:                 *value, label = value\n21:                 value = tuple(value)\n22:             else:\n23:                 label = key.replace('_', ' ').title()\n24:             labels.append(label)\n25:             # Use dict.__setitem__() to suppress defenses against double\n26:             # assignment in enum's classdict.\n27:             dict.__setitem__(classdict, key, value)\n28:         cls = super().__new__(metacls, classname, bases, classdict)\n29:         cls._value2label_map_ = dict(zip(cls._value2member_map_, labels))\n30:         # Add a label property to instances of enum which uses the enum member\n31:         # that is passed in as \"self\" as the value to use when looking up the\n32:         # label in the choices.\n33:         cls.label = property(lambda self: cls._value2label_map_.get(self.value))\n34:         return enum.unique(cls)\n35: \n36:     def __contains__(cls, member):\n37:         if not isinstance(member, enum.Enum):\n38:             # Allow non-enums to match against member values.\n39:             return any(x.value == member for x in cls)\n40:         return super().__contains__(member)\n41: \n42:     @property\n43:     def names(cls):\n44:         empty = ['__empty__'] if hasattr(cls, '__empty__') else []\n45:         return empty + [member.name for member in cls]\n46: \n47:     @property\n48:     def choices(cls):\n49:         empty = [(None, cls.__empty__)] if hasattr(cls, '__empty__') else []\n50:         return empty + [(member.value, member.label) for member in cls]\n51: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/enums.py",
      "suspect_lines": []
    }
  ]
}