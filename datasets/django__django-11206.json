{
  "instance_id": "django__django-11206",
  "problem_statement": "utils.numberformat.format renders small decimals in exponential notation.\nDescription\n\t\nWhen using utils.number_format with decimal_pos, extremely small numbers get displayed using exponential notation.\n>>> from django.utils.numberformat import format as nformat\n>>> nformat(Decimal('1e-199'), '.', decimal_pos=2)\n'0.00'\n>>> nformat(Decimal('1e-200'), '.', decimal_pos=2)\n'1.00e-200'\nThis is caused by a hardcoded cut-off point in the internal logic, but I would argue that when a decimal_pos argument is supplied and the number to be formatted is smaller in absolute size than what can be encoded using the provided number of decimal positions, the returned string should be 0.0000...000 instead.\n",
  "localized_code": "[start of django/utils/numberformat.py]\n1: from decimal import Decimal\n2: \n3: from django.conf import settings\n4: from django.utils.safestring import mark_safe\n5: \n6: \n7: def format(number, decimal_sep, decimal_pos=None, grouping=0, thousand_sep='',\n8:            force_grouping=False, use_l10n=None):\n9:     \"\"\"\n10:     Get a number (as a number or string), and return it as a string,\n11:     using formats defined as arguments:\n12: \n13:     * decimal_sep: Decimal separator symbol (for example \".\")\n14:     * decimal_pos: Number of decimal positions\n15:     * grouping: Number of digits in every group limited by thousand separator.\n16:         For non-uniform digit grouping, it can be a sequence with the number\n17:         of digit group sizes following the format used by the Python locale\n18:         module in locale.localeconv() LC_NUMERIC grouping (e.g. (3, 2, 0)).\n19:     * thousand_sep: Thousand separator symbol (for example \",\")\n20:     \"\"\"\n21:     use_grouping = (use_l10n or (use_l10n is None and settings.USE_L10N)) and settings.USE_THOUSAND_SEPARATOR\n22:     use_grouping = use_grouping or force_grouping\n23:     use_grouping = use_grouping and grouping != 0\n24:     # Make the common case fast\n25:     if isinstance(number, int) and not use_grouping and not decimal_pos:\n26:         return mark_safe(number)\n27:     # sign\n28:     sign = ''\n29:     if isinstance(number, Decimal):\n30:         # Format values with more than 200 digits (an arbitrary cutoff) using\n31:         # scientific notation to avoid high memory usage in {:f}'.format().\n32:         _, digits, exponent = number.as_tuple()\n33:         if abs(exponent) + len(digits) > 200:\n34:             number = '{:e}'.format(number)\n35:             coefficient, exponent = number.split('e')\n36:             # Format the coefficient.\n37:             coefficient = format(\n38:                 coefficient, decimal_sep, decimal_pos, grouping,\n39:                 thousand_sep, force_grouping, use_l10n,\n40:             )\n41:             return '{}e{}'.format(coefficient, exponent)\n42:         else:\n43:             str_number = '{:f}'.format(number)\n44:     else:\n45:         str_number = str(number)\n46:     if str_number[0] == '-':\n47:         sign = '-'\n48:         str_number = str_number[1:]\n49:     # decimal part\n50:     if '.' in str_number:\n51:         int_part, dec_part = str_number.split('.')\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/numberformat.py",
      "suspect_lines": []
    }
  ]
}