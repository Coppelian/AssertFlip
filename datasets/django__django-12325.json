{
  "instance_id": "django__django-12325",
  "problem_statement": "pk setup for MTI to parent get confused by multiple OneToOne references.\nDescription\n\t\nclass Document(models.Model):\n\tpass\nclass Picking(Document):\n\tdocument_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n\torigin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\nproduces django.core.exceptions.ImproperlyConfigured: Add parent_link=True to appname.Picking.origin.\nclass Picking(Document):\n\torigin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n\tdocument_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\nWorks\nFirst issue is that order seems to matter?\nEven if ordering is required \"by design\"(It shouldn't be we have explicit parent_link marker) shouldn't it look from top to bottom like it does with managers and other things?\n",
  "localized_code": "[start of django/db/models/base.py]\n1: import copy\n2: import inspect\n3: import warnings\n4: from functools import partialmethod\n5: from itertools import chain\n6: \n7: from django.apps import apps\n8: from django.conf import settings\n9: from django.core import checks\n10: from django.core.exceptions import (\n11:     NON_FIELD_ERRORS, FieldDoesNotExist, FieldError, MultipleObjectsReturned,\n12:     ObjectDoesNotExist, ValidationError,\n13: )\n14: from django.db import (\n15:     DEFAULT_DB_ALIAS, DJANGO_VERSION_PICKLE_KEY, DatabaseError, connection,\n16:     connections, router, transaction,\n17: )\n18: from django.db.models import (\n19:     NOT_PROVIDED, ExpressionWrapper, IntegerField, Max, Value,\n20: )\n21: from django.db.models.constants import LOOKUP_SEP\n22: from django.db.models.constraints import CheckConstraint, UniqueConstraint\n23: from django.db.models.deletion import CASCADE, Collector\n24: from django.db.models.fields.related import (\n25:     ForeignObjectRel, OneToOneField, lazy_related_operation, resolve_relation,\n26: )\n27: from django.db.models.functions import Coalesce\n28: from django.db.models.manager import Manager\n29: from django.db.models.options import Options\n30: from django.db.models.query import Q\n31: from django.db.models.signals import (\n32:     class_prepared, post_init, post_save, pre_init, pre_save,\n33: )\n34: from django.db.models.utils import make_model_tuple\n35: from django.utils.encoding import force_str\n36: from django.utils.hashable import make_hashable\n37: from django.utils.text import capfirst, get_text_list\n38: from django.utils.translation import gettext_lazy as _\n39: from django.utils.version import get_version\n40: \n41: \n42: class Deferred:\n43:     def __repr__(self):\n44:         return '<Deferred field>'\n45: \n46:     def __str__(self):\n47:         return '<Deferred field>'\n48: \n49: \n50: DEFERRED = Deferred()\n51: \n52: \n53: def subclass_exception(name, bases, module, attached_to):\nCode replaced for brevity.\n64: \n65: \n66: \n67:     # Only call contribute_to_class() if it's bound.\nCode replaced for brevity.\n69: \n70: \n71: \n72: class ModelBase(type):\n73:     \"\"\"Metaclass for all models.\"\"\"\n74:     def __new__(cls, name, bases, attrs, **kwargs):\n75:         super_new = super().__new__\n76: \n77:         # Also ensure initialization is only performed for subclasses of Model\n78:         # (excluding Model class itself).\n79:         parents = [b for b in bases if isinstance(b, ModelBase)]\n80:         if not parents:\n81:             return super_new(cls, name, bases, attrs)\n82: \n83:         # Create the class.\n84:         module = attrs.pop('__module__')\n85:         new_attrs = {'__module__': module}\n86:         classcell = attrs.pop('__classcell__', None)\n87:         if classcell is not None:\n88:             new_attrs['__classcell__'] = classcell\n89:         attr_meta = attrs.pop('Meta', None)\n90:         # Pass all attrs without a (Django-specific) contribute_to_class()\n91:         # method to type.__new__() so that they're properly initialized\n92:         # (i.e. __set_name__()).\n93:         contributable_attrs = {}\n94:         for obj_name, obj in list(attrs.items()):\n95:             if _has_contribute_to_class(obj):\n96:                 contributable_attrs[obj_name] = obj\n97:             else:\n98:                 new_attrs[obj_name] = obj\n99:         new_class = super_new(cls, name, bases, new_attrs, **kwargs)\n100: \n101:         abstract = getattr(attr_meta, 'abstract', False)\n102:         meta = attr_meta or getattr(new_class, 'Meta', None)\n103:         base_meta = getattr(new_class, '_meta', None)\n104: \n105:         app_label = None\n106: \n107:         # Look for an application configuration to attach the model to.\n108:         app_config = apps.get_containing_app_config(module)\n109: \n110:         if getattr(meta, 'app_label', None) is None:\n111:             if app_config is None:\n112:                 if not abstract:\n113:                     raise RuntimeError(\n114:                         \"Model class %s.%s doesn't declare an explicit \"\n115:                         \"app_label and isn't in an application in \"\n116:                         \"INSTALLED_APPS.\" % (module, name)\n117:                     )\n118: \n119:             else:\n120:                 app_label = app_config.label\n121: \n122:         new_class.add_to_class('_meta', Options(meta, app_label))\n123:         if not abstract:\n124:             new_class.add_to_class(\n125:                 'DoesNotExist',\n126:                 subclass_exception(\n127:                     'DoesNotExist',\n128:                     tuple(\n129:                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract\n130:                     ) or (ObjectDoesNotExist,),\n131:                     module,\n132:                     attached_to=new_class))\n133:             new_class.add_to_class(\n134:                 'MultipleObjectsReturned',\n135:                 subclass_exception(\n136:                     'MultipleObjectsReturned',\n137:                     tuple(\n138:                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract\n139:                     ) or (MultipleObjectsReturned,),\n140:                     module,\n141:                     attached_to=new_class))\n142:             if base_meta and not base_meta.abstract:\n143:                 # Non-abstract child classes inherit some attributes from their\n144:                 # non-abstract parent (unless an ABC comes before it in the\n145:                 # method resolution order).\n146:                 if not hasattr(meta, 'ordering'):\n147:                     new_class._meta.ordering = base_meta.ordering\n148:                 if not hasattr(meta, 'get_latest_by'):\n149:                     new_class._meta.get_latest_by = base_meta.get_latest_by\n150: \n151:         is_proxy = new_class._meta.proxy\n152: \n153:         # If the model is a proxy, ensure that the base class\n154:         # hasn't been swapped out.\n155:         if is_proxy and base_meta and base_meta.swapped:\n156:             raise TypeError(\"%s cannot proxy the swapped model '%s'.\" % (name, base_meta.swapped))\n157: \n158:         # Add remaining attributes (those with a contribute_to_class() method)\n159:         # to the class.\n160:         for obj_name, obj in contributable_attrs.items():\n161:             new_class.add_to_class(obj_name, obj)\n162: \n163:         # All the fields of any type declared on this model\n164:         new_fields = chain(\n165:             new_class._meta.local_fields,\n166:             new_class._meta.local_many_to_many,\n167:             new_class._meta.private_fields\n168:         )\n169:         field_names = {f.name for f in new_fields}\n170: \n171:         # Basic setup for proxy models.\n172:         if is_proxy:\n173:             base = None\n174:             for parent in [kls for kls in parents if hasattr(kls, '_meta')]:\n175:                 if parent._meta.abstract:\n176:                     if parent._meta.fields:\n177:                         raise TypeError(\n178:                             \"Abstract base class containing model fields not \"\n179:                             \"permitted for proxy model '%s'.\" % name\n180:                         )\n181:                     else:\n182:                         continue\n183:                 if base is None:\n184:                     base = parent\n185:                 elif parent._meta.concrete_model is not base._meta.concrete_model:\n186:                     raise TypeError(\"Proxy model '%s' has more than one non-abstract model base class.\" % name)\n187:             if base is None:\n188:                 raise TypeError(\"Proxy model '%s' has no non-abstract model base class.\" % name)\n189:             new_class._meta.setup_proxy(base)\n190:             new_class._meta.concrete_model = base._meta.concrete_model\n191:         else:\n192:             new_class._meta.concrete_model = new_class\n193: \n194:         # Collect the parent links for multi-table inheritance.\n195:         parent_links = {}\n196:         for base in reversed([new_class] + parents):\n197:             # Conceptually equivalent to `if base is Model`.\n198:             if not hasattr(base, '_meta'):\n199:                 continue\n200:             # Skip concrete parent classes.\n201:             if base != new_class and not base._meta.abstract:\n202:                 continue\n203:             # Locate OneToOneField instances.\n204:             for field in base._meta.local_fields:\n205:                 if isinstance(field, OneToOneField):\n206:                     related = resolve_relation(new_class, field.remote_field.model)\n207:                     parent_links[make_model_tuple(related)] = field\n208: \n209:         # Track fields inherited from base models.\n210:         inherited_attributes = set()\n211:         # Do the appropriate setup for any model parents.\n212:         for base in new_class.mro():\n213:             if base not in parents or not hasattr(base, '_meta'):\n214:                 # Things without _meta aren't functional models, so they're\n215:                 # uninteresting parents.\n... Code Truncated ...\n\n[start of django/db/models/options.py]\n1: import bisect\n2: import copy\n3: import inspect\n4: from collections import defaultdict\n5: \n6: from django.apps import apps\n7: from django.conf import settings\n8: from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured\n9: from django.db import connections\n10: from django.db.models import Manager\n11: from django.db.models.fields import AutoField\n12: from django.db.models.fields.proxy import OrderWrt\n13: from django.db.models.query_utils import PathInfo\n14: from django.utils.datastructures import ImmutableList, OrderedSet\n15: from django.utils.functional import cached_property\n16: from django.utils.text import camel_case_to_spaces, format_lazy\n17: from django.utils.translation import override\n18: \n19: PROXY_PARENTS = object()\n20: \n21: EMPTY_RELATION_TREE = ()\n22: \n23: IMMUTABLE_WARNING = (\n24:     \"The return type of '%s' should never be mutated. If you want to manipulate this list \"\n25:     \"for your own use, make a copy first.\"\n26: )\n27: \n28: DEFAULT_NAMES = (\n29:     'verbose_name', 'verbose_name_plural', 'db_table', 'ordering',\n30:     'unique_together', 'permissions', 'get_latest_by', 'order_with_respect_to',\n31:     'app_label', 'db_tablespace', 'abstract', 'managed', 'proxy', 'swappable',\n32:     'auto_created', 'index_together', 'apps', 'default_permissions',\n33:     'select_on_save', 'default_related_name', 'required_db_features',\n34:     'required_db_vendor', 'base_manager_name', 'default_manager_name',\n35:     'indexes', 'constraints',\n36: )\n37: \n38: \n39: def normalize_together(option_together):\n40:     \"\"\"\n41:     option_together can be either a tuple of tuples, or a single\n42:     tuple of two strings. Normalize it to a tuple of tuples, so that\n43:     calling code can uniformly expect that.\n44:     \"\"\"\n45:     try:\n46:         if not option_together:\n47:             return ()\n48:         if not isinstance(option_together, (tuple, list)):\n49:             raise TypeError\n50:         first_element = option_together[0]\n51:         if not isinstance(first_element, (tuple, list)):\n52:             option_together = (option_together,)\n53:         # Normalize everything to tuples\n54:         return tuple(tuple(ot) for ot in option_together)\n55:     except TypeError:\n56:         # If the value of option_together isn't valid, return it\n57:         # verbatim; this will be picked up by the check framework later.\n58:         return option_together\n59: \n60: \n61: def make_immutable_fields_list(name, data):\nCode replaced for brevity.\n62: \n63: \n64: \n65: class Options:\n66:     FORWARD_PROPERTIES = {\n67:         'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields',\n68:         '_forward_fields_map', 'managers', 'managers_map', 'base_manager',\n69:         'default_manager',\n70:     }\n71:     REVERSE_PROPERTIES = {'related_objects', 'fields_map', '_relation_tree'}\n72: \n73:     default_apps = apps\n74: \n75:     def __init__(self, meta, app_label=None):\n76:         self._get_fields_cache = {}\n77:         self.local_fields = []\n78:         self.local_many_to_many = []\n79:         self.private_fields = []\n80:         self.local_managers = []\n81:         self.base_manager_name = None\n82:         self.default_manager_name = None\n83:         self.model_name = None\n84:         self.verbose_name = None\n85:         self.verbose_name_plural = None\n86:         self.db_table = ''\n87:         self.ordering = []\n88:         self._ordering_clash = False\n89:         self.indexes = []\n90:         self.constraints = []\n91:         self.unique_together = []\n92:         self.index_together = []\n93:         self.select_on_save = False\n94:         self.default_permissions = ('add', 'change', 'delete', 'view')\n95:         self.permissions = []\n96:         self.object_name = None\n97:         self.app_label = app_label\n98:         self.get_latest_by = None\n99:         self.order_with_respect_to = None\n100:         self.db_tablespace = settings.DEFAULT_TABLESPACE\n101:         self.required_db_features = []\n102:         self.required_db_vendor = None\n103:         self.meta = meta\n104:         self.pk = None\n105:         self.auto_field = None\n106:         self.abstract = False\n107:         self.managed = True\n108:         self.proxy = False\n109:         # For any class that is a proxy (including automatically created\n110:         # classes for deferred object loading), proxy_for_model tells us\n111:         # which class this model is proxying. Note that proxy_for_model\n112:         # can create a chain of proxy models. For non-proxy models, the\n113:         # variable is always None.\n114:         self.proxy_for_model = None\n115:         # For any non-abstract class, the concrete class is the model\n116:         # in the end of the proxy_for_model chain. In particular, for\n117:         # concrete models, the concrete_model is always the class itself.\n118:         self.concrete_model = None\n119:         self.swappable = None\n120:         self.parents = {}\n121:         self.auto_created = False\n122: \n123:         # List of all lookups defined in ForeignKey 'limit_choices_to' options\n124:         # from *other* models. Needed for some admin checks. Internal use only.\n125:         self.related_fkey_lookups = []\n126: \n127:         # A custom app registry to use, if you're making a separate model set.\n128:         self.apps = self.default_apps\n129: \n130:         self.default_related_name = None\n131: \n132:     @property\n133:     def label(self):\n134:         return '%s.%s' % (self.app_label, self.object_name)\n135: \n136:     @property\n137:     def label_lower(self):\n138:         return '%s.%s' % (self.app_label, self.model_name)\n139: \n140:     @property\n141:     def app_config(self):\n142:         # Don't go through get_app_config to avoid triggering imports.\n143:         return self.apps.app_configs.get(self.app_label)\n144: \n145:     @property\n146:     def installed(self):\n147:         return self.app_config is not None\n148: \n149:     def contribute_to_class(self, cls, name):\n150:         from django.db import connection\n151:         from django.db.backends.utils import truncate_name\n152: \n153:         cls._meta = self\n154:         self.model = cls\n155:         # First, construct the default values for these options.\n156:         self.object_name = cls.__name__\n157:         self.model_name = self.object_name.lower()\n158:         self.verbose_name = camel_case_to_spaces(self.object_name)\n159: \n160:         # Store the original user-defined values for each option,\n161:         # for use when serializing the model definition\n162:         self.original_attrs = {}\n163: \n164:         # Next, apply any overridden values from 'class Meta'.\n165:         if self.meta:\n166:             meta_attrs = self.meta.__dict__.copy()\n167:             for name in self.meta.__dict__:\n168:                 # Ignore any private attributes that Django doesn't care about.\n169:                 # NOTE: We can't modify a dictionary's contents while looping\n170:                 # over it, so we loop over the *original* dictionary instead.\n171:                 if name.startswith('_'):\n172:                     del meta_attrs[name]\n173:             for attr_name in DEFAULT_NAMES:\n174:                 if attr_name in meta_attrs:\n175:                     setattr(self, attr_name, meta_attrs.pop(attr_name))\n176:                     self.original_attrs[attr_name] = getattr(self, attr_name)\n177:                 elif hasattr(self.meta, attr_name):\n178:                     setattr(self, attr_name, getattr(self.meta, attr_name))\n179:                     self.original_attrs[attr_name] = getattr(self, attr_name)\n180: \n181:             self.unique_together = normalize_together(self.unique_together)\n182:             self.index_together = normalize_together(self.index_together)\n183:             # App label/class name interpolation for names of constraints and\n184:             # indexes.\n185:             if not getattr(cls._meta, 'abstract', False):\n186:                 for attr_name in {'constraints', 'indexes'}:\n187:                     objs = getattr(self, attr_name, [])\n188:                     setattr(self, attr_name, self._format_names_with_class(cls, objs))\n189: \n190:             # verbose_name_plural is a special case because it uses a 's'\n191:             # by default.\n192:             if self.verbose_name_plural is None:\n193:                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n194: \n195:             # order_with_respect_and ordering are mutually exclusive.\n196:             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)\n197: \n198:             # Any leftover attributes must be invalid.\n199:             if meta_attrs != {}:\n200:                 raise TypeError(\"'class Meta' got invalid attribute(s): %s\" % ','.join(meta_attrs))\n201:         else:\n202:             self.verbose_name_plural = format_lazy('{}s', self.verbose_name)\n203:         del self.meta\n204: \n205:         # If the db_table wasn't provided, use the app_label + model_name.\n206:         if not self.db_table:\n207:             self.db_table = \"%s_%s\" % (self.app_label, self.model_name)\n208:             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())\n209: \n210:     def _format_names_with_class(self, cls, objs):\n211:         \"\"\"App label/class name interpolation for object names.\"\"\"\n212:         new_objs = []\n213:         for obj in objs:\n214:             obj = obj.clone()\n215:             obj.name = obj.name % {\n216:                 'app_label': cls._meta.app_label.lower(),\n217:                 'class': cls.__name__.lower(),\n218:             }\n219:             new_objs.append(obj)\n220:         return new_objs\n221: \n222:     def _prepare(self, model):\n223:         if self.order_with_respect_to:\n224:             # The app registry will not be ready at this point, so we cannot\n225:             # use get_field().\n226:             query = self.order_with_respect_to\n227:             try:\n228:                 self.order_with_respect_to = next(\n229:                     f for f in self._get_fields(reverse=False)\n230:                     if f.name == query or f.attname == query\n231:                 )\n232:             except StopIteration:\n233:                 raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, query))\n234: \n235:             self.ordering = ('_order',)\n236:             if not any(isinstance(field, OrderWrt) for field in model._meta.local_fields):\n237:                 model.add_to_class('_order', OrderWrt())\n238:         else:\n239:             self.order_with_respect_to = None\n240: \n241:         if self.pk is None:\n242:             if self.parents:\n243:                 # Promote the first parent link in lieu of adding yet another\n244:                 # field.\n245:                 field = next(iter(self.parents.values()))\n246:                 # Look for a local field with the same name as the\n247:                 # first parent link. If a local field has already been\n248:                 # created, use it instead of promoting the parent\n249:                 already_created = [fld for fld in self.local_fields if fld.name == field.name]\n250:                 if already_created:\n251:                     field = already_created[0]\n252:                 field.primary_key = True\n253:                 self.setup_pk(field)\n254:                 if not field.remote_field.parent_link:\n255:                     raise ImproperlyConfigured(\n256:                         'Add parent_link=True to %s.' % field,\n257:                     )\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/base.py",
      "suspect_lines": [
        205
      ]
    },
    {
      "filename": "/django/db/models/options.py",
      "suspect_lines": [
        8,
        254,
        255,
        256,
        257
      ]
    }
  ]
}