{
  "instance_id": "matplotlib__matplotlib-24970",
  "problem_statement": "[Bug]: NumPy 1.24 deprecation warnings\n### Bug summary\r\n\r\nStarting NumPy 1.24 I observe several deprecation warnings.\r\n\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\nplt.get_cmap()(np.empty((0, ), dtype=np.uint8))\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n```\r\n/usr/lib/python3.10/site-packages/matplotlib/colors.py:730: DeprecationWarning: NumPy will stop allowing conversion of out-of-bound Python integers to integer arrays.  The conversion of 257 to uint8 will fail in the future.\r\nFor the old behavior, usually:\r\n    np.array(value).astype(dtype)`\r\nwill give the desired result (the cast overflows).\r\n  xa[xa > self.N - 1] = self._i_over\r\n/usr/lib/python3.10/site-packages/matplotlib/colors.py:731: DeprecationWarning: NumPy will stop allowing conversion of out-of-bound Python integers to integer arrays.  The conversion of 256 to uint8 will fail in the future.\r\nFor the old behavior, usually:\r\n    np.array(value).astype(dtype)`\r\nwill give the desired result (the cast overflows).\r\n  xa[xa < 0] = self._i_under\r\n/usr/lib/python3.10/site-packages/matplotlib/colors.py:732: DeprecationWarning: NumPy will stop allowing conversion of out-of-bound Python integers to integer arrays.  The conversion of 258 to uint8 will fail in the future.\r\nFor the old behavior, usually:\r\n    np.array(value).astype(dtype)`\r\nwill give the desired result (the cast overflows).\r\n  xa[mask_bad] = self._i_bad\r\n```\r\n\r\n### Expected outcome\r\n\r\nNo warnings.\r\n\r\n### Additional information\r\n\r\n_No response_\r\n\r\n### Operating system\r\n\r\nArchLinux\r\n\r\n### Matplotlib Version\r\n\r\n3.6.2\r\n\r\n### Matplotlib Backend\r\n\r\nQtAgg\r\n\r\n### Python version\r\n\r\nPython 3.10.9\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\nLinux package manager\n",
  "localized_code": "[start of lib/matplotlib/colors.py]\n1: \"\"\"\n2: A module for converting numbers or color arguments to *RGB* or *RGBA*.\n3: \n4: *RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\n5: range 0-1.\n6: \n7: This module includes functions and classes for color specification conversions,\n8: and for mapping numbers to colors in a 1-D array of colors called a colormap.\n9: \n10: Mapping data onto colors using a colormap typically involves two steps: a data\n11: array is first mapped onto the range 0-1 using a subclass of `Normalize`,\n12: then this number is mapped to a color using a subclass of `Colormap`.  Two\n13: subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses\n14: piecewise-linear interpolation to define colormaps, and `ListedColormap`, which\n15: makes a colormap from a list of colors.\n16: \n17: .. seealso::\n18: \n19:   :doc:`/tutorials/colors/colormap-manipulation` for examples of how to\n20:   make colormaps and\n21: \n22:   :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.\n23: \n24:   :doc:`/tutorials/colors/colormapnorms` for more details about data\n25:   normalization\n26: \n27:   More colormaps are available at palettable_.\n28: \n29: The module also provides functions for checking whether an object can be\n30: interpreted as a color (`is_color_like`), for converting such an object\n31: to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the\n32: \"#rrggbb\" format (`to_hex`), and a sequence of colors to an (n, 4)\n33: RGBA array (`to_rgba_array`).  Caching is used for efficiency.\n34: \n35: Colors that Matplotlib recognizes are listed at\n36: :doc:`/tutorials/colors/colors`.\n37: \n38: .. _palettable: https://jiffyclub.github.io/palettable/\n39: .. _xkcd color survey: https://xkcd.com/color/rgb/\n40: \"\"\"\n41: \n42: import base64\n43: from collections.abc import Sized, Sequence, Mapping\n44: import functools\n45: import importlib\n46: import inspect\n47: import io\n48: import itertools\n49: from numbers import Number\n50: import re\n51: from PIL import Image\n52: from PIL.PngImagePlugin import PngInfo\n53: \n54: import matplotlib as mpl\n55: import numpy as np\n56: from matplotlib import _api, _cm, cbook, scale\n57: from ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS\n58: \n59: \n60: class _ColorMapping(dict):\nCode replaced for brevity.\n71: \n72: \n73: \n74: _colors_full_map = {}\n75: # Set by reverse priority order.\n76: _colors_full_map.update(XKCD_COLORS)\n77: _colors_full_map.update({k.replace('grey', 'gray'): v\n78:                          for k, v in XKCD_COLORS.items()\n79:                          if 'grey' in k})\n80: _colors_full_map.update(CSS4_COLORS)\n81: _colors_full_map.update(TABLEAU_COLORS)\n82: _colors_full_map.update({k.replace('gray', 'grey'): v\n83:                          for k, v in TABLEAU_COLORS.items()\n84:                          if 'gray' in k})\n85: _colors_full_map.update(BASE_COLORS)\n86: _colors_full_map = _ColorMapping(_colors_full_map)\n87: \n88: _REPR_PNG_SIZE = (512, 64)\n89: \n90: \n91: def get_named_colors_mapping():\nCode replaced for brevity.\n93: \n94: \n95: \n96: class ColorSequenceRegistry(Mapping):\nCode replaced for brevity.\n197: \n198: \n199: \n200: _color_sequences = ColorSequenceRegistry()\n201: \n202: \n203: def _sanitize_extrema(ex):\nCode replaced for brevity.\n210: \n211: \n212: \n213: def _is_nth_color(c):\nCode replaced for brevity.\n215: \n216: \n217: \n218: def is_color_like(c):\nCode replaced for brevity.\n228: \n229: \n230: \n231: def _has_alpha_channel(c):\nCode replaced for brevity.\n234: \n235: \n236: \n237: def _check_color_like(**kwargs):\nCode replaced for brevity.\n243: \n244: \n245: \n246: def same_color(c1, c2):\nCode replaced for brevity.\n262: \n263: \n264: \n265: def to_rgba(c, alpha=None):\nCode replaced for brevity.\n304: \n305: \n306: \n307: def _to_rgba_no_colorcycle(c, alpha=None):\nCode replaced for brevity.\n396: \n397: \n398: \n399: def to_rgba_array(c, alpha=None):\nCode replaced for brevity.\n491: \n492: \n493: \n494: def to_rgb(c):\nCode replaced for brevity.\n496: \n497: \n498: \n499: def to_hex(c, keep_alpha=False):\nCode replaced for brevity.\n518: \n519: \n520: \n521: ### Backwards-compatible color-conversion API\n522: \n523: \n524: cnames = CSS4_COLORS\n525: hexColorPattern = re.compile(r\"\\A#[a-fA-F0-9]{6}\\Z\")\n526: rgb2hex = to_hex\n527: hex2color = to_rgb\n528: \n529: \n530: class ColorConverter:\nCode replaced for brevity.\n540: \n541: \n542: \n543: colorConverter = ColorConverter()\n544: \n545: \n546: ### End of backwards-compatible color-conversion API\n547: \n548: \n549: def _create_lookup_table(N, data, gamma=1.0):\nCode replaced for brevity.\n644: \n645: \n646: \n647: class Colormap:\n648:     \"\"\"\n649:     Baseclass for all scalar to RGBA mappings.\n650: \n651:     Typically, Colormap instances are used to convert data values (floats)\n652:     from the interval ``[0, 1]`` to the RGBA color that the respective\n653:     Colormap represents. For scaling of data into the ``[0, 1]`` interval see\n654:     `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`\n655:     make heavy use of this ``data -> normalize -> map-to-color`` processing\n656:     chain.\n657:     \"\"\"\n658: \n659:     def __init__(self, name, N=256):\n660:         \"\"\"\n661:         Parameters\n662:         ----------\n663:         name : str\n664:             The name of the colormap.\n665:         N : int\n666:             The number of RGB quantization levels.\n667:         \"\"\"\n668:         self.name = name\n669:         self.N = int(N)  # ensure that N is always int\n670:         self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n671:         self._rgba_under = None\n672:         self._rgba_over = None\n673:         self._i_under = self.N\n674:         self._i_over = self.N + 1\n675:         self._i_bad = self.N + 2\n676:         self._isinit = False\n677:         #: When this colormap exists on a scalar mappable and colorbar_extend\n678:         #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n679:         #: the default value for the ``extend`` keyword in the\n680:         #: `matplotlib.colorbar.Colorbar` constructor.\n681:         self.colorbar_extend = False\n682: \n683:     def __call__(self, X, alpha=None, bytes=False):\n684:         \"\"\"\n685:         Parameters\n686:         ----------\n687:         X : float or int, `~numpy.ndarray` or scalar\n688:             The data value(s) to convert to RGBA.\n689:             For floats, *X* should be in the interval ``[0.0, 1.0]`` to\n690:             return the RGBA values ``X*100`` percent along the Colormap line.\n691:             For integers, *X* should be in the interval ``[0, Colormap.N)`` to\n692:             return RGBA values *indexed* from the Colormap with index ``X``.\n693:         alpha : float or array-like or None\n694:             Alpha must be a scalar between 0 and 1, a sequence of such\n695:             floats with shape matching X, or None.\n696:         bytes : bool\n697:             If False (default), the returned RGBA values will be floats in the\n698:             interval ``[0, 1]`` otherwise they will be uint8s in the interval\n699:             ``[0, 255]``.\n700: \n701:         Returns\n702:         -------\n703:         Tuple of RGBA values if X is scalar, otherwise an array of\n704:         RGBA values with a shape of ``X.shape + (4, )``.\n705:         \"\"\"\n706:         if not self._isinit:\n707:             self._init()\n708: \n709:         # Take the bad mask from a masked array, or in all other cases defer\n710:         # np.isnan() to after we have converted to an array.\n711:         mask_bad = X.mask if np.ma.is_masked(X) else None\n712:         xa = np.array(X, copy=True)\n713:         if mask_bad is None:\n714:             mask_bad = np.isnan(xa)\n715:         if not xa.dtype.isnative:\n716:             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n717:         if xa.dtype.kind == \"f\":\n718:             with np.errstate(invalid=\"ignore\"):\n719:                 xa *= self.N\n720:                 # Negative values are out of range, but astype(int) would\n721:                 # truncate them towards zero.\n722:                 xa[xa < 0] = -1\n723:                 # xa == 1 (== N after multiplication) is not out of range.\n724:                 xa[xa == self.N] = self.N - 1\n725:                 # Avoid converting large positive values to negative integers.\n726:                 np.clip(xa, -1, self.N, out=xa)\n727:                 xa = xa.astype(int)\n728:         # Set the over-range indices before the under-range;\n729:         # otherwise the under-range values get converted to over-range.\n730:         xa[xa > self.N - 1] = self._i_over\n731:         xa[xa < 0] = self._i_under\n732:         xa[mask_bad] = self._i_bad\n733: \n734:         lut = self._lut\n735:         if bytes:\n736:             lut = (lut * 255).astype(np.uint8)\n737: \n738:         rgba = lut.take(xa, axis=0, mode='clip')\n739: \n740:         if alpha is not None:\n741:             alpha = np.clip(alpha, 0, 1)\n742:             if bytes:\n743:                 alpha *= 255  # Will be cast to uint8 upon assignment.\n744:             if alpha.shape not in [(), xa.shape]:\n745:                 raise ValueError(\n746:                     f\"alpha is array-like but its shape {alpha.shape} does \"\n747:                     f\"not match that of X {xa.shape}\")\n748:             rgba[..., -1] = alpha\n749: \n750:             # If the \"bad\" color is all zeros, then ignore alpha input.\n751:             if (lut[-1] == 0).all() and np.any(mask_bad):\n752:                 if np.iterable(mask_bad) and mask_bad.shape == xa.shape:\n753:                     rgba[mask_bad] = (0, 0, 0, 0)\n754:                 else:\n755:                     rgba[..., :] = (0, 0, 0, 0)\n756: \n757:         if not np.iterable(X):\n758:             rgba = tuple(rgba)\n759:         return rgba\n760: \n761:     def __copy__(self):\n762:         cls = self.__class__\n763:         cmapobject = cls.__new__(cls)\n764:         cmapobject.__dict__.update(self.__dict__)\n765:         if self._isinit:\n766:             cmapobject._lut = np.copy(self._lut)\n767:         return cmapobject\n768: \n769:     def __eq__(self, other):\n770:         if (not isinstance(other, Colormap) or self.name != other.name or\n771:                 self.colorbar_extend != other.colorbar_extend):\n772:             return False\n773:         # To compare lookup tables the Colormaps have to be initialized\n774:         if not self._isinit:\n775:             self._init()\n776:         if not other._isinit:\n777:             other._init()\n778:         return np.array_equal(self._lut, other._lut)\n779: \n780:     def get_bad(self):\n781:         \"\"\"Get the color for masked values.\"\"\"\n782:         if not self._isinit:\n783:             self._init()\n784:         return np.array(self._lut[self._i_bad])\n785: \n786:     def set_bad(self, color='k', alpha=None):\n787:         \"\"\"Set the color for masked values.\"\"\"\n788:         self._rgba_bad = to_rgba(color, alpha)\n789:         if self._isinit:\n790:             self._set_extremes()\n791: \n792:     def get_under(self):\n793:         \"\"\"Get the color for low out-of-range values.\"\"\"\n794:         if not self._isinit:\n795:             self._init()\n796:         return np.array(self._lut[self._i_under])\n797: \n798:     def set_under(self, color='k', alpha=None):\n799:         \"\"\"Set the color for low out-of-range values.\"\"\"\n800:         self._rgba_under = to_rgba(color, alpha)\n801:         if self._isinit:\n802:             self._set_extremes()\n803: \n804:     def get_over(self):\n805:         \"\"\"Get the color for high out-of-range values.\"\"\"\n806:         if not self._isinit:\n807:             self._init()\n808:         return np.array(self._lut[self._i_over])\n809: \n810:     def set_over(self, color='k', alpha=None):\n811:         \"\"\"Set the color for high out-of-range values.\"\"\"\n812:         self._rgba_over = to_rgba(color, alpha)\n813:         if self._isinit:\n814:             self._set_extremes()\n815: \n816:     def set_extremes(self, *, bad=None, under=None, over=None):\n817:         \"\"\"\n818:         Set the colors for masked (*bad*) values and, when ``norm.clip =\n819:         False``, low (*under*) and high (*over*) out-of-range values.\n820:         \"\"\"\n821:         if bad is not None:\n822:             self.set_bad(bad)\n823:         if under is not None:\n824:             self.set_under(under)\n825:         if over is not None:\n826:             self.set_over(over)\n827: \n828:     def with_extremes(self, *, bad=None, under=None, over=None):\n829:         \"\"\"\n830:         Return a copy of the colormap, for which the colors for masked (*bad*)\n831:         values and, when ``norm.clip = False``, low (*under*) and high (*over*)\n832:         out-of-range values, have been set accordingly.\n833:         \"\"\"\n834:         new_cm = self.copy()\n835:         new_cm.set_extremes(bad=bad, under=under, over=over)\n836:         return new_cm\n837: \n838:     def _set_extremes(self):\n839:         if self._rgba_under:\n840:             self._lut[self._i_under] = self._rgba_under\n841:         else:\n842:             self._lut[self._i_under] = self._lut[0]\n843:         if self._rgba_over:\n844:             self._lut[self._i_over] = self._rgba_over\n845:         else:\n846:             self._lut[self._i_over] = self._lut[self.N - 1]\n847:         self._lut[self._i_bad] = self._rgba_bad\n848: \n849:     def _init(self):\n850:         \"\"\"Generate the lookup table, ``self._lut``.\"\"\"\n851:         raise NotImplementedError(\"Abstract class only\")\n852: \n853:     def is_gray(self):\n854:         \"\"\"Return whether the colormap is grayscale.\"\"\"\n855:         if not self._isinit:\n856:             self._init()\n857:         return (np.all(self._lut[:, 0] == self._lut[:, 1]) and\n858:                 np.all(self._lut[:, 0] == self._lut[:, 2]))\n859: \n860:     def resampled(self, lutsize):\n861:         \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n862:         if hasattr(self, '_resample'):\n863:             _api.warn_external(\n864:                 \"The ability to resample a color map is now public API \"\n865:                 f\"However the class {type(self)} still only implements \"\n866:                 \"the previous private _resample method.  Please update \"\n867:                 \"your class.\"\n868:             )\n869:             return self._resample(lutsize)\n870: \n871:         raise NotImplementedError()\n872: \n873:     def reversed(self, name=None):\n874:         \"\"\"\n875:         Return a reversed instance of the Colormap.\n876: \n877:         .. note:: This function is not implemented for the base class.\n878: \n879:         Parameters\n880:         ----------\n881:         name : str, optional\n882:             The name for the reversed colormap. If None, the\n883:             name is set to ``self.name + \"_r\"``.\n884: \n885:         See Also\n886:         --------\n887:         LinearSegmentedColormap.reversed\n888:         ListedColormap.reversed\n889:         \"\"\"\n890:         raise NotImplementedError()\n891: \n892:     def _repr_png_(self):\n893:         \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n894:         X = np.tile(np.linspace(0, 1, _REPR_PNG_SIZE[0]),\n895:                     (_REPR_PNG_SIZE[1], 1))\n896:         pixels = self(X, bytes=True)\n897:         png_bytes = io.BytesIO()\n898:         title = self.name + ' colormap'\n899:         author = f'Matplotlib v{mpl.__version__}, https://matplotlib.org'\n900:         pnginfo = PngInfo()\n901:         pnginfo.add_text('Title', title)\n902:         pnginfo.add_text('Description', title)\n903:         pnginfo.add_text('Author', author)\n904:         pnginfo.add_text('Software', author)\n905:         Image.fromarray(pixels).save(png_bytes, format='png', pnginfo=pnginfo)\n906:         return png_bytes.getvalue()\n907: \n908:     def _repr_html_(self):\n909:         \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n910:         png_bytes = self._repr_png_()\n911:         png_base64 = base64.b64encode(png_bytes).decode('ascii')\n912:         def color_block(color):\n913:             hex_color = to_hex(color, keep_alpha=True)\n914:             return (f'<div title=\"{hex_color}\" '\n915:                     'style=\"display: inline-block; '\n916:                     'width: 1em; height: 1em; '\n917:                     'margin: 0; '\n918:                     'vertical-align: middle; '\n919:                     'border: 1px solid #555; '\n920:                     f'background-color: {hex_color};\"></div>')\n921: \n922:         return ('<div style=\"vertical-align: middle;\">'\n923:                 f'<strong>{self.name}</strong> '\n924:                 '</div>'\n925:                 '<div class=\"cmap\"><img '\n926:                 f'alt=\"{self.name} colormap\" '\n927:                 f'title=\"{self.name}\" '\n928:                 'style=\"border: 1px solid #555;\" '\n929:                 f'src=\"data:image/png;base64,{png_base64}\"></div>'\n930:                 '<div style=\"vertical-align: middle; '\n931:                 f'max-width: {_REPR_PNG_SIZE[0]+2}px; '\n932:                 'display: flex; justify-content: space-between;\">'\n933:                 '<div style=\"float: left;\">'\n934:                 f'{color_block(self.get_under())} under'\n935:                 '</div>'\n936:                 '<div style=\"margin: 0 auto; display: inline-block;\">'\n937:                 f'bad {color_block(self.get_bad())}'\n938:                 '</div>'\n939:                 '<div style=\"float: right;\">'\n940:                 f'over {color_block(self.get_over())}'\n941:                 '</div>')\n942: \n943:     def copy(self):\n944:         \"\"\"Return a copy of the colormap.\"\"\"\n945:         return self.__copy__()\n946: \n947: \n948: class LinearSegmentedColormap(Colormap):\nCode replaced for brevity.\n1108: \n1109: \n1110: \n1111: class ListedColormap(Colormap):\nCode replaced for brevity.\n1203: \n1204: \n1205: \n1206: class Normalize:\nCode replaced for brevity.\n1387: \n1388: \n1389: \n1390: class TwoSlopeNorm(Normalize):\nCode replaced for brevity.\n1478: \n1479: \n1480: \n1481: class CenteredNorm(Normalize):\nCode replaced for brevity.\n1583: \n1584: \n1585: \n1586: def make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\nCode replaced for brevity.\n1632: \n1633: \n1634: \n1635: @functools.lru_cache(None)\n1636: ):\nCode replaced for brevity.\n1741: \n1742: \n1743: \n1744: def _create_empty_object_of_class(cls):\n1745:     return cls.__new__(cls)\n1746: \n1747: \n1748: def _picklable_norm_constructor(*args):\nCode replaced for brevity.\n1749: \n1750: \n1751: \n1752: @make_norm_from_scale(\n1753:     scale.FuncScale,\n1754:     init=lambda functions, vmin=None, vmax=None, clip=False: None)\n1755: class FuncNorm(Normalize):\nCode replaced for brevity.\n1782: \n1783: \n1784: \n1785: LogNorm = make_norm_from_scale(\n1786:     functools.partial(scale.LogScale, nonpositive=\"mask\"))(Normalize)\n1787: LogNorm.__name__ = LogNorm.__qualname__ = \"LogNorm\"\n1788: LogNorm.__doc__ = \"Normalize a given value to the 0-1 range on a log scale.\"\n1789: \n1790: \n1791: @make_norm_from_scale(\n1792:     scale.SymmetricalLogScale,\n1793:     init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,\n1794:                 base=10: None)\n1795: class SymLogNorm(Normalize):\nCode replaced for brevity.\n1826: \n1827: \n1828: \n1829: @make_norm_from_scale(\n1830:     scale.AsinhScale,\n1831:     init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None)\n1832: class AsinhNorm(Normalize):\nCode replaced for brevity.\n1858: \n1859: \n1860: \n1861: class PowerNorm(Normalize):\nCode replaced for brevity.\n1909: \n1910: \n1911: \n1912: class BoundaryNorm(Normalize):\nCode replaced for brevity.\n2037: \n2038: \n2039: \n2040: class NoNorm(Normalize):\nCode replaced for brevity.\n2049: \n2050: \n2051: \n2052: def rgb_to_hsv(arr):\nCode replaced for brevity.\n2101: \n2102: \n2103: \n2104: def hsv_to_rgb(hsv):\nCode replaced for brevity.\n2183: \n2184: \n2185: \n2186:     #  * np.sum: drops mask from ma.array unless entire vector is masked\nCode replaced for brevity.\n2193: \n2194: \n2195: \n2196: class LightSource:\nCode replaced for brevity.\n2607: \n2608: \n2609: \n2610: def from_levels_and_colors(levels, colors, extend='neither'):\nCode replaced for brevity.\n2664: \n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/colors.py",
      "suspect_lines": [
        718,
        719,
        720,
        721,
        722,
        723,
        724,
        725,
        726,
        727
      ]
    }
  ]
}