{
  "instance_id": "django__django-11141",
  "problem_statement": "Allow migrations directories without __init__.py files\nDescription\n\t \n\t\t(last modified by Tim Graham)\n\t \nBackground: In python 3 a package with no __init__.py is implicitly a namespace package, so it has no __file__ attribute. \nThe migrate command currently checks for existence of a __file__ attribute on the migrations package. This check was introduced in #21015, because the __file__ attribute was used in migration file discovery. \nHowever, in #23406 migration file discovery was changed to use pkgutil.iter_modules (), instead of direct filesystem access. pkgutil. iter_modules() uses the package's __path__ list, which exists on implicit namespace packages.\nAs a result, the __file__ check is no longer needed, and in fact prevents migrate from working on namespace packages (implicit or otherwise). \nRelated work: #29091\n",
  "localized_code": "[start of django/db/migrations/loader.py]\n1: import pkgutil\n2: import sys\n3: from importlib import import_module, reload\n4: \n5: from django.apps import apps\n6: from django.conf import settings\n7: from django.db.migrations.graph import MigrationGraph\n8: from django.db.migrations.recorder import MigrationRecorder\n9: \n10: from .exceptions import (\n11:     AmbiguityError, BadMigrationError, InconsistentMigrationHistory,\n12:     NodeNotFoundError,\n13: )\n14: \n15: MIGRATIONS_MODULE_NAME = 'migrations'\n16: \n17: \n18: class MigrationLoader:\n19:     \"\"\"\n20:     Load migration files from disk and their status from the database.\n21: \n22:     Migration files are expected to live in the \"migrations\" directory of\n23:     an app. Their names are entirely unimportant from a code perspective,\n24:     but will probably follow the 1234_name.py convention.\n25: \n26:     On initialization, this class will scan those directories, and open and\n27:     read the Python files, looking for a class called Migration, which should\n28:     inherit from django.db.migrations.Migration. See\n29:     django.db.migrations.migration for what that looks like.\n30: \n31:     Some migrations will be marked as \"replacing\" another set of migrations.\n32:     These are loaded into a separate set of migrations away from the main ones.\n33:     If all the migrations they replace are either unapplied or missing from\n34:     disk, then they are injected into the main set, replacing the named migrations.\n35:     Any dependency pointers to the replaced migrations are re-pointed to the\n36:     new migration.\n37: \n38:     This does mean that this class MUST also talk to the database as well as\n39:     to disk, but this is probably fine. We're already not just operating\n40:     in memory.\n41:     \"\"\"\n42: \n43:     def __init__(self, connection, load=True, ignore_no_migrations=False):\n44:         self.connection = connection\n45:         self.disk_migrations = None\n46:         self.applied_migrations = None\n47:         self.ignore_no_migrations = ignore_no_migrations\n48:         if load:\n49:             self.build_graph()\n50: \n51:     @classmethod\n52:     def migrations_module(cls, app_label):\n53:         \"\"\"\n54:         Return the path to the migrations module for the specified app_label\n55:         and a boolean indicating if the module is specified in\n56:         settings.MIGRATION_MODULE.\n57:         \"\"\"\n58:         if app_label in settings.MIGRATION_MODULES:\n59:             return settings.MIGRATION_MODULES[app_label], True\n60:         else:\n61:             app_package_name = apps.get_app_config(app_label).name\n62:             return '%s.%s' % (app_package_name, MIGRATIONS_MODULE_NAME), False\n63: \n64:     def load_disk(self):\n65:         \"\"\"Load the migrations from all INSTALLED_APPS from disk.\"\"\"\n66:         self.disk_migrations = {}\n67:         self.unmigrated_apps = set()\n68:         self.migrated_apps = set()\n69:         for app_config in apps.get_app_configs():\n70:             # Get the migrations module directory\n71:             module_name, explicit = self.migrations_module(app_config.label)\n72:             if module_name is None:\n73:                 self.unmigrated_apps.add(app_config.label)\n74:                 continue\n75:             was_loaded = module_name in sys.modules\n76:             try:\n77:                 module = import_module(module_name)\n78:             except ImportError as e:\n79:                 # I hate doing this, but I don't want to squash other import errors.\n80:                 # Might be better to try a directory check directly.\n81:                 if ((explicit and self.ignore_no_migrations) or (\n82:                         not explicit and \"No module named\" in str(e) and MIGRATIONS_MODULE_NAME in str(e))):\n83:                     self.unmigrated_apps.add(app_config.label)\n84:                     continue\n85:                 raise\n86:             else:\n87:                 # Empty directories are namespaces.\n88:                 # getattr() needed on PY36 and older (replace w/attribute access).\n89:                 if getattr(module, '__file__', None) is None:\n90:                     self.unmigrated_apps.add(app_config.label)\n91:                     continue\n92:                 # Module is not a package (e.g. migrations.py).\n93:                 if not hasattr(module, '__path__'):\n94:                     self.unmigrated_apps.add(app_config.label)\n95:                     continue\n96:                 # Force a reload if it's already loaded (tests need this)\n97:                 if was_loaded:\n98:                     reload(module)\n99:             self.migrated_apps.add(app_config.label)\n100:             migration_names = {\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/loader.py",
      "suspect_lines": [
        87,
        88,
        89,
        90,
        91,
        99
      ]
    }
  ]
}