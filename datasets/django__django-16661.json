{
  "instance_id": "django__django-16661",
  "problem_statement": "ModelAdmin.lookup_allowed() incorrectly raises DisallowedModelAdminLookup lookup with foreign key as primary key\nDescription\n\t \n\t\t(last modified by Tim Graham)\n\t \nWrote a failing test for tests/modeladmin/tests.py to demonstrate - same test/code passes on 1.8\n@isolate_apps('modeladmin')\ndef test_lookup_allowed_foreign_primary(self):\n\tclass Country(models.Model):\n\t\tname = models.CharField(max_length=256)\n\tclass Place(models.Model):\n\t\tcountry = models.ForeignKey(Country, models.CASCADE)\n\tclass Restaurant(models.Model):\n\t\tplace = models.OneToOneField(Place, models.CASCADE, primary_key=True)\n\tclass Waiter(models.Model):\n\t\trestaurant = models.ForeignKey(Restaurant, models.CASCADE)\n\tclass WaiterAdmin(ModelAdmin):\n\t\tlist_filter = [\n\t\t\t'restaurant__place__country',\n\t\t]\n\tma = WaiterAdmin(Waiter, self.site)\n\tself.assertIs(ma.lookup_allowed('restaurant__place__country', 'test_value'), True)\nI think this is caused by the admin thinking that having a foreign key field as a primary key is the same as concrete inheritance. So when you try and check lookups for restaurant__place__country it thinks 'place' is the concrete parent of 'restaurant' and shortcuts it to restaurant__country which isn't in 'list_filter'. And you can't add restaurant__country to list_filter because country isn't actually on restaurant.\n",
  "localized_code": "[start of django/contrib/admin/options.py]\n1: import copy\n2: import enum\n3: import json\n4: import re\n5: from functools import partial, update_wrapper\n6: from urllib.parse import quote as urlquote\n7: \n8: from django import forms\n9: from django.conf import settings\n10: from django.contrib import messages\n11: from django.contrib.admin import helpers, widgets\n12: from django.contrib.admin.checks import (\n13:     BaseModelAdminChecks,\n14:     InlineModelAdminChecks,\n15:     ModelAdminChecks,\n16: )\n17: from django.contrib.admin.exceptions import DisallowedModelAdminToField\n18: from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n19: from django.contrib.admin.utils import (\n20:     NestedObjects,\n21:     construct_change_message,\n22:     flatten_fieldsets,\n23:     get_deleted_objects,\n24:     lookup_spawns_duplicates,\n25:     model_format_dict,\n26:     model_ngettext,\n27:     quote,\n28:     unquote,\n29: )\n30: from django.contrib.admin.widgets import AutocompleteSelect, AutocompleteSelectMultiple\n31: from django.contrib.auth import get_permission_codename\n32: from django.core.exceptions import (\n33:     FieldDoesNotExist,\n34:     FieldError,\n35:     PermissionDenied,\n36:     ValidationError,\n37: )\n38: from django.core.paginator import Paginator\n39: from django.db import models, router, transaction\n40: from django.db.models.constants import LOOKUP_SEP\n41: from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n42: from django.forms.models import (\n43:     BaseInlineFormSet,\n44:     inlineformset_factory,\n45:     modelform_defines_fields,\n46:     modelform_factory,\n47:     modelformset_factory,\n48: )\n49: from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n50: from django.http import HttpResponseRedirect\n51: from django.http.response import HttpResponseBase\n52: from django.template.response import SimpleTemplateResponse, TemplateResponse\n53: from django.urls import reverse\n54: from django.utils.decorators import method_decorator\n55: from django.utils.html import format_html\n56: from django.utils.http import urlencode\n57: from django.utils.safestring import mark_safe\n58: from django.utils.text import (\n59:     capfirst,\n60:     format_lazy,\n61:     get_text_list,\n62:     smart_split,\n63:     unescape_string_literal,\n64: )\n65: from django.utils.translation import gettext as _\n66: from django.utils.translation import ngettext\n67: from django.views.decorators.csrf import csrf_protect\n68: from django.views.generic import RedirectView\n69: \n70: IS_POPUP_VAR = \"_popup\"\n71: TO_FIELD_VAR = \"_to_field\"\n72: IS_FACETS_VAR = \"_facets\"\n73: \n74: \n75: class ShowFacets(enum.Enum):\nCode replaced for brevity.\n78: \n79: \n80: \n81: HORIZONTAL, VERTICAL = 1, 2\n82: \n83: \n84:     # it cannot import models from other applications at the module level.\nCode replaced for brevity.\n89: \n90: \n91: \n92: def get_ul_class(radio_style):\nCode replaced for brevity.\n93: \n94: \n95: \n96: class IncorrectLookupParameters(Exception):\n97:     pass\n98: \n99: \n100: # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n101: # by adding to ModelAdmin.formfield_overrides.\n102: \n103: FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n104:     models.DateTimeField: {\n105:         \"form_class\": forms.SplitDateTimeField,\n106:         \"widget\": widgets.AdminSplitDateTime,\n107:     },\n108:     models.DateField: {\"widget\": widgets.AdminDateWidget},\n109:     models.TimeField: {\"widget\": widgets.AdminTimeWidget},\n110:     models.TextField: {\"widget\": widgets.AdminTextareaWidget},\n111:     models.URLField: {\"widget\": widgets.AdminURLFieldWidget},\n112:     models.IntegerField: {\"widget\": widgets.AdminIntegerFieldWidget},\n113:     models.BigIntegerField: {\"widget\": widgets.AdminBigIntegerFieldWidget},\n114:     models.CharField: {\"widget\": widgets.AdminTextInputWidget},\n115:     models.ImageField: {\"widget\": widgets.AdminFileWidget},\n116:     models.FileField: {\"widget\": widgets.AdminFileWidget},\n117:     models.EmailField: {\"widget\": widgets.AdminEmailInputWidget},\n118:     models.UUIDField: {\"widget\": widgets.AdminUUIDInputWidget},\n119: }\n120: \n121: csrf_protect_m = method_decorator(csrf_protect)\n122: \n123: \n124: class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n125:     \"\"\"Functionality common to both ModelAdmin and InlineAdmin.\"\"\"\n126: \n127:     autocomplete_fields = ()\n128:     raw_id_fields = ()\n129:     fields = None\n130:     exclude = None\n131:     fieldsets = None\n132:     form = forms.ModelForm\n133:     filter_vertical = ()\n134:     filter_horizontal = ()\n135:     radio_fields = {}\n136:     prepopulated_fields = {}\n137:     formfield_overrides = {}\n138:     readonly_fields = ()\n139:     ordering = None\n140:     sortable_by = None\n141:     view_on_site = True\n142:     show_full_result_count = True\n143:     checks_class = BaseModelAdminChecks\n144: \n145:     def check(self, **kwargs):\n146:         return self.checks_class().check(self, **kwargs)\n147: \n148:     def __init__(self):\n149:         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides\n150:         # rather than simply overwriting.\n151:         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)\n152:         for k, v in self.formfield_overrides.items():\n153:             overrides.setdefault(k, {}).update(v)\n154:         self.formfield_overrides = overrides\n155: \n156:     def formfield_for_dbfield(self, db_field, request, **kwargs):\n157:         \"\"\"\n158:         Hook for specifying the form Field instance for a given database Field\n159:         instance.\n160: \n161:         If kwargs are given, they're passed to the form Field's constructor.\n162:         \"\"\"\n163:         # If the field specifies choices, we don't need to look for special\n164:         # admin widgets - we just need to use a select widget of some kind.\n165:         if db_field.choices:\n166:             return self.formfield_for_choice_field(db_field, request, **kwargs)\n167: \n168:         # ForeignKey or ManyToManyFields\n169:         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):\n170:             # Combine the field kwargs with any options for formfield_overrides.\n171:             # Make sure the passed in **kwargs override anything in\n172:             # formfield_overrides because **kwargs is more specific, and should\n173:             # always win.\n174:             if db_field.__class__ in self.formfield_overrides:\n175:                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}\n176: \n177:             # Get the correct formfield.\n178:             if isinstance(db_field, models.ForeignKey):\n179:                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)\n180:             elif isinstance(db_field, models.ManyToManyField):\n181:                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)\n182: \n183:             # For non-raw_id fields, wrap the widget with a wrapper that adds\n184:             # extra HTML -- the \"add other\" interface -- to the end of the\n185:             # rendered output. formfield can be None if it came from a\n186:             # OneToOneField with parent_link=True or a M2M intermediary.\n187:             if formfield and db_field.name not in self.raw_id_fields:\n188:                 related_modeladmin = self.admin_site._registry.get(\n189:                     db_field.remote_field.model\n190:                 )\n191:                 wrapper_kwargs = {}\n192:                 if related_modeladmin:\n193:                     wrapper_kwargs.update(\n194:                         can_add_related=related_modeladmin.has_add_permission(request),\n195:                         can_change_related=related_modeladmin.has_change_permission(\n196:                             request\n197:                         ),\n198:                         can_delete_related=related_modeladmin.has_delete_permission(\n199:                             request\n200:                         ),\n201:                         can_view_related=related_modeladmin.has_view_permission(\n202:                             request\n203:                         ),\n204:                     )\n205:                 formfield.widget = widgets.RelatedFieldWidgetWrapper(\n206:                     formfield.widget,\n207:                     db_field.remote_field,\n208:                     self.admin_site,\n209:                     **wrapper_kwargs,\n210:                 )\n211: \n212:             return formfield\n213: \n214:         # If we've got overrides for the formfield defined, use 'em. **kwargs\n215:         # passed to formfield_for_dbfield override the defaults.\n216:         for klass in db_field.__class__.mro():\n217:             if klass in self.formfield_overrides:\n218:                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}\n219:                 return db_field.formfield(**kwargs)\n220: \n221:         # For any other type of field, just call its formfield() method.\n222:         return db_field.formfield(**kwargs)\n223: \n224:     def formfield_for_choice_field(self, db_field, request, **kwargs):\n225:         \"\"\"\n226:         Get a form Field for a database Field that has declared choices.\n227:         \"\"\"\n228:         # If the field is named as a radio_field, use a RadioSelect\n229:         if db_field.name in self.radio_fields:\n230:             # Avoid stomping on custom widget/choices arguments.\n231:             if \"widget\" not in kwargs:\n232:                 kwargs[\"widget\"] = widgets.AdminRadioSelect(\n233:                     attrs={\n234:                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n235:                     }\n236:                 )\n237:             if \"choices\" not in kwargs:\n238:                 kwargs[\"choices\"] = db_field.get_choices(\n239:                     include_blank=db_field.blank, blank_choice=[(\"\", _(\"None\"))]\n240:                 )\n241:         return db_field.formfield(**kwargs)\n242: \n243:     def get_field_queryset(self, db, db_field, request):\n244:         \"\"\"\n245:         If the ModelAdmin specifies ordering, the queryset should respect that\n246:         ordering.  Otherwise don't specify the queryset, let the field decide\n247:         (return None in that case).\n248:         \"\"\"\n249:         related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n250:         if related_admin is not None:\n251:             ordering = related_admin.get_ordering(request)\n252:             if ordering is not None and ordering != ():\n253:                 return db_field.remote_field.model._default_manager.using(db).order_by(\n254:                     *ordering\n255:                 )\n256:         return None\n257: \n258:     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n259:         \"\"\"\n260:         Get a form Field for a ForeignKey.\n261:         \"\"\"\n262:         db = kwargs.get(\"using\")\n263: \n264:         if \"widget\" not in kwargs:\n265:             if db_field.name in self.get_autocomplete_fields(request):\n266:                 kwargs[\"widget\"] = AutocompleteSelect(\n267:                     db_field, self.admin_site, using=db\n268:                 )\n269:             elif db_field.name in self.raw_id_fields:\n270:                 kwargs[\"widget\"] = widgets.ForeignKeyRawIdWidget(\n271:                     db_field.remote_field, self.admin_site, using=db\n272:                 )\n273:             elif db_field.name in self.radio_fields:\n274:                 kwargs[\"widget\"] = widgets.AdminRadioSelect(\n275:                     attrs={\n276:                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n277:                     }\n278:                 )\n279:                 kwargs[\"empty_label\"] = (\n280:                     kwargs.get(\"empty_label\", _(\"None\")) if db_field.blank else None\n281:                 )\n282: \n283:         if \"queryset\" not in kwargs:\n284:             queryset = self.get_field_queryset(db, db_field, request)\n285:             if queryset is not None:\n286:                 kwargs[\"queryset\"] = queryset\n287: \n288:         return db_field.formfield(**kwargs)\n289: \n290:     def formfield_for_manytomany(self, db_field, request, **kwargs):\n291:         \"\"\"\n292:         Get a form Field for a ManyToManyField.\n293:         \"\"\"\n294:         # If it uses an intermediary model that isn't auto created, don't show\n295:         # a field in admin.\n296:         if not db_field.remote_field.through._meta.auto_created:\n297:             return None\n298:         db = kwargs.get(\"using\")\n299: \n300:         if \"widget\" not in kwargs:\n301:             autocomplete_fields = self.get_autocomplete_fields(request)\n302:             if db_field.name in autocomplete_fields:\n303:                 kwargs[\"widget\"] = AutocompleteSelectMultiple(\n304:                     db_field,\n305:                     self.admin_site,\n306:                     using=db,\n307:                 )\n308:             elif db_field.name in self.raw_id_fields:\n309:                 kwargs[\"widget\"] = widgets.ManyToManyRawIdWidget(\n310:                     db_field.remote_field,\n311:                     self.admin_site,\n312:                     using=db,\n313:                 )\n314:             elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n315:                 kwargs[\"widget\"] = widgets.FilteredSelectMultiple(\n316:                     db_field.verbose_name, db_field.name in self.filter_vertical\n317:                 )\n318:         if \"queryset\" not in kwargs:\n319:             queryset = self.get_field_queryset(db, db_field, request)\n320:             if queryset is not None:\n321:                 kwargs[\"queryset\"] = queryset\n322: \n323:         form_field = db_field.formfield(**kwargs)\n324:         if (\n325:             isinstance(form_field.widget, SelectMultiple)\n326:             and form_field.widget.allow_multiple_selected\n327:             and not isinstance(\n328:                 form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple)\n329:             )\n330:         ):\n331:             msg = _(\n332:                 \"Hold down “Control”, or “Command” on a Mac, to select more than one.\"\n333:             )\n334:             help_text = form_field.help_text\n335:             form_field.help_text = (\n336:                 format_lazy(\"{} {}\", help_text, msg) if help_text else msg\n337:             )\n338:         return form_field\n339: \n340:     def get_autocomplete_fields(self, request):\n341:         \"\"\"\n342:         Return a list of ForeignKey and/or ManyToMany fields which should use\n343:         an autocomplete widget.\n344:         \"\"\"\n345:         return self.autocomplete_fields\n346: \n347:     def get_view_on_site_url(self, obj=None):\n348:         if obj is None or not self.view_on_site:\n349:             return None\n350: \n351:         if callable(self.view_on_site):\n352:             return self.view_on_site(obj)\n353:         elif hasattr(obj, \"get_absolute_url\"):\n354:             # use the ContentType lookup if view_on_site is True\n355:             return reverse(\n356:                 \"admin:view_on_site\",\n357:                 kwargs={\n358:                     \"content_type_id\": get_content_type_for_model(obj).pk,\n359:                     \"object_id\": obj.pk,\n360:                 },\n361:                 current_app=self.admin_site.name,\n362:             )\n363: \n364:     def get_empty_value_display(self):\n365:         \"\"\"\n366:         Return the empty_value_display set on ModelAdmin or AdminSite.\n367:         \"\"\"\n368:         try:\n369:             return mark_safe(self.empty_value_display)\n370:         except AttributeError:\n371:             return mark_safe(self.admin_site.empty_value_display)\n372: \n373:     def get_exclude(self, request, obj=None):\n374:         \"\"\"\n375:         Hook for specifying exclude.\n376:         \"\"\"\n377:         return self.exclude\n378: \n379:     def get_fields(self, request, obj=None):\n380:         \"\"\"\n381:         Hook for specifying fields.\n382:         \"\"\"\n383:         if self.fields:\n384:             return self.fields\n385:         # _get_form_for_get_fields() is implemented in subclasses.\n386:         form = self._get_form_for_get_fields(request, obj)\n387:         return [*form.base_fields, *self.get_readonly_fields(request, obj)]\n388: \n389:     def get_fieldsets(self, request, obj=None):\n390:         \"\"\"\n391:         Hook for specifying fieldsets.\n392:         \"\"\"\n393:         if self.fieldsets:\n394:             return self.fieldsets\n395:         return [(None, {\"fields\": self.get_fields(request, obj)})]\n396: \n397:     def get_inlines(self, request, obj):\n398:         \"\"\"Hook for specifying custom inlines.\"\"\"\n399:         return self.inlines\n400: \n401:     def get_ordering(self, request):\n402:         \"\"\"\n403:         Hook for specifying field ordering.\n404:         \"\"\"\n405:         return self.ordering or ()  # otherwise we might try to *None, which is bad ;)\n406: \n407:     def get_readonly_fields(self, request, obj=None):\n408:         \"\"\"\n409:         Hook for specifying custom readonly fields.\n410:         \"\"\"\n411:         return self.readonly_fields\n412: \n413:     def get_prepopulated_fields(self, request, obj=None):\n414:         \"\"\"\n415:         Hook for specifying custom prepopulated fields.\n416:         \"\"\"\n417:         return self.prepopulated_fields\n418: \n419:     def get_queryset(self, request):\n420:         \"\"\"\n421:         Return a QuerySet of all model instances that can be edited by the\n422:         admin site. This is used by changelist_view.\n423:         \"\"\"\n424:         qs = self.model._default_manager.get_queryset()\n425:         # TODO: this should be handled by some parameter to the ChangeList.\n426:         ordering = self.get_ordering(request)\n427:         if ordering:\n428:             qs = qs.order_by(*ordering)\n429:         return qs\n430: \n431:     def get_sortable_by(self, request):\n432:         \"\"\"Hook for specifying which fields can be sorted in the changelist.\"\"\"\n433:         return (\n434:             self.sortable_by\n435:             if self.sortable_by is not None\n436:             else self.get_list_display(request)\n437:         )\n438: \n439:     def lookup_allowed(self, lookup, value):\n440:         from django.contrib.admin.filters import SimpleListFilter\n441: \n442:         model = self.model\n443:         # Check FKey lookups that are allowed, so that popups produced by\n444:         # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,\n445:         # are allowed to work.\n446:         for fk_lookup in model._meta.related_fkey_lookups:\n447:             # As ``limit_choices_to`` can be a callable, invoke it here.\n448:             if callable(fk_lookup):\n449:                 fk_lookup = fk_lookup()\n450:             if (lookup, value) in widgets.url_params_from_lookup_dict(\n451:                 fk_lookup\n452:             ).items():\n453:                 return True\n454: \n455:         relation_parts = []\n456:         prev_field = None\n457:         for part in lookup.split(LOOKUP_SEP):\n458:             try:\n459:                 field = model._meta.get_field(part)\n460:             except FieldDoesNotExist:\n461:                 # Lookups on nonexistent fields are ok, since they're ignored\n462:                 # later.\n463:                 break\n464:             # It is allowed to filter on values that would be found from local\n465:             # model anyways. For example, if you filter on employee__department__id,\n466:             # then the id value would be found already from employee__department_id.\n467:             if not prev_field or (\n468:                 prev_field.is_relation\n469:                 and field not in prev_field.path_infos[-1].target_fields\n470:             ):\n471:                 relation_parts.append(part)\n472:             if not getattr(field, \"path_infos\", None):\n473:                 # This is not a relational field, so further parts\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/options.py",
      "suspect_lines": [
        464,
        465,
        466,
        469
      ]
    }
  ]
}