{
  "instance_id": "django__django-13810",
  "problem_statement": "MiddlewareNotUsed leaves undesired side effects when loading middleware in ASGI context\nDescription\n\t\nI experienced strange issues when working with ​ASGI , ​django-debug-toolbar and my own small middleware. It was hard problem to debug, I uploaded an example project here: ​https://github.com/hbielenia/asgi-djangotoolbar-bug (the name is misleading - I initially thought it's a bug with django-debug-toolbar).\nThe SESSION_FILE_PATH setting is intentionally broken to cause a 500 error. When starting the application and accessing /admin (any location really, but I wanted to leave it at a minimum and didn't add any views) it gives TypeError: object HttpResponse can't be used in 'await' expression. Commenting out asgi_djangotoolbar_bug.middleware.DummyMiddleware fixes the issue (in that I receive a 500 ImproperlyConfigured exception). I'm not sure about the overall role of django-debug-toolbar here - removing it causes Daphne to return a 500 error page but without debug information and there's no traceback in console either. I decided to leave it since it helped me approximate the causes of issue.\nI notice that in ​https://github.com/django/django/blob/3.1.4/django/core/handlers/base.py#L58 while MiddlewareNotUsed causes the loop to skip futher processing and go to next middleware, it does leave handler variable overwritten with output of self.adapt_method_mode(). On next pass, this handler is passed to next middleware instance, disregarding all the previous checks for (lack of) async support. This likely causes the middleware chain to be \"poisoned\" from this point onwards, resulting in last middleware in response cycle to return an HttpResponse as a synchronous middleware would, instead of coroutine that is expected.\nThis is probably avoided by adding async support to my middleware, but unless I'm missing something ​docs indicate it should work as it is. It is my intention that it's applied only on synchronous requests, so I didn't make it async compatible on purpose. If it's intentional in Django that every middleware needs to support async if the application is run as ASGI app, the documentation should probably state that clearly. Though it kinda defeats the purpose of having async_capable = False flag in the first place.\n",
  "localized_code": "[start of django/core/handlers/base.py]\n1: import asyncio\n2: import logging\n3: import types\n4: \n5: from asgiref.sync import async_to_sync, sync_to_async\n6: \n7: from django.conf import settings\n8: from django.core.exceptions import ImproperlyConfigured, MiddlewareNotUsed\n9: from django.core.signals import request_finished\n10: from django.db import connections, transaction\n11: from django.urls import get_resolver, set_urlconf\n12: from django.utils.log import log_response\n13: from django.utils.module_loading import import_string\n14: \n15: from .exception import convert_exception_to_response\n16: \n17: logger = logging.getLogger('django.request')\n18: \n19: \n20: class BaseHandler:\n21:     _view_middleware = None\n22:     _template_response_middleware = None\n23:     _exception_middleware = None\n24:     _middleware_chain = None\n25: \n26:     def load_middleware(self, is_async=False):\n27:         \"\"\"\n28:         Populate middleware lists from settings.MIDDLEWARE.\n29: \n30:         Must be called after the environment is fixed (see __call__ in subclasses).\n31:         \"\"\"\n32:         self._view_middleware = []\n33:         self._template_response_middleware = []\n34:         self._exception_middleware = []\n35: \n36:         get_response = self._get_response_async if is_async else self._get_response\n37:         handler = convert_exception_to_response(get_response)\n38:         handler_is_async = is_async\n39:         for middleware_path in reversed(settings.MIDDLEWARE):\n40:             middleware = import_string(middleware_path)\n41:             middleware_can_sync = getattr(middleware, 'sync_capable', True)\n42:             middleware_can_async = getattr(middleware, 'async_capable', False)\n43:             if not middleware_can_sync and not middleware_can_async:\n44:                 raise RuntimeError(\n45:                     'Middleware %s must have at least one of '\n46:                     'sync_capable/async_capable set to True.' % middleware_path\n47:                 )\n48:             elif not handler_is_async and middleware_can_sync:\n49:                 middleware_is_async = False\n50:             else:\n51:                 middleware_is_async = middleware_can_async\n52:             try:\n53:                 # Adapt handler, if needed.\n54:                 handler = self.adapt_method_mode(\n55:                     middleware_is_async, handler, handler_is_async,\n56:                     debug=settings.DEBUG, name='middleware %s' % middleware_path,\n57:                 )\n58:                 mw_instance = middleware(handler)\n59:             except MiddlewareNotUsed as exc:\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/handlers/base.py",
      "suspect_lines": [
        54,
        58
      ]
    }
  ]
}