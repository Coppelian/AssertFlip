{
  "instance_id": "sympy__sympy-17318",
  "problem_statement": "sqrtdenest raises IndexError\n```\r\n>>> sqrtdenest((3 - sqrt(2)*sqrt(4 + 3*I) + 3*I)/2)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 132, in sqrtdenest\r\n    z = _sqrtdenest0(expr)\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 242, in _sqrtdenest0\r\n    return expr.func(*[_sqrtdenest0(a) for a in args])\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 242, in _sqrtdenest0\r\n    return expr.func(*[_sqrtdenest0(a) for a in args])\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 235, in _sqrtdenest0\r\n    return _sqrtdenest1(expr)\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 319, in _sqrtdenest1\r\n    val = _sqrt_match(a)\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 159, in _sqrt_match\r\n    r, b, a = split_surds(p)\r\n  File \"sympy\\simplify\\radsimp.py\", line 1032, in split_surds\r\n    g, b1, b2 = _split_gcd(*surds)\r\n  File \"sympy\\simplify\\radsimp.py\", line 1068, in _split_gcd\r\n    g = a[0]\r\nIndexError: tuple index out of range\r\n```\r\n\r\nIf an expression cannot be denested it should be returned unchanged.\nIndexError fixed for sqrtdenest.\nFixes #12420 \r\nNow if the expression can't be **denested**, it will be returned unchanged.\r\nOld Result:\r\n```\r\n>>> sqrtdenest((3 - sqrt(2)*sqrt(4 + 3*I) + 3*I)/2)\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 132, in sqrtdenest\r\n    z = _sqrtdenest0(expr)\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 242, in _sqrtdenest0\r\n    return expr.func(*[_sqrtdenest0(a) for a in args])\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 242, in _sqrtdenest0\r\n    return expr.func(*[_sqrtdenest0(a) for a in args])\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 235, in _sqrtdenest0\r\n    return _sqrtdenest1(expr)\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 319, in _sqrtdenest1\r\n    val = _sqrt_match(a)\r\n  File \"sympy\\simplify\\sqrtdenest.py\", line 159, in _sqrt_match\r\n    r, b, a = split_surds(p)\r\n  File \"sympy\\simplify\\radsimp.py\", line 1032, in split_surds\r\n    g, b1, b2 = _split_gcd(*surds)\r\n  File \"sympy\\simplify\\radsimp.py\", line 1068, in _split_gcd\r\n    g = a[0]\r\nIndexError: tuple index out of range\r\n\r\n```\r\nNew Result:\r\n\r\n```\r\nIn [9]: sqrtdenest((3 - sqrt(2)*sqrt(4 + 3*I) + 3*I)/2)\r\nOut[9]: 3/2 - sqrt(2)*sqrt(4 + 3*I)/2 + 3*I/2\r\n```\n",
  "localized_code": "[start of sympy/simplify/radsimp.py]\n1: from __future__ import print_function, division\n2: \n3: from collections import defaultdict\n4: \n5: from sympy import SYMPY_DEBUG\n6: \n7: from sympy.core import expand_power_base, sympify, Add, S, Mul, Derivative, Pow, symbols, expand_mul\n8: from sympy.core.add import _unevaluated_Add\n9: from sympy.core.compatibility import iterable, ordered, default_sort_key\n10: from sympy.core.evaluate import global_evaluate\n11: from sympy.core.exprtools import Factors, gcd_terms\n12: from sympy.core.function import _mexpand\n13: from sympy.core.mul import _keep_coeff, _unevaluated_Mul\n14: from sympy.core.numbers import Rational\n15: from sympy.functions import exp, sqrt, log\n16: from sympy.polys import gcd\n17: from sympy.simplify.sqrtdenest import sqrtdenest\n18: \n19: \n20: \n21: \n22: def collect(expr, syms, func=None, evaluate=None, exact=False, distribute_order_term=True):\n23:     \"\"\"\n24:     Collect additive terms of an expression.\n25: \n26:     This function collects additive terms of an expression with respect\n27:     to a list of expression up to powers with rational exponents. By the\n28:     term symbol here are meant arbitrary expressions, which can contain\n29:     powers, products, sums etc. In other words symbol is a pattern which\n30:     will be searched for in the expression's terms.\n31: \n32:     The input expression is not expanded by :func:`collect`, so user is\n33:     expected to provide an expression is an appropriate form. This makes\n34:     :func:`collect` more predictable as there is no magic happening behind the\n35:     scenes. However, it is important to note, that powers of products are\n36:     converted to products of powers using the :func:`expand_power_base`\n37:     function.\n38: \n39:     There are two possible types of output. First, if ``evaluate`` flag is\n40:     set, this function will return an expression with collected terms or\n41:     else it will return a dictionary with expressions up to rational powers\n42:     as keys and collected coefficients as values.\n43: \n44:     Examples\n45:     ========\n46: \n47:     >>> from sympy import S, collect, expand, factor, Wild\n48:     >>> from sympy.abc import a, b, c, x, y, z\n49: \n50:     This function can collect symbolic coefficients in polynomials or\n51:     rational expressions. It will manage to find all integer or rational\n52:     powers of collection variable::\n53: \n54:         >>> collect(a*x**2 + b*x**2 + a*x - b*x + c, x)\n55:         c + x**2*(a + b) + x*(a - b)\n56: \n57:     The same result can be achieved in dictionary form::\n58: \n59:         >>> d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)\n60:         >>> d[x**2]\n61:         a + b\n62:         >>> d[x]\n63:         a - b\n64:         >>> d[S.One]\n65:         c\n66: \n67:     You can also work with multivariate polynomials. However, remember that\n68:     this function is greedy so it will care only about a single symbol at time,\n69:     in specification order::\n70: \n71:         >>> collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])\n72:         x**2*(y + 1) + x*y + y*(a + 1)\n73: \n74:     Also more complicated expressions can be used as patterns::\n75: \n76:         >>> from sympy import sin, log\n77:         >>> collect(a*sin(2*x) + b*sin(2*x), sin(2*x))\n78:         (a + b)*sin(2*x)\n79: \n80:         >>> collect(a*x*log(x) + b*(x*log(x)), x*log(x))\n81:         x*(a + b)*log(x)\n82: \n83:     You can use wildcards in the pattern::\n84: \n85:         >>> w = Wild('w1')\n86:         >>> collect(a*x**y - b*x**y, w**y)\n87:         x**y*(a - b)\n88: \n89:     It is also possible to work with symbolic powers, although it has more\n90:     complicated behavior, because in this case power's base and symbolic part\n91:     of the exponent are treated as a single symbol::\n92: \n93:         >>> collect(a*x**c + b*x**c, x)\n94:         a*x**c + b*x**c\n95:         >>> collect(a*x**c + b*x**c, x**c)\n96:         x**c*(a + b)\n97: \n98:     However if you incorporate rationals to the exponents, then you will get\n99:     well known behavior::\n100: \n101:         >>> collect(a*x**(2*c) + b*x**(2*c), x**c)\n102:         x**(2*c)*(a + b)\n103: \n104:     Note also that all previously stated facts about :func:`collect` function\n105:     apply to the exponential function, so you can get::\n106: \n107:         >>> from sympy import exp\n108:         >>> collect(a*exp(2*x) + b*exp(2*x), exp(x))\n109:         (a + b)*exp(2*x)\n110: \n111:     If you are interested only in collecting specific powers of some symbols\n112:     then set ``exact`` flag in arguments::\n113: \n114:         >>> collect(a*x**7 + b*x**7, x, exact=True)\n115:         a*x**7 + b*x**7\n116:         >>> collect(a*x**7 + b*x**7, x**7, exact=True)\n117:         x**7*(a + b)\n118: \n119:     You can also apply this function to differential equations, where\n120:     derivatives of arbitrary order can be collected. Note that if you\n121:     collect with respect to a function or a derivative of a function, all\n122:     derivatives of that function will also be collected. Use\n123:     ``exact=True`` to prevent this from happening::\n124: \n125:         >>> from sympy import Derivative as D, collect, Function\n126:         >>> f = Function('f') (x)\n127: \n128:         >>> collect(a*D(f,x) + b*D(f,x), D(f,x))\n129:         (a + b)*Derivative(f(x), x)\n130: \n131:         >>> collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)\n132:         (a + b)*Derivative(f(x), (x, 2))\n133: \n134:         >>> collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)\n135:         a*Derivative(f(x), (x, 2)) + b*Derivative(f(x), (x, 2))\n136: \n137:         >>> collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)\n138:         (a + b)*f(x) + (a + b)*Derivative(f(x), x)\n139: \n140:     Or you can even match both derivative order and exponent at the same time::\n141: \n142:         >>> collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))\n143:         (a + b)*Derivative(f(x), (x, 2))**2\n144: \n145:     Finally, you can apply a function to each of the collected coefficients.\n146:     For example you can factorize symbolic coefficients of polynomial::\n147: \n148:         >>> f = expand((x + a + 1)**3)\n149: \n150:         >>> collect(f, x, factor)\n151:         x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3\n152: \n153:     .. note:: Arguments are expected to be in expanded form, so you might have\n154:               to call :func:`expand` prior to calling this function.\n155: \n156:     See Also\n157:     ========\n158: \n159:     collect_const, collect_sqrt, rcollect\n160:     \"\"\"\n161:     expr = sympify(expr)\n162:     syms = list(syms) if iterable(syms) else [syms]\n163: \n164:     if evaluate is None:\n165:         evaluate = global_evaluate[0]\n166: \n167:     def make_expression(terms):\n168:         product = []\n169: \n170:         for term, rat, sym, deriv in terms:\n171:             if deriv is not None:\n172:                 var, order = deriv\n173: \n174:                 while order > 0:\n175:                     term, order = Derivative(term, var), order - 1\n176: \n177:             if sym is None:\n178:                 if rat is S.One:\n179:                     product.append(term)\n180:                 else:\n181:                     product.append(Pow(term, rat))\n182:             else:\n183:                 product.append(Pow(term, rat*sym))\n184: \n185:         return Mul(*product)\n186: \n187:     def parse_derivative(deriv):\n188:         # scan derivatives tower in the input expression and return\n189:         # underlying function and maximal differentiation order\n190:         expr, sym, order = deriv.expr, deriv.variables[0], 1\n191: \n192:         for s in deriv.variables[1:]:\n193:             if s == sym:\n194:                 order += 1\n195:             else:\n196:                 raise NotImplementedError(\n197:                     'Improve MV Derivative support in collect')\n198: \n199:         while isinstance(expr, Derivative):\n200:             s0 = expr.variables[0]\n201: \n202:             for s in expr.variables:\n203:                 if s != s0:\n204:                     raise NotImplementedError(\n205:                         'Improve MV Derivative support in collect')\n206: \n207:             if s0 == sym:\n208:                 expr, order = expr.expr, order + len(expr.variables)\n209:             else:\n210:                 break\n211: \n212:         return expr, (sym, Rational(order))\n213: \n214:     def parse_term(expr):\n215:         \"\"\"Parses expression expr and outputs tuple (sexpr, rat_expo,\n216:         sym_expo, deriv)\n217:         where:\n218:          - sexpr is the base expression\n219:          - rat_expo is the rational exponent that sexpr is raised to\n220:          - sym_expo is the symbolic exponent that sexpr is raised to\n221:          - deriv contains the derivatives the the expression\n222: \n223:          for example, the output of x would be (x, 1, None, None)\n224:          the output of 2**x would be (2, 1, x, None)\n225:         \"\"\"\n226:         rat_expo, sym_expo = S.One, None\n227:         sexpr, deriv = expr, None\n228: \n229:         if expr.is_Pow:\n230:             if isinstance(expr.base, Derivative):\n231:                 sexpr, deriv = parse_derivative(expr.base)\n232:             else:\n233:                 sexpr = expr.base\n234: \n235:             if expr.exp.is_Number:\n236:                 rat_expo = expr.exp\n237:             else:\n238:                 coeff, tail = expr.exp.as_coeff_Mul()\n239: \n240:                 if coeff.is_Number:\n241:                     rat_expo, sym_expo = coeff, tail\n242:                 else:\n243:                     sym_expo = expr.exp\n244:         elif isinstance(expr, exp):\n245:             arg = expr.args[0]\n246:             if arg.is_Rational:\n247:                 sexpr, rat_expo = S.Exp1, arg\n248:             elif arg.is_Mul:\n249:                 coeff, tail = arg.as_coeff_Mul(rational=True)\n250:                 sexpr, rat_expo = exp(tail), coeff\n251:         elif isinstance(expr, Derivative):\n252:             sexpr, deriv = parse_derivative(expr)\n253: \n254:         return sexpr, rat_expo, sym_expo, deriv\n255: \n256:     def parse_expression(terms, pattern):\n257:         \"\"\"Parse terms searching for a pattern.\n258:         terms is a list of tuples as returned by parse_terms;\n259:         pattern is an expression treated as a product of factors\n260:         \"\"\"\n261:         pattern = Mul.make_args(pattern)\n262: \n263:         if len(terms) < len(pattern):\n264:             # pattern is longer than matched product\n265:             # so no chance for positive parsing result\n266:             return None\n267:         else:\n268:             pattern = [parse_term(elem) for elem in pattern]\n269: \n270:             terms = terms[:]  # need a copy\n271:             elems, common_expo, has_deriv = [], None, False\n272: \n273:             for elem, e_rat, e_sym, e_ord in pattern:\n274: \n275:                 if elem.is_Number and e_rat == 1 and e_sym is None:\n276:                     # a constant is a match for everything\n277:                     continue\n278: \n279:                 for j in range(len(terms)):\n280:                     if terms[j] is None:\n281:                         continue\n282: \n283:                     term, t_rat, t_sym, t_ord = terms[j]\n284: \n285:                     # keeping track of whether one of the terms had\n286:                     # a derivative or not as this will require rebuilding\n287:                     # the expression later\n288:                     if t_ord is not None:\n289:                         has_deriv = True\n290: \n291:                     if (term.match(elem) is not None and\n292:                             (t_sym == e_sym or t_sym is not None and\n293:                             e_sym is not None and\n294:                             t_sym.match(e_sym) is not None)):\n295:                         if exact is False:\n296:                             # we don't have to be exact so find common exponent\n297:                             # for both expression's term and pattern's element\n298:                             expo = t_rat / e_rat\n299: \n300:                             if common_expo is None:\n301:                                 # first time\n302:                                 common_expo = expo\n303:                             else:\n304:                                 # common exponent was negotiated before so\n305:                                 # there is no chance for a pattern match unless\n306:                                 # common and current exponents are equal\n307:                                 if common_expo != expo:\n308:                                     common_expo = 1\n309:                         else:\n310:                             # we ought to be exact so all fields of\n311:                             # interest must match in every details\n312:                             if e_rat != t_rat or e_ord != t_ord:\n313:                                 continue\n314: \n315:                         # found common term so remove it from the expression\n316:                         # and try to match next element in the pattern\n317:                         elems.append(terms[j])\n318:                         terms[j] = None\n319: \n320:                         break\n321: \n322:                 else:\n323:                     # pattern element not found\n324:                     return None\n325: \n326:             return [_f for _f in terms if _f], elems, common_expo, has_deriv\n327: \n328:     if evaluate:\n329:         if expr.is_Add:\n330:             o = expr.getO() or 0\n331:             expr = expr.func(*[\n332:                     collect(a, syms, func, True, exact, distribute_order_term)\n333:                     for a in expr.args if a != o]) + o\n334:         elif expr.is_Mul:\n335:             return expr.func(*[\n336:                 collect(term, syms, func, True, exact, distribute_order_term)\n337:                 for term in expr.args])\n338:         elif expr.is_Pow:\n339:             b = collect(\n340:                 expr.base, syms, func, True, exact, distribute_order_term)\n341:             return Pow(b, expr.exp)\n342: \n343:     syms = [expand_power_base(i, deep=False) for i in syms]\n344: \n345:     order_term = None\n346: \n347:     if distribute_order_term:\n348:         order_term = expr.getO()\n349: \n350:         if order_term is not None:\n351:             if order_term.has(*syms):\n352:                 order_term = None\n353:             else:\n354:                 expr = expr.removeO()\n355: \n356:     summa = [expand_power_base(i, deep=False) for i in Add.make_args(expr)]\n357: \n358:     collected, disliked = defaultdict(list), S.Zero\n359:     for product in summa:\n360:         c, nc = product.args_cnc(split_1=False)\n361:         args = list(ordered(c)) + nc\n362:         terms = [parse_term(i) for i in args]\n363:         small_first = True\n364: \n365:         for symbol in syms:\n366:             if SYMPY_DEBUG:\n367:                 print(\"DEBUG: parsing of expression %s with symbol %s \" % (\n368:                     str(terms), str(symbol))\n369:                 )\n370: \n371:             if isinstance(symbol, Derivative) and small_first:\n372:                 terms = list(reversed(terms))\n373:                 small_first = not small_first\n374:             result = parse_expression(terms, symbol)\n375: \n376:             if SYMPY_DEBUG:\n377:                 print(\"DEBUG: returned %s\" % str(result))\n378: \n379:             if result is not None:\n380:                 if not symbol.is_commutative:\n381:                     raise AttributeError(\"Can not collect noncommutative symbol\")\n382: \n383:                 terms, elems, common_expo, has_deriv = result\n384: \n385:                 # when there was derivative in current pattern we\n386:                 # will need to rebuild its expression from scratch\n387:                 if not has_deriv:\n388:                     margs = []\n389:                     for elem in elems:\n390:                         if elem[2] is None:\n391:                             e = elem[1]\n392:                         else:\n393:                             e = elem[1]*elem[2]\n394:                         margs.append(Pow(elem[0], e))\n395:                     index = Mul(*margs)\n396:                 else:\n397:                     index = make_expression(elems)\n398:                 terms = expand_power_base(make_expression(terms), deep=False)\n399:                 index = expand_power_base(index, deep=False)\n400:                 collected[index].append(terms)\n401:                 break\n402:         else:\n403:             # none of the patterns matched\n404:             disliked += product\n405:     # add terms now for each key\n406:     collected = {k: Add(*v) for k, v in collected.items()}\n407: \n408:     if disliked is not S.Zero:\n409:         collected[S.One] = disliked\n410: \n411:     if order_term is not None:\n412:         for key, val in collected.items():\n413:             collected[key] = val + order_term\n414: \n415:     if func is not None:\n416:         collected = dict(\n417:             [(key, func(val)) for key, val in collected.items()])\n418: \n419:     if evaluate:\n420:         return Add(*[key*val for key, val in collected.items()])\n421:     else:\n422:         return collected\n423: \n424: \n425: def rcollect(expr, *vars):\nCode replaced for brevity.\n453: \n454: \n455: \n456: def collect_sqrt(expr, evaluate=None):\nCode replaced for brevity.\n532: \n533: \n534: \n535: def collect_const(expr, *vars, **kwargs):\nCode replaced for brevity.\n669: \n670: \n671: \n672: def radsimp(expr, symbolic=True, max_terms=4):\nCode replaced for brevity.\n917: \n918: \n919: \n920: def rad_rationalize(num, den):\n921:     \"\"\"\n922:     Rationalize num/den by removing square roots in the denominator;\n923:     num and den are sum of terms whose squares are rationals\n924: \n925:     Examples\n926:     ========\n927: \n928:     >>> from sympy import sqrt\n929:     >>> from sympy.simplify.radsimp import rad_rationalize\n930:     >>> rad_rationalize(sqrt(3), 1 + sqrt(2)/3)\n931:     (-sqrt(3) + sqrt(6)/3, -7/9)\n932:     \"\"\"\n933:     if not den.is_Add:\n934:         return num, den\n935:     g, a, b = split_surds(den)\n936:     a = a*sqrt(g)\n937:     num = _mexpand((a - b)*num)\n938:     den = _mexpand(a**2 - b**2)\n939:     return rad_rationalize(num, den)\n940: \n941: \n942: def fraction(expr, exact=False):\nCode replaced for brevity.\n1032: \n1033: \n1034: \n1035: def numer(expr):\n1036:     return fraction(expr)[0]\n1037: \n1038: \n1039: def denom(expr):\n1040:     return fraction(expr)[1]\n1041: \n1042: \n1043: def fraction_expand(expr, **hints):\n1044:     return expr.expand(frac=True, **hints)\n1045: \n1046: \n1047: def numer_expand(expr, **hints):\nCode replaced for brevity.\n1049: \n1050: \n1051: \n1052: def denom_expand(expr, **hints):\nCode replaced for brevity.\n1054: \n1055: \n1056: \n1057: expand_numer = numer_expand\n1058: expand_denom = denom_expand\n1059: expand_fraction = fraction_expand\n1060: \n1061: \n1062: def split_surds(expr):\n1063:     \"\"\"\n1064:     split an expression with terms whose squares are rationals\n1065:     into a sum of terms whose surds squared have gcd equal to g\n1066:     and a sum of terms with surds squared prime with g\n1067: \n1068:     Examples\n1069:     ========\n1070: \n1071:     >>> from sympy import sqrt\n1072:     >>> from sympy.simplify.radsimp import split_surds\n1073:     >>> split_surds(3*sqrt(3) + sqrt(5)/7 + sqrt(6) + sqrt(10) + sqrt(15))\n1074:     (3, sqrt(2) + sqrt(5) + 3, sqrt(5)/7 + sqrt(10))\n1075:     \"\"\"\n1076:     args = sorted(expr.args, key=default_sort_key)\n1077:     coeff_muls = [x.as_coeff_Mul() for x in args]\n1078:     surds = [x[1]**2 for x in coeff_muls if x[1].is_Pow]\n1079:     surds.sort(key=default_sort_key)\n1080:     g, b1, b2 = _split_gcd(*surds)\n1081:     g2 = g\n1082:     if not b2 and len(b1) >= 2:\n1083:         b1n = [x/g for x in b1]\n1084:         b1n = [x for x in b1n if x != 1]\n1085:         # only a common factor has been factored; split again\n1086:         g1, b1n, b2 = _split_gcd(*b1n)\n1087:         g2 = g*g1\n1088:     a1v, a2v = [], []\n1089:     for c, s in coeff_muls:\n1090:         if s.is_Pow and s.exp == S.Half:\n1091:             s1 = s.base\n1092:             if s1 in b1:\n1093:                 a1v.append(c*sqrt(s1/g2))\n1094:             else:\n1095:                 a2v.append(c*s)\n1096:         else:\n1097:             a2v.append(c*s)\n1098:     a = Add(*a1v)\n1099:     b = Add(*a2v)\n1100:     return g2, a, b\n1101: \n1102: \n1103: def _split_gcd(*a):\nCode replaced for brevity.\n1126: \n\n[start of sympy/simplify/sqrtdenest.py]\n1: from __future__ import print_function, division\n2: \n3: from sympy.core import S, sympify, Mul, Add, Expr\n4: from sympy.core.compatibility import range\n5: from sympy.core.function import expand_mul, count_ops, _mexpand\n6: from sympy.core.symbol import Dummy\n7: from sympy.functions import sqrt, sign, root\n8: from sympy.polys import Poly, PolynomialError\n9: from sympy.utilities import default_sort_key\n10: \n11: \n12: def is_sqrt(expr):\n13:     \"\"\"Return True if expr is a sqrt, otherwise False.\"\"\"\n14: \n15:     return expr.is_Pow and expr.exp.is_Rational and abs(expr.exp) is S.Half\n16: \n17: \n18: def sqrt_depth(p):\n19:     \"\"\"Return the maximum depth of any square root argument of p.\n20: \n21:     >>> from sympy.functions.elementary.miscellaneous import sqrt\n22:     >>> from sympy.simplify.sqrtdenest import sqrt_depth\n23: \n24:     Neither of these square roots contains any other square roots\n25:     so the depth is 1:\n26: \n27:     >>> sqrt_depth(1 + sqrt(2)*(1 + sqrt(3)))\n28:     1\n29: \n30:     The sqrt(3) is contained within a square root so the depth is\n31:     2:\n32: \n33:     >>> sqrt_depth(1 + sqrt(2)*sqrt(1 + sqrt(3)))\n34:     2\n35:     \"\"\"\n36: \n37:     if p.is_Atom:\n38:         return 0\n39:     elif p.is_Add or p.is_Mul:\n40:         return max([sqrt_depth(x) for x in p.args], key=default_sort_key)\n41:     elif is_sqrt(p):\n42:         return sqrt_depth(p.base) + 1\n43:     else:\n44:         return 0\n45: \n46: \n47: def is_algebraic(p):\n48:     \"\"\"Return True if p is comprised of only Rationals or square roots\n49:     of Rationals and algebraic operations.\n50: \n51:     Examples\n52:     ========\n53: \n54:     >>> from sympy.functions.elementary.miscellaneous import sqrt\n55:     >>> from sympy.simplify.sqrtdenest import is_algebraic\n56:     >>> from sympy import cos\n57:     >>> is_algebraic(sqrt(2)*(3/(sqrt(7) + sqrt(5)*sqrt(2))))\n58:     True\n59:     >>> is_algebraic(sqrt(2)*(3/(sqrt(7) + sqrt(5)*cos(2))))\n60:     False\n61:     \"\"\"\n62: \n63:     if p.is_Rational:\n64:         return True\n65:     elif p.is_Atom:\n66:         return False\n67:     elif is_sqrt(p) or p.is_Pow and p.exp.is_Integer:\n68:         return is_algebraic(p.base)\n69:     elif p.is_Add or p.is_Mul:\n70:         return all(is_algebraic(x) for x in p.args)\n71:     else:\n72:         return False\n73: \n74: \n75: def _subsets(n):\nCode replaced for brevity.\n101: \n102: \n103: \n104: def sqrtdenest(expr, max_iter=3):\nCode replaced for brevity.\n137: \n138: \n139: \n140: def _sqrt_match(p):\n141:     \"\"\"Return [a, b, r] for p.match(a + b*sqrt(r)) where, in addition to\n142:     matching, sqrt(r) also has then maximal sqrt_depth among addends of p.\n143: \n144:     Examples\n145:     ========\n146: \n147:     >>> from sympy.functions.elementary.miscellaneous import sqrt\n148:     >>> from sympy.simplify.sqrtdenest import _sqrt_match\n149:     >>> _sqrt_match(1 + sqrt(2) + sqrt(2)*sqrt(3) +  2*sqrt(1+sqrt(5)))\n150:     [1 + sqrt(2) + sqrt(6), 2, 1 + sqrt(5)]\n151:     \"\"\"\n152:     from sympy.simplify.radsimp import split_surds\n153: \n154:     p = _mexpand(p)\n155:     if p.is_Number:\n156:         res = (p, S.Zero, S.Zero)\n157:     elif p.is_Add:\n158:         pargs = sorted(p.args, key=default_sort_key)\n159:         if all((x**2).is_Rational for x in pargs):\n160:             r, b, a = split_surds(p)\n161:             res = a, b, r\n162:             return list(res)\n163:         # to make the process canonical, the argument is included in the tuple\n164:         # so when the max is selected, it will be the largest arg having a\n165:         # given depth\n166:         v = [(sqrt_depth(x), x, i) for i, x in enumerate(pargs)]\n167:         nmax = max(v, key=default_sort_key)\n168:         if nmax[0] == 0:\n169:             res = []\n170:         else:\n171:             # select r\n172:             depth, _, i = nmax\n173:             r = pargs.pop(i)\n174:             v.pop(i)\n175:             b = S.One\n176:             if r.is_Mul:\n177:                 bv = []\n178:                 rv = []\n179:                 for x in r.args:\n180:                     if sqrt_depth(x) < depth:\n181:                         bv.append(x)\n182:                     else:\n183:                         rv.append(x)\n184:                 b = Mul._from_args(bv)\n185:                 r = Mul._from_args(rv)\n186:             # collect terms comtaining r\n187:             a1 = []\n188:             b1 = [b]\n189:             for x in v:\n190:                 if x[0] < depth:\n191:                     a1.append(x[1])\n192:                 else:\n193:                     x1 = x[1]\n194:                     if x1 == r:\n195:                         b1.append(1)\n196:                     else:\n197:                         if x1.is_Mul:\n198:                             x1args = list(x1.args)\n199:                             if r in x1args:\n200:                                 x1args.remove(r)\n201:                                 b1.append(Mul(*x1args))\n202:                             else:\n203:                                 a1.append(x[1])\n204:                         else:\n205:                             a1.append(x[1])\n206:             a = Add(*a1)\n207:             b = Add(*b1)\n208:             res = (a, b, r**2)\n209:     else:\n210:         b, r = p.as_coeff_Mul()\n211:         if is_sqrt(r):\n212:             res = (S.Zero, b, r**2)\n213:         else:\n214:             res = []\n215:     return list(res)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/simplify/radsimp.py",
      "suspect_lines": [
        923,
        1064,
        1066
      ]
    },
    {
      "filename": "/sympy/simplify/sqrtdenest.py",
      "suspect_lines": [
        159
      ]
    }
  ]
}