{
  "instance_id": "sympy__sympy-21596",
  "problem_statement": "bug in is_subset(Reals)\nSolving issue #19513 has given rise to another bug.\r\nNow:\r\n```\r\nIn [8]: S1 = imageset(Lambda(n, n + (n - 1)*(n + 1)*I), S.Integers)\r\n\r\nIn [9]: S1\r\nOut[9]: {n + ⅈ⋅(n - 1)⋅(n + 1) │ n ∊ ℤ}\r\n\r\nIn [10]: 2 in S1\r\nOut[10]: False\r\n\r\nIn [11]: 2 in S1.intersect(Reals)\r\nOut[11]: True\r\n```\r\nThis output is incorrect.\r\n\r\nCorrect output is:\r\n```\r\nIn [4]: S1\r\nOut[4]: {n + ⅈ⋅(n - 1)⋅(n + 1) │ n ∊ ℤ}\r\n\r\nIn [5]: 2 in S1\r\nOut[5]: False\r\n\r\nIn [6]: 2 in S1.intersect(Reals)\r\nOut[6]: False\r\n\r\nIn [7]: S2 = Reals\r\n\r\nIn [8]: S1.intersect(S2)\r\nOut[8]: {-1, 1}\r\n```\n",
  "localized_code": "[start of sympy/sets/handlers/intersection.py]\n1: from sympy import (S, Dummy, Lambda, symbols, Interval, Intersection, Set,\n2:                    EmptySet, FiniteSet, Union, ComplexRegion, Mul)\n3: from sympy.multipledispatch import dispatch\n4: from sympy.sets.conditionset import ConditionSet\n5: from sympy.sets.fancysets import (Integers, Naturals, Reals, Range,\n6:     ImageSet, Rationals)\n7: from sympy.sets.sets import UniversalSet, imageset, ProductSet\n8: \n9: \n10: @dispatch(ConditionSet, ConditionSet)  # type: ignore # noqa:F811\n11: def intersection_sets(a, b): # noqa:F811\n12:     return None\n13: \n14: @dispatch(ConditionSet, Set)  # type: ignore # noqa:F811\n15: def intersection_sets(a, b): # noqa:F811\n16:     return ConditionSet(a.sym, a.condition, Intersection(a.base_set, b))\n17: \n18: @dispatch(Naturals, Integers)  # type: ignore # noqa:F811\n19: def intersection_sets(a, b): # noqa:F811\n20:     return a\n21: \n22: @dispatch(Naturals, Naturals)  # type: ignore # noqa:F811\n23: def intersection_sets(a, b): # noqa:F811\n24:     return a if a is S.Naturals else b\n25: \n26: @dispatch(Interval, Naturals)  # type: ignore # noqa:F811\n27: def intersection_sets(a, b): # noqa:F811\n28:     return intersection_sets(b, a)\n29: \n30: @dispatch(ComplexRegion, Set)  # type: ignore # noqa:F811\n31: def intersection_sets(self, other): # noqa:F811\n32:     if other.is_ComplexRegion:\n33:         # self in rectangular form\n34:         if (not self.polar) and (not other.polar):\n35:             return ComplexRegion(Intersection(self.sets, other.sets))\n36: \n37:         # self in polar form\n38:         elif self.polar and other.polar:\n39:             r1, theta1 = self.a_interval, self.b_interval\n40:             r2, theta2 = other.a_interval, other.b_interval\n41:             new_r_interval = Intersection(r1, r2)\n42:             new_theta_interval = Intersection(theta1, theta2)\n43: \n44:             # 0 and 2*Pi means the same\n45:             if ((2*S.Pi in theta1 and S.Zero in theta2) or\n46:                (2*S.Pi in theta2 and S.Zero in theta1)):\n47:                 new_theta_interval = Union(new_theta_interval,\n48:                                            FiniteSet(0))\n49:             return ComplexRegion(new_r_interval*new_theta_interval,\n50:                                 polar=True)\n51: \n52: \n53:     if other.is_subset(S.Reals):\n54:         new_interval = []\n55:         x = symbols(\"x\", cls=Dummy, real=True)\n56: \n57:         # self in rectangular form\n58:         if not self.polar:\n59:             for element in self.psets:\n60:                 if S.Zero in element.args[1]:\n61:                     new_interval.append(element.args[0])\n62:             new_interval = Union(*new_interval)\n63:             return Intersection(new_interval, other)\n64: \n65:         # self in polar form\n66:         elif self.polar:\n67:             for element in self.psets:\n68:                 if S.Zero in element.args[1]:\n69:                     new_interval.append(element.args[0])\n70:                 if S.Pi in element.args[1]:\n71:                     new_interval.append(ImageSet(Lambda(x, -x), element.args[0]))\n72:                 if S.Zero in element.args[0]:\n73:                     new_interval.append(FiniteSet(0))\n74:             new_interval = Union(*new_interval)\n75:             return Intersection(new_interval, other)\n76: \n77: @dispatch(Integers, Reals)  # type: ignore # noqa:F811\n78: def intersection_sets(a, b): # noqa:F811\n79:     return a\n80: \n81: @dispatch(Range, Interval)  # type: ignore # noqa:F811\n82: def intersection_sets(a, b): # noqa:F811\nCode replaced for brevity.\n99: \n100: \n101: @dispatch(Range, Naturals)  # type: ignore # noqa:F811\n102: def intersection_sets(a, b): # noqa:F811\nCode replaced for brevity.\n103: \n104: \n105: @dispatch(Range, Range)  # type: ignore # noqa:F811\n106: def intersection_sets(a, b): # noqa:F811\nCode replaced for brevity.\n215: \n216: \n217: \n218: @dispatch(Range, Integers)  # type: ignore # noqa:F811\n219: def intersection_sets(a, b): # noqa:F811\n220:     return a\n221: \n222: \n223: @dispatch(ImageSet, Set)  # type: ignore # noqa:F811\n224: def intersection_sets(self, other): # noqa:F811\n225:     from sympy.solvers.diophantine import diophantine\n226: \n227:     # Only handle the straight-forward univariate case\n228:     if (len(self.lamda.variables) > 1\n229:             or self.lamda.signature != self.lamda.variables):\n230:         return None\n231:     base_set = self.base_sets[0]\n232: \n233:     # Intersection between ImageSets with Integers as base set\n234:     # For {f(n) : n in Integers} & {g(m) : m in Integers} we solve the\n235:     # diophantine equations f(n)=g(m).\n236:     # If the solutions for n are {h(t) : t in Integers} then we return\n237:     # {f(h(t)) : t in integers}.\n238:     # If the solutions for n are {n_1, n_2, ..., n_k} then we return\n239:     # {f(n_i) : 1 <= i <= k}.\n240:     if base_set is S.Integers:\n241:         gm = None\n242:         if isinstance(other, ImageSet) and other.base_sets == (S.Integers,):\n243:             gm = other.lamda.expr\n244:             var = other.lamda.variables[0]\n245:             # Symbol of second ImageSet lambda must be distinct from first\n246:             m = Dummy('m')\n247:             gm = gm.subs(var, m)\n248:         elif other is S.Integers:\n249:             m = gm = Dummy('m')\n250:         if gm is not None:\n251:             fn = self.lamda.expr\n252:             n = self.lamda.variables[0]\n253:             try:\n254:                 solns = list(diophantine(fn - gm, syms=(n, m), permute=True))\n255:             except (TypeError, NotImplementedError):\n256:                 # TypeError if equation not polynomial with rational coeff.\n257:                 # NotImplementedError if correct format but no solver.\n258:                 return\n259:             # 3 cases are possible for solns:\n260:             # - empty set,\n261:             # - one or more parametric (infinite) solutions,\n262:             # - a finite number of (non-parametric) solution couples.\n263:             # Among those, there is one type of solution set that is\n264:             # not helpful here: multiple parametric solutions.\n265:             if len(solns) == 0:\n266:                 return EmptySet\n267:             elif any(not isinstance(s, int) and s.free_symbols\n268:                      for tupl in solns for s in tupl):\n269:                 if len(solns) == 1:\n270:                     soln, solm = solns[0]\n271:                     (t,) = soln.free_symbols\n272:                     expr = fn.subs(n, soln.subs(t, n)).expand()\n273:                     return imageset(Lambda(n, expr), S.Integers)\n274:                 else:\n275:                     return\n276:             else:\n277:                 return FiniteSet(*(fn.subs(n, s[0]) for s in solns))\n278: \n279:     if other == S.Reals:\n280:         from sympy.core.function import expand_complex\n281:         from sympy.solvers.solvers import denoms, solve_linear\n282:         from sympy.core.relational import Eq\n283:         f = self.lamda.expr\n284:         n = self.lamda.variables[0]\n285: \n286:         n_ = Dummy(n.name, real=True)\n287:         f_ = f.subs(n, n_)\n288: \n289:         re, im = f_.as_real_imag()\n290:         im = expand_complex(im)\n291: \n292:         re = re.subs(n_, n)\n293:         im = im.subs(n_, n)\n294:         ifree = im.free_symbols\n295:         lam = Lambda(n, re)\n296:         if im.is_zero:\n297:             # allow re-evaluation\n298:             # of self in this case to make\n299:             # the result canonical\n300:             pass\n301:         elif im.is_zero is False:\n302:             return S.EmptySet\n303:         elif ifree != {n}:\n304:             return None\n305:         else:\n306:             # univarite imaginary part in same variable\n307:             x, xis = zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols])\n308:             if x and all(i == n for i in x):\n309:                 base_set -= FiniteSet(xis)\n310:             else:\n311:                 base_set -= ConditionSet(n, Eq(im, 0), S.Integers)\n312:         # exclude values that make denominators 0\n313:         for i in denoms(f):\n314:             if i.has(n):\n315:                 sol = list(zip(*[solve_linear(i, 0) for i in Mul.make_args(im) if n in i.free_symbols]))\n316:                 if sol != []:\n317:                     x, xis = sol\n318:                     if x and all(i == n for i in x):\n319:                         base_set -= FiniteSet(xis)\n320:                 else:\n321:                     base_set -= ConditionSet(n, Eq(i, 0), S.Integers)\n322:         return imageset(lam, base_set)\n323: \n324:     elif isinstance(other, Interval):\n325:         from sympy.solvers.solveset import (invert_real, invert_complex,\n326:                                             solveset)\n327: \n328:         f = self.lamda.expr\n329:         n = self.lamda.variables[0]\n330:         new_inf, new_sup = None, None\n331:         new_lopen, new_ropen = other.left_open, other.right_open\n332: \n333:         if f.is_real:\n334:             inverter = invert_real\n335:         else:\n336:             inverter = invert_complex\n337: \n338:         g1, h1 = inverter(f, other.inf, n)\n339:         g2, h2 = inverter(f, other.sup, n)\n340: \n341:         if all(isinstance(i, FiniteSet) for i in (h1, h2)):\n342:             if g1 == n:\n343:                 if len(h1) == 1:\n344:                     new_inf = h1.args[0]\n345:             if g2 == n:\n346:                 if len(h2) == 1:\n347:                     new_sup = h2.args[0]\n348:             # TODO: Design a technique to handle multiple-inverse\n349:             # functions\n350: \n351:             # Any of the new boundary values cannot be determined\n352:             if any(i is None for i in (new_sup, new_inf)):\n353:                 return\n354: \n355: \n356:             range_set = S.EmptySet\n357: \n358:             if all(i.is_real for i in (new_sup, new_inf)):\n359:                 # this assumes continuity of underlying function\n360:                 # however fixes the case when it is decreasing\n361:                 if new_inf > new_sup:\n362:                     new_inf, new_sup = new_sup, new_inf\n363:                 new_interval = Interval(new_inf, new_sup, new_lopen, new_ropen)\n364:                 range_set = base_set.intersect(new_interval)\n365:             else:\n366:                 if other.is_subset(S.Reals):\n367:                     solutions = solveset(f, n, S.Reals)\n368:                     if not isinstance(range_set, (ImageSet, ConditionSet)):\n369:                         range_set = solutions.intersect(other)\n370:                     else:\n371:                         return\n372: \n373:             if range_set is S.EmptySet:\n374:                 return S.EmptySet\n375:             elif isinstance(range_set, Range) and range_set.size is not S.Infinity:\n376:                 range_set = FiniteSet(*list(range_set))\n377: \n378:             if range_set is not None:\n379:                 return imageset(Lambda(n, f), range_set)\n380:             return\n381:         else:\n382:             return\n383: \n384: \n385: @dispatch(ProductSet, ProductSet)  # type: ignore # noqa:F811\n386: def intersection_sets(a, b): # noqa:F811\nCode replaced for brevity.\n389: \n390: \n391: \n392: @dispatch(Interval, Interval)  # type: ignore # noqa:F811\n393:     # handle (-oo, oo)\nCode replaced for brevity.\n437: \n438: \n439: @dispatch(type(EmptySet), Set)  # type: ignore # noqa:F811\n440: def intersection_sets(a, b): # noqa:F811\n441:     return S.EmptySet\n442: \n443: @dispatch(UniversalSet, Set)  # type: ignore # noqa:F811\n444: def intersection_sets(a, b): # noqa:F811\n445:     return b\n446: \n447: @dispatch(FiniteSet, FiniteSet)  # type: ignore # noqa:F811\n448: def intersection_sets(a, b): # noqa:F811\nCode replaced for brevity.\n449: \n450: \n451: @dispatch(FiniteSet, Set)  # type: ignore # noqa:F811\n452: def intersection_sets(a, b): # noqa:F811\nCode replaced for brevity.\n456: \n457: \n458: @dispatch(Set, Set)  # type: ignore # noqa:F811\n459: def intersection_sets(a, b): # noqa:F811\n460:     return None\n461: \n462: @dispatch(Integers, Rationals)  # type: ignore # noqa:F811\n463: def intersection_sets(a, b): # noqa:F811\n464:     return a\n465: \n466: @dispatch(Naturals, Rationals)  # type: ignore # noqa:F811\n467: def intersection_sets(a, b): # noqa:F811\n468:     return a\n469: \n470: @dispatch(Rationals, Reals)  # type: ignore # noqa:F811\n471: def intersection_sets(a, b): # noqa:F811\n472:     return a\n473: \n474: def _intlike_interval(a, b):\nCode replaced for brevity.\n482: \n483: \n484: @dispatch(Integers, Interval)  # type: ignore # noqa:F811\n485: def intersection_sets(a, b): # noqa:F811\n486:     return _intlike_interval(a, b)\n487: \n488: @dispatch(Naturals, Interval)  # type: ignore # noqa:F811\n489: def intersection_sets(a, b): # noqa:F811\n490:     return _intlike_interval(a, b)\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/sets/handlers/intersection.py",
      "suspect_lines": [
        8,
        306,
        307,
        308,
        309,
        310,
        311,
        313,
        314,
        315,
        316,
        317,
        318,
        319,
        320,
        321
      ]
    }
  ]
}