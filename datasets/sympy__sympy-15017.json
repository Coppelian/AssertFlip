{
  "instance_id": "sympy__sympy-15017",
  "problem_statement": "`len` of rank-0 arrays returns 0\n`sympy.tensor.array.NDimArray.__len__` always returns zero for rank-0 arrays (scalars). I believe the correct value should be one, which is the number of elements of the iterator and the observed behaviour in numpy.\r\n\r\n```python\r\n>>> import sympy\r\n>>> a = sympy.Array(3)\r\n>>> len(a)\r\n0\r\n>>> len(list(a))\r\n1\r\n```\r\nIn numpy we have the following: \r\n\r\n```python\r\n>>> import numpy\r\n>>> numpy.asarray(1).size\r\n1\r\n```\r\n\r\nThis was tested in sympy 1.2-rc1 running in Python 3.6.6\n`len` of rank-0 arrays returns 0\n`sympy.tensor.array.NDimArray.__len__` always returns zero for rank-0 arrays (scalars). I believe the correct value should be one, which is the number of elements of the iterator and the observed behaviour in numpy.\r\n\r\n```python\r\n>>> import sympy\r\n>>> a = sympy.Array(3)\r\n>>> len(a)\r\n0\r\n>>> len(list(a))\r\n1\r\n```\r\nIn numpy we have the following: \r\n\r\n```python\r\n>>> import numpy\r\n>>> numpy.asarray(1).size\r\n1\r\n```\r\n\r\nThis was tested in sympy 1.2-rc1 running in Python 3.6.6\n",
  "localized_code": "[start of sympy/tensor/array/dense_ndim_array.py]\n1: from __future__ import print_function, division\n2: import functools\n3: \n4: import itertools\n5: \n6: from sympy.core.sympify import _sympify\n7: \n8: from sympy import Basic, Tuple\n9: from sympy.tensor.array.mutable_ndim_array import MutableNDimArray\n10: from sympy.tensor.array.ndim_array import NDimArray, ImmutableNDimArray\n11: \n12: \n13: class DenseNDimArray(NDimArray):\n14: \n15:     def __new__(self, *args, **kwargs):\n16:         return ImmutableDenseNDimArray(*args, **kwargs)\n17: \n18:     def __getitem__(self, index):\n19:         \"\"\"\n20:         Allows to get items from N-dim array.\n21: \n22:         Examples\n23:         ========\n24: \n25:         >>> from sympy import MutableDenseNDimArray\n26:         >>> a = MutableDenseNDimArray([0, 1, 2, 3], (2, 2))\n27:         >>> a\n28:         [[0, 1], [2, 3]]\n29:         >>> a[0, 0]\n30:         0\n31:         >>> a[1, 1]\n32:         3\n33: \n34:         Symbolic index:\n35: \n36:         >>> from sympy.abc import i, j\n37:         >>> a[i, j]\n38:         [[0, 1], [2, 3]][i, j]\n39: \n40:         Replace `i` and `j` to get element `(1, 1)`:\n41: \n42:         >>> a[i, j].subs({i: 1, j: 1})\n43:         3\n44: \n45:         \"\"\"\n46:         syindex = self._check_symbolic_index(index)\n47:         if syindex is not None:\n48:             return syindex\n49: \n50:         if isinstance(index, tuple) and any([isinstance(i, slice) for i in index]):\n51: \n52:             def slice_expand(s, dim):\n53:                 if not isinstance(s, slice):\n54:                         return (s,)\n55:                 start, stop, step = s.indices(dim)\n56:                 return [start + i*step for i in range((stop-start)//step)]\n57: \n58:             sl_factors = [slice_expand(i, dim) for (i, dim) in zip(index, self.shape)]\n59:             eindices = itertools.product(*sl_factors)\n60:             array = [self._array[self._parse_index(i)] for i in eindices]\n61:             nshape = [len(el) for i, el in enumerate(sl_factors) if isinstance(index[i], slice)]\n62:             return type(self)(array, nshape)\n63:         else:\n64:             if isinstance(index, slice):\n65:                 return self._array[index]\n66:             else:\n67:                 index = self._parse_index(index)\n68:                 return self._array[index]\n69: \n70:     @classmethod\n71:     def zeros(cls, *shape):\n72:         list_length = functools.reduce(lambda x, y: x*y, shape)\n73:         return cls._new(([0]*list_length,), shape)\n74: \n75:     def tomatrix(self):\n76:         \"\"\"\n77:         Converts MutableDenseNDimArray to Matrix. Can convert only 2-dim array, else will raise error.\n78: \n79:         Examples\n80:         ========\n81: \n82:         >>> from sympy import MutableDenseNDimArray\n83:         >>> a = MutableDenseNDimArray([1 for i in range(9)], (3, 3))\n84:         >>> b = a.tomatrix()\n85:         >>> b\n86:         Matrix([\n87:         [1, 1, 1],\n88:         [1, 1, 1],\n89:         [1, 1, 1]])\n90: \n91:         \"\"\"\n92:         from sympy.matrices import Matrix\n93: \n94:         if self.rank() != 2:\n95:             raise ValueError('Dimensions must be of size of 2')\n96: \n97:         return Matrix(self.shape[0], self.shape[1], self._array)\n98: \n99:     def __iter__(self):\n100:         return self._array.__iter__()\n101: \n102:     def reshape(self, *newshape):\n103:         \"\"\"\n104:         Returns MutableDenseNDimArray instance with new shape. Elements number\n105:         must be        suitable to new shape. The only argument of method sets\n106:         new shape.\n107: \n108:         Examples\n109:         ========\n110: \n111:         >>> from sympy import MutableDenseNDimArray\n112:         >>> a = MutableDenseNDimArray([1, 2, 3, 4, 5, 6], (2, 3))\n113:         >>> a.shape\n114:         (2, 3)\n115:         >>> a\n116:         [[1, 2, 3], [4, 5, 6]]\n117:         >>> b = a.reshape(3, 2)\n118:         >>> b.shape\n119:         (3, 2)\n120:         >>> b\n121:         [[1, 2], [3, 4], [5, 6]]\n122: \n123:         \"\"\"\n124:         new_total_size = functools.reduce(lambda x,y: x*y, newshape)\n125:         if new_total_size != self._loop_size:\n126:             raise ValueError(\"Invalid reshape parameters \" + newshape)\n127: \n128:         # there is no `.func` as this class does not subtype `Basic`:\n129:         return type(self)(self._array, newshape)\n130: \n131: \n132: class ImmutableDenseNDimArray(DenseNDimArray, ImmutableNDimArray):\n133:     \"\"\"\n134: \n135:     \"\"\"\n136: \n137:     def __new__(cls, iterable, shape=None, **kwargs):\n138:         return cls._new(iterable, shape, **kwargs)\n139: \n140:     @classmethod\n141:     def _new(cls, iterable, shape, **kwargs):\n142:         from sympy.utilities.iterables import flatten\n143: \n144:         shape, flat_list = cls._handle_ndarray_creation_inputs(iterable, shape, **kwargs)\n145:         shape = Tuple(*map(_sympify, shape))\n146:         flat_list = flatten(flat_list)\n147:         flat_list = Tuple(*flat_list)\n148:         self = Basic.__new__(cls, flat_list, shape, **kwargs)\n149:         self._shape = shape\n150:         self._array = list(flat_list)\n151:         self._rank = len(shape)\n152:         self._loop_size = functools.reduce(lambda x,y: x*y, shape) if shape else 0\n153:         return self\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/tensor/array/dense_ndim_array.py",
      "suspect_lines": [
        152
      ]
    }
  ]
}