{
  "instance_id": "django__django-11276",
  "problem_statement": "Use Python stdlib html.escape() to in django.utils.html.escape()\nDescription\n\t\nThe function django.utils.html.escape() partially duplicates the Python stdlib function html.escape(). We can replace this duplication with wider community developed version.\nhtml.escape() has been available since Python 3.2:\n​https://docs.python.org/3/library/html.html#html.escape\nThis function is also faster than Django's. As Python bug ​https://bugs.python.org/issue18020 concludes, using .replace() can be faster than .translate(). This function gets called numerous times when rendering templates. After making the change locally, I saw the following improvement:\nmaster:\n$ python -m timeit -s 'from django.utils.html import escape' 'escape(copyright)'\n50000 loops, best of 5: 4.03 usec per loop\nbranch:\n$ python -m timeit -s 'from django.utils.html import escape' 'escape(copyright)'\n100000 loops, best of 5: 2.45 usec per loop\nOne small concern, html.escape() converts ' to &#x27 rather than &#39. These values are functionally equivalent HTML, but I'll mention it as a backwards incompatible change as the literal text has changed\n",
  "localized_code": "[start of django/utils/html.py]\n1: \"\"\"HTML utilities suitable for global use.\"\"\"\n2: \n3: import json\n4: import re\n5: from html.parser import HTMLParser\n6: from urllib.parse import (\n7:     parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,\n8: )\n9: \n10: from django.utils.functional import Promise, keep_lazy, keep_lazy_text\n11: from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS\n12: from django.utils.safestring import SafeData, SafeString, mark_safe\n13: from django.utils.text import normalize_newlines\n14: \n15: # Configuration for urlize() function.\n16: TRAILING_PUNCTUATION_CHARS = '.,:;!'\n17: WRAPPING_PUNCTUATION = [('(', ')'), ('[', ']')]\n18: \n19: # List of possible strings used for bullets in bulleted lists.\n20: DOTS = ['&middot;', '*', '\\u2022', '&#149;', '&bull;', '&#8226;']\n21: \n22: unencoded_ampersands_re = re.compile(r'&(?!(\\w+|#\\d+);)')\n23: word_split_re = re.compile(r'''([\\s<>\"']+)''')\n24: simple_url_re = re.compile(r'^https?://\\[?\\w', re.IGNORECASE)\n25: simple_url_2_re = re.compile(r'^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$', re.IGNORECASE)\n26: \n27: _html_escapes = {\n28:     ord('&'): '&amp;',\n29:     ord('<'): '&lt;',\n30:     ord('>'): '&gt;',\n31:     ord('\"'): '&quot;',\n32:     ord(\"'\"): '&#39;',\n33: }\n34: \n35: \n36: @keep_lazy(str, SafeString)\n37: def escape(text):\n38:     \"\"\"\n39:     Return the given text with ampersands, quotes and angle brackets encoded\n40:     for use in HTML.\n41: \n42:     Always escape input, even if it's already escaped and marked as such.\n43:     This may result in double-escaping. If this is a concern, use\n44:     conditional_escape() instead.\n45:     \"\"\"\n46:     return mark_safe(str(text).translate(_html_escapes))\n47: \n48: \n49: _js_escapes = {\n50:     ord('\\\\'): '\\\\u005C',\n51:     ord('\\''): '\\\\u0027',\n52:     ord('\"'): '\\\\u0022',\n53:     ord('>'): '\\\\u003E',\n54:     ord('<'): '\\\\u003C',\n55:     ord('&'): '\\\\u0026',\n56:     ord('='): '\\\\u003D',\n57:     ord('-'): '\\\\u002D',\n58:     ord(';'): '\\\\u003B',\n59:     ord('`'): '\\\\u0060',\n60:     ord('\\u2028'): '\\\\u2028',\n61:     ord('\\u2029'): '\\\\u2029'\n62: }\n63: \n64: # Escape every ASCII character with a value less than 32.\n65: _js_escapes.update((ord('%c' % z), '\\\\u%04X' % z) for z in range(32))\n66: \n67: \n68: @keep_lazy(str, SafeString)\n69: def escapejs(value):\nCode replaced for brevity.\n71: \n72: \n73: \n74: _json_script_escapes = {\n75:     ord('>'): '\\\\u003E',\n76:     ord('<'): '\\\\u003C',\n77:     ord('&'): '\\\\u0026',\n78: }\n79: \n80: \n81: def json_script(value, element_id):\nCode replaced for brevity.\n92: \n93: \n94: \n95: def conditional_escape(text):\nCode replaced for brevity.\n107: \n108: \n109: \n110: def format_html(format_string, *args, **kwargs):\nCode replaced for brevity.\n118: \n119: \n120: \n121: def format_html_join(sep, format_string, args_generator):\nCode replaced for brevity.\n138: \n139: \n140: \n141: @keep_lazy_text\n142: def linebreaks(value, autoescape=False):\nCode replaced for brevity.\n150: \n151: \n152: \n153: class MLStripper(HTMLParser):\nCode replaced for brevity.\n169: \n170: \n171: \n172: def _strip_once(value):\nCode replaced for brevity.\n179: \n180: \n181: \n182: @keep_lazy_text\n183: def strip_tags(value):\nCode replaced for brevity.\n194: \n195: \n196: \n197: @keep_lazy_text\n198: def strip_spaces_between_tags(value):\nCode replaced for brevity.\n200: \n201: \n202: \n203: def smart_urlquote(url):\nCode replaced for brevity.\n235: \n236: \n237: \n238: @keep_lazy_text\n239: def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n240:     \"\"\"\n241:     Convert any URLs in text into clickable links.\n242: \n243:     Works on http://, https://, www. links, and also on links ending in one of\n244:     the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).\n245:     Links can have trailing punctuation (periods, commas, close-parens) and\n246:     leading punctuation (opening parens) and it'll still do the right thing.\n247: \n248:     If trim_url_limit is not None, truncate the URLs in the link text longer\n249:     than this limit to trim_url_limit - 1 characters and append an ellipsis.\n250: \n251:     If nofollow is True, give the links a rel=\"nofollow\" attribute.\n252: \n253:     If autoescape is True, autoescape the link text and URLs.\n254:     \"\"\"\n255:     safe_input = isinstance(text, SafeData)\n256: \n257:     def trim_url(x, limit=trim_url_limit):\n258:         if limit is None or len(x) <= limit:\n259:             return x\n260:         return '%s…' % x[:max(0, limit - 1)]\n261: \n262:     def unescape(text):\n263:         \"\"\"\n264:         If input URL is HTML-escaped, unescape it so that it can be safely fed\n265:         to smart_urlquote. For example:\n266:         http://example.com?x=1&amp;y=&lt;2&gt; => http://example.com?x=1&y=<2>\n267:         \"\"\"\n268:         return text.replace('&amp;', '&').replace('&lt;', '<').replace(\n269:             '&gt;', '>').replace('&quot;', '\"').replace('&#39;', \"'\")\n270: \n271:     def trim_punctuation(lead, middle, trail):\n272:         \"\"\"\n273:         Trim trailing and wrapping punctuation from `middle`. Return the items\n274:         of the new state.\n275:         \"\"\"\n276:         # Continue trimming until middle remains unchanged.\n277:         trimmed_something = True\n278:         while trimmed_something:\n279:             trimmed_something = False\n280:             # Trim wrapping punctuation.\n281:             for opening, closing in WRAPPING_PUNCTUATION:\n282:                 if middle.startswith(opening):\n283:                     middle = middle[len(opening):]\n284:                     lead += opening\n285:                     trimmed_something = True\n286:                 # Keep parentheses at the end only if they're balanced.\n287:                 if (middle.endswith(closing) and\n288:                         middle.count(closing) == middle.count(opening) + 1):\n289:                     middle = middle[:-len(closing)]\n290:                     trail = closing + trail\n291:                     trimmed_something = True\n292:             # Trim trailing punctuation (after trimming wrapping punctuation,\n293:             # as encoded entities contain ';'). Unescape entites to avoid\n294:             # breaking them by removing ';'.\n295:             middle_unescaped = unescape(middle)\n296:             stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)\n297:             if middle_unescaped != stripped:\n298:                 trail = middle[len(stripped):] + trail\n299:                 middle = middle[:len(stripped) - len(middle_unescaped)]\n300:                 trimmed_something = True\n301:         return lead, middle, trail\n302: \n303:     def is_email_simple(value):\n304:         \"\"\"Return True if value looks like an email address.\"\"\"\n305:         # An @ must be in the middle of the value.\n306:         if '@' not in value or value.startswith('@') or value.endswith('@'):\n307:             return False\n308:         try:\n309:             p1, p2 = value.split('@')\n310:         except ValueError:\n311:             # value contains more than one @.\n312:             return False\n313:         # Dot must be in p2 (e.g. example.com)\n314:         if '.' not in p2 or p2.startswith('.'):\n315:             return False\n316:         return True\n317: \n318:     words = word_split_re.split(str(text))\n319:     for i, word in enumerate(words):\n320:         if '.' in word or '@' in word or ':' in word:\n321:             # lead: Current punctuation trimmed from the beginning of the word.\n322:             # middle: Current state of the word.\n323:             # trail: Current punctuation trimmed from the end of the word.\n324:             lead, middle, trail = '', word, ''\n325:             # Deal with punctuation.\n326:             lead, middle, trail = trim_punctuation(lead, middle, trail)\n327: \n328:             # Make URL we want to point to.\n329:             url = None\n330:             nofollow_attr = ' rel=\"nofollow\"' if nofollow else ''\n331:             if simple_url_re.match(middle):\n332:                 url = smart_urlquote(unescape(middle))\n333:             elif simple_url_2_re.match(middle):\n334:                 url = smart_urlquote('http://%s' % unescape(middle))\n335:             elif ':' not in middle and is_email_simple(middle):\n336:                 local, domain = middle.rsplit('@', 1)\n337:                 try:\n338:                     domain = domain.encode('idna').decode('ascii')\n339:                 except UnicodeError:\n340:                     continue\n341:                 url = 'mailto:%s@%s' % (local, domain)\n342:                 nofollow_attr = ''\n343: \n344:             # Make link.\n345:             if url:\n346:                 trimmed = trim_url(middle)\n347:                 if autoescape and not safe_input:\n348:                     lead, trail = escape(lead), escape(trail)\n349:                     trimmed = escape(trimmed)\n350:                 middle = '<a href=\"%s\"%s>%s</a>' % (escape(url), nofollow_attr, trimmed)\n351:                 words[i] = mark_safe('%s%s%s' % (lead, middle, trail))\n352:             else:\n353:                 if safe_input:\n354:                     words[i] = mark_safe(word)\n355:                 elif autoescape:\n356:                     words[i] = escape(word)\n357:         elif safe_input:\n358:             words[i] = mark_safe(word)\n359:         elif autoescape:\n360:             words[i] = escape(word)\n361:     return ''.join(words)\n362: \n363: \n364:     \"\"\nCode replaced for brevity.\n369: \n370: \n371: \n372:     \"\"\nCode replaced for brevity.\n390: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/html.py",
      "suspect_lines": [
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        46,
        262,
        263,
        264,
        265,
        266,
        267,
        268,
        269,
        270,
        295,
        332,
        334
      ]
    }
  ]
}