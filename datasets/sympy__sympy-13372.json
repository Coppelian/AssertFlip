{
  "instance_id": "sympy__sympy-13372",
  "problem_statement": "UnboundLocalError in evalf\n```\r\n>>> Mul(x, Max(0, y), evaluate=False).evalf()\r\nx*Max(0, y)\r\n>>> Mul(Max(0, y), x, evaluate=False).evalf()\r\nTraceback (most recent call last):\r\n  File \"./sympy/core/evalf.py\", line 1285, in evalf\r\n    rf = evalf_table[x.func]\r\nKeyError: Max\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"./sympy/core/evalf.py\", line 1394, in evalf\r\n    result = evalf(self, prec + 4, options)\r\n  File \"./sympy/core/evalf.py\", line 1286, in evalf\r\n    r = rf(x, prec, options)\r\n  File \"./sympy/core/evalf.py\", line 538, in evalf_mul\r\n    arg = evalf(arg, prec, options)\r\n  File \"./sympy/core/evalf.py\", line 1308, in evalf\r\n    r = re, im, reprec, imprec\r\nUnboundLocalError: local variable 'reprec' referenced before assignment\r\n```\r\n\r\nI found this after changing the order of Mul args in https://github.com/sympy/sympy/pull/13059.\r\n\r\nBased on the code, I think the elif clauses that define reprec and imprec should have an `else: raise NotImplementedError`. That appears to fix it, although I didn't try to debug to see why the arg order is mattering here. \n",
  "localized_code": "[start of sympy/core/evalf.py]\n1: \"\"\"\n2: Adaptive numerical evaluation of SymPy expressions, using mpmath\n3: for mathematical functions.\n4: \"\"\"\n5: from __future__ import print_function, division\n6: \n7: import math\n8: \n9: import mpmath.libmp as libmp\n10: from mpmath import (\n11:     make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec)\n12: from mpmath import inf as mpmath_inf\n13: from mpmath.libmp import (from_int, from_man_exp, from_rational, fhalf,\n14:         fnan, fnone, fone, fzero, mpf_abs, mpf_add,\n15:         mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt,\n16:         mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin,\n17:         mpf_sqrt, normalize, round_nearest, to_int, to_str)\n18: from mpmath.libmp import bitcount as mpmath_bitcount\n19: from mpmath.libmp.backend import MPZ\n20: from mpmath.libmp.libmpc import _infs_nan\n21: from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps\n22: from mpmath.libmp.gammazeta import mpf_bernoulli\n23: \n24: from .compatibility import SYMPY_INTS, range\n25: from .sympify import sympify\n26: from .singleton import S\n27: \n28: from sympy.utilities.iterables import is_sequence\n29: \n30: LG10 = math.log(10, 2)\n31: rnd = round_nearest\n32: \n33: \n34: def bitcount(n):\n35:     \"\"\"Return smallest integer, b, such that |n|/2**b < 1.\n36:     \"\"\"\n37:     return mpmath_bitcount(abs(int(n)))\n38: \n39: # Used in a few places as placeholder values to denote exponents and\n40: # precision levels, e.g. of exact numbers. Must be careful to avoid\n41: # passing these to mpmath functions or returning them in final results.\n42: INF = float(mpmath_inf)\n43: MINUS_INF = float(-mpmath_inf)\n44: \n45: # ~= 100 digits. Real men set this to INF.\n46: DEFAULT_MAXPREC = 333\n47: \n48: \n49: class PrecisionExhausted(ArithmeticError):\n50:     pass\n51: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/evalf.py",
      "suspect_lines": []
    }
  ]
}