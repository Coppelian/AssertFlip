{
  "instance_id": "sympy__sympy-12481",
  "problem_statement": "`Permutation` constructor fails with non-disjoint cycles\nCalling `Permutation([[0,1],[0,1]])` raises a `ValueError` instead of constructing the identity permutation.  If the cycles passed in are non-disjoint, they should be applied in left-to-right order and the resulting permutation should be returned.\r\n\r\nThis should be easy to compute.  I don't see a reason why non-disjoint cycles should be forbidden.\n",
  "localized_code": "[start of sympy/combinatorics/permutations.py]\n1: from __future__ import print_function, division\n2: \n3: import random\n4: from collections import defaultdict\n5: \n6: from sympy.core import Basic\n7: from sympy.core.compatibility import is_sequence, reduce, range, as_int\n8: from sympy.utilities.iterables import (flatten, has_variety, minlex,\n9:     has_dups, runs)\n10: from sympy.polys.polytools import lcm\n11: from sympy.matrices import zeros\n12: from mpmath.libmp.libintmath import ifac\n13: \n14: \n15: def _af_rmul(a, b):\n16:     \"\"\"\n17:     Return the product b*a; input and output are array forms. The ith value\n18:     is a[b[i]].\n19: \n20:     Examples\n21:     ========\n22: \n23:     >>> from sympy.combinatorics.permutations import _af_rmul, Permutation\n24:     >>> Permutation.print_cyclic = False\n25: \n26:     >>> a, b = [1, 0, 2], [0, 2, 1]\n27:     >>> _af_rmul(a, b)\n28:     [1, 2, 0]\n29:     >>> [a[b[i]] for i in range(3)]\n30:     [1, 2, 0]\n31: \n32:     This handles the operands in reverse order compared to the ``*`` operator:\n33: \n34:     >>> a = Permutation(a)\n35:     >>> b = Permutation(b)\n36:     >>> list(a*b)\n37:     [2, 0, 1]\n38:     >>> [b(a(i)) for i in range(3)]\n39:     [2, 0, 1]\n40: \n41:     See Also\n42:     ========\n43:     rmul, _af_rmuln\n44:     \"\"\"\n45:     return [a[i] for i in b]\n46: \n47: \n48: def _af_rmuln(*abc):\n49:     \"\"\"\n50:     Given [a, b, c, ...] return the product of ...*c*b*a using array forms.\n51:     The ith value is a[b[c[i]]].\n52: \n53:     Examples\n54:     ========\n55: \n56:     >>> from sympy.combinatorics.permutations import _af_rmul, Permutation\n57:     >>> Permutation.print_cyclic = False\n58: \n59:     >>> a, b = [1, 0, 2], [0, 2, 1]\n60:     >>> _af_rmul(a, b)\n61:     [1, 2, 0]\n62:     >>> [a[b[i]] for i in range(3)]\n63:     [1, 2, 0]\n64: \n65:     This handles the operands in reverse order compared to the ``*`` operator:\n66: \n67:     >>> a = Permutation(a); b = Permutation(b)\n68:     >>> list(a*b)\n69:     [2, 0, 1]\n70:     >>> [b(a(i)) for i in range(3)]\n71:     [2, 0, 1]\n72: \n73:     See Also\n74:     ========\n75:     rmul, _af_rmul\n76:     \"\"\"\n77:     a = abc\n78:     m = len(a)\n79:     if m == 3:\n80:         p0, p1, p2 = a\n81:         return [p0[p1[i]] for i in p2]\n82:     if m == 4:\n83:         p0, p1, p2, p3 = a\n84:         return [p0[p1[p2[i]]] for i in p3]\n85:     if m == 5:\n86:         p0, p1, p2, p3, p4 = a\n87:         return [p0[p1[p2[p3[i]]]] for i in p4]\n88:     if m == 6:\n89:         p0, p1, p2, p3, p4, p5 = a\n90:         return [p0[p1[p2[p3[p4[i]]]]] for i in p5]\n91:     if m == 7:\n92:         p0, p1, p2, p3, p4, p5, p6 = a\n93:         return [p0[p1[p2[p3[p4[p5[i]]]]]] for i in p6]\n94:     if m == 8:\n95:         p0, p1, p2, p3, p4, p5, p6, p7 = a\n96:         return [p0[p1[p2[p3[p4[p5[p6[i]]]]]]] for i in p7]\n97:     if m == 1:\n98:         return a[0][:]\n99:     if m == 2:\n100:         a, b = a\n101:         return [a[i] for i in b]\n102:     if m == 0:\n103:         raise ValueError(\"String must not be empty\")\n104:     p0 = _af_rmuln(*a[:m//2])\n105:     p1 = _af_rmuln(*a[m//2:])\n106:     return [p0[i] for i in p1]\n107: \n108: \n109: def _af_parity(pi):\nCode replaced for brevity.\n142: \n143: \n144: \n145: def _af_invert(a):\nCode replaced for brevity.\n167: \n168: \n169: def _af_pow(a, n):\nCode replaced for brevity.\n211: \n212: \n213: def _af_commutes_with(a, b):\nCode replaced for brevity.\n230: \n231: \n232: \n233: class Cycle(dict):\nCode replaced for brevity.\n462: \n463: \n464: class Permutation(Basic):\n465:     \"\"\"\n466:     A permutation, alternatively known as an 'arrangement number' or 'ordering'\n467:     is an arrangement of the elements of an ordered list into a one-to-one\n468:     mapping with itself. The permutation of a given arrangement is given by\n469:     indicating the positions of the elements after re-arrangement [2]_. For\n470:     example, if one started with elements [x, y, a, b] (in that order) and\n471:     they were reordered as [x, y, b, a] then the permutation would be\n472:     [0, 1, 3, 2]. Notice that (in SymPy) the first element is always referred\n473:     to as 0 and the permutation uses the indices of the elements in the\n474:     original ordering, not the elements (a, b, etc...) themselves.\n475: \n476:     >>> from sympy.combinatorics import Permutation\n477:     >>> Permutation.print_cyclic = False\n478: \n479:     Permutations Notation\n480:     =====================\n481: \n482:     Permutations are commonly represented in disjoint cycle or array forms.\n483: \n484:     Array Notation and 2-line Form\n485:     ------------------------------------\n486: \n487:     In the 2-line form, the elements and their final positions are shown\n488:     as a matrix with 2 rows:\n489: \n490:     [0    1    2     ... n-1]\n491:     [p(0) p(1) p(2)  ... p(n-1)]\n492: \n493:     Since the first line is always range(n), where n is the size of p,\n494:     it is sufficient to represent the permutation by the second line,\n495:     referred to as the \"array form\" of the permutation. This is entered\n496:     in brackets as the argument to the Permutation class:\n497: \n498:     >>> p = Permutation([0, 2, 1]); p\n499:     Permutation([0, 2, 1])\n500: \n501:     Given i in range(p.size), the permutation maps i to i^p\n502: \n503:     >>> [i^p for i in range(p.size)]\n504:     [0, 2, 1]\n505: \n506:     The composite of two permutations p*q means first apply p, then q, so\n507:     i^(p*q) = (i^p)^q which is i^p^q according to Python precedence rules:\n508: \n509:     >>> q = Permutation([2, 1, 0])\n510:     >>> [i^p^q for i in range(3)]\n511:     [2, 0, 1]\n512:     >>> [i^(p*q) for i in range(3)]\n513:     [2, 0, 1]\n514: \n515:     One can use also the notation p(i) = i^p, but then the composition\n516:     rule is (p*q)(i) = q(p(i)), not p(q(i)):\n517: \n518:     >>> [(p*q)(i) for i in range(p.size)]\n519:     [2, 0, 1]\n520:     >>> [q(p(i)) for i in range(p.size)]\n521:     [2, 0, 1]\n522:     >>> [p(q(i)) for i in range(p.size)]\n523:     [1, 2, 0]\n524: \n525:     Disjoint Cycle Notation\n526:     -----------------------\n527: \n528:     In disjoint cycle notation, only the elements that have shifted are\n529:     indicated. In the above case, the 2 and 1 switched places. This can\n530:     be entered in two ways:\n531: \n532:     >>> Permutation(1, 2) == Permutation([[1, 2]]) == p\n533:     True\n534: \n535:     Only the relative ordering of elements in a cycle matter:\n536: \n537:     >>> Permutation(1,2,3) == Permutation(2,3,1) == Permutation(3,1,2)\n538:     True\n539: \n540:     The disjoint cycle notation is convenient when representing permutations\n541:     that have several cycles in them:\n542: \n543:     >>> Permutation(1, 2)(3, 5) == Permutation([[1, 2], [3, 5]])\n544:     True\n545: \n546:     It also provides some economy in entry when computing products of\n547:     permutations that are written in disjoint cycle notation:\n548: \n549:     >>> Permutation(1, 2)(1, 3)(2, 3)\n550:     Permutation([0, 3, 2, 1])\n551:     >>> _ == Permutation([[1, 2]])*Permutation([[1, 3]])*Permutation([[2, 3]])\n552:     True\n553: \n554:     Entering a singleton in a permutation is a way to indicate the size of the\n555:     permutation. The ``size`` keyword can also be used.\n556: \n557:     Array-form entry:\n558: \n559:     >>> Permutation([[1, 2], [9]])\n560:     Permutation([0, 2, 1], size=10)\n561:     >>> Permutation([[1, 2]], size=10)\n562:     Permutation([0, 2, 1], size=10)\n563: \n564:     Cyclic-form entry:\n565: \n566:     >>> Permutation(1, 2, size=10)\n567:     Permutation([0, 2, 1], size=10)\n568:     >>> Permutation(9)(1, 2)\n569:     Permutation([0, 2, 1], size=10)\n570: \n571:     Caution: no singleton containing an element larger than the largest\n572:     in any previous cycle can be entered. This is an important difference\n573:     in how Permutation and Cycle handle the __call__ syntax. A singleton\n574:     argument at the start of a Permutation performs instantiation of the\n575:     Permutation and is permitted:\n576: \n577:     >>> Permutation(5)\n578:     Permutation([], size=6)\n579: \n580:     A singleton entered after instantiation is a call to the permutation\n581:     -- a function call -- and if the argument is out of range it will\n582:     trigger an error. For this reason, it is better to start the cycle\n583:     with the singleton:\n584: \n585:     The following fails because there is is no element 3:\n586: \n587:     >>> Permutation(1, 2)(3)\n588:     Traceback (most recent call last):\n589:     ...\n590:     IndexError: list index out of range\n591: \n592:     This is ok: only the call to an out of range singleton is prohibited;\n593:     otherwise the permutation autosizes:\n594: \n595:     >>> Permutation(3)(1, 2)\n596:     Permutation([0, 2, 1, 3])\n597:     >>> Permutation(1, 2)(3, 4) == Permutation(3, 4)(1, 2)\n598:     True\n599: \n600: \n601:     Equality testing\n602:     ----------------\n603: \n604:     The array forms must be the same in order for permutations to be equal:\n605: \n606:     >>> Permutation([1, 0, 2, 3]) == Permutation([1, 0])\n607:     False\n608: \n609: \n610:     Identity Permutation\n611:     --------------------\n612: \n613:     The identity permutation is a permutation in which no element is out of\n614:     place. It can be entered in a variety of ways. All the following create\n615:     an identity permutation of size 4:\n616: \n617:     >>> I = Permutation([0, 1, 2, 3])\n618:     >>> all(p == I for p in [\n619:     ... Permutation(3),\n620:     ... Permutation(range(4)),\n621:     ... Permutation([], size=4),\n622:     ... Permutation(size=4)])\n623:     True\n624: \n625:     Watch out for entering the range *inside* a set of brackets (which is\n626:     cycle notation):\n627: \n628:     >>> I == Permutation([range(4)])\n629:     False\n630: \n631: \n632:     Permutation Printing\n633:     ====================\n634: \n635:     There are a few things to note about how Permutations are printed.\n636: \n637:     1) If you prefer one form (array or cycle) over another, you can set that\n638:     with the print_cyclic flag.\n639: \n640:     >>> Permutation(1, 2)(4, 5)(3, 4)\n641:     Permutation([0, 2, 1, 4, 5, 3])\n642:     >>> p = _\n643: \n644:     >>> Permutation.print_cyclic = True\n645:     >>> p\n646:     (1 2)(3 4 5)\n647:     >>> Permutation.print_cyclic = False\n648: \n649:     2) Regardless of the setting, a list of elements in the array for cyclic\n650:     form can be obtained and either of those can be copied and supplied as\n651:     the argument to Permutation:\n652: \n653:     >>> p.array_form\n654:     [0, 2, 1, 4, 5, 3]\n655:     >>> p.cyclic_form\n656:     [[1, 2], [3, 4, 5]]\n657:     >>> Permutation(_) == p\n658:     True\n659: \n660:     3) Printing is economical in that as little as possible is printed while\n661:     retaining all information about the size of the permutation:\n662: \n663:     >>> Permutation([1, 0, 2, 3])\n664:     Permutation([1, 0, 2, 3])\n665:     >>> Permutation([1, 0, 2, 3], size=20)\n666:     Permutation([1, 0], size=20)\n667:     >>> Permutation([1, 0, 2, 4, 3, 5, 6], size=20)\n668:     Permutation([1, 0, 2, 4, 3], size=20)\n669: \n670:     >>> p = Permutation([1, 0, 2, 3])\n671:     >>> Permutation.print_cyclic = True\n672:     >>> p\n673:     (3)(0 1)\n674:     >>> Permutation.print_cyclic = False\n675: \n676:     The 2 was not printed but it is still there as can be seen with the\n677:     array_form and size methods:\n678: \n679:     >>> p.array_form\n680:     [1, 0, 2, 3]\n681:     >>> p.size\n682:     4\n683: \n684:     Short introduction to other methods\n685:     ===================================\n686: \n687:     The permutation can act as a bijective function, telling what element is\n688:     located at a given position\n689: \n690:     >>> q = Permutation([5, 2, 3, 4, 1, 0])\n691:     >>> q.array_form[1] # the hard way\n692:     2\n693:     >>> q(1) # the easy way\n694:     2\n695:     >>> {i: q(i) for i in range(q.size)} # showing the bijection\n696:     {0: 5, 1: 2, 2: 3, 3: 4, 4: 1, 5: 0}\n697: \n698:     The full cyclic form (including singletons) can be obtained:\n699: \n700:     >>> p.full_cyclic_form\n701:     [[0, 1], [2], [3]]\n702: \n703:     Any permutation can be factored into transpositions of pairs of elements:\n704: \n705:     >>> Permutation([[1, 2], [3, 4, 5]]).transpositions()\n706:     [(1, 2), (3, 5), (3, 4)]\n707:     >>> Permutation.rmul(*[Permutation([ti], size=6) for ti in _]).cyclic_form\n708:     [[1, 2], [3, 4, 5]]\n709: \n710:     The number of permutations on a set of n elements is given by n! and is\n711:     called the cardinality.\n712: \n713:     >>> p.size\n714:     4\n715:     >>> p.cardinality\n716:     24\n717: \n718:     A given permutation has a rank among all the possible permutations of the\n719:     same elements, but what that rank is depends on how the permutations are\n720:     enumerated. (There are a number of different methods of doing so.) The\n721:     lexicographic rank is given by the rank method and this rank is used to\n722:     increment a permutation with addition/subtraction:\n723: \n724:     >>> p.rank()\n725:     6\n726:     >>> p + 1\n727:     Permutation([1, 0, 3, 2])\n728:     >>> p.next_lex()\n729:     Permutation([1, 0, 3, 2])\n730:     >>> _.rank()\n731:     7\n732:     >>> p.unrank_lex(p.size, rank=7)\n733:     Permutation([1, 0, 3, 2])\n734: \n735:     The product of two permutations p and q is defined as their composition as\n736:     functions, (p*q)(i) = q(p(i)) [6]_.\n737: \n738:     >>> p = Permutation([1, 0, 2, 3])\n739:     >>> q = Permutation([2, 3, 1, 0])\n740:     >>> list(q*p)\n741:     [2, 3, 0, 1]\n742:     >>> list(p*q)\n743:     [3, 2, 1, 0]\n744:     >>> [q(p(i)) for i in range(p.size)]\n745:     [3, 2, 1, 0]\n746: \n747:     The permutation can be 'applied' to any list-like object, not only\n748:     Permutations:\n749: \n750:     >>> p(['zero', 'one', 'four', 'two'])\n751:      ['one', 'zero', 'four', 'two']\n752:     >>> p('zo42')\n753:     ['o', 'z', '4', '2']\n754: \n755:     If you have a list of arbitrary elements, the corresponding permutation\n756:     can be found with the from_sequence method:\n757: \n758:     >>> Permutation.from_sequence('SymPy')\n759:     Permutation([1, 3, 2, 0, 4])\n760: \n761:     See Also\n762:     ========\n763: \n764:     Cycle\n765: \n766:     References\n767:     ==========\n768: \n769:     .. [1] Skiena, S. 'Permutations.' 1.1 in Implementing Discrete Mathematics\n770:            Combinatorics and Graph Theory with Mathematica.  Reading, MA:\n771:            Addison-Wesley, pp. 3-16, 1990.\n772: \n773:     .. [2] Knuth, D. E. The Art of Computer Programming, Vol. 4: Combinatorial\n774:            Algorithms, 1st ed. Reading, MA: Addison-Wesley, 2011.\n775: \n776:     .. [3] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking\n777:            permutations in linear time. Inf. Process. Lett. 79, 6 (September 2001),\n778:            281-284. DOI=10.1016/S0020-0190(01)00141-7\n779: \n780:     .. [4] D. L. Kreher, D. R. Stinson 'Combinatorial Algorithms'\n781:            CRC Press, 1999\n782: \n783:     .. [5] Graham, R. L.; Knuth, D. E.; and Patashnik, O.\n784:            Concrete Mathematics: A Foundation for Computer Science, 2nd ed.\n785:            Reading, MA: Addison-Wesley, 1994.\n786: \n787:     .. [6] http://en.wikipedia.org/wiki/Permutation#Product_and_inverse\n788: \n789:     .. [7] http://en.wikipedia.org/wiki/Lehmer_code\n790: \n791:     \"\"\"\n792: \n793:     is_Permutation = True\n794: \n795:     _array_form = None\n796:     _cyclic_form = None\n797:     _cycle_structure = None\n798:     _size = None\n799:     _rank = None\n800: \n801:     def __new__(cls, *args, **kwargs):\n802:         \"\"\"\n803:         Constructor for the Permutation object from a list or a\n804:         list of lists in which all elements of the permutation may\n805:         appear only once.\n806: \n807:         Examples\n808:         ========\n809: \n810:         >>> from sympy.combinatorics.permutations import Permutation\n811:         >>> Permutation.print_cyclic = False\n812: \n813:         Permutations entered in array-form are left unaltered:\n814: \n815:         >>> Permutation([0, 2, 1])\n816:         Permutation([0, 2, 1])\n817: \n818:         Permutations entered in cyclic form are converted to array form;\n819:         singletons need not be entered, but can be entered to indicate the\n820:         largest element:\n821: \n822:         >>> Permutation([[4, 5, 6], [0, 1]])\n823:         Permutation([1, 0, 2, 3, 5, 6, 4])\n824:         >>> Permutation([[4, 5, 6], [0, 1], [19]])\n825:         Permutation([1, 0, 2, 3, 5, 6, 4], size=20)\n826: \n827:         All manipulation of permutations assumes that the smallest element\n828:         is 0 (in keeping with 0-based indexing in Python) so if the 0 is\n829:         missing when entering a permutation in array form, an error will be\n830:         raised:\n831: \n832:         >>> Permutation([2, 1])\n833:         Traceback (most recent call last):\n834:         ...\n835:         ValueError: Integers 0 through 2 must be present.\n836: \n837:         If a permutation is entered in cyclic form, it can be entered without\n838:         singletons and the ``size`` specified so those values can be filled\n839:         in, otherwise the array form will only extend to the maximum value\n840:         in the cycles:\n841: \n842:         >>> Permutation([[1, 4], [3, 5, 2]], size=10)\n843:         Permutation([0, 4, 3, 5, 1, 2], size=10)\n844:         >>> _.array_form\n845:         [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]\n846:         \"\"\"\n847:         size = kwargs.pop('size', None)\n848:         if size is not None:\n849:             size = int(size)\n850: \n851:         #a) ()\n852:         #b) (1) = identity\n853:         #c) (1, 2) = cycle\n854:         #d) ([1, 2, 3]) = array form\n855:         #e) ([[1, 2]]) = cyclic form\n856:         #f) (Cycle) = conversion to permutation\n857:         #g) (Permutation) = adjust size or return copy\n858:         ok = True\n859:         if not args:  # a\n860:             return _af_new(list(range(size or 0)))\n861:         elif len(args) > 1:  # c\n862:             return _af_new(Cycle(*args).list(size))\n863:         if len(args) == 1:\n864:             a = args[0]\n865:             if isinstance(a, Perm):  # g\n866:                 if size is None or size == a.size:\n867:                     return a\n868:                 return Perm(a.array_form, size=size)\n869:             if isinstance(a, Cycle):  # f\n870:                 return _af_new(a.list(size))\n871:             if not is_sequence(a):  # b\n872:                 return _af_new(list(range(a + 1)))\n873:             if has_variety(is_sequence(ai) for ai in a):\n874:                 ok = False\n875:         else:\n876:             ok = False\n877:         if not ok:\n878:             raise ValueError(\"Permutation argument must be a list of ints, \"\n879:                              \"a list of lists, Permutation or Cycle.\")\n880: \n881: \n882:         # safe to assume args are valid; this also makes a copy\n883:         # of the args\n884:         args = list(args[0])\n885: \n886:         is_cycle = args and is_sequence(args[0])\n887:         if is_cycle:  # e\n888:             args = [[int(i) for i in c] for c in args]\n889:         else:  # d\n890:             args = [int(i) for i in args]\n891: \n892:         # if there are n elements present, 0, 1, ..., n-1 should be present\n893:         # unless a cycle notation has been provided. A 0 will be added\n894:         # for convenience in case one wants to enter permutations where\n895:         # counting starts from 1.\n896: \n897:         temp = flatten(args)\n898:         if has_dups(temp):\n899:             if is_cycle:\n900:                 raise ValueError('there were repeated elements; to resolve '\n901:                 'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n902:             else:\n903:                 raise ValueError('there were repeated elements.')\n904:         temp = set(temp)\n905: \n906:         if not is_cycle and \\\n907:                 any(i not in temp for i in range(len(temp))):\n908:             raise ValueError(\"Integers 0 through %s must be present.\" %\n909:                              max(temp))\n910: \n911:         if is_cycle:\n912:             # it's not necessarily canonical so we won't store\n913:             # it -- use the array form instead\n914:             c = Cycle()\n915:             for ci in args:\n916:                 c = c(*ci)\n917:             aform = c.list()\n918:         else:\n919:             aform = list(args)\n920:         if size and size > len(aform):\n921:             # don't allow for truncation of permutation which\n922:             # might split a cycle and lead to an invalid aform\n923:             # but do allow the permutation size to be increased\n924:             aform.extend(list(range(len(aform), size)))\n925:         size = len(aform)\n926:         obj = Basic.__new__(cls, aform)\n927:         obj._array_form = aform\n928:         obj._size = size\n929:         return obj\n930: \n931:     @staticmethod\n932:     def _af_new(perm):\n933:         \"\"\"A method to produce a Permutation object from a list;\n934:         the list is bound to the _array_form attribute, so it must\n935:         not be modified; this method is meant for internal use only;\n936:         the list ``a`` is supposed to be generated as a temporary value\n937:         in a method, so p = Perm._af_new(a) is the only object\n938:         to hold a reference to ``a``::\n939: \n940:         Examples\n941:         ========\n942: \n943:         >>> from sympy.combinatorics.permutations import Perm\n944:         >>> Perm.print_cyclic = False\n945:         >>> a = [2,1,3,0]\n946:         >>> p = Perm._af_new(a)\n947:         >>> p\n948:         Permutation([2, 1, 3, 0])\n949: \n950:         \"\"\"\n951:         p = Basic.__new__(Perm, perm)\n952:         p._array_form = perm\n953:         p._size = len(perm)\n954:         return p\n955: \n956:     def _hashable_content(self):\n957:         # the array_form (a list) is the Permutation arg, so we need to\n958:         # return a tuple, instead\n959:         return tuple(self.array_form)\n960: \n961:     @property\n962:     def array_form(self):\n963:         \"\"\"\n964:         Return a copy of the attribute _array_form\n965:         Examples\n966:         ========\n967: \n968:         >>> from sympy.combinatorics.permutations import Permutation\n969:         >>> Permutation.print_cyclic = False\n970:         >>> p = Permutation([[2, 0], [3, 1]])\n971:         >>> p.array_form\n972:         [2, 3, 0, 1]\n973:         >>> Permutation([[2, 0, 3, 1]]).array_form\n974:         [3, 2, 0, 1]\n975:         >>> Permutation([2, 0, 3, 1]).array_form\n976:         [2, 0, 3, 1]\n977:         >>> Permutation([[1, 2], [4, 5]]).array_form\n978:         [0, 2, 1, 3, 5, 4]\n979:         \"\"\"\n980:         return self._array_form[:]\n981: \n982:     def __repr__(self):\n983:         from sympy.combinatorics.permutations import Permutation, Cycle\n984:         if Permutation.print_cyclic:\n985:             if not self.size:\n986:                 return 'Permutation()'\n987:             # before taking Cycle notation, see if the last element is\n988:             # a singleton and move it to the head of the string\n989:             s = Cycle(self)(self.size - 1).__repr__()[len('Cycle'):]\n990:             last = s.rfind('(')\n991:             if not last == 0 and ',' not in s[last:]:\n992:                 s = s[last:] + s[:last]\n993:             return 'Permutation%s' %s\n994:         else:\n995:             s = self.support()\n996:             if not s:\n997:                 if self.size < 5:\n998:                     return 'Permutation(%s)' % str(self.array_form)\n999:                 return 'Permutation([], size=%s)' % self.size\n1000:             trim = str(self.array_form[:s[-1] + 1]) + ', size=%s' % self.size\n1001:             use = full = str(self.array_form)\n1002:             if len(trim) < len(full):\n1003:                 use = trim\n1004:             return 'Permutation(%s)' % use\n1005: \n1006:     def list(self, size=None):\n1007:         \"\"\"Return the permutation as an explicit list, possibly\n1008:         trimming unmoved elements if size is less than the maximum\n1009:         element in the permutation; if this is desired, setting\n1010:         ``size=-1`` will guarantee such trimming.\n1011: \n1012:         Examples\n1013:         ========\n1014: \n1015:         >>> from sympy.combinatorics.permutations import Permutation\n1016:         >>> Permutation.print_cyclic = False\n1017:         >>> p = Permutation(2, 3)(4, 5)\n1018:         >>> p.list()\n1019:         [0, 1, 3, 2, 5, 4]\n1020:         >>> p.list(10)\n1021:         [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]\n1022: \n1023:         Passing a length too small will trim trailing, unchanged elements\n1024:         in the permutation:\n1025: \n1026:         >>> Permutation(2, 4)(1, 2, 4).list(-1)\n1027:         [0, 2, 1]\n1028:         >>> Permutation(3).list(-1)\n1029:         []\n1030:         \"\"\"\n1031:         if not self and size is None:\n1032:             raise ValueError('must give size for empty Cycle')\n1033:         rv = self.array_form\n1034:         if size is not None:\n1035:             if size > self.size:\n1036:                 rv.extend(list(range(self.size, size)))\n1037:             else:\n1038:                 # find first value from rhs where rv[i] != i\n1039:                 i = self.size - 1\n1040:                 while rv:\n1041:                     if rv[-1] != i:\n1042:                         break\n1043:                     rv.pop()\n1044:                     i -= 1\n1045:         return rv\n1046: \n1047:     @property\n1048:     def cyclic_form(self):\n1049:         \"\"\"\n1050:         This is used to convert to the cyclic notation\n1051:         from the canonical notation. Singletons are omitted.\n1052: \n1053:         Examples\n1054:         ========\n1055: \n1056:         >>> from sympy.combinatorics.permutations import Permutation\n1057:         >>> Permutation.print_cyclic = False\n1058:         >>> p = Permutation([0, 3, 1, 2])\n1059:         >>> p.cyclic_form\n1060:         [[1, 3, 2]]\n1061:         >>> Permutation([1, 0, 2, 4, 3, 5]).cyclic_form\n1062:         [[0, 1], [3, 4]]\n1063: \n1064:         See Also\n1065:         ========\n1066: \n1067:         array_form, full_cyclic_form\n1068:         \"\"\"\n1069:         if self._cyclic_form is not None:\n1070:             return list(self._cyclic_form)\n1071:         array_form = self.array_form\n1072:         unchecked = [True] * len(array_form)\n1073:         cyclic_form = []\n1074:         for i in range(len(array_form)):\n1075:             if unchecked[i]:\n1076:                 cycle = []\n1077:                 cycle.append(i)\n1078:                 unchecked[i] = False\n1079:                 j = i\n1080:                 while unchecked[array_form[j]]:\n1081:                     j = array_form[j]\n1082:                     cycle.append(j)\n1083:                     unchecked[j] = False\n1084:                 if len(cycle) > 1:\n1085:                     cyclic_form.append(cycle)\n1086:                     assert cycle == list(minlex(cycle, is_set=True))\n1087:         cyclic_form.sort()\n1088:         self._cyclic_form = cyclic_form[:]\n1089:         return cyclic_form\n1090: \n1091:     @property\n1092:     def full_cyclic_form(self):\n1093:         \"\"\"Return permutation in cyclic form including singletons.\n1094: \n1095:         Examples\n1096:         ========\n1097: \n1098:         >>> from sympy.combinatorics.permutations import Permutation\n1099:         >>> Permutation([0, 2, 1]).full_cyclic_form\n1100:         [[0], [1, 2]]\n1101:         \"\"\"\n1102:         need = set(range(self.size)) - set(flatten(self.cyclic_form))\n1103:         rv = self.cyclic_form\n1104:         rv.extend([[i] for i in need])\n1105:         rv.sort()\n1106:         return rv\n1107: \n1108:     @property\n1109:     def size(self):\n1110:         \"\"\"\n1111:         Returns the number of elements in the permutation.\n1112: \n1113:         Examples\n1114:         ========\n1115: \n1116:         >>> from sympy.combinatorics import Permutation\n1117:         >>> Permutation([[3, 2], [0, 1]]).size\n1118:         4\n1119: \n1120:         See Also\n1121:         ========\n1122: \n1123:         cardinality, length, order, rank\n1124:         \"\"\"\n1125:         return self._size\n1126: \n1127:     def support(self):\n1128:         \"\"\"Return the elements in permutation, P, for which P[i] != i.\n1129: \n1130:         Examples\n1131:         ========\n1132: \n1133:         >>> from sympy.combinatorics import Permutation\n1134:         >>> p = Permutation([[3, 2], [0, 1], [4]])\n1135:         >>> p.array_form\n1136:         [1, 0, 3, 2, 4]\n1137:         >>> p.support()\n1138:         [0, 1, 2, 3]\n1139:         \"\"\"\n1140:         a = self.array_form\n1141:         return [i for i, e in enumerate(a) if a[i] != i]\n1142: \n1143:     def __add__(self, other):\n1144:         \"\"\"Return permutation that is other higher in rank than self.\n1145: \n1146:         The rank is the lexicographical rank, with the identity permutation\n1147:         having rank of 0.\n1148: \n1149:         Examples\n1150:         ========\n1151: \n1152:         >>> from sympy.combinatorics.permutations import Permutation\n1153:         >>> Permutation.print_cyclic = False\n1154:         >>> I = Permutation([0, 1, 2, 3])\n1155:         >>> a = Permutation([2, 1, 3, 0])\n1156:         >>> I + a.rank() == a\n1157:         True\n1158: \n1159:         See Also\n1160:         ========\n1161: \n1162:         __sub__, inversion_vector\n1163: \n1164:         \"\"\"\n1165:         rank = (self.rank() + other) % self.cardinality\n1166:         rv = Perm.unrank_lex(self.size, rank)\n1167:         rv._rank = rank\n1168:         return rv\n1169: \n1170:     def __sub__(self, other):\n1171:         \"\"\"Return the permutation that is other lower in rank than self.\n1172: \n1173:         See Also\n1174:         ========\n1175: \n1176:         __add__\n1177:         \"\"\"\n1178:         return self.__add__(-other)\n1179: \n1180:     @staticmethod\n1181:     def rmul(*args):\n1182:         \"\"\"\n1183:         Return product of Permutations [a, b, c, ...] as the Permutation whose\n1184:         ith value is a(b(c(i))).\n1185: \n1186:         a, b, c, ... can be Permutation objects or tuples.\n1187: \n1188:         Examples\n1189:         ========\n1190: \n1191:         >>> from sympy.combinatorics.permutations import _af_rmul, Permutation\n1192:         >>> Permutation.print_cyclic = False\n1193: \n1194:         >>> a, b = [1, 0, 2], [0, 2, 1]\n1195:         >>> a = Permutation(a); b = Permutation(b)\n1196:         >>> list(Permutation.rmul(a, b))\n1197:         [1, 2, 0]\n1198:         >>> [a(b(i)) for i in range(3)]\n1199:         [1, 2, 0]\n1200: \n1201:         This handles the operands in reverse order compared to the ``*`` operator:\n1202: \n1203:         >>> a = Permutation(a); b = Permutation(b)\n1204:         >>> list(a*b)\n1205:         [2, 0, 1]\n1206:         >>> [b(a(i)) for i in range(3)]\n1207:         [2, 0, 1]\n1208: \n1209:         Notes\n1210:         =====\n1211: \n1212:         All items in the sequence will be parsed by Permutation as\n1213:         necessary as long as the first item is a Permutation:\n1214: \n1215:         >>> Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)\n1216:         True\n1217: \n1218:         The reverse order of arguments will raise a TypeError.\n1219: \n1220:         \"\"\"\n1221:         rv = args[0]\n1222:         for i in range(1, len(args)):\n1223:             rv = args[i]*rv\n1224:         return rv\n1225: \n1226:     @staticmethod\n1227:     def rmul_with_af(*args):\n1228:         \"\"\"\n1229:         same as rmul, but the elements of args are Permutation objects\n1230:         which have _array_form\n1231:         \"\"\"\n1232:         a = [x._array_form for x in args]\n1233:         rv = _af_new(_af_rmuln(*a))\n1234:         return rv\n1235: \n1236:     def mul_inv(self, other):\n1237:         \"\"\"\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/combinatorics/permutations.py",
      "suspect_lines": [
        898,
        899,
        900,
        901,
        902,
        903
      ]
    }
  ]
}