{
  "instance_id": "sympy__sympy-18189",
  "problem_statement": "diophantine: incomplete results depending on syms order with permute=True\n```\r\nIn [10]: diophantine(n**4 + m**4 - 2**4 - 3**4, syms=(m,n), permute=True)\r\nOut[10]: {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\r\n\r\nIn [11]: diophantine(n**4 + m**4 - 2**4 - 3**4, syms=(n,m), permute=True)\r\nOut[11]: {(3, 2)}\r\n```\r\n\ndiophantine: incomplete results depending on syms order with permute=True\n```\r\nIn [10]: diophantine(n**4 + m**4 - 2**4 - 3**4, syms=(m,n), permute=True)\r\nOut[10]: {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\r\n\r\nIn [11]: diophantine(n**4 + m**4 - 2**4 - 3**4, syms=(n,m), permute=True)\r\nOut[11]: {(3, 2)}\r\n```\r\n\n",
  "localized_code": "[start of sympy/solvers/diophantine.py]\n1: from __future__ import print_function, division\n2: \n3: from sympy.core.add import Add\n4: from sympy.core.compatibility import as_int, is_sequence, range\n5: from sympy.core.exprtools import factor_terms\n6: from sympy.core.function import _mexpand\n7: from sympy.core.mul import Mul\n8: from sympy.core.numbers import Rational\n9: from sympy.core.numbers import igcdex, ilcm, igcd\n10: from sympy.core.power import integer_nthroot, isqrt\n11: from sympy.core.relational import Eq\n12: from sympy.core.singleton import S\n13: from sympy.core.symbol import Symbol, symbols\n14: from sympy.functions.elementary.complexes import sign\n15: from sympy.functions.elementary.integers import floor\n16: from sympy.functions.elementary.miscellaneous import sqrt\n17: from sympy.matrices.dense import MutableDenseMatrix as Matrix\n18: from sympy.ntheory.factor_ import (\n19:     divisors, factorint, multiplicity, perfect_power)\n20: from sympy.ntheory.generate import nextprime\n21: from sympy.ntheory.primetest import is_square, isprime\n22: from sympy.ntheory.residue_ntheory import sqrt_mod\n23: from sympy.polys.polyerrors import GeneratorsNeeded\n24: from sympy.polys.polytools import Poly, factor_list\n25: from sympy.simplify.simplify import signsimp\n26: from sympy.solvers.solvers import check_assumptions\n27: from sympy.solvers.solveset import solveset_real\n28: from sympy.utilities import default_sort_key, numbered_symbols\n29: from sympy.utilities.misc import filldedent\n30: \n31: \n32: \n33: # these are imported with 'from sympy.solvers.diophantine import *\n34: __all__ = ['diophantine', 'classify_diop']\n35: \n36: \n37: # these types are known (but not necessarily handled)\n38: diop_known = {\n39:     \"binary_quadratic\",\n40:     \"cubic_thue\",\n41:     \"general_pythagorean\",\n42:     \"general_sum_of_even_powers\",\n43:     \"general_sum_of_squares\",\n44:     \"homogeneous_general_quadratic\",\n45:     \"homogeneous_ternary_quadratic\",\n46:     \"homogeneous_ternary_quadratic_normal\",\n47:     \"inhomogeneous_general_quadratic\",\n48:     \"inhomogeneous_ternary_quadratic\",\n49:     \"linear\",\n50:     \"univariate\"}\n51: \n52: \n53: def _is_int(i):\nCode replaced for brevity.\n58: \n59: \n60: \n61: def _sorted_tuple(*i):\n62:     return tuple(sorted(i))\n63: \n64: \n65: def _remove_gcd(*x):\nCode replaced for brevity.\n77: \n78: \n79: \n80:     # return `(numer, denom)` for a/b; sign in numer and gcd removed\nCode replaced for brevity.\n82: \n83: \n84: \n85:     # return nearest int to p/q; in case of tie return floor(p/q)\nCode replaced for brevity.\n90: \n91: \n92: \n93: def _odd(i):\n94:     return i % 2 != 0\n95: \n96: \n97: def _even(i):\n98:     return i % 2 == 0\n99: \n100: \n101: def diophantine(eq, param=symbols(\"t\", integer=True), syms=None,\n102:                 permute=False):\n103:     \"\"\"\n104:     Simplify the solution procedure of diophantine equation ``eq`` by\n105:     converting it into a product of terms which should equal zero.\n106: \n107:     For example, when solving, `x^2 - y^2 = 0` this is treated as\n108:     `(x + y)(x - y) = 0` and `x + y = 0` and `x - y = 0` are solved\n109:     independently and combined. Each term is solved by calling\n110:     ``diop_solve()``. (Although it is possible to call ``diop_solve()``\n111:     directly, one must be careful to pass an equation in the correct\n112:     form and to interpret the output correctly; ``diophantine()`` is\n113:     the public-facing function to use in general.)\n114: \n115:     Output of ``diophantine()`` is a set of tuples. The elements of the\n116:     tuple are the solutions for each variable in the equation and\n117:     are arranged according to the alphabetic ordering of the variables.\n118:     e.g. For an equation with two variables, `a` and `b`, the first\n119:     element of the tuple is the solution for `a` and the second for `b`.\n120: \n121:     Usage\n122:     =====\n123: \n124:     ``diophantine(eq, t, syms)``: Solve the diophantine\n125:     equation ``eq``.\n126:     ``t`` is the optional parameter to be used by ``diop_solve()``.\n127:     ``syms`` is an optional list of symbols which determines the\n128:     order of the elements in the returned tuple.\n129: \n130:     By default, only the base solution is returned. If ``permute`` is set to\n131:     True then permutations of the base solution and/or permutations of the\n132:     signs of the values will be returned when applicable.\n133: \n134:     >>> from sympy.solvers.diophantine import diophantine\n135:     >>> from sympy.abc import a, b\n136:     >>> eq = a**4 + b**4 - (2**4 + 3**4)\n137:     >>> diophantine(eq)\n138:     {(2, 3)}\n139:     >>> diophantine(eq, permute=True)\n140:     {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n141: \n142:     Details\n143:     =======\n144: \n145:     ``eq`` should be an expression which is assumed to be zero.\n146:     ``t`` is the parameter to be used in the solution.\n147: \n148:     Examples\n149:     ========\n150: \n151:     >>> from sympy.abc import x, y, z\n152:     >>> diophantine(x**2 - y**2)\n153:     {(t_0, -t_0), (t_0, t_0)}\n154: \n155:     >>> diophantine(x*(2*x + 3*y - z))\n156:     {(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}\n157:     >>> diophantine(x**2 + 3*x*y + 4*x)\n158:     {(0, n1), (3*t_0 - 4, -t_0)}\n159: \n160:     See Also\n161:     ========\n162: \n163:     diop_solve()\n164:     sympy.utilities.iterables.permute_signs\n165:     sympy.utilities.iterables.signed_permutations\n166:     \"\"\"\n167: \n168:     from sympy.utilities.iterables import (\n169:         subsets, permute_signs, signed_permutations)\n170: \n171:     if isinstance(eq, Eq):\n172:         eq = eq.lhs - eq.rhs\n173: \n174:     try:\n175:         var = list(eq.expand(force=True).free_symbols)\n176:         var.sort(key=default_sort_key)\n177:         if syms:\n178:             if not is_sequence(syms):\n179:                 raise TypeError(\n180:                     'syms should be given as a sequence, e.g. a list')\n181:             syms = [i for i in syms if i in var]\n182:             if syms != var:\n183:                 dict_sym_index = dict(zip(syms, range(len(syms))))\n184:                 return {tuple([t[dict_sym_index[i]] for i in var])\n185:                             for t in diophantine(eq, param)}\n186:         n, d = eq.as_numer_denom()\n187:         if n.is_number:\n188:             return set()\n189:         if not d.is_number:\n190:             dsol = diophantine(d)\n191:             good = diophantine(n) - dsol\n192:             return {s for s in good if _mexpand(d.subs(zip(var, s)))}\n193:         else:\n194:             eq = n\n195:         eq = factor_terms(eq)\n196:         assert not eq.is_number\n197:         eq = eq.as_independent(*var, as_Add=False)[1]\n198:         p = Poly(eq)\n199:         assert not any(g.is_number for g in p.gens)\n200:         eq = p.as_expr()\n201:         assert eq.is_polynomial()\n202:     except (GeneratorsNeeded, AssertionError, AttributeError):\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/solvers/diophantine.py",
      "suspect_lines": [
        185
      ]
    }
  ]
}