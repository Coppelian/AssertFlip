{
  "instance_id": "django__django-12262",
  "problem_statement": "Custom template tags raise TemplateSyntaxError when keyword-only arguments with defaults are provided.\nDescription\n\t \n\t\t(last modified by P-Seebauer)\n\t \nWhen creating simple tags without variable keyword args, but an keyword argument with a default value. It's not possible to supply any other variable.\n@register.simple_tag\ndef hello(*, greeting='hello'):\n\treturn f'{greeting} world'\n{% hello greeting='hi' %}\nRaises “'hello' received unexpected keyword argument 'greeting'”\nAlso supplying a keyword argument a second time raises the wrong error message:\n#tag\n@register.simple_tag\ndef hi(*, greeting):\n\treturn f'{greeting} world'\n{% hi greeting='hi' greeting='hello' %}\nRaises “'hi' received unexpected keyword argument 'greeting'”\ninstead of \"'hi' received multiple values for keyword argument 'greeting'\"\nSame goes for inclusion tags (is the same code) I already have a fix ready, will push it after creating the ticket (that I have a ticket# for the commit).\nIs actually for all versions since the offending line is from 2.0…\n",
  "localized_code": "[start of django/template/library.py]\n1: import functools\n2: from importlib import import_module\n3: from inspect import getfullargspec, unwrap\n4: \n5: from django.utils.html import conditional_escape\n6: from django.utils.itercompat import is_iterable\n7: \n8: from .base import Node, Template, token_kwargs\n9: from .exceptions import TemplateSyntaxError\n10: \n11: \n12: class InvalidTemplateLibrary(Exception):\n13:     pass\n14: \n15: \n16: class Library:\n17:     \"\"\"\n18:     A class for registering template tags and filters. Compiled filter and\n19:     template tag functions are stored in the filters and tags attributes.\n20:     The filter, simple_tag, and inclusion_tag methods provide a convenient\n21:     way to register callables as tags.\n22:     \"\"\"\n23:     def __init__(self):\n24:         self.filters = {}\n25:         self.tags = {}\n26: \n27:     def tag(self, name=None, compile_function=None):\n28:         if name is None and compile_function is None:\n29:             # @register.tag()\n30:             return self.tag_function\n31:         elif name is not None and compile_function is None:\n32:             if callable(name):\n33:                 # @register.tag\n34:                 return self.tag_function(name)\n35:             else:\n36:                 # @register.tag('somename') or @register.tag(name='somename')\n37:                 def dec(func):\n38:                     return self.tag(name, func)\n39:                 return dec\n40:         elif name is not None and compile_function is not None:\n41:             # register.tag('somename', somefunc)\n42:             self.tags[name] = compile_function\n43:             return compile_function\n44:         else:\n45:             raise ValueError(\n46:                 \"Unsupported arguments to Library.tag: (%r, %r)\" %\n47:                 (name, compile_function),\n48:             )\n49: \n50:     def tag_function(self, func):\n51:         self.tags[getattr(func, \"_decorated_function\", func).__name__] = func\n52:         return func\n53: \n54:     def filter(self, name=None, filter_func=None, **flags):\n55:         \"\"\"\n56:         Register a callable as a template filter. Example:\n57: \n58:         @register.filter\n59:         def lower(value):\n60:             return value.lower()\n61:         \"\"\"\n62:         if name is None and filter_func is None:\n63:             # @register.filter()\n64:             def dec(func):\n65:                 return self.filter_function(func, **flags)\n66:             return dec\n67:         elif name is not None and filter_func is None:\n68:             if callable(name):\n69:                 # @register.filter\n70:                 return self.filter_function(name, **flags)\n71:             else:\n72:                 # @register.filter('somename') or @register.filter(name='somename')\n73:                 def dec(func):\n74:                     return self.filter(name, func, **flags)\n75:                 return dec\n76:         elif name is not None and filter_func is not None:\n77:             # register.filter('somename', somefunc)\n78:             self.filters[name] = filter_func\n79:             for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'):\n80:                 if attr in flags:\n81:                     value = flags[attr]\n82:                     # set the flag on the filter for FilterExpression.resolve\n83:                     setattr(filter_func, attr, value)\n84:                     # set the flag on the innermost decorated function\n85:                     # for decorators that need it, e.g. stringfilter\n86:                     if hasattr(filter_func, \"_decorated_function\"):\n87:                         setattr(filter_func._decorated_function, attr, value)\n88:             filter_func._filter_name = name\n89:             return filter_func\n90:         else:\n91:             raise ValueError(\n92:                 \"Unsupported arguments to Library.filter: (%r, %r)\" %\n93:                 (name, filter_func),\n94:             )\n95: \n96:     def filter_function(self, func, **flags):\n97:         name = getattr(func, \"_decorated_function\", func).__name__\n98:         return self.filter(name, func, **flags)\n99: \n100:     def simple_tag(self, func=None, takes_context=None, name=None):\n101:         \"\"\"\n102:         Register a callable as a compiled template tag. Example:\n103: \n104:         @register.simple_tag\n105:         def hello(*args, **kwargs):\n106:             return 'world'\n107:         \"\"\"\n108:         def dec(func):\n109:             params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n110:             function_name = (name or getattr(func, '_decorated_function', func).__name__)\n111: \n112:             @functools.wraps(func)\n113:             def compile_func(parser, token):\n114:                 bits = token.split_contents()[1:]\n115:                 target_var = None\n116:                 if len(bits) >= 2 and bits[-2] == 'as':\n117:                     target_var = bits[-1]\n118:                     bits = bits[:-2]\n119:                 args, kwargs = parse_bits(\n120:                     parser, bits, params, varargs, varkw, defaults,\n121:                     kwonly, kwonly_defaults, takes_context, function_name,\n122:                 )\n123:                 return SimpleNode(func, takes_context, args, kwargs, target_var)\n124:             self.tag(function_name, compile_func)\n125:             return func\n126: \n127:         if func is None:\n128:             # @register.simple_tag(...)\n129:             return dec\n130:         elif callable(func):\n131:             # @register.simple_tag\n132:             return dec(func)\n133:         else:\n134:             raise ValueError(\"Invalid arguments provided to simple_tag\")\n135: \n136:     def inclusion_tag(self, filename, func=None, takes_context=None, name=None):\n137:         \"\"\"\n138:         Register a callable as an inclusion tag:\n139: \n140:         @register.inclusion_tag('results.html')\n141:         def show_results(poll):\n142:             choices = poll.choice_set.all()\n143:             return {'choices': choices}\n144:         \"\"\"\n145:         def dec(func):\n146:             params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(unwrap(func))\n147:             function_name = (name or getattr(func, '_decorated_function', func).__name__)\n148: \n149:             @functools.wraps(func)\n150:             def compile_func(parser, token):\n151:                 bits = token.split_contents()[1:]\n152:                 args, kwargs = parse_bits(\n153:                     parser, bits, params, varargs, varkw, defaults,\n154:                     kwonly, kwonly_defaults, takes_context, function_name,\n155:                 )\n156:                 return InclusionNode(\n157:                     func, takes_context, args, kwargs, filename,\n158:                 )\n159:             self.tag(function_name, compile_func)\n160:             return func\n161:         return dec\n162: \n163: \n164: class TagHelperNode(Node):\nCode replaced for brevity.\n181: \n182: \n183: \n184: class SimpleNode(TagHelperNode):\nCode replaced for brevity.\n198: \n199: \n200: \n201: class InclusionNode(TagHelperNode):\nCode replaced for brevity.\n234: \n235: \n236: \n237: def parse_bits(parser, bits, params, varargs, varkw, defaults,\n238:                kwonly, kwonly_defaults, takes_context, name):\n239:     \"\"\"\n240:     Parse bits for template tag helpers simple_tag and inclusion_tag, in\n241:     particular by detecting syntax errors and by extracting positional and\n242:     keyword arguments.\n243:     \"\"\"\n244:     if takes_context:\n245:         if params[0] == 'context':\n246:             params = params[1:]\n247:         else:\n248:             raise TemplateSyntaxError(\n249:                 \"'%s' is decorated with takes_context=True so it must \"\n250:                 \"have a first argument of 'context'\" % name)\n251:     args = []\n252:     kwargs = {}\n253:     unhandled_params = list(params)\n254:     unhandled_kwargs = [\n255:         kwarg for kwarg in kwonly\n256:         if not kwonly_defaults or kwarg not in kwonly_defaults\n257:     ]\n258:     for bit in bits:\n259:         # First we try to extract a potential kwarg from the bit\n260:         kwarg = token_kwargs([bit], parser)\n261:         if kwarg:\n262:             # The kwarg was successfully extracted\n263:             param, value = kwarg.popitem()\n264:             if param not in params and param not in unhandled_kwargs and varkw is None:\n265:                 # An unexpected keyword argument was supplied\n266:                 raise TemplateSyntaxError(\n267:                     \"'%s' received unexpected keyword argument '%s'\" %\n268:                     (name, param))\n269:             elif param in kwargs:\n270:                 # The keyword argument has already been supplied once\n271:                 raise TemplateSyntaxError(\n272:                     \"'%s' received multiple values for keyword argument '%s'\" %\n273:                     (name, param))\n274:             else:\n275:                 # All good, record the keyword argument\n276:                 kwargs[str(param)] = value\n277:                 if param in unhandled_params:\n278:                     # If using the keyword syntax for a positional arg, then\n279:                     # consume it.\n280:                     unhandled_params.remove(param)\n281:                 elif param in unhandled_kwargs:\n282:                     # Same for keyword-only arguments\n283:                     unhandled_kwargs.remove(param)\n284:         else:\n285:             if kwargs:\n286:                 raise TemplateSyntaxError(\n287:                     \"'%s' received some positional argument(s) after some \"\n288:                     \"keyword argument(s)\" % name)\n289:             else:\n290:                 # Record the positional argument\n291:                 args.append(parser.compile_filter(bit))\n292:                 try:\n293:                     # Consume from the list of expected positional arguments\n294:                     unhandled_params.pop(0)\n295:                 except IndexError:\n296:                     if varargs is None:\n297:                         raise TemplateSyntaxError(\n298:                             \"'%s' received too many positional arguments\" %\n299:                             name)\n300:     if defaults is not None:\n301:         # Consider the last n params handled, where n is the\n302:         # number of defaults.\n303:         unhandled_params = unhandled_params[:-len(defaults)]\n304:     if unhandled_params or unhandled_kwargs:\n305:         # Some positional arguments were not supplied\n306:         raise TemplateSyntaxError(\n307:             \"'%s' did not receive value(s) for the argument(s): %s\" %\n308:             (name, \", \".join(\"'%s'\" % p for p in unhandled_params + unhandled_kwargs)))\n309:     return args, kwargs\n310: \n311: \n312: def import_library(name):\nCode replaced for brevity.\n328: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/template/library.py",
      "suspect_lines": [
        264
      ]
    }
  ]
}