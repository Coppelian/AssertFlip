{
  "instance_id": "django__django-16612",
  "problem_statement": "AdminSite.catch_all_view() drops query string in redirects\nDescription\n\t\n#31747 introduced AdminSite.catch_all_view(). However, in the process it broke the ability to redirect with settings.APPEND_SLASH = True when there are query strings.\nProvided URL: ​http://127.0.0.1:8000/admin/auth/foo?id=123\nExpected redirect: ​http://127.0.0.1:8000/admin/auth/foo/?id=123\nActual redirect: ​http://127.0.0.1:8000/admin/auth/foo/\nThis seems to be because the redirect in question does not include the query strings (such as via request.META['QUERY_STRING']):\nreturn HttpResponsePermanentRedirect(\"%s/\" % request.path)\n​https://github.com/django/django/blob/c57ff9ba5e251cd4c2761105a6046662c08f951e/django/contrib/admin/sites.py#L456\n",
  "localized_code": "[start of django/contrib/admin/sites.py]\n1: from functools import update_wrapper\n2: from weakref import WeakSet\n3: \n4: from django.apps import apps\n5: from django.conf import settings\n6: from django.contrib.admin import ModelAdmin, actions\n7: from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n8: from django.contrib.auth import REDIRECT_FIELD_NAME\n9: from django.core.exceptions import ImproperlyConfigured\n10: from django.db.models.base import ModelBase\n11: from django.http import Http404, HttpResponsePermanentRedirect, HttpResponseRedirect\n12: from django.template.response import TemplateResponse\n13: from django.urls import NoReverseMatch, Resolver404, resolve, reverse\n14: from django.utils.decorators import method_decorator\n15: from django.utils.functional import LazyObject\n16: from django.utils.module_loading import import_string\n17: from django.utils.text import capfirst\n18: from django.utils.translation import gettext as _\n19: from django.utils.translation import gettext_lazy\n20: from django.views.decorators.cache import never_cache\n21: from django.views.decorators.common import no_append_slash\n22: from django.views.decorators.csrf import csrf_protect\n23: from django.views.i18n import JavaScriptCatalog\n24: \n25: all_sites = WeakSet()\n26: \n27: \n28: class AlreadyRegistered(Exception):\n29:     pass\n30: \n31: \n32: class NotRegistered(Exception):\n33:     pass\n34: \n35: \n36: class AdminSite:\n37:     \"\"\"\n38:     An AdminSite object encapsulates an instance of the Django admin application, ready\n39:     to be hooked in to your URLconf. Models are registered with the AdminSite using the\n40:     register() method, and the get_urls() method can then be used to access Django view\n41:     functions that present a full admin interface for the collection of registered\n42:     models.\n43:     \"\"\"\n44: \n45:     # Text to put at the end of each page's <title>.\n46:     site_title = gettext_lazy(\"Django site admin\")\n47: \n48:     # Text to put in each page's <h1>.\n49:     site_header = gettext_lazy(\"Django administration\")\n50: \n51:     # Text to put at the top of the admin index page.\n52:     index_title = gettext_lazy(\"Site administration\")\n53: \n54:     # URL for the \"View site\" link at the top of each admin page.\n55:     site_url = \"/\"\n56: \n57:     enable_nav_sidebar = True\n58: \n59:     empty_value_display = \"-\"\n60: \n61:     login_form = None\n62:     index_template = None\n63:     app_index_template = None\n64:     login_template = None\n65:     logout_template = None\n66:     password_change_template = None\n67:     password_change_done_template = None\n68: \n69:     final_catch_all_view = True\n70: \n71:     def __init__(self, name=\"admin\"):\n72:         self._registry = {}  # model_class class -> admin_class instance\n73:         self.name = name\n74:         self._actions = {\"delete_selected\": actions.delete_selected}\n75:         self._global_actions = self._actions.copy()\n76:         all_sites.add(self)\n77: \n78:     def __repr__(self):\n79:         return f\"{self.__class__.__name__}(name={self.name!r})\"\n80: \n81:     def check(self, app_configs):\n82:         \"\"\"\n83:         Run the system checks on all ModelAdmins, except if they aren't\n84:         customized at all.\n85:         \"\"\"\n86:         if app_configs is None:\n87:             app_configs = apps.get_app_configs()\n88:         app_configs = set(app_configs)  # Speed up lookups below\n89: \n90:         errors = []\n91:         modeladmins = (\n92:             o for o in self._registry.values() if o.__class__ is not ModelAdmin\n93:         )\n94:         for modeladmin in modeladmins:\n95:             if modeladmin.model._meta.app_config in app_configs:\n96:                 errors.extend(modeladmin.check())\n97:         return errors\n98: \n99:     def register(self, model_or_iterable, admin_class=None, **options):\n100:         \"\"\"\n101:         Register the given model(s) with the given admin class.\n102: \n103:         The model(s) should be Model classes, not instances.\n104: \n105:         If an admin class isn't given, use ModelAdmin (the default admin\n106:         options). If keyword arguments are given -- e.g., list_display --\n107:         apply them as options to the admin class.\n108: \n109:         If a model is already registered, raise AlreadyRegistered.\n110: \n111:         If a model is abstract, raise ImproperlyConfigured.\n112:         \"\"\"\n113:         admin_class = admin_class or ModelAdmin\n114:         if isinstance(model_or_iterable, ModelBase):\n115:             model_or_iterable = [model_or_iterable]\n116:         for model in model_or_iterable:\n117:             if model._meta.abstract:\n118:                 raise ImproperlyConfigured(\n119:                     \"The model %s is abstract, so it cannot be registered with admin.\"\n120:                     % model.__name__\n121:                 )\n122: \n123:             if model in self._registry:\n124:                 registered_admin = str(self._registry[model])\n125:                 msg = \"The model %s is already registered \" % model.__name__\n126:                 if registered_admin.endswith(\".ModelAdmin\"):\n127:                     # Most likely registered without a ModelAdmin subclass.\n128:                     msg += \"in app %r.\" % registered_admin.removesuffix(\".ModelAdmin\")\n129:                 else:\n130:                     msg += \"with %r.\" % registered_admin\n131:                 raise AlreadyRegistered(msg)\n132: \n133:             # Ignore the registration if the model has been\n134:             # swapped out.\n135:             if not model._meta.swapped:\n136:                 # If we got **options then dynamically construct a subclass of\n137:                 # admin_class with those **options.\n138:                 if options:\n139:                     # For reasons I don't quite understand, without a __module__\n140:                     # the created class appears to \"live\" in the wrong place,\n141:                     # which causes issues later on.\n142:                     options[\"__module__\"] = __name__\n143:                     admin_class = type(\n144:                         \"%sAdmin\" % model.__name__, (admin_class,), options\n145:                     )\n146: \n147:                 # Instantiate the admin class to save in the registry\n148:                 self._registry[model] = admin_class(model, self)\n149: \n150:     def unregister(self, model_or_iterable):\n151:         \"\"\"\n152:         Unregister the given model(s).\n153: \n154:         If a model isn't already registered, raise NotRegistered.\n155:         \"\"\"\n156:         if isinstance(model_or_iterable, ModelBase):\n157:             model_or_iterable = [model_or_iterable]\n158:         for model in model_or_iterable:\n159:             if model not in self._registry:\n160:                 raise NotRegistered(\"The model %s is not registered\" % model.__name__)\n161:             del self._registry[model]\n162: \n163:     def is_registered(self, model):\n164:         \"\"\"\n165:         Check if a model class is registered with this `AdminSite`.\n166:         \"\"\"\n167:         return model in self._registry\n168: \n169:     def add_action(self, action, name=None):\n170:         \"\"\"\n171:         Register an action to be available globally.\n172:         \"\"\"\n173:         name = name or action.__name__\n174:         self._actions[name] = action\n175:         self._global_actions[name] = action\n176: \n177:     def disable_action(self, name):\n178:         \"\"\"\n179:         Disable a globally-registered action. Raise KeyError for invalid names.\n180:         \"\"\"\n181:         del self._actions[name]\n182: \n183:     def get_action(self, name):\n184:         \"\"\"\n185:         Explicitly get a registered global action whether it's enabled or\n186:         not. Raise KeyError for invalid names.\n187:         \"\"\"\n188:         return self._global_actions[name]\n189: \n190:     @property\n191:     def actions(self):\n192:         \"\"\"\n193:         Get all the enabled actions as an iterable of (name, func).\n194:         \"\"\"\n195:         return self._actions.items()\n196: \n197:     def has_permission(self, request):\n198:         \"\"\"\n199:         Return True if the given HttpRequest has permission to view\n200:         *at least one* page in the admin site.\n201:         \"\"\"\n202:         return request.user.is_active and request.user.is_staff\n203: \n204:     def admin_view(self, view, cacheable=False):\n205:         \"\"\"\n206:         Decorator to create an admin view attached to this ``AdminSite``. This\n207:         wraps the view and provides permission checking by calling\n208:         ``self.has_permission``.\n209: \n210:         You'll want to use this from within ``AdminSite.get_urls()``:\n211: \n212:             class MyAdminSite(AdminSite):\n213: \n214:                 def get_urls(self):\n215:                     from django.urls import path\n216: \n217:                     urls = super().get_urls()\n218:                     urls += [\n219:                         path('my_view/', self.admin_view(some_view))\n220:                     ]\n221:                     return urls\n222: \n223:         By default, admin_views are marked non-cacheable using the\n224:         ``never_cache`` decorator. If the view can be safely cached, set\n225:         cacheable=True.\n226:         \"\"\"\n227: \n228:         def inner(request, *args, **kwargs):\n229:             if not self.has_permission(request):\n230:                 if request.path == reverse(\"admin:logout\", current_app=self.name):\n231:                     index_path = reverse(\"admin:index\", current_app=self.name)\n232:                     return HttpResponseRedirect(index_path)\n233:                 # Inner import to prevent django.contrib.admin (app) from\n234:                 # importing django.contrib.auth.models.User (unrelated model).\n235:                 from django.contrib.auth.views import redirect_to_login\n236: \n237:                 return redirect_to_login(\n238:                     request.get_full_path(),\n239:                     reverse(\"admin:login\", current_app=self.name),\n240:                 )\n241:             return view(request, *args, **kwargs)\n242: \n243:         if not cacheable:\n244:             inner = never_cache(inner)\n245:         # We add csrf_protect here so this function can be used as a utility\n246:         # function for any view, without having to repeat 'csrf_protect'.\n247:         if not getattr(view, \"csrf_exempt\", False):\n248:             inner = csrf_protect(inner)\n249:         return update_wrapper(inner, view)\n250: \n251:     def get_urls(self):\n252:         # Since this module gets imported in the application's root package,\n253:         # it cannot import models from other applications at the module level,\n254:         # and django.contrib.contenttypes.views imports ContentType.\n255:         from django.contrib.contenttypes import views as contenttype_views\n256:         from django.urls import include, path, re_path\n257: \n258:         def wrap(view, cacheable=False):\n259:             def wrapper(*args, **kwargs):\n260:                 return self.admin_view(view, cacheable)(*args, **kwargs)\n261: \n262:             wrapper.admin_site = self\n263:             return update_wrapper(wrapper, view)\n264: \n265:         # Admin-site-wide views.\n266:         urlpatterns = [\n267:             path(\"\", wrap(self.index), name=\"index\"),\n268:             path(\"login/\", self.login, name=\"login\"),\n269:             path(\"logout/\", wrap(self.logout), name=\"logout\"),\n270:             path(\n271:                 \"password_change/\",\n272:                 wrap(self.password_change, cacheable=True),\n273:                 name=\"password_change\",\n274:             ),\n275:             path(\n276:                 \"password_change/done/\",\n277:                 wrap(self.password_change_done, cacheable=True),\n278:                 name=\"password_change_done\",\n279:             ),\n280:             path(\"autocomplete/\", wrap(self.autocomplete_view), name=\"autocomplete\"),\n281:             path(\"jsi18n/\", wrap(self.i18n_javascript, cacheable=True), name=\"jsi18n\"),\n282:             path(\n283:                 \"r/<int:content_type_id>/<path:object_id>/\",\n284:                 wrap(contenttype_views.shortcut),\n285:                 name=\"view_on_site\",\n286:             ),\n287:         ]\n288: \n289:         # Add in each model's views, and create a list of valid URLS for the\n290:         # app_index\n291:         valid_app_labels = []\n292:         for model, model_admin in self._registry.items():\n293:             urlpatterns += [\n294:                 path(\n295:                     \"%s/%s/\" % (model._meta.app_label, model._meta.model_name),\n296:                     include(model_admin.urls),\n297:                 ),\n298:             ]\n299:             if model._meta.app_label not in valid_app_labels:\n300:                 valid_app_labels.append(model._meta.app_label)\n301: \n302:         # If there were ModelAdmins registered, we should have a list of app\n303:         # labels for which we need to allow access to the app_index view,\n304:         if valid_app_labels:\n305:             regex = r\"^(?P<app_label>\" + \"|\".join(valid_app_labels) + \")/$\"\n306:             urlpatterns += [\n307:                 re_path(regex, wrap(self.app_index), name=\"app_list\"),\n308:             ]\n309: \n310:         if self.final_catch_all_view:\n311:             urlpatterns.append(re_path(r\"(?P<url>.*)$\", wrap(self.catch_all_view)))\n312: \n313:         return urlpatterns\n314: \n315:     @property\n316:     def urls(self):\n317:         return self.get_urls(), \"admin\", self.name\n318: \n319:     def each_context(self, request):\n320:         \"\"\"\n321:         Return a dictionary of variables to put in the template context for\n322:         *every* page in the admin site.\n323: \n324:         For sites running on a subpath, use the SCRIPT_NAME value if site_url\n325:         hasn't been customized.\n326:         \"\"\"\n327:         script_name = request.META[\"SCRIPT_NAME\"]\n328:         site_url = (\n329:             script_name if self.site_url == \"/\" and script_name else self.site_url\n330:         )\n331:         return {\n332:             \"site_title\": self.site_title,\n333:             \"site_header\": self.site_header,\n334:             \"site_url\": site_url,\n335:             \"has_permission\": self.has_permission(request),\n336:             \"available_apps\": self.get_app_list(request),\n337:             \"is_popup\": False,\n338:             \"is_nav_sidebar_enabled\": self.enable_nav_sidebar,\n339:             \"log_entries\": self.get_log_entries(request),\n340:         }\n341: \n342:     def password_change(self, request, extra_context=None):\n343:         \"\"\"\n344:         Handle the \"change password\" task -- both form display and validation.\n345:         \"\"\"\n346:         from django.contrib.admin.forms import AdminPasswordChangeForm\n347:         from django.contrib.auth.views import PasswordChangeView\n348: \n349:         url = reverse(\"admin:password_change_done\", current_app=self.name)\n350:         defaults = {\n351:             \"form_class\": AdminPasswordChangeForm,\n352:             \"success_url\": url,\n353:             \"extra_context\": {**self.each_context(request), **(extra_context or {})},\n354:         }\n355:         if self.password_change_template is not None:\n356:             defaults[\"template_name\"] = self.password_change_template\n357:         request.current_app = self.name\n358:         return PasswordChangeView.as_view(**defaults)(request)\n359: \n360:     def password_change_done(self, request, extra_context=None):\n361:         \"\"\"\n362:         Display the \"success\" page after a password change.\n363:         \"\"\"\n364:         from django.contrib.auth.views import PasswordChangeDoneView\n365: \n366:         defaults = {\n367:             \"extra_context\": {**self.each_context(request), **(extra_context or {})},\n368:         }\n369:         if self.password_change_done_template is not None:\n370:             defaults[\"template_name\"] = self.password_change_done_template\n371:         request.current_app = self.name\n372:         return PasswordChangeDoneView.as_view(**defaults)(request)\n373: \n374:     def i18n_javascript(self, request, extra_context=None):\n375:         \"\"\"\n376:         Display the i18n JavaScript that the Django admin requires.\n377: \n378:         `extra_context` is unused but present for consistency with the other\n379:         admin views.\n380:         \"\"\"\n381:         return JavaScriptCatalog.as_view(packages=[\"django.contrib.admin\"])(request)\n382: \n383:     def logout(self, request, extra_context=None):\n384:         \"\"\"\n385:         Log out the user for the given HttpRequest.\n386: \n387:         This should *not* assume the user is already logged in.\n388:         \"\"\"\n389:         from django.contrib.auth.views import LogoutView\n390: \n391:         defaults = {\n392:             \"extra_context\": {\n393:                 **self.each_context(request),\n394:                 # Since the user isn't logged out at this point, the value of\n395:                 # has_permission must be overridden.\n396:                 \"has_permission\": False,\n397:                 **(extra_context or {}),\n398:             },\n399:         }\n400:         if self.logout_template is not None:\n401:             defaults[\"template_name\"] = self.logout_template\n402:         request.current_app = self.name\n403:         return LogoutView.as_view(**defaults)(request)\n404: \n405:     @method_decorator(never_cache)\n406:     def login(self, request, extra_context=None):\n407:         \"\"\"\n408:         Display the login form for the given HttpRequest.\n409:         \"\"\"\n410:         if request.method == \"GET\" and self.has_permission(request):\n411:             # Already logged-in, redirect to admin index\n412:             index_path = reverse(\"admin:index\", current_app=self.name)\n413:             return HttpResponseRedirect(index_path)\n414: \n415:         # Since this module gets imported in the application's root package,\n416:         # it cannot import models from other applications at the module level,\n417:         # and django.contrib.admin.forms eventually imports User.\n418:         from django.contrib.admin.forms import AdminAuthenticationForm\n419:         from django.contrib.auth.views import LoginView\n420: \n421:         context = {\n422:             **self.each_context(request),\n423:             \"title\": _(\"Log in\"),\n424:             \"subtitle\": None,\n425:             \"app_path\": request.get_full_path(),\n426:             \"username\": request.user.get_username(),\n427:         }\n428:         if (\n429:             REDIRECT_FIELD_NAME not in request.GET\n430:             and REDIRECT_FIELD_NAME not in request.POST\n431:         ):\n432:             context[REDIRECT_FIELD_NAME] = reverse(\"admin:index\", current_app=self.name)\n433:         context.update(extra_context or {})\n434: \n435:         defaults = {\n436:             \"extra_context\": context,\n437:             \"authentication_form\": self.login_form or AdminAuthenticationForm,\n438:             \"template_name\": self.login_template or \"admin/login.html\",\n439:         }\n440:         request.current_app = self.name\n441:         return LoginView.as_view(**defaults)(request)\n442: \n443:     def autocomplete_view(self, request):\n444:         return AutocompleteJsonView.as_view(admin_site=self)(request)\n445: \n446:     @no_append_slash\n447:     def catch_all_view(self, request, url):\n448:         if settings.APPEND_SLASH and not url.endswith(\"/\"):\n449:             urlconf = getattr(request, \"urlconf\", None)\n450:             try:\n451:                 match = resolve(\"%s/\" % request.path_info, urlconf)\n452:             except Resolver404:\n453:                 pass\n454:             else:\n455:                 if getattr(match.func, \"should_append_slash\", True):\n456:                     return HttpResponsePermanentRedirect(\"%s/\" % request.path)\n457:         raise Http404\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/sites.py",
      "suspect_lines": [
        456
      ]
    }
  ]
}