{
  "instance_id": "sympy__sympy-23534",
  "problem_statement": "Using symbols to create functions doesn't work if there is an extra layer of parentheses\nSympy version == 1.10.1\r\n\r\nUsing `symbols` to create symbol-like objects like instances of `Function` as shown in the [documentation](https://docs.sympy.org/latest/modules/core.html?highlight=symbols#symbols) creates objects of class `Symbol` instead of `Function` if there is an extra layer of parentheses.\r\n\r\nThe extra layer of parentheses are necessary to deconstruct the output as separate tuples.\r\n\r\nRunning the code:\r\n```\r\nq, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)\r\nprint(type(q[0]))\r\n```\r\n#### Expected result:\r\n<class 'sympy.core.function.UndefinedFunction'>\r\n\r\n#### Actual result: \r\n<class 'sympy.core.symbol.Symbol'>\n",
  "localized_code": "[start of sympy/core/symbol.py]\n1: from __future__ import annotations\n2: \n3: from .assumptions import StdFactKB, _assume_defined\n4: from .basic import Basic, Atom\n5: from .cache import cacheit\n6: from .containers import Tuple\n7: from .expr import Expr, AtomicExpr\n8: from .function import AppliedUndef, FunctionClass\n9: from .kind import NumberKind, UndefinedKind\n10: from .logic import fuzzy_bool\n11: from .singleton import S\n12: from .sorting import ordered\n13: from .sympify import sympify\n14: from sympy.logic.boolalg import Boolean\n15: from sympy.utilities.iterables import sift, is_sequence\n16: from sympy.utilities.misc import filldedent\n17: \n18: import string\n19: import re as _re\n20: import random\n21: from itertools import product\n22: from typing import Any\n23: \n24: \n25: class Str(Atom):\n26:     \"\"\"\n27:     Represents string in SymPy.\n28: \n29:     Explanation\n30:     ===========\n31: \n32:     Previously, ``Symbol`` was used where string is needed in ``args`` of SymPy\n33:     objects, e.g. denoting the name of the instance. However, since ``Symbol``\n34:     represents mathematical scalar, this class should be used instead.\n35: \n36:     \"\"\"\n37:     __slots__ = ('name',)\n38: \n39:     def __new__(cls, name, **kwargs):\n40:         if not isinstance(name, str):\n41:             raise TypeError(\"name should be a string, not %s\" % repr(type(name)))\n42:         obj = Expr.__new__(cls, **kwargs)\n43:         obj.name = name\n44:         return obj\n45: \n46:     def __getnewargs__(self):\n47:         return (self.name,)\n48: \n49:     def _hashable_content(self):\n50:         return (self.name,)\n51: \n52: \n53: def _filter_assumptions(kwargs):\nCode replaced for brevity.\n62: \n63: \n64: def _symbol(s, matching_symbol=None, **assumptions):\nCode replaced for brevity.\n128: \n129: \n130: def uniquely_named_symbol(xname, exprs=(), compare=str, modify=None, **assumptions):\nCode replaced for brevity.\n203: _uniquely_named_symbol = uniquely_named_symbol\n204: _uniquely_named_symbol = uniquely_named_symbol\n205: \n206: class Symbol(AtomicExpr, Boolean):\nCode replaced for brevity.\n385: \n386: \n387: \n388: class Dummy(Symbol):\nCode replaced for brevity.\n453: \n454: \n455: \n456: class Wild(Symbol):\nCode replaced for brevity.\n580: \n581: \n582: \n583: _range = _re.compile('([0-9]*:[0-9]+|[a-zA-Z]?:[a-zA-Z])')\n584: \n585: \n586: def symbols(names, *, cls=Symbol, **args) -> Any:\n587:     r\"\"\"\n588:     Transform strings into instances of :class:`Symbol` class.\n589: \n590:     :func:`symbols` function returns a sequence of symbols with names taken\n591:     from ``names`` argument, which can be a comma or whitespace delimited\n592:     string, or a sequence of strings::\n593: \n594:         >>> from sympy import symbols, Function\n595: \n596:         >>> x, y, z = symbols('x,y,z')\n597:         >>> a, b, c = symbols('a b c')\n598: \n599:     The type of output is dependent on the properties of input arguments::\n600: \n601:         >>> symbols('x')\n602:         x\n603:         >>> symbols('x,')\n604:         (x,)\n605:         >>> symbols('x,y')\n606:         (x, y)\n607:         >>> symbols(('a', 'b', 'c'))\n608:         (a, b, c)\n609:         >>> symbols(['a', 'b', 'c'])\n610:         [a, b, c]\n611:         >>> symbols({'a', 'b', 'c'})\n612:         {a, b, c}\n613: \n614:     If an iterable container is needed for a single symbol, set the ``seq``\n615:     argument to ``True`` or terminate the symbol name with a comma::\n616: \n617:         >>> symbols('x', seq=True)\n618:         (x,)\n619: \n620:     To reduce typing, range syntax is supported to create indexed symbols.\n621:     Ranges are indicated by a colon and the type of range is determined by\n622:     the character to the right of the colon. If the character is a digit\n623:     then all contiguous digits to the left are taken as the nonnegative\n624:     starting value (or 0 if there is no digit left of the colon) and all\n625:     contiguous digits to the right are taken as 1 greater than the ending\n626:     value::\n627: \n628:         >>> symbols('x:10')\n629:         (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n630: \n631:         >>> symbols('x5:10')\n632:         (x5, x6, x7, x8, x9)\n633:         >>> symbols('x5(:2)')\n634:         (x50, x51)\n635: \n636:         >>> symbols('x5:10,y:5')\n637:         (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)\n638: \n639:         >>> symbols(('x5:10', 'y:5'))\n640:         ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))\n641: \n642:     If the character to the right of the colon is a letter, then the single\n643:     letter to the left (or 'a' if there is none) is taken as the start\n644:     and all characters in the lexicographic range *through* the letter to\n645:     the right are used as the range::\n646: \n647:         >>> symbols('x:z')\n648:         (x, y, z)\n649:         >>> symbols('x:c')  # null range\n650:         ()\n651:         >>> symbols('x(:c)')\n652:         (xa, xb, xc)\n653: \n654:         >>> symbols(':c')\n655:         (a, b, c)\n656: \n657:         >>> symbols('a:d, x:z')\n658:         (a, b, c, d, x, y, z)\n659: \n660:         >>> symbols(('a:d', 'x:z'))\n661:         ((a, b, c, d), (x, y, z))\n662: \n663:     Multiple ranges are supported; contiguous numerical ranges should be\n664:     separated by parentheses to disambiguate the ending number of one\n665:     range from the starting number of the next::\n666: \n667:         >>> symbols('x:2(1:3)')\n668:         (x01, x02, x11, x12)\n669:         >>> symbols(':3:2')  # parsing is from left to right\n670:         (00, 01, 10, 11, 20, 21)\n671: \n672:     Only one pair of parentheses surrounding ranges are removed, so to\n673:     include parentheses around ranges, double them. And to include spaces,\n674:     commas, or colons, escape them with a backslash::\n675: \n676:         >>> symbols('x((a:b))')\n677:         (x(a), x(b))\n678:         >>> symbols(r'x(:1\\,:2)')  # or r'x((:1)\\,(:2))'\n679:         (x(0,0), x(0,1))\n680: \n681:     All newly created symbols have assumptions set according to ``args``::\n682: \n683:         >>> a = symbols('a', integer=True)\n684:         >>> a.is_integer\n685:         True\n686: \n687:         >>> x, y, z = symbols('x,y,z', real=True)\n688:         >>> x.is_real and y.is_real and z.is_real\n689:         True\n690: \n691:     Despite its name, :func:`symbols` can create symbol-like objects like\n692:     instances of Function or Wild classes. To achieve this, set ``cls``\n693:     keyword argument to the desired type::\n694: \n695:         >>> symbols('f,g,h', cls=Function)\n696:         (f, g, h)\n697: \n698:         >>> type(_[0])\n699:         <class 'sympy.core.function.UndefinedFunction'>\n700: \n701:     \"\"\"\n702:     result = []\n703: \n704:     if isinstance(names, str):\n705:         marker = 0\n706:         splitters = r'\\,', r'\\:', r'\\ '\n707:         literals: list[tuple[str, str]] = []\n708:         for splitter in splitters:\n709:             if splitter in names:\n710:                 while chr(marker) in names:\n711:                     marker += 1\n712:                 lit_char = chr(marker)\n713:                 marker += 1\n714:                 names = names.replace(splitter, lit_char)\n715:                 literals.append((lit_char, splitter[1:]))\n716:         def literal(s):\n717:             if literals:\n718:                 for c, l in literals:\n719:                     s = s.replace(c, l)\n720:             return s\n721: \n722:         names = names.strip()\n723:         as_seq = names.endswith(',')\n724:         if as_seq:\n725:             names = names[:-1].rstrip()\n726:         if not names:\n727:             raise ValueError('no symbols given')\n728: \n729:         # split on commas\n730:         names = [n.strip() for n in names.split(',')]\n731:         if not all(n for n in names):\n732:             raise ValueError('missing symbol between commas')\n733:         # split on spaces\n734:         for i in range(len(names) - 1, -1, -1):\n735:             names[i: i + 1] = names[i].split()\n736: \n737:         seq = args.pop('seq', as_seq)\n738: \n739:         for name in names:\n740:             if not name:\n741:                 raise ValueError('missing symbol')\n742: \n743:             if ':' not in name:\n744:                 symbol = cls(literal(name), **args)\n745:                 result.append(symbol)\n746:                 continue\n747: \n748:             split: list[str] = _range.split(name)\n749:             split_list: list[list[str]] = []\n750:             # remove 1 layer of bounding parentheses around ranges\n751:             for i in range(len(split) - 1):\n752:                 if i and ':' in split[i] and split[i] != ':' and \\\n753:                         split[i - 1].endswith('(') and \\\n754:                         split[i + 1].startswith(')'):\n755:                     split[i - 1] = split[i - 1][:-1]\n756:                     split[i + 1] = split[i + 1][1:]\n757:             for s in split:\n758:                 if ':' in s:\n759:                     if s.endswith(':'):\n760:                         raise ValueError('missing end range')\n761:                     a, b = s.split(':')\n762:                     if b[-1] in string.digits:\n763:                         a_i = 0 if not a else int(a)\n764:                         b_i = int(b)\n765:                         split_list.append([str(c) for c in range(a_i, b_i)])\n766:                     else:\n767:                         a = a or 'a'\n768:                         split_list.append([string.ascii_letters[c] for c in range(\n769:                             string.ascii_letters.index(a),\n770:                             string.ascii_letters.index(b) + 1)])  # inclusive\n771:                     if not split_list[-1]:\n772:                         break\n773:                 else:\n774:                     split_list.append([s])\n775:             else:\n776:                 seq = True\n777:                 if len(split_list) == 1:\n778:                     names = split_list[0]\n779:                 else:\n780:                     names = [''.join(s) for s in product(*split_list)]\n781:                 if literals:\n782:                     result.extend([cls(literal(s), **args) for s in names])\n783:                 else:\n784:                     result.extend([cls(s, **args) for s in names])\n785: \n786:         if not seq and len(result) <= 1:\n787:             if not result:\n788:                 return ()\n789:             return result[0]\n790: \n791:         return tuple(result)\n792:     else:\n793:         for name in names:\n794:             result.append(symbols(name, **args))\n795: \n796:         return type(names)(result)\n797: \n798: \n799: def var(names, **args):\nCode replaced for brevity.\n860: \n861: \n862: def disambiguate(*iter):\nCode replaced for brevity.\n925: \n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/symbol.py",
      "suspect_lines": [
        794
      ]
    }
  ]
}