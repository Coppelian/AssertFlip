{
  "instance_id": "django__django-14376",
  "problem_statement": "MySQL backend uses deprecated \"db\" and \"passwd\" kwargs.\nDescription\n\t\nThe \"db\" and \"passwd\" usage can be seen at ​https://github.com/django/django/blob/ca9872905559026af82000e46cde6f7dedc897b6/django/db/backends/mysql/base.py#L202-L205 in main. mysqlclient recently marked these two kwargs as deprecated (see ​https://github.com/PyMySQL/mysqlclient/commit/fa25358d0f171bd8a63729c5a8d76528f4ae74e9) in favor of \"database\" and \"password\" respectively. mysqlclient added support for \"database\" and \"password\" in 1.3.8 with ​https://github.com/PyMySQL/mysqlclient/commit/66029d64060fca03f3d0b22661b1b4cf9849ef03.\nDjango 2.2, 3.1, and 3.2 all require a minimum version of mysqlclient newer than 1.3.8, so a fix for this could be backported to all currently supported versions of Django.\n",
  "localized_code": "[start of django/db/backends/mysql/base.py]\n1: \"\"\"\n2: MySQL database backend for Django.\n3: \n4: Requires mysqlclient: https://pypi.org/project/mysqlclient/\n5: \"\"\"\n6: from django.core.exceptions import ImproperlyConfigured\n7: from django.db import IntegrityError\n8: from django.db.backends import utils as backend_utils\n9: from django.db.backends.base.base import BaseDatabaseWrapper\n10: from django.utils.asyncio import async_unsafe\n11: from django.utils.functional import cached_property\n12: from django.utils.regex_helper import _lazy_re_compile\n13: \n14: try:\n15:     import MySQLdb as Database\n16: except ImportError as err:\n17:     raise ImproperlyConfigured(\n18:         'Error loading MySQLdb module.\\n'\n19:         'Did you install mysqlclient?'\n20:     ) from err\n21: \n22: from MySQLdb.constants import CLIENT, FIELD_TYPE\n23: from MySQLdb.converters import conversions\n24: \n25: # Some of these import MySQLdb, so import them after checking if it's installed.\n26: from .client import DatabaseClient\n27: from .creation import DatabaseCreation\n28: from .features import DatabaseFeatures\n29: from .introspection import DatabaseIntrospection\n30: from .operations import DatabaseOperations\n31: from .schema import DatabaseSchemaEditor\n32: from .validation import DatabaseValidation\n33: \n34: version = Database.version_info\n35: if version < (1, 4, 0):\n36:     raise ImproperlyConfigured('mysqlclient 1.4.0 or newer is required; you have %s.' % Database.__version__)\n37: \n38: \n39: # MySQLdb returns TIME columns as timedelta -- they are more like timedelta in\n40: # terms of actual behavior as they are signed and include days -- and Django\n41: # expects time.\n42: django_conversions = {\n43:     **conversions,\n44:     **{FIELD_TYPE.TIME: backend_utils.typecast_time},\n45: }\n46: \n47: # This should match the numerical portion of the version numbers (we can treat\n48: # versions like 5.0.24 and 5.0.24a as the same).\n49: server_version_re = _lazy_re_compile(r'(\\d{1,2})\\.(\\d{1,2})\\.(\\d{1,2})')\n50: \n51: \n52: class CursorWrapper:\nCode replaced for brevity.\n95: \n96: \n97: \n98: class DatabaseWrapper(BaseDatabaseWrapper):\n99:     vendor = 'mysql'\n100:     # This dictionary maps Field objects to their associated MySQL column\n101:     # types, as strings. Column-type strings can contain format strings; they'll\n102:     # be interpolated against the values of Field.__dict__ before being output.\n103:     # If a column type is set to None, it won't be included in the output.\n104:     data_types = {\n105:         'AutoField': 'integer AUTO_INCREMENT',\n106:         'BigAutoField': 'bigint AUTO_INCREMENT',\n107:         'BinaryField': 'longblob',\n108:         'BooleanField': 'bool',\n109:         'CharField': 'varchar(%(max_length)s)',\n110:         'DateField': 'date',\n111:         'DateTimeField': 'datetime(6)',\n112:         'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)',\n113:         'DurationField': 'bigint',\n114:         'FileField': 'varchar(%(max_length)s)',\n115:         'FilePathField': 'varchar(%(max_length)s)',\n116:         'FloatField': 'double precision',\n117:         'IntegerField': 'integer',\n118:         'BigIntegerField': 'bigint',\n119:         'IPAddressField': 'char(15)',\n120:         'GenericIPAddressField': 'char(39)',\n121:         'JSONField': 'json',\n122:         'OneToOneField': 'integer',\n123:         'PositiveBigIntegerField': 'bigint UNSIGNED',\n124:         'PositiveIntegerField': 'integer UNSIGNED',\n125:         'PositiveSmallIntegerField': 'smallint UNSIGNED',\n126:         'SlugField': 'varchar(%(max_length)s)',\n127:         'SmallAutoField': 'smallint AUTO_INCREMENT',\n128:         'SmallIntegerField': 'smallint',\n129:         'TextField': 'longtext',\n130:         'TimeField': 'time(6)',\n131:         'UUIDField': 'char(32)',\n132:     }\n133: \n134:     # For these data types:\n135:     # - MySQL < 8.0.13 and MariaDB < 10.2.1 don't accept default values and\n136:     #   implicitly treat them as nullable\n137:     # - all versions of MySQL and MariaDB don't support full width database\n138:     #   indexes\n139:     _limited_data_types = (\n140:         'tinyblob', 'blob', 'mediumblob', 'longblob', 'tinytext', 'text',\n141:         'mediumtext', 'longtext', 'json',\n142:     )\n143: \n144:     operators = {\n145:         'exact': '= %s',\n146:         'iexact': 'LIKE %s',\n147:         'contains': 'LIKE BINARY %s',\n148:         'icontains': 'LIKE %s',\n149:         'gt': '> %s',\n150:         'gte': '>= %s',\n151:         'lt': '< %s',\n152:         'lte': '<= %s',\n153:         'startswith': 'LIKE BINARY %s',\n154:         'endswith': 'LIKE BINARY %s',\n155:         'istartswith': 'LIKE %s',\n156:         'iendswith': 'LIKE %s',\n157:     }\n158: \n159:     # The patterns below are used to generate SQL pattern lookup clauses when\n160:     # the right-hand side of the lookup isn't a raw string (it might be an expression\n161:     # or the result of a bilateral transformation).\n162:     # In those cases, special characters for LIKE operators (e.g. \\, *, _) should be\n163:     # escaped on database side.\n164:     #\n165:     # Note: we use str.format() here for readability as '%' is used as a wildcard for\n166:     # the LIKE operator.\n167:     pattern_esc = r\"REPLACE(REPLACE(REPLACE({}, '\\\\', '\\\\\\\\'), '%%', '\\%%'), '_', '\\_')\"\n168:     pattern_ops = {\n169:         'contains': \"LIKE BINARY CONCAT('%%', {}, '%%')\",\n170:         'icontains': \"LIKE CONCAT('%%', {}, '%%')\",\n171:         'startswith': \"LIKE BINARY CONCAT({}, '%%')\",\n172:         'istartswith': \"LIKE CONCAT({}, '%%')\",\n173:         'endswith': \"LIKE BINARY CONCAT('%%', {})\",\n174:         'iendswith': \"LIKE CONCAT('%%', {})\",\n175:     }\n176: \n177:     isolation_levels = {\n178:         'read uncommitted',\n179:         'read committed',\n180:         'repeatable read',\n181:         'serializable',\n182:     }\n183: \n184:     Database = Database\n185:     SchemaEditorClass = DatabaseSchemaEditor\n186:     # Classes instantiated in __init__().\n187:     client_class = DatabaseClient\n188:     creation_class = DatabaseCreation\n189:     features_class = DatabaseFeatures\n190:     introspection_class = DatabaseIntrospection\n191:     ops_class = DatabaseOperations\n192:     validation_class = DatabaseValidation\n193: \n194:     def get_connection_params(self):\n195:         kwargs = {\n196:             'conv': django_conversions,\n197:             'charset': 'utf8',\n198:         }\n199:         settings_dict = self.settings_dict\n200:         if settings_dict['USER']:\n201:             kwargs['user'] = settings_dict['USER']\n202:         if settings_dict['NAME']:\n203:             kwargs['db'] = settings_dict['NAME']\n204:         if settings_dict['PASSWORD']:\n205:             kwargs['passwd'] = settings_dict['PASSWORD']\n206:         if settings_dict['HOST'].startswith('/'):\n207:             kwargs['unix_socket'] = settings_dict['HOST']\n208:         elif settings_dict['HOST']:\n209:             kwargs['host'] = settings_dict['HOST']\n210:         if settings_dict['PORT']:\n211:             kwargs['port'] = int(settings_dict['PORT'])\n212:         # We need the number of potentially affected rows after an\n213:         # \"UPDATE\", not the number of changed rows.\n214:         kwargs['client_flag'] = CLIENT.FOUND_ROWS\n215:         # Validate the transaction isolation level, if specified.\n216:         options = settings_dict['OPTIONS'].copy()\n217:         isolation_level = options.pop('isolation_level', 'read committed')\n218:         if isolation_level:\n219:             isolation_level = isolation_level.lower()\n220:             if isolation_level not in self.isolation_levels:\n221:                 raise ImproperlyConfigured(\n222:                     \"Invalid transaction isolation level '%s' specified.\\n\"\n223:                     \"Use one of %s, or None.\" % (\n224:                         isolation_level,\n225:                         ', '.join(\"'%s'\" % s for s in sorted(self.isolation_levels))\n226:                     ))\n227:         self.isolation_level = isolation_level\n228:         kwargs.update(options)\n229:         return kwargs\n230: \n231:     @async_unsafe\n232:     def get_new_connection(self, conn_params):\n233:         connection = Database.connect(**conn_params)\n234:         # bytes encoder in mysqlclient doesn't work and was added only to\n235:         # prevent KeyErrors in Django < 2.0. We can remove this workaround when\n236:         # mysqlclient 2.1 becomes the minimal mysqlclient supported by Django.\n237:         # See https://github.com/PyMySQL/mysqlclient/issues/489\n238:         if connection.encoders.get(bytes) is bytes:\n239:             connection.encoders.pop(bytes)\n240:         return connection\n241: \n242:     def init_connection_state(self):\n243:         assignments = []\n244:         if self.features.is_sql_auto_is_null_enabled:\n245:             # SQL_AUTO_IS_NULL controls whether an AUTO_INCREMENT column on\n246:             # a recently inserted row will return when the field is tested\n247:             # for NULL. Disabling this brings this aspect of MySQL in line\n... Code Truncated ...\n\n[start of django/db/backends/mysql/client.py]\n1: from django.db.backends.base.client import BaseDatabaseClient\n2: \n3: \n4: class DatabaseClient(BaseDatabaseClient):\n5:     executable_name = 'mysql'\n6: \n7:     @classmethod\n8:     def settings_to_cmd_args_env(cls, settings_dict, parameters):\n9:         args = [cls.executable_name]\n10:         env = None\n11:         db = settings_dict['OPTIONS'].get('db', settings_dict['NAME'])\n12:         user = settings_dict['OPTIONS'].get('user', settings_dict['USER'])\n13:         password = settings_dict['OPTIONS'].get(\n14:             'password',\n15:             settings_dict['OPTIONS'].get('passwd', settings_dict['PASSWORD'])\n16:         )\n17:         host = settings_dict['OPTIONS'].get('host', settings_dict['HOST'])\n18:         port = settings_dict['OPTIONS'].get('port', settings_dict['PORT'])\n19:         server_ca = settings_dict['OPTIONS'].get('ssl', {}).get('ca')\n20:         client_cert = settings_dict['OPTIONS'].get('ssl', {}).get('cert')\n21:         client_key = settings_dict['OPTIONS'].get('ssl', {}).get('key')\n22:         defaults_file = settings_dict['OPTIONS'].get('read_default_file')\n23:         charset = settings_dict['OPTIONS'].get('charset')\n24:         # Seems to be no good way to set sql_mode with CLI.\n25: \n26:         if defaults_file:\n27:             args += [\"--defaults-file=%s\" % defaults_file]\n28:         if user:\n29:             args += [\"--user=%s\" % user]\n30:         if password:\n31:             # The MYSQL_PWD environment variable usage is discouraged per\n32:             # MySQL's documentation due to the possibility of exposure through\n33:             # `ps` on old Unix flavors but --password suffers from the same\n34:             # flaw on even more systems. Usage of an environment variable also\n35:             # prevents password exposure if the subprocess.run(check=True) call\n36:             # raises a CalledProcessError since the string representation of\n37:             # the latter includes all of the provided `args`.\n38:             env = {'MYSQL_PWD': password}\n39:         if host:\n40:             if '/' in host:\n41:                 args += [\"--socket=%s\" % host]\n42:             else:\n43:                 args += [\"--host=%s\" % host]\n44:         if port:\n45:             args += [\"--port=%s\" % port]\n46:         if server_ca:\n47:             args += [\"--ssl-ca=%s\" % server_ca]\n48:         if client_cert:\n49:             args += [\"--ssl-cert=%s\" % client_cert]\n50:         if client_key:\n51:             args += [\"--ssl-key=%s\" % client_key]\n52:         if charset:\n53:             args += ['--default-character-set=%s' % charset]\n54:         if db:\n55:             args += [db]\n56:         args.extend(parameters)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/backends/mysql/base.py",
      "suspect_lines": [
        203,
        205
      ]
    },
    {
      "filename": "/django/db/backends/mysql/client.py",
      "suspect_lines": [
        11,
        54,
        55
      ]
    }
  ]
}