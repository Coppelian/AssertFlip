{
  "instance_id": "django__django-16662",
  "problem_statement": "Migration import ordering violates coding style and isort defaults\nDescription\n\t\nNew migration files are generated with imports sorted by module, independent of import style. For example:\nimport datetime\nfrom django.db import migrations, models\nimport time\nThe ​Django coding style specifies:\nPlace all import module statements before from module import objects in each section.\nThis guidance is the same as what isort does by default, ​as documented here. Newly generated migrations can fail isort for this reason.\nThis would mean migration files should instead be generated like this:\nimport datetime\nimport time\nfrom django.db import migrations, models\nFor reference, previous issues related to migration import sorting: #24155, #25384.\n",
  "localized_code": "[start of django/db/migrations/writer.py]\n1: import os\n2: import re\n3: from importlib import import_module\n4: \n5: from django import get_version\n6: from django.apps import apps\n7: \n8: # SettingsReference imported for backwards compatibility in Django 2.2.\n9: from django.conf import SettingsReference  # NOQA\n10: from django.db import migrations\n11: from django.db.migrations.loader import MigrationLoader\n12: from django.db.migrations.serializer import Serializer, serializer_factory\n13: from django.utils.inspect import get_func_args\n14: from django.utils.module_loading import module_dir\n15: from django.utils.timezone import now\n16: \n17: \n18: class OperationWriter:\n19:     def __init__(self, operation, indentation=2):\n20:         self.operation = operation\n21:         self.buff = []\n22:         self.indentation = indentation\n23: \n24:     def serialize(self):\n25:         def _write(_arg_name, _arg_value):\n26:             if _arg_name in self.operation.serialization_expand_args and isinstance(\n27:                 _arg_value, (list, tuple, dict)\n28:             ):\n29:                 if isinstance(_arg_value, dict):\n30:                     self.feed(\"%s={\" % _arg_name)\n31:                     self.indent()\n32:                     for key, value in _arg_value.items():\n33:                         key_string, key_imports = MigrationWriter.serialize(key)\n34:                         arg_string, arg_imports = MigrationWriter.serialize(value)\n35:                         args = arg_string.splitlines()\n36:                         if len(args) > 1:\n37:                             self.feed(\"%s: %s\" % (key_string, args[0]))\n38:                             for arg in args[1:-1]:\n39:                                 self.feed(arg)\n40:                             self.feed(\"%s,\" % args[-1])\n41:                         else:\n42:                             self.feed(\"%s: %s,\" % (key_string, arg_string))\n43:                         imports.update(key_imports)\n44:                         imports.update(arg_imports)\n45:                     self.unindent()\n46:                     self.feed(\"},\")\n47:                 else:\n48:                     self.feed(\"%s=[\" % _arg_name)\n49:                     self.indent()\n50:                     for item in _arg_value:\n51:                         arg_string, arg_imports = MigrationWriter.serialize(item)\n52:                         args = arg_string.splitlines()\n53:                         if len(args) > 1:\n54:                             for arg in args[:-1]:\n55:                                 self.feed(arg)\n56:                             self.feed(\"%s,\" % args[-1])\n57:                         else:\n58:                             self.feed(\"%s,\" % arg_string)\n59:                         imports.update(arg_imports)\n60:                     self.unindent()\n61:                     self.feed(\"],\")\n62:             else:\n63:                 arg_string, arg_imports = MigrationWriter.serialize(_arg_value)\n64:                 args = arg_string.splitlines()\n65:                 if len(args) > 1:\n66:                     self.feed(\"%s=%s\" % (_arg_name, args[0]))\n67:                     for arg in args[1:-1]:\n68:                         self.feed(arg)\n69:                     self.feed(\"%s,\" % args[-1])\n70:                 else:\n71:                     self.feed(\"%s=%s,\" % (_arg_name, arg_string))\n72:                 imports.update(arg_imports)\n73: \n74:         imports = set()\n75:         name, args, kwargs = self.operation.deconstruct()\n76:         operation_args = get_func_args(self.operation.__init__)\n77: \n78:         # See if this operation is in django.db.migrations. If it is,\n79:         # We can just use the fact we already have that imported,\n80:         # otherwise, we need to add an import for the operation class.\n81:         if getattr(migrations, name, None) == self.operation.__class__:\n82:             self.feed(\"migrations.%s(\" % name)\n83:         else:\n84:             imports.add(\"import %s\" % (self.operation.__class__.__module__))\n85:             self.feed(\"%s.%s(\" % (self.operation.__class__.__module__, name))\n86: \n87:         self.indent()\n88: \n89:         for i, arg in enumerate(args):\n90:             arg_value = arg\n91:             arg_name = operation_args[i]\n92:             _write(arg_name, arg_value)\n93: \n94:         i = len(args)\n95:         # Only iterate over remaining arguments\n96:         for arg_name in operation_args[i:]:\n97:             if arg_name in kwargs:  # Don't sort to maintain signature order\n98:                 arg_value = kwargs[arg_name]\n99:                 _write(arg_name, arg_value)\n100: \n101:         self.unindent()\n102:         self.feed(\"),\")\n103:         return self.render(), imports\n104: \n105:     def indent(self):\n106:         self.indentation += 1\n107: \n108:     def unindent(self):\n109:         self.indentation -= 1\n110: \n111:     def feed(self, line):\n112:         self.buff.append(\" \" * (self.indentation * 4) + line)\n113: \n114:     def render(self):\n115:         return \"\\n\".join(self.buff)\n116: \n117: \n118: class MigrationWriter:\n119:     \"\"\"\n120:     Take a Migration instance and is able to produce the contents\n121:     of the migration file from it.\n122:     \"\"\"\n123: \n124:     def __init__(self, migration, include_header=True):\n125:         self.migration = migration\n126:         self.include_header = include_header\n127:         self.needs_manual_porting = False\n128: \n129:     def as_string(self):\n130:         \"\"\"Return a string of the file contents.\"\"\"\n131:         items = {\n132:             \"replaces_str\": \"\",\n133:             \"initial_str\": \"\",\n134:         }\n135: \n136:         imports = set()\n137: \n138:         # Deconstruct operations\n139:         operations = []\n140:         for operation in self.migration.operations:\n141:             operation_string, operation_imports = OperationWriter(operation).serialize()\n142:             imports.update(operation_imports)\n143:             operations.append(operation_string)\n144:         items[\"operations\"] = \"\\n\".join(operations) + \"\\n\" if operations else \"\"\n145: \n146:         # Format dependencies and write out swappable dependencies right\n147:         dependencies = []\n148:         for dependency in self.migration.dependencies:\n149:             if dependency[0] == \"__setting__\":\n150:                 dependencies.append(\n151:                     \"        migrations.swappable_dependency(settings.%s),\"\n152:                     % dependency[1]\n153:                 )\n154:                 imports.add(\"from django.conf import settings\")\n155:             else:\n156:                 dependencies.append(\"        %s,\" % self.serialize(dependency)[0])\n157:         items[\"dependencies\"] = \"\\n\".join(dependencies) + \"\\n\" if dependencies else \"\"\n158: \n159:         # Format imports nicely, swapping imports of functions from migration files\n160:         # for comments\n161:         migration_imports = set()\n162:         for line in list(imports):\n163:             if re.match(r\"^import (.*)\\.\\d+[^\\s]*$\", line):\n164:                 migration_imports.add(line.split(\"import\")[1].strip())\n165:                 imports.remove(line)\n166:                 self.needs_manual_porting = True\n167: \n168:         # django.db.migrations is always used, but models import may not be.\n169:         # If models import exists, merge it with migrations import.\n170:         if \"from django.db import models\" in imports:\n171:             imports.discard(\"from django.db import models\")\n172:             imports.add(\"from django.db import migrations, models\")\n173:         else:\n174:             imports.add(\"from django.db import migrations\")\n175: \n176:         # Sort imports by the package / module to be imported (the part after\n177:         # \"from\" in \"from ... import ...\" or after \"import\" in \"import ...\").\n178:         sorted_imports = sorted(imports, key=lambda i: i.split()[1])\n179:         items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/writer.py",
      "suspect_lines": [
        178
      ]
    }
  ]
}