{
  "instance_id": "django__django-13344",
  "problem_statement": "Coroutine passed to the first middleware's process_response() instead of HttpResponse.\nDescription\n\t\nLike the title says, using ASGI (+ uvicorn in my case), the first middleware (according to the list in settings.py) receives a coroutine as its response parameter, while all other middlewares down the line receive a django.http.response.HttpResponse object.\nThis seems to have caused an issue in the django-cors-headers package which is often placed first in order:\nâ€‹https://github.com/adamchainz/django-cors-headers/issues/558\nHow to reproduce:\nSet up a django 3.1 project with an async server (uvicorn in my case)\nCreate a dummy class-based middleware that prints the types of arguments it receives in its process_response method:\nclass DummyMiddleware(MiddlewareMixin):\n\tdef process_response(self, request, response):\n\t\tprint(request.__class__, response.__class__)\nSet up the middleware as the first one in settings.py:\nMIDDLEWARE = [\n\t'django_uvicorn_test.middleware.DummyMiddleware',\n\t'django.middleware.security.SecurityMiddleware',\n ...\nLaunch the server and perform any request, observe console output:\n <class 'django.core.handlers.asgi.ASGIRequest'> <class 'coroutine'> \nMove the middleware down on the list, restart the server and perform a request again:\n <class 'django.core.handlers.asgi.ASGIRequest'> <class 'django.http.response.HttpResponse'>\n",
  "localized_code": "[start of django/contrib/sessions/middleware.py]\n1: import time\n2: from importlib import import_module\n3: \n4: from django.conf import settings\n5: from django.contrib.sessions.backends.base import UpdateError\n6: from django.core.exceptions import SuspiciousOperation\n7: from django.utils.cache import patch_vary_headers\n8: from django.utils.deprecation import MiddlewareMixin\n9: from django.utils.http import http_date\n10: \n11: \n12: class SessionMiddleware(MiddlewareMixin):\n13:     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n14:     #   def __init__(self, get_response):\n15:     def __init__(self, get_response=None):\n16:         self._get_response_none_deprecation(get_response)\n17:         self.get_response = get_response\n18:         self._async_check()\n19:         engine = import_module(settings.SESSION_ENGINE)\n20:         self.SessionStore = engine.SessionStore\n21: \n22:     def process_request(self, request):\n23:         session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME)\n24:         request.session = self.SessionStore(session_key)\n25: \n26:     def process_response(self, request, response):\n27:         \"\"\"\n28:         If request.session was modified, or if the configuration is to save the\n29:         session every time, save the changes and set a session cookie or delete\n30:         the session cookie if the session has been emptied.\n31:         \"\"\"\n32:         try:\n33:             accessed = request.session.accessed\n34:             modified = request.session.modified\n35:             empty = request.session.is_empty()\n36:         except AttributeError:\n37:             return response\n38:         # First check if we need to delete this cookie.\n39:         # The session should be deleted only if the session is entirely empty.\n40:         if settings.SESSION_COOKIE_NAME in request.COOKIES and empty:\n41:             response.delete_cookie(\n42:                 settings.SESSION_COOKIE_NAME,\n43:                 path=settings.SESSION_COOKIE_PATH,\n44:                 domain=settings.SESSION_COOKIE_DOMAIN,\n45:                 samesite=settings.SESSION_COOKIE_SAMESITE,\n46:             )\n47:             patch_vary_headers(response, ('Cookie',))\n48:         else:\n49:             if accessed:\n50:                 patch_vary_headers(response, ('Cookie',))\n51:             if (modified or settings.SESSION_SAVE_EVERY_REQUEST) and not empty:\n... Code Truncated ...\n\n[start of django/middleware/cache.py]\n1: \"\"\"\n2: Cache middleware. If enabled, each Django-powered page will be cached based on\n3: URL. The canonical way to enable cache middleware is to set\n4: ``UpdateCacheMiddleware`` as your first piece of middleware, and\n5: ``FetchFromCacheMiddleware`` as the last::\n6: \n7:     MIDDLEWARE = [\n8:         'django.middleware.cache.UpdateCacheMiddleware',\n9:         ...\n10:         'django.middleware.cache.FetchFromCacheMiddleware'\n11:     ]\n12: \n13: This is counter-intuitive, but correct: ``UpdateCacheMiddleware`` needs to run\n14: last during the response phase, which processes middleware bottom-up;\n15: ``FetchFromCacheMiddleware`` needs to run last during the request phase, which\n16: processes middleware top-down.\n17: \n18: The single-class ``CacheMiddleware`` can be used for some simple sites.\n19: However, if any other piece of middleware needs to affect the cache key, you'll\n20: need to use the two-part ``UpdateCacheMiddleware`` and\n21: ``FetchFromCacheMiddleware``. This'll most often happen when you're using\n22: Django's ``LocaleMiddleware``.\n23: \n24: More details about how the caching works:\n25: \n26: * Only GET or HEAD-requests with status code 200 are cached.\n27: \n28: * The number of seconds each page is stored for is set by the \"max-age\" section\n29:   of the response's \"Cache-Control\" header, falling back to the\n30:   CACHE_MIDDLEWARE_SECONDS setting if the section was not found.\n31: \n32: * This middleware expects that a HEAD request is answered with the same response\n33:   headers exactly like the corresponding GET request.\n34: \n35: * When a hit occurs, a shallow copy of the original response object is returned\n36:   from process_request.\n37: \n38: * Pages will be cached based on the contents of the request headers listed in\n39:   the response's \"Vary\" header.\n40: \n41: * This middleware also sets ETag, Last-Modified, Expires and Cache-Control\n42:   headers on the response object.\n43: \n44: \"\"\"\n45: \n46: from django.conf import settings\n47: from django.core.cache import DEFAULT_CACHE_ALIAS, caches\n48: from django.utils.cache import (\n49:     get_cache_key, get_max_age, has_vary_header, learn_cache_key,\n50:     patch_response_headers,\n51: )\n52: from django.utils.deprecation import MiddlewareMixin\n53: \n54: \n55: class UpdateCacheMiddleware(MiddlewareMixin):\n56:     \"\"\"\n57:     Response-phase cache middleware that updates the cache if the response is\n58:     cacheable.\n59: \n60:     Must be used as part of the two-part update/fetch cache middleware.\n61:     UpdateCacheMiddleware must be the first piece of middleware in MIDDLEWARE\n62:     so that it'll get called last during the response phase.\n63:     \"\"\"\n64:     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n65:     #   def __init__(self, get_response):\n66:     def __init__(self, get_response=None):\n67:         self._get_response_none_deprecation(get_response)\n68:         self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n69:         self.page_timeout = None\n70:         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n71:         self.cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n72:         self.cache = caches[self.cache_alias]\n73:         self.get_response = get_response\n74: \n75:     def _should_update_cache(self, request, response):\n76:         return hasattr(request, '_cache_update_cache') and request._cache_update_cache\n77: \n78:     def process_response(self, request, response):\n79:         \"\"\"Set the cache, if needed.\"\"\"\n80:         if not self._should_update_cache(request, response):\n81:             # We don't need to update the cache, just return.\n82:             return response\n83: \n84:         if response.streaming or response.status_code not in (200, 304):\n85:             return response\n86: \n87:         # Don't cache responses that set a user-specific (and maybe security\n88:         # sensitive) cookie in response to a cookie-less request.\n89:         if not request.COOKIES and response.cookies and has_vary_header(response, 'Cookie'):\n90:             return response\n91: \n92:         # Don't cache a response with 'Cache-Control: private'\n93:         if 'private' in response.get('Cache-Control', ()):\n94:             return response\n95: \n96:         # Page timeout takes precedence over the \"max-age\" and the default\n97:         # cache timeout.\n98:         timeout = self.page_timeout\n99:         if timeout is None:\n100:             # The timeout from the \"max-age\" section of the \"Cache-Control\"\n101:             # header takes precedence over the default cache timeout.\n102:             timeout = get_max_age(response)\n103:             if timeout is None:\n104:                 timeout = self.cache_timeout\n105:             elif timeout == 0:\n106:                 # max-age was set to 0, don't cache.\n107:                 return response\n108:         patch_response_headers(response, timeout)\n109:         if timeout and response.status_code == 200:\n110:             cache_key = learn_cache_key(request, response, timeout, self.key_prefix, cache=self.cache)\n111:             if hasattr(response, 'render') and callable(response.render):\n112:                 response.add_post_render_callback(\n113:                     lambda r: self.cache.set(cache_key, r, timeout)\n114:                 )\n115:             else:\n116:                 self.cache.set(cache_key, response, timeout)\n117:         return response\n118: \n119: \n120: class FetchFromCacheMiddleware(MiddlewareMixin):\n121:     \"\"\"\n122:     Request-phase cache middleware that fetches a page from the cache.\n123: \n124:     Must be used as part of the two-part update/fetch cache middleware.\n125:     FetchFromCacheMiddleware must be the last piece of middleware in MIDDLEWARE\n126:     so that it'll get called last during the request phase.\n127:     \"\"\"\n128:     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n129:     #   def __init__(self, get_response):\n130:     def __init__(self, get_response=None):\n131:         self._get_response_none_deprecation(get_response)\n132:         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n133:         self.cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n134:         self.cache = caches[self.cache_alias]\n135:         self.get_response = get_response\n136: \n137:     def process_request(self, request):\n138:         \"\"\"\n139:         Check whether the page is already cached and return the cached\n140:         version if available.\n141:         \"\"\"\n142:         if request.method not in ('GET', 'HEAD'):\n143:             request._cache_update_cache = False\n144:             return None  # Don't bother checking the cache.\n145: \n146:         # try and get the cached GET response\n147:         cache_key = get_cache_key(request, self.key_prefix, 'GET', cache=self.cache)\n148:         if cache_key is None:\n149:             request._cache_update_cache = True\n150:             return None  # No cache information available, need to rebuild.\n151:         response = self.cache.get(cache_key)\n152:         # if it wasn't found and we are looking for a HEAD, try looking just for that\n153:         if response is None and request.method == 'HEAD':\n154:             cache_key = get_cache_key(request, self.key_prefix, 'HEAD', cache=self.cache)\n155:             response = self.cache.get(cache_key)\n156: \n157:         if response is None:\n158:             request._cache_update_cache = True\n159:             return None  # No cache information available, need to rebuild.\n160: \n161:         # hit, return cached response\n162:         request._cache_update_cache = False\n163:         return response\n164: \n165: \n166: class CacheMiddleware(UpdateCacheMiddleware, FetchFromCacheMiddleware):\n167:     \"\"\"\n168:     Cache middleware that provides basic behavior for many simple sites.\n169: \n170:     Also used as the hook point for the cache decorator, which is generated\n171:     using the decorator-from-middleware utility.\n172:     \"\"\"\n173:     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n174:     #   def __init__(self, get_response, cache_timeout=None, page_timeout=None, **kwargs):\n175:     def __init__(self, get_response=None, cache_timeout=None, page_timeout=None, **kwargs):\n176:         self._get_response_none_deprecation(get_response)\n177:         self.get_response = get_response\n178:         # We need to differentiate between \"provided, but using default value\",\n179:         # and \"not provided\". If the value is provided using a default, then\n180:         # we fall back to system defaults. If it is not provided at all,\n181:         # we need to use middleware defaults.\n182: \n183:         try:\n184:             key_prefix = kwargs['key_prefix']\n185:             if key_prefix is None:\n186:                 key_prefix = ''\n187:         except KeyError:\n188:             key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n189:         self.key_prefix = key_prefix\n190: \n191:         try:\n192:             cache_alias = kwargs['cache_alias']\n193:             if cache_alias is None:\n194:                 cache_alias = DEFAULT_CACHE_ALIAS\n195:         except KeyError:\n196:             cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n197:         self.cache_alias = cache_alias\n198: \n199:         if cache_timeout is None:\n200:             cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n201:         self.cache_timeout = cache_timeout\n202:         self.page_timeout = page_timeout\n203:         self.cache = caches[self.cache_alias]\n\n[start of django/middleware/security.py]\n1: import re\n2: \n3: from django.conf import settings\n4: from django.http import HttpResponsePermanentRedirect\n5: from django.utils.deprecation import MiddlewareMixin\n6: \n7: \n8: class SecurityMiddleware(MiddlewareMixin):\n9:     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n10:     #   def __init__(self, get_response):\n11:     def __init__(self, get_response=None):\n12:         self._get_response_none_deprecation(get_response)\n13:         self.sts_seconds = settings.SECURE_HSTS_SECONDS\n14:         self.sts_include_subdomains = settings.SECURE_HSTS_INCLUDE_SUBDOMAINS\n15:         self.sts_preload = settings.SECURE_HSTS_PRELOAD\n16:         self.content_type_nosniff = settings.SECURE_CONTENT_TYPE_NOSNIFF\n17:         self.xss_filter = settings.SECURE_BROWSER_XSS_FILTER\n18:         self.redirect = settings.SECURE_SSL_REDIRECT\n19:         self.redirect_host = settings.SECURE_SSL_HOST\n20:         self.redirect_exempt = [re.compile(r) for r in settings.SECURE_REDIRECT_EXEMPT]\n21:         self.referrer_policy = settings.SECURE_REFERRER_POLICY\n22:         self.get_response = get_response\n23: \n24:     def process_request(self, request):\n25:         path = request.path.lstrip(\"/\")\n26:         if (self.redirect and not request.is_secure() and\n27:                 not any(pattern.search(path)\n28:                         for pattern in self.redirect_exempt)):\n29:             host = self.redirect_host or request.get_host()\n30:             return HttpResponsePermanentRedirect(\n31:                 \"https://%s%s\" % (host, request.get_full_path())\n32:             )\n33: \n34:     def process_response(self, request, response):\n35:         if (self.sts_seconds and request.is_secure() and\n36:                 'Strict-Transport-Security' not in response):\n37:             sts_header = \"max-age=%s\" % self.sts_seconds\n38:             if self.sts_include_subdomains:\n39:                 sts_header = sts_header + \"; includeSubDomains\"\n40:             if self.sts_preload:\n41:                 sts_header = sts_header + \"; preload\"\n42:             response['Strict-Transport-Security'] = sts_header\n43: \n44:         if self.content_type_nosniff:\n45:             response.setdefault('X-Content-Type-Options', 'nosniff')\n46: \n47:         if self.xss_filter:\n48:             response.setdefault('X-XSS-Protection', '1; mode=block')\n49: \n50:         if self.referrer_policy:\n51:             # Support a comma-separated string or iterable of values to allow\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/sessions/middleware.py",
      "suspect_lines": [
        16,
        17,
        18
      ]
    },
    {
      "filename": "/django/middleware/cache.py",
      "suspect_lines": [
        67,
        73,
        131,
        135,
        176,
        177,
        188,
        189,
        190,
        196,
        197,
        199,
        200,
        201,
        203
      ]
    },
    {
      "filename": "/django/middleware/security.py",
      "suspect_lines": [
        12,
        22
      ]
    }
  ]
}