{
  "instance_id": "django__django-10880",
  "problem_statement": "Query syntax error with condition and distinct combination\nDescription\n\t\nA Count annotation containing both a Case condition and a distinct=True param produces a query error on Django 2.2 (whatever the db backend). A space is missing at least (... COUNT(DISTINCTCASE WHEN ...).\n",
  "localized_code": "[start of django/db/models/aggregates.py]\n1: \"\"\"\n2: Classes to represent the definitions of aggregate functions.\n3: \"\"\"\n4: from django.core.exceptions import FieldError\n5: from django.db.models.expressions import Case, Func, Star, When\n6: from django.db.models.fields import IntegerField\n7: from django.db.models.functions.mixins import (\n8:     FixDurationInputMixin, NumericOutputFieldMixin,\n9: )\n10: \n11: __all__ = [\n12:     'Aggregate', 'Avg', 'Count', 'Max', 'Min', 'StdDev', 'Sum', 'Variance',\n13: ]\n14: \n15: \n16: class Aggregate(Func):\n17:     template = '%(function)s(%(distinct)s%(expressions)s)'\n18:     contains_aggregate = True\n19:     name = None\n20:     filter_template = '%s FILTER (WHERE %%(filter)s)'\n21:     window_compatible = True\n22:     allow_distinct = False\n23: \n24:     def __init__(self, *expressions, distinct=False, filter=None, **extra):\n25:         if distinct and not self.allow_distinct:\n26:             raise TypeError(\"%s does not allow distinct.\" % self.__class__.__name__)\n27:         self.distinct = distinct\n28:         self.filter = filter\n29:         super().__init__(*expressions, **extra)\n30: \n31:     def get_source_fields(self):\n32:         # Don't return the filter expression since it's not a source field.\n33:         return [e._output_field_or_none for e in super().get_source_expressions()]\n34: \n35:     def get_source_expressions(self):\n36:         source_expressions = super().get_source_expressions()\n37:         if self.filter:\n38:             return source_expressions + [self.filter]\n39:         return source_expressions\n40: \n41:     def set_source_expressions(self, exprs):\n42:         self.filter = self.filter and exprs.pop()\n43:         return super().set_source_expressions(exprs)\n44: \n45:     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n46:         # Aggregates are not allowed in UPDATE queries, so ignore for_save\n47:         c = super().resolve_expression(query, allow_joins, reuse, summarize)\n48:         c.filter = c.filter and c.filter.resolve_expression(query, allow_joins, reuse, summarize)\n49:         if not summarize:\n50:             # Call Aggregate.get_source_expressions() to avoid\n51:             # returning self.filter and including that in this loop.\n52:             expressions = super(Aggregate, c).get_source_expressions()\n53:             for index, expr in enumerate(expressions):\n54:                 if expr.contains_aggregate:\n55:                     before_resolved = self.get_source_expressions()[index]\n56:                     name = before_resolved.name if hasattr(before_resolved, 'name') else repr(before_resolved)\n57:                     raise FieldError(\"Cannot compute %s('%s'): '%s' is an aggregate\" % (c.name, name, name))\n58:         return c\n59: \n60:     @property\n61:     def default_alias(self):\n62:         expressions = self.get_source_expressions()\n63:         if len(expressions) == 1 and hasattr(expressions[0], 'name'):\n64:             return '%s__%s' % (expressions[0].name, self.name.lower())\n65:         raise TypeError(\"Complex expressions require an alias\")\n66: \n67:     def get_group_by_cols(self):\n68:         return []\n69: \n70:     def as_sql(self, compiler, connection, **extra_context):\n71:         extra_context['distinct'] = 'DISTINCT' if self.distinct else ''\n72:         if self.filter:\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/aggregates.py",
      "suspect_lines": [
        71
      ]
    }
  ]
}