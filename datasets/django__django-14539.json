{
  "instance_id": "django__django-14539",
  "problem_statement": "urlize() does not handle html escaped string and trailing punctuation correctly\nDescription\n\t\nExample:\nurlize('Search for google.com/?q=1&lt! and see.')\n# expected output\n'Search for <a href=\"http://google.com/?q=1%3C\">google.com/?q=1&lt</a>! and see.'\n# actual output\n'Search for <a href=\"http://google.com/?q=1%3C\">google.com/?q=1&lt</a>lt! and see.'\n",
  "localized_code": "[start of django/utils/html.py]\n1: \"\"\"HTML utilities suitable for global use.\"\"\"\n2: \n3: import html\n4: import json\n5: import re\n6: from html.parser import HTMLParser\n7: from urllib.parse import (\n8:     parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,\n9: )\n10: \n11: from django.utils.encoding import punycode\n12: from django.utils.functional import Promise, keep_lazy, keep_lazy_text\n13: from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS\n14: from django.utils.regex_helper import _lazy_re_compile\n15: from django.utils.safestring import SafeData, SafeString, mark_safe\n16: from django.utils.text import normalize_newlines\n17: \n18: # Configuration for urlize() function.\n19: TRAILING_PUNCTUATION_CHARS = '.,:;!'\n20: WRAPPING_PUNCTUATION = [('(', ')'), ('[', ']')]\n21: \n22: # List of possible strings used for bullets in bulleted lists.\n23: DOTS = ['&middot;', '*', '\\u2022', '&#149;', '&bull;', '&#8226;']\n24: \n25: word_split_re = _lazy_re_compile(r'''([\\s<>\"']+)''')\n26: simple_url_re = _lazy_re_compile(r'^https?://\\[?\\w', re.IGNORECASE)\n27: simple_url_2_re = _lazy_re_compile(\n28:     r'^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$',\n29:     re.IGNORECASE\n30: )\n31: \n32: \n33: @keep_lazy(str, SafeString)\n34: def escape(text):\n35:     \"\"\"\n36:     Return the given text with ampersands, quotes and angle brackets encoded\n37:     for use in HTML.\n38: \n39:     Always escape input, even if it's already escaped and marked as such.\n40:     This may result in double-escaping. If this is a concern, use\n41:     conditional_escape() instead.\n42:     \"\"\"\n43:     return mark_safe(html.escape(str(text)))\n44: \n45: \n46: _js_escapes = {\n47:     ord('\\\\'): '\\\\u005C',\n48:     ord('\\''): '\\\\u0027',\n49:     ord('\"'): '\\\\u0022',\n50:     ord('>'): '\\\\u003E',\n51:     ord('<'): '\\\\u003C',\n52:     ord('&'): '\\\\u0026',\n53:     ord('='): '\\\\u003D',\n54:     ord('-'): '\\\\u002D',\n55:     ord(';'): '\\\\u003B',\n56:     ord('`'): '\\\\u0060',\n57:     ord('\\u2028'): '\\\\u2028',\n58:     ord('\\u2029'): '\\\\u2029'\n59: }\n60: \n61: # Escape every ASCII character with a value less than 32.\n62: _js_escapes.update((ord('%c' % z), '\\\\u%04X' % z) for z in range(32))\n63: \n64: \n65: @keep_lazy(str, SafeString)\n66: def escapejs(value):\nCode replaced for brevity.\n68: \n69: \n70: \n71: _json_script_escapes = {\n72:     ord('>'): '\\\\u003E',\n73:     ord('<'): '\\\\u003C',\n74:     ord('&'): '\\\\u0026',\n75: }\n76: \n77: \n78: def json_script(value, element_id):\nCode replaced for brevity.\n89: \n90: \n91: \n92: def conditional_escape(text):\nCode replaced for brevity.\n104: \n105: \n106: \n107: def format_html(format_string, *args, **kwargs):\nCode replaced for brevity.\n115: \n116: \n117: \n118: def format_html_join(sep, format_string, args_generator):\nCode replaced for brevity.\n135: \n136: \n137: \n138: @keep_lazy_text\n139: def linebreaks(value, autoescape=False):\nCode replaced for brevity.\n147: \n148: \n149: \n150: class MLStripper(HTMLParser):\nCode replaced for brevity.\n166: \n167: \n168: \n169: def _strip_once(value):\nCode replaced for brevity.\n176: \n177: \n178: \n179: @keep_lazy_text\n180: def strip_tags(value):\nCode replaced for brevity.\n191: \n192: \n193: \n194: @keep_lazy_text\n195: def strip_spaces_between_tags(value):\nCode replaced for brevity.\n197: \n198: \n199: \n200: def smart_urlquote(url):\nCode replaced for brevity.\n232: \n233: \n234: \n235: @keep_lazy_text\n236: def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n237:     \"\"\"\n238:     Convert any URLs in text into clickable links.\n239: \n240:     Works on http://, https://, www. links, and also on links ending in one of\n241:     the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).\n242:     Links can have trailing punctuation (periods, commas, close-parens) and\n243:     leading punctuation (opening parens) and it'll still do the right thing.\n244: \n245:     If trim_url_limit is not None, truncate the URLs in the link text longer\n246:     than this limit to trim_url_limit - 1 characters and append an ellipsis.\n247: \n248:     If nofollow is True, give the links a rel=\"nofollow\" attribute.\n249: \n250:     If autoescape is True, autoescape the link text and URLs.\n251:     \"\"\"\n252:     safe_input = isinstance(text, SafeData)\n253: \n254:     def trim_url(x, limit=trim_url_limit):\n255:         if limit is None or len(x) <= limit:\n256:             return x\n257:         return '%sâ€¦' % x[:max(0, limit - 1)]\n258: \n259:     def trim_punctuation(lead, middle, trail):\n260:         \"\"\"\n261:         Trim trailing and wrapping punctuation from `middle`. Return the items\n262:         of the new state.\n263:         \"\"\"\n264:         # Continue trimming until middle remains unchanged.\n265:         trimmed_something = True\n266:         while trimmed_something:\n267:             trimmed_something = False\n268:             # Trim wrapping punctuation.\n269:             for opening, closing in WRAPPING_PUNCTUATION:\n270:                 if middle.startswith(opening):\n271:                     middle = middle[len(opening):]\n272:                     lead += opening\n273:                     trimmed_something = True\n274:                 # Keep parentheses at the end only if they're balanced.\n275:                 if (middle.endswith(closing) and\n276:                         middle.count(closing) == middle.count(opening) + 1):\n277:                     middle = middle[:-len(closing)]\n278:                     trail = closing + trail\n279:                     trimmed_something = True\n280:             # Trim trailing punctuation (after trimming wrapping punctuation,\n281:             # as encoded entities contain ';'). Unescape entities to avoid\n282:             # breaking them by removing ';'.\n283:             middle_unescaped = html.unescape(middle)\n284:             stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)\n285:             if middle_unescaped != stripped:\n286:                 trail = middle[len(stripped):] + trail\n287:                 middle = middle[:len(stripped) - len(middle_unescaped)]\n288:                 trimmed_something = True\n289:         return lead, middle, trail\n290: \n291:     def is_email_simple(value):\n292:         \"\"\"Return True if value looks like an email address.\"\"\"\n293:         # An @ must be in the middle of the value.\n294:         if '@' not in value or value.startswith('@') or value.endswith('@'):\n295:             return False\n296:         try:\n297:             p1, p2 = value.split('@')\n298:         except ValueError:\n299:             # value contains more than one @.\n300:             return False\n301:         # Dot must be in p2 (e.g. example.com)\n302:         if '.' not in p2 or p2.startswith('.'):\n303:             return False\n304:         return True\n305: \n306:     words = word_split_re.split(str(text))\n307:     for i, word in enumerate(words):\n308:         if '.' in word or '@' in word or ':' in word:\n309:             # lead: Current punctuation trimmed from the beginning of the word.\n310:             # middle: Current state of the word.\n311:             # trail: Current punctuation trimmed from the end of the word.\n312:             lead, middle, trail = '', word, ''\n313:             # Deal with punctuation.\n314:             lead, middle, trail = trim_punctuation(lead, middle, trail)\n315: \n316:             # Make URL we want to point to.\n317:             url = None\n318:             nofollow_attr = ' rel=\"nofollow\"' if nofollow else ''\n319:             if simple_url_re.match(middle):\n320:                 url = smart_urlquote(html.unescape(middle))\n321:             elif simple_url_2_re.match(middle):\n322:                 url = smart_urlquote('http://%s' % html.unescape(middle))\n323:             elif ':' not in middle and is_email_simple(middle):\n324:                 local, domain = middle.rsplit('@', 1)\n325:                 try:\n326:                     domain = punycode(domain)\n327:                 except UnicodeError:\n328:                     continue\n329:                 url = 'mailto:%s@%s' % (local, domain)\n330:                 nofollow_attr = ''\n331: \n332:             # Make link.\n333:             if url:\n334:                 trimmed = trim_url(middle)\n335:                 if autoescape and not safe_input:\n336:                     lead, trail = escape(lead), escape(trail)\n337:                     trimmed = escape(trimmed)\n338:                 middle = '<a href=\"%s\"%s>%s</a>' % (escape(url), nofollow_attr, trimmed)\n339:                 words[i] = mark_safe('%s%s%s' % (lead, middle, trail))\n340:             else:\n341:                 if safe_input:\n342:                     words[i] = mark_safe(word)\n343:                 elif autoescape:\n344:                     words[i] = escape(word)\n345:         elif safe_input:\n346:             words[i] = mark_safe(word)\n347:         elif autoescape:\n348:             words[i] = escape(word)\n349:     return ''.join(words)\n350: \n351: \n352:     \"\"\nCode replaced for brevity.\n357: \n358: \n359: \n360:     \"\"\nCode replaced for brevity.\n378: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/html.py",
      "suspect_lines": [
        286,
        287
      ]
    }
  ]
}