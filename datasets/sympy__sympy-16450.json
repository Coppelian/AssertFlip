{
  "instance_id": "sympy__sympy-16450",
  "problem_statement": "Posify ignores is_finite assmptions\nPosify removes a finite assumption from a symbol:\r\n```julia\r\nIn [1]: x = Symbol('x', finite=True)                                                                                                           \r\n\r\nIn [2]: x._assumptions                                                                                                                         \r\nOut[2]: {'finite': True, 'infinite': False, 'commutative': True}\r\n\r\nIn [3]: x.is_finite                                                                                                                            \r\nOut[3]: True\r\n\r\nIn [4]: xp, _ = posify(x)                                                                                                                      \r\n\r\nIn [5]: xp._assumptions                                                                                                                        \r\nOut[5]: \r\n{'positive': True,\r\n 'real': True,\r\n 'hermitian': True,\r\n 'imaginary': False,\r\n 'negative': False,\r\n 'nonnegative': True,\r\n 'nonzero': True,\r\n 'zero': False,\r\n 'complex': True,\r\n 'nonpositive': False,\r\n 'commutative': True}\r\n\r\nIn [6]: xp.is_finite                                                                                                                           \r\n\r\nIn [7]: print(xp.is_finite)                                                                                                                    \r\nNone\r\n```\r\nI think that posify should preserve the finiteness assumption. Possibly other assumptions should be preserved as well (integer, rational, prime, even, odd...).\n",
  "localized_code": "[start of sympy/simplify/simplify.py]\n1: from __future__ import print_function, division\n2: \n3: from collections import defaultdict\n4: \n5: from sympy.core import (Basic, S, Add, Mul, Pow, Symbol, sympify, expand_mul,\n6:                         expand_func, Function, Dummy, Expr, factor_terms,\n7:                         expand_power_exp)\n8: from sympy.core.compatibility import iterable, ordered, range, as_int\n9: from sympy.core.evaluate import global_evaluate\n10: from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg, nfloat\n11: from sympy.core.numbers import Float, I, pi, Rational, Integer\n12: from sympy.core.rules import Transform\n13: from sympy.core.sympify import _sympify\n14: from sympy.functions import gamma, exp, sqrt, log, exp_polar, piecewise_fold\n15: from sympy.functions.combinatorial.factorials import CombinatorialFunction\n16: from sympy.functions.elementary.complexes import unpolarify\n17: from sympy.functions.elementary.exponential import ExpBase\n18: from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n19: from sympy.functions.elementary.integers import ceiling\n20: from sympy.functions.elementary.trigonometric import TrigonometricFunction\n21: from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely\n22: from sympy.polys import together, cancel, factor\n23: from sympy.simplify.combsimp import combsimp\n24: from sympy.simplify.cse_opts import sub_pre, sub_post\n25: from sympy.simplify.powsimp import powsimp\n26: from sympy.simplify.radsimp import radsimp, fraction\n27: from sympy.simplify.sqrtdenest import sqrtdenest\n28: from sympy.simplify.trigsimp import trigsimp, exptrigsimp\n29: from sympy.utilities.iterables import has_variety\n30: \n31: \n32: \n33: import mpmath\n34: \n35: \n36: \n37: def separatevars(expr, symbols=[], dict=False, force=False):\n38:     \"\"\"\n39:     Separates variables in an expression, if possible.  By\n40:     default, it separates with respect to all symbols in an\n41:     expression and collects constant coefficients that are\n42:     independent of symbols.\n43: \n44:     If dict=True then the separated terms will be returned\n45:     in a dictionary keyed to their corresponding symbols.\n46:     By default, all symbols in the expression will appear as\n47:     keys; if symbols are provided, then all those symbols will\n48:     be used as keys, and any terms in the expression containing\n49:     other symbols or non-symbols will be returned keyed to the\n50:     string 'coeff'. (Passing None for symbols will return the\n51:     expression in a dictionary keyed to 'coeff'.)\n52: \n53:     If force=True, then bases of powers will be separated regardless\n54:     of assumptions on the symbols involved.\n55: \n56:     Notes\n57:     =====\n58: \n59:     The order of the factors is determined by Mul, so that the\n60:     separated expressions may not necessarily be grouped together.\n61: \n62:     Although factoring is necessary to separate variables in some\n63:     expressions, it is not necessary in all cases, so one should not\n64:     count on the returned factors being factored.\n65: \n66:     Examples\n67:     ========\n68: \n69:     >>> from sympy.abc import x, y, z, alpha\n70:     >>> from sympy import separatevars, sin\n71:     >>> separatevars((x*y)**y)\n72:     (x*y)**y\n73:     >>> separatevars((x*y)**y, force=True)\n74:     x**y*y**y\n75: \n76:     >>> e = 2*x**2*z*sin(y)+2*z*x**2\n77:     >>> separatevars(e)\n78:     2*x**2*z*(sin(y) + 1)\n79:     >>> separatevars(e, symbols=(x, y), dict=True)\n80:     {'coeff': 2*z, x: x**2, y: sin(y) + 1}\n81:     >>> separatevars(e, [x, y, alpha], dict=True)\n82:     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}\n83: \n84:     If the expression is not really separable, or is only partially\n85:     separable, separatevars will do the best it can to separate it\n86:     by using factoring.\n87: \n88:     >>> separatevars(x + x*y - 3*x**2)\n89:     -x*(3*x - y - 1)\n90: \n91:     If the expression is not separable then expr is returned unchanged\n92:     or (if dict=True) then None is returned.\n93: \n94:     >>> eq = 2*x + y*sin(x)\n95:     >>> separatevars(eq) == eq\n96:     True\n97:     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None\n98:     True\n99: \n100:     \"\"\"\n101:     expr = sympify(expr)\n102:     if dict:\n103:         return _separatevars_dict(_separatevars(expr, force), symbols)\n104:     else:\n105:         return _separatevars(expr, force)\n106: \n107: \n108: def _separatevars(expr, force):\nCode replaced for brevity.\n159: \n160: \n161: \n162: def _separatevars_dict(expr, symbols):\nCode replaced for brevity.\n191: \n192: \n193: \n194: def _is_sum_surds(p):\nCode replaced for brevity.\n199: \n200: \n201: \n202: def posify(eq):\n203:     \"\"\"Return eq (with generic symbols made positive) and a\n204:     dictionary containing the mapping between the old and new\n205:     symbols.\n206: \n207:     Any symbol that has positive=None will be replaced with a positive dummy\n208:     symbol having the same name. This replacement will allow more symbolic\n209:     processing of expressions, especially those involving powers and\n210:     logarithms.\n211: \n212:     A dictionary that can be sent to subs to restore eq to its original\n213:     symbols is also returned.\n214: \n215:     >>> from sympy import posify, Symbol, log, solve\n216:     >>> from sympy.abc import x\n217:     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))\n218:     (_x + n + p, {_x: x})\n219: \n220:     >>> eq = 1/x\n221:     >>> log(eq).expand()\n222:     log(1/x)\n223:     >>> log(posify(eq)[0]).expand()\n224:     -log(_x)\n225:     >>> p, rep = posify(eq)\n226:     >>> log(p).expand().subs(rep)\n227:     -log(x)\n228: \n229:     It is possible to apply the same transformations to an iterable\n230:     of expressions:\n231: \n232:     >>> eq = x**2 - 4\n233:     >>> solve(eq, x)\n234:     [-2, 2]\n235:     >>> eq_x, reps = posify([eq, x]); eq_x\n236:     [_x**2 - 4, _x]\n237:     >>> solve(*eq_x)\n238:     [2]\n239:     \"\"\"\n240:     eq = sympify(eq)\n241:     if iterable(eq):\n242:         f = type(eq)\n243:         eq = list(eq)\n244:         syms = set()\n245:         for e in eq:\n246:             syms = syms.union(e.atoms(Symbol))\n247:         reps = {}\n248:         for s in syms:\n249:             reps.update(dict((v, k) for k, v in posify(s)[1].items()))\n250:         for i, e in enumerate(eq):\n251:             eq[i] = e.subs(reps)\n252:         return f(eq), {r: s for s, r in reps.items()}\n253: \n254:     reps = {s: Dummy(s.name, positive=True)\n255:                  for s in eq.free_symbols if s.is_positive is None}\n256:     eq = eq.subs(reps)\n257:     return eq, {r: s for s, r in reps.items()}\n258: \n259: \n260: def hypersimp(f, k):\nCode replaced for brevity.\n298: \n299: \n300: \n301: def hypersimilar(f, g, k):\nCode replaced for brevity.\n316: \n317: \n318: \n319: def signsimp(expr, evaluate=None):\nCode replaced for brevity.\n378: \n379: \n380: \n381: def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False):\nCode replaced for brevity.\n639: \n640: \n641: \n642: def sum_simplify(s):\nCode replaced for brevity.\n683: \n684: \n685: def sum_combine(s_t):\nCode replaced for brevity.\n712: \n713: \n714: def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):\nCode replaced for brevity.\n744: \n745: \n746: def sum_add(self, other, method=0):\nCode replaced for brevity.\n790: \n791: \n792: \n793: def product_simplify(s):\nCode replaced for brevity.\n824: \n825: \n826: \n827: def product_mul(self, other, method=0):\nCode replaced for brevity.\n851: \n852: \n853: \n854: def _nthroot_solve(p, n, prec):\nCode replaced for brevity.\n876: \n877: \n878: \n879: def logcombine(expr, force=False):\nCode replaced for brevity.\n1020: \n1021: \n1022: \n1023: def inversecombine(expr):\nCode replaced for brevity.\n1049: \n1050: \n1051: \n1052: def walk(e, *target):\nCode replaced for brevity.\n1077: \n1078: \n1079: \n1080: def bottom_up(rv, F, atoms=False, nonbasic=False):\nCode replaced for brevity.\n1101: \n1102: \n1103: \n1104: def besselsimp(expr):\nCode replaced for brevity.\n1189: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/simplify/simplify.py",
      "suspect_lines": [
        254
      ]
    }
  ]
}