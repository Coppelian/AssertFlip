{
  "instance_id": "sphinx-doc__sphinx-8595",
  "problem_statement": "autodoc: empty __all__ attribute is ignored\n**Describe the bug**\r\nautodoc: empty `__all__` attribute is ignored\r\n\r\n**To Reproduce**\r\n```\r\n# example.py\r\n__all__ = []\r\n\r\n\r\ndef foo():\r\n    \"docstring\"\r\n\r\n\r\ndef bar():\r\n    \"docstring\"\r\n\r\n\r\ndef baz():\r\n    \"docstring\"\r\n```\r\n```\r\n# index.rst\r\n.. automodule:: example\r\n   :members:\r\n```\r\n\r\nAll foo, bar, and baz are shown.\r\n\r\n**Expected behavior**\r\nNo entries should be shown because `__all__` is empty.\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.1\r\n- Sphinx version: HEAD of 3.x\r\n- Sphinx extensions: sphinx.ext.autodoc\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\n",
  "localized_code": "[start of sphinx/ext/autodoc/__init__.py]\n1: \"\"\"\n2:     sphinx.ext.autodoc\n3:     ~~~~~~~~~~~~~~~~~~\n4: \n5:     Automatically insert docstrings for functions, classes or whole modules into\n6:     the doctree, thus avoiding duplication between docstrings and documentation\n7:     for those who like elaborate docstrings.\n8: \n9:     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10:     :license: BSD, see LICENSE for details.\n11: \"\"\"\n12: \n13: import re\n14: import warnings\n15: from inspect import Parameter, Signature\n16: from types import ModuleType\n17: from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,\n18:                     TypeVar, Union)\n19: \n20: from docutils.statemachine import StringList\n21: \n22: import sphinx\n23: from sphinx.application import Sphinx\n24: from sphinx.config import ENUM, Config\n25: from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,\n26:                                 RemovedInSphinx60Warning)\n27: from sphinx.environment import BuildEnvironment\n28: from sphinx.ext.autodoc.importer import (ClassAttribute, get_class_members, get_object_members,\n29:                                          import_module, import_object)\n30: from sphinx.ext.autodoc.mock import mock\n31: from sphinx.locale import _, __\n32: from sphinx.pycode import ModuleAnalyzer, PycodeError\n33: from sphinx.util import inspect, logging\n34: from sphinx.util.docstrings import extract_metadata, prepare_docstring\n35: from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n36:                                  stringify_signature)\n37: from sphinx.util.typing import get_type_hints, restify\n38: from sphinx.util.typing import stringify as stringify_typehint\n39: \n40: if False:\n41:     # For type annotation\n42:     from typing import Type  # NOQA # for python3.5.1\n43: \n44:     from sphinx.ext.autodoc.directive import DocumenterBridge\n45: \n46: \n47: logger = logging.getLogger(__name__)\n48: \n49: \n50: # This type isn't exposed directly in any modules, but can be found\n51: # here in most Python versions\n52: MethodDescriptorType = type(type.__subclasses__)\n53: \n54: \n55: #: extended signature RE: with explicit module name separated by ::\n56: py_ext_sig_re = re.compile(\n57:     r'''^ ([\\w.]+::)?            # explicit module name\n58:           ([\\w.]+\\.)?            # module and/or class name(s)\n59:           (\\w+)  \\s*             # thing name\n60:           (?: \\((.*)\\)           # optional: arguments\n61:            (?:\\s* -> \\s* (.*))?  #           return annotation\n62:           )? $                   # and nothing more\n63:           ''', re.VERBOSE)\n64: special_member_re = re.compile(r'^__\\S+__$')\n65: \n66: \n67: def identity(x: Any) -> Any:\n68:     return x\n69: \n70: \n71: class _All:\nCode replaced for brevity.\n75: \n76: \n77: \n78: class _Empty:\nCode replaced for brevity.\n82: \n83: \n84: \n85: ALL = _All()\n86: EMPTY = _Empty()\n87: UNINITIALIZED_ATTR = object()\n88: INSTANCEATTR = object()\n89: SLOTSATTR = object()\n90: \n91: \n92: def members_option(arg: Any) -> Union[object, List[str]]:\nCode replaced for brevity.\n99: \n100: \n101: \n102: def members_set_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n108: \n109: \n110: \n111: def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n115: \n116: \n117: \n118: def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n123: \n124: \n125: \n126: def member_order_option(arg: Any) -> Optional[str]:\nCode replaced for brevity.\n133: \n134: \n135: \n136: SUPPRESS = object()\n137: \n138: \n139: def annotation_option(arg: Any) -> Any:\nCode replaced for brevity.\n144: \n145: \n146: \n147: def bool_option(arg: Any) -> bool:\nCode replaced for brevity.\n151: \n152: \n153: \n154: def merge_special_members_option(options: Dict) -> None:\nCode replaced for brevity.\n166: \n167: \n168: \n169: def merge_members_option(options: Dict) -> None:\nCode replaced for brevity.\n180: \n181: \n182: \n183: # Some useful event listener factories for autodoc-process-docstring.\n184: \n185: def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\nCode replaced for brevity.\n210: \n211: \n212: \n213:             exclude: bool = False) -> Callable:\nCode replaced for brevity.\n246: \n247: \n248: \n249: # This class is used only in ``sphinx.ext.autodoc.directive``,\n250: # But we define this class here to keep compatibility (see #4538)\n251: class Options(dict):\nCode replaced for brevity.\n257: \n258: \n259: \n260: class ObjectMember(tuple):\nCode replaced for brevity.\n283: \n284: \n285: \n286: ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n287: \n288: \n289: class Documenter:\nCode replaced for brevity.\n968: \n969: \n970: \n971: class ModuleDocumenter(Documenter):\n972:     \"\"\"\n973:     Specialized Documenter subclass for modules.\n974:     \"\"\"\n975:     objtype = 'module'\n976:     content_indent = ''\n977:     titles_allowed = True\n978: \n979:     option_spec = {\n980:         'members': members_option, 'undoc-members': bool_option,\n981:         'noindex': bool_option, 'inherited-members': inherited_members_option,\n982:         'show-inheritance': bool_option, 'synopsis': identity,\n983:         'platform': identity, 'deprecated': bool_option,\n984:         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n985:         'private-members': members_option, 'special-members': members_option,\n986:         'imported-members': bool_option, 'ignore-module-all': bool_option\n987:     }  # type: Dict[str, Callable]\n988: \n989:     def __init__(self, *args: Any) -> None:\n990:         super().__init__(*args)\n991:         merge_members_option(self.options)\n992:         self.__all__ = None  # type: Optional[Sequence[str]]\n993: \n994:     @classmethod\n995:     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n996:                             ) -> bool:\n997:         # don't document submodules automatically\n998:         return False\n999: \n1000:     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1001:                      ) -> Tuple[str, List[str]]:\n1002:         if modname is not None:\n1003:             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n1004:                            type='autodoc')\n1005:         return (path or '') + base, []\n1006: \n1007:     def parse_name(self) -> bool:\n1008:         ret = super().parse_name()\n1009:         if self.args or self.retann:\n1010:             logger.warning(__('signature arguments or return annotation '\n1011:                               'given for automodule %s') % self.fullname,\n1012:                            type='autodoc')\n1013:         return ret\n1014: \n1015:     def import_object(self, raiseerror: bool = False) -> bool:\n1016:         ret = super().import_object(raiseerror)\n1017: \n1018:         try:\n1019:             if not self.options.ignore_module_all:\n1020:                 self.__all__ = inspect.getall(self.object)\n1021:         except AttributeError as exc:\n1022:             # __all__ raises an error.\n1023:             logger.warning(__('%s.__all__ raises an error. Ignored: %r'),\n1024:                            (self.fullname, exc), type='autodoc')\n1025:         except ValueError as exc:\n1026:             # invalid __all__ found.\n1027:             logger.warning(__('__all__ should be a list of strings, not %r '\n1028:                               '(in module %s) -- ignoring __all__') %\n1029:                            (exc.args[0], self.fullname), type='autodoc')\n1030: \n1031:         return ret\n1032: \n1033:     def add_directive_header(self, sig: str) -> None:\n1034:         Documenter.add_directive_header(self, sig)\n1035: \n1036:         sourcename = self.get_sourcename()\n1037: \n1038:         # add some module-specific options\n1039:         if self.options.synopsis:\n1040:             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n1041:         if self.options.platform:\n1042:             self.add_line('   :platform: ' + self.options.platform, sourcename)\n1043:         if self.options.deprecated:\n1044:             self.add_line('   :deprecated:', sourcename)\n1045: \n1046:     def get_module_members(self) -> Dict[str, ObjectMember]:\n1047:         \"\"\"Get members of target module.\"\"\"\n1048:         if self.analyzer:\n1049:             attr_docs = self.analyzer.attr_docs\n1050:         else:\n1051:             attr_docs = {}\n1052: \n1053:         members = {}  # type: Dict[str, ObjectMember]\n1054:         for name in dir(self.object):\n1055:             try:\n1056:                 value = safe_getattr(self.object, name, None)\n1057:                 docstring = attr_docs.get(('', name), [])\n1058:                 members[name] = ObjectMember(name, value, docstring=\"\\n\".join(docstring))\n1059:             except AttributeError:\n1060:                 continue\n1061: \n1062:         # annotation only member (ex. attr: int)\n1063:         try:\n1064:             for name in inspect.getannotations(self.object):\n1065:                 if name not in members:\n1066:                     docstring = attr_docs.get(('', name), [])\n1067:                     members[name] = ObjectMember(name, INSTANCEATTR,\n1068:                                                  docstring=\"\\n\".join(docstring))\n1069:         except AttributeError:\n1070:             pass\n1071: \n1072:         return members\n1073: \n1074:     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1075:         members = self.get_module_members()\n1076:         if want_all:\n1077:             if not self.__all__:\n1078:                 # for implicit module members, check __module__ to avoid\n1079:                 # documenting imported objects\n1080:                 return True, list(members.values())\n1081:             else:\n1082:                 for member in members.values():\n1083:                     if member.__name__ not in self.__all__:\n1084:                         member.skipped = True\n1085: \n1086:                 return False, list(members.values())\n1087:         else:\n1088:             memberlist = self.options.members or []\n1089:             ret = []\n1090:             for name in memberlist:\n1091:                 if name in members:\n1092:                     ret.append(members[name])\n1093:                 else:\n1094:                     logger.warning(__('missing attribute mentioned in :members: option: '\n1095:                                       'module %s, attribute %s') %\n1096:                                    (safe_getattr(self.object, '__name__', '???'), name),\n1097:                                    type='autodoc')\n1098:             return False, ret\n1099: \n1100:     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1101:                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1102:         if order == 'bysource' and self.__all__:\n1103:             # Sort alphabetically first (for members not listed on the __all__)\n1104:             documenters.sort(key=lambda e: e[0].name)\n1105: \n1106:             # Sort by __all__\n1107:             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1108:                 name = entry[0].name.split('::')[1]\n1109:                 if name in self.__all__:\n1110:                     return self.__all__.index(name)\n1111:                 else:\n1112:                     return len(self.__all__)\n1113:             documenters.sort(key=keyfunc)\n1114: \n1115:             return documenters\n1116:         else:\n1117:             return super().sort_members(documenters, order)\n1118: \n1119: \n1120: class ModuleLevelDocumenter(Documenter):\nCode replaced for brevity.\n1138: \n1139: \n1140: \n1141: class ClassLevelDocumenter(Documenter):\nCode replaced for brevity.\n1171: \n1172: \n1173: \n1174: class DocstringSignatureMixin:\nCode replaced for brevity.\n1266: \n1267: \n1268: \n1269: class DocstringStripSignatureMixin(DocstringSignatureMixin):\nCode replaced for brevity.\n1284: \n1285: \n1286: \n1287: class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n1387: \n1388: \n1389: \n1390: class DecoratorDocumenter(FunctionDocumenter):\nCode replaced for brevity.\n1404: \n1405: \n1406: \n1407: # Types which have confusing metaclass signatures it would be best not to show.\n1408: # These are listed by name, rather than storing the objects themselves, to avoid\n1409: # needing to import the modules.\n1410: _METACLASS_CALL_BLACKLIST = [\n1411:     'enum.EnumMeta.__call__',\n1412: ]\n1413: \n1414: \n1415: # Types whose __new__ signature is a pass-thru.\n1416: _CLASS_NEW_BLACKLIST = [\n1417:     'typing.Generic.__new__',\n1418: ]\n1419: \n1420: \n1421: class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n1717: \n1718: \n1719: \n1720: class ExceptionDocumenter(ClassDocumenter):\nCode replaced for brevity.\n1733: \n1734: \n1735: \n1736:     # define types of instance variables\nCode replaced for brevity.\n1755: \n1756: \n1757: \n1758: class GenericAliasMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1774: \n1775: \n1776: \n1777: class NewTypeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1793: \n1794: \n1795: \n1796: class TypeVarMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1833: \n1834: \n1835: \n1836: class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1874: \n1875: \n1876: \n1877:                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\nCode replaced for brevity.\n1987: \n1988: \n1989: \n1990: class NewTypeDataDocumenter(DataDocumenter):\nCode replaced for brevity.\n2005: \n2006: \n2007: \n2008: class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n2153: \n2154: \n2155: \n2156: class NonDataDescriptorMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2175: \n2176: \n2177: \n2178: class SlotsMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2222: \n2223: \n2224: \n2225: class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2275: \n2276: \n2277: \n2278: class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2324: \n2325: \n2326: \n2327:                           DocstringStripSignatureMixin, ClassLevelDocumenter):\nCode replaced for brevity.\n2498: \n2499: \n2500: \n2501: class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n2529: \n2530: \n2531: \n2532: class NewTypeAttributeDocumenter(AttributeDocumenter):\nCode replaced for brevity.\n2547: \n2548: \n2549: \n2550: def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\nCode replaced for brevity.\n2553: \n2554: \n2555: \n2556: def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\nCode replaced for brevity.\n2562: \n2563: \n2564: \n2565: def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\nCode replaced for brevity.\n2570: \n2571: \n2572: \n2573: # for compatibility\n2574: from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2575: from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2576: from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2577: from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2578: from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2579: from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2580: from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2581: \n2582: \n2583: def setup(app: Sphinx) -> Dict[str, Any]:\nCode replaced for brevity.\n2617: \n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/ext/autodoc/__init__.py",
      "suspect_lines": [
        1077
      ]
    }
  ]
}