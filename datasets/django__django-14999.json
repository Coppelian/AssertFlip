{
  "instance_id": "django__django-14999",
  "problem_statement": "RenameModel with db_table should be a noop.\nDescription\n\t\nA RenameModel operation that already has db_table defined must be a noop.\nIn Postgres, it drops and recreates foreign key constraints. In sqlite it recreates the table (as expected for a table renaming).\n",
  "localized_code": "[start of django/db/migrations/operations/models.py]\n1: from django.db import models\n2: from django.db.migrations.operations.base import Operation\n3: from django.db.migrations.state import ModelState\n4: from django.db.migrations.utils import field_references, resolve_relation\n5: from django.db.models.options import normalize_together\n6: from django.utils.functional import cached_property\n7: \n8: from .fields import (\n9:     AddField, AlterField, FieldOperation, RemoveField, RenameField,\n10: )\n11: \n12: \n13: def _check_for_duplicates(arg_name, objs):\n14:     used_vals = set()\n15:     for val in objs:\n16:         if val in used_vals:\n17:             raise ValueError(\n18:                 \"Found duplicate value %s in CreateModel %s argument.\" % (val, arg_name)\n19:             )\n20:         used_vals.add(val)\n21: \n22: \n23: class ModelOperation(Operation):\n24:     def __init__(self, name):\n25:         self.name = name\n26: \n27:     @cached_property\n28:     def name_lower(self):\n29:         return self.name.lower()\n30: \n31:     def references_model(self, name, app_label):\n32:         return name.lower() == self.name_lower\n33: \n34:     def reduce(self, operation, app_label):\n35:         return (\n36:             super().reduce(operation, app_label) or\n37:             not operation.references_model(self.name, app_label)\n38:         )\n39: \n40: \n41: class CreateModel(ModelOperation):\n42:     \"\"\"Create a model's table.\"\"\"\n43: \n44:     serialization_expand_args = ['fields', 'options', 'managers']\n45: \n46:     def __init__(self, name, fields, options=None, bases=None, managers=None):\n47:         self.fields = fields\n48:         self.options = options or {}\n49:         self.bases = bases or (models.Model,)\n50:         self.managers = managers or []\n51:         super().__init__(name)\n52:         # Sanity-check that there are no duplicated field names, bases, or\n53:         # manager names\n54:         _check_for_duplicates('fields', (name for name, _ in self.fields))\n55:         _check_for_duplicates('bases', (\n56:             base._meta.label_lower if hasattr(base, '_meta') else\n57:             base.lower() if isinstance(base, str) else base\n58:             for base in self.bases\n59:         ))\n60:         _check_for_duplicates('managers', (name for name, _ in self.managers))\n61: \n62:     def deconstruct(self):\n63:         kwargs = {\n64:             'name': self.name,\n65:             'fields': self.fields,\n66:         }\n67:         if self.options:\n68:             kwargs['options'] = self.options\n69:         if self.bases and self.bases != (models.Model,):\n70:             kwargs['bases'] = self.bases\n71:         if self.managers and self.managers != [('objects', models.Manager())]:\n72:             kwargs['managers'] = self.managers\n73:         return (\n74:             self.__class__.__qualname__,\n75:             [],\n76:             kwargs\n77:         )\n78: \n79:     def state_forwards(self, app_label, state):\n80:         state.add_model(ModelState(\n81:             app_label,\n82:             self.name,\n83:             list(self.fields),\n84:             dict(self.options),\n85:             tuple(self.bases),\n86:             list(self.managers),\n87:         ))\n88: \n89:     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n90:         model = to_state.apps.get_model(app_label, self.name)\n91:         if self.allow_migrate_model(schema_editor.connection.alias, model):\n92:             schema_editor.create_model(model)\n93: \n94:     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n95:         model = from_state.apps.get_model(app_label, self.name)\n96:         if self.allow_migrate_model(schema_editor.connection.alias, model):\n97:             schema_editor.delete_model(model)\n98: \n99:     def describe(self):\n100:         return \"Create %smodel %s\" % (\"proxy \" if self.options.get(\"proxy\", False) else \"\", self.name)\n101: \n102:     @property\n103:     def migration_name_fragment(self):\n104:         return self.name_lower\n105: \n106:     def references_model(self, name, app_label):\n107:         name_lower = name.lower()\n108:         if name_lower == self.name_lower:\n109:             return True\n110: \n111:         # Check we didn't inherit from the model\n112:         reference_model_tuple = (app_label, name_lower)\n113:         for base in self.bases:\n114:             if (base is not models.Model and isinstance(base, (models.base.ModelBase, str)) and\n115:                     resolve_relation(base, app_label) == reference_model_tuple):\n116:                 return True\n117: \n118:         # Check we have no FKs/M2Ms with it\n119:         for _name, field in self.fields:\n120:             if field_references((app_label, self.name_lower), field, reference_model_tuple):\n121:                 return True\n122:         return False\n123: \n124:     def reduce(self, operation, app_label):\n125:         if (isinstance(operation, DeleteModel) and\n126:                 self.name_lower == operation.name_lower and\n127:                 not self.options.get(\"proxy\", False)):\n128:             return []\n129:         elif isinstance(operation, RenameModel) and self.name_lower == operation.old_name_lower:\n130:             return [\n131:                 CreateModel(\n132:                     operation.new_name,\n133:                     fields=self.fields,\n134:                     options=self.options,\n135:                     bases=self.bases,\n136:                     managers=self.managers,\n137:                 ),\n138:             ]\n139:         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:\n140:             options = {**self.options, **operation.options}\n141:             for key in operation.ALTER_OPTION_KEYS:\n142:                 if key not in operation.options:\n143:                     options.pop(key, None)\n144:             return [\n145:                 CreateModel(\n146:                     self.name,\n147:                     fields=self.fields,\n148:                     options=options,\n149:                     bases=self.bases,\n150:                     managers=self.managers,\n151:                 ),\n152:             ]\n153:         elif isinstance(operation, AlterTogetherOptionOperation) and self.name_lower == operation.name_lower:\n154:             return [\n155:                 CreateModel(\n156:                     self.name,\n157:                     fields=self.fields,\n158:                     options={**self.options, **{operation.option_name: operation.option_value}},\n159:                     bases=self.bases,\n160:                     managers=self.managers,\n161:                 ),\n162:             ]\n163:         elif isinstance(operation, AlterOrderWithRespectTo) and self.name_lower == operation.name_lower:\n164:             return [\n165:                 CreateModel(\n166:                     self.name,\n167:                     fields=self.fields,\n168:                     options={**self.options, 'order_with_respect_to': operation.order_with_respect_to},\n169:                     bases=self.bases,\n170:                     managers=self.managers,\n171:                 ),\n172:             ]\n173:         elif isinstance(operation, FieldOperation) and self.name_lower == operation.model_name_lower:\n174:             if isinstance(operation, AddField):\n175:                 return [\n176:                     CreateModel(\n177:                         self.name,\n178:                         fields=self.fields + [(operation.name, operation.field)],\n179:                         options=self.options,\n180:                         bases=self.bases,\n181:                         managers=self.managers,\n182:                     ),\n183:                 ]\n184:             elif isinstance(operation, AlterField):\n185:                 return [\n186:                     CreateModel(\n187:                         self.name,\n188:                         fields=[\n189:                             (n, operation.field if n == operation.name else v)\n190:                             for n, v in self.fields\n191:                         ],\n192:                         options=self.options,\n193:                         bases=self.bases,\n194:                         managers=self.managers,\n195:                     ),\n196:                 ]\n197:             elif isinstance(operation, RemoveField):\n198:                 options = self.options.copy()\n199:                 for option_name in ('unique_together', 'index_together'):\n200:                     option = options.pop(option_name, None)\n201:                     if option:\n202:                         option = set(filter(bool, (\n203:                             tuple(f for f in fields if f != operation.name_lower) for fields in option\n204:                         )))\n205:                         if option:\n206:                             options[option_name] = option\n207:                 order_with_respect_to = options.get('order_with_respect_to')\n208:                 if order_with_respect_to == operation.name_lower:\n209:                     del options['order_with_respect_to']\n210:                 return [\n211:                     CreateModel(\n212:                         self.name,\n213:                         fields=[\n214:                             (n, v)\n215:                             for n, v in self.fields\n216:                             if n.lower() != operation.name_lower\n217:                         ],\n218:                         options=options,\n219:                         bases=self.bases,\n220:                         managers=self.managers,\n221:                     ),\n222:                 ]\n223:             elif isinstance(operation, RenameField):\n224:                 options = self.options.copy()\n225:                 for option_name in ('unique_together', 'index_together'):\n226:                     option = options.get(option_name)\n227:                     if option:\n228:                         options[option_name] = {\n229:                             tuple(operation.new_name if f == operation.old_name else f for f in fields)\n230:                             for fields in option\n231:                         }\n232:                 order_with_respect_to = options.get('order_with_respect_to')\n233:                 if order_with_respect_to == operation.old_name:\n234:                     options['order_with_respect_to'] = operation.new_name\n235:                 return [\n236:                     CreateModel(\n237:                         self.name,\n238:                         fields=[\n239:                             (operation.new_name if n == operation.old_name else n, v)\n240:                             for n, v in self.fields\n241:                         ],\n242:                         options=options,\n243:                         bases=self.bases,\n244:                         managers=self.managers,\n245:                     ),\n246:                 ]\n247:         return super().reduce(operation, app_label)\n248: \n249: \n250: class DeleteModel(ModelOperation):\nCode replaced for brevity.\n286: \n287: \n288: \n289: class RenameModel(ModelOperation):\n290:     \"\"\"Rename a model.\"\"\"\n291: \n292:     def __init__(self, old_name, new_name):\n293:         self.old_name = old_name\n294:         self.new_name = new_name\n295:         super().__init__(old_name)\n296: \n297:     @cached_property\n298:     def old_name_lower(self):\n299:         return self.old_name.lower()\n300: \n301:     @cached_property\n302:     def new_name_lower(self):\n303:         return self.new_name.lower()\n304: \n305:     def deconstruct(self):\n306:         kwargs = {\n307:             'old_name': self.old_name,\n308:             'new_name': self.new_name,\n309:         }\n310:         return (\n311:             self.__class__.__qualname__,\n312:             [],\n313:             kwargs\n314:         )\n315: \n316:     def state_forwards(self, app_label, state):\n317:         state.rename_model(app_label, self.old_name, self.new_name)\n318: \n319:     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n320:         new_model = to_state.apps.get_model(app_label, self.new_name)\n321:         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n322:             old_model = from_state.apps.get_model(app_label, self.old_name)\n323:             # Move the main table\n324:             schema_editor.alter_db_table(\n325:                 new_model,\n326:                 old_model._meta.db_table,\n327:                 new_model._meta.db_table,\n328:             )\n329:             # Alter the fields pointing to us\n330:             for related_object in old_model._meta.related_objects:\n331:                 if related_object.related_model == old_model:\n332:                     model = new_model\n333:                     related_key = (app_label, self.new_name_lower)\n334:                 else:\n335:                     model = related_object.related_model\n336:                     related_key = (\n337:                         related_object.related_model._meta.app_label,\n338:                         related_object.related_model._meta.model_name,\n339:                     )\n340:                 to_field = to_state.apps.get_model(\n341:                     *related_key\n342:                 )._meta.get_field(related_object.field.name)\n343:                 schema_editor.alter_field(\n344:                     model,\n345:                     related_object.field,\n346:                     to_field,\n347:                 )\n348:             # Rename M2M fields whose name is based on this model's name.\n349:             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)\n350:             for (old_field, new_field) in fields:\n351:                 # Skip self-referential fields as these are renamed above.\n352:                 if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:\n353:                     continue\n354:                 # Rename the M2M table that's based on this model's name.\n355:                 old_m2m_model = old_field.remote_field.through\n356:                 new_m2m_model = new_field.remote_field.through\n357:                 schema_editor.alter_db_table(\n358:                     new_m2m_model,\n359:                     old_m2m_model._meta.db_table,\n360:                     new_m2m_model._meta.db_table,\n361:                 )\n362:                 # Rename the column in the M2M table that's based on this\n363:                 # model's name.\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/operations/models.py",
      "suspect_lines": [
        324,
        325,
        326,
        327,
        328
      ]
    }
  ]
}