{
  "instance_id": "django__django-15252",
  "problem_statement": "MigrationRecorder does not obey db_router allow_migrate rules\nDescription\n\t\nHi,\nWe have a multi-db setup. We have one connection that is for the django project, and several connections that talk to other dbs for information (ie models with managed = False). Django should only create tables in the first connection, never in any of the other connections. We have a simple router that does the following: \nclass Router(object):\n\tdef allow_migrate(self, db, model):\n\t\tif db == 'default':\n\t\t\treturn True\n\t\treturn False\nCurrent Behaviour\nWe run our functional tests and the migrate command is called against each connection when the test databases are created (see django/test/runner.py, setup_databases, line 300-ish, which calls django/db/backends/creation.py, create_test_db, line 377-ish)\nWhen this migrate runs, it tries to apply our migrations, which tries to record that a migration has been applied (see django/db/migrations/executor.py, apply_migration, which has several calls to self.recorder.record_applied). \nThe first thing that record_applied does is a call to self.ensure_schema() (see django/db/migrations/recorder.py, record_applied, lien 66-ish). \nensure_schema checks to see if the Migration model is in the tables in the connection. If it does not find the table then it tries to create the table. \nI believe that this is incorrect behaviour when a db_router has been provided. If using the router above, my expectation would be that the table is not created on any connection other than the 'default' connection. Looking at the other methods on the MigrationRecorder, I would expect that there will be similar issues with applied_migrations and record_unapplied.\n",
  "localized_code": "[start of django/db/migrations/executor.py]\n1: from django.apps.registry import apps as global_apps\n2: from django.db import migrations, router\n3: \n4: from .exceptions import InvalidMigrationPlan\n5: from .loader import MigrationLoader\n6: from .recorder import MigrationRecorder\n7: from .state import ProjectState\n8: \n9: \n10: class MigrationExecutor:\n11:     \"\"\"\n12:     End-to-end migration execution - load migrations and run them up or down\n13:     to a specified set of targets.\n14:     \"\"\"\n15: \n16:     def __init__(self, connection, progress_callback=None):\n17:         self.connection = connection\n18:         self.loader = MigrationLoader(self.connection)\n19:         self.recorder = MigrationRecorder(self.connection)\n20:         self.progress_callback = progress_callback\n21: \n22:     def migration_plan(self, targets, clean_start=False):\n23:         \"\"\"\n24:         Given a set of targets, return a list of (Migration instance, backwards?).\n25:         \"\"\"\n26:         plan = []\n27:         if clean_start:\n28:             applied = {}\n29:         else:\n30:             applied = dict(self.loader.applied_migrations)\n31:         for target in targets:\n32:             # If the target is (app_label, None), that means unmigrate everything\n33:             if target[1] is None:\n34:                 for root in self.loader.graph.root_nodes():\n35:                     if root[0] == target[0]:\n36:                         for migration in self.loader.graph.backwards_plan(root):\n37:                             if migration in applied:\n38:                                 plan.append((self.loader.graph.nodes[migration], True))\n39:                                 applied.pop(migration)\n40:             # If the migration is already applied, do backwards mode,\n41:             # otherwise do forwards mode.\n42:             elif target in applied:\n43:                 # If the target is missing, it's likely a replaced migration.\n44:                 # Reload the graph without replacements.\n45:                 if (\n46:                     self.loader.replace_migrations and\n47:                     target not in self.loader.graph.node_map\n48:                 ):\n49:                     self.loader.replace_migrations = False\n50:                     self.loader.build_graph()\n51:                     return self.migration_plan(targets, clean_start=clean_start)\n52:                 # Don't migrate backwards all the way to the target node (that\n53:                 # may roll back dependencies in other apps that don't need to\n54:                 # be rolled back); instead roll back through target's immediate\n55:                 # child(ren) in the same app, and no further.\n56:                 next_in_app = sorted(\n57:                     n for n in\n58:                     self.loader.graph.node_map[target].children\n59:                     if n[0] == target[0]\n60:                 )\n61:                 for node in next_in_app:\n62:                     for migration in self.loader.graph.backwards_plan(node):\n63:                         if migration in applied:\n64:                             plan.append((self.loader.graph.nodes[migration], True))\n65:                             applied.pop(migration)\n66:             else:\n67:                 for migration in self.loader.graph.forwards_plan(target):\n68:                     if migration not in applied:\n69:                         plan.append((self.loader.graph.nodes[migration], False))\n70:                         applied[migration] = self.loader.graph.nodes[migration]\n71:         return plan\n72: \n73:     def _create_project_state(self, with_applied_migrations=False):\n74:         \"\"\"\n75:         Create a project state including all the applications without\n76:         migrations and applied migrations if with_applied_migrations=True.\n77:         \"\"\"\n78:         state = ProjectState(real_apps=self.loader.unmigrated_apps)\n79:         if with_applied_migrations:\n80:             # Create the forwards plan Django would follow on an empty database\n81:             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)\n82:             applied_migrations = {\n83:                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations\n84:                 if key in self.loader.graph.nodes\n85:             }\n86:             for migration, _ in full_plan:\n87:                 if migration in applied_migrations:\n88:                     migration.mutate_state(state, preserve=False)\n89:         return state\n90: \n91:     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):\n92:         \"\"\"\n93:         Migrate the database up to the given targets.\n94: \n95:         Django first needs to create all project states before a migration is\n96:         (un)applied and in a second step run all the database operations.\n97:         \"\"\"\n98:         # The django_migrations table must be present to record applied\n99:         # migrations.\n100:         self.recorder.ensure_schema()\n101: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/executor.py",
      "suspect_lines": [
        99,
        100
      ]
    }
  ]
}