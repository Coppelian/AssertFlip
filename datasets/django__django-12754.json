{
  "instance_id": "django__django-12754",
  "problem_statement": "FieldError when migrating field to new model subclass.\nDescription\n\t\nAnalogous to #21890. If creating a model subclass and moving a field onto it in the same step, makemigrations works but migrate dies with django.core.exceptions.FieldError: Local field 'title' in class 'Book' clashes with field of the same name from base class 'Readable'.\nFor example, take this model:\nfrom django.db import models\nclass Readable(models.Model):\n\ttitle = models.CharField(max_length=200)\nAnd change to this:\nfrom django.db import models\nclass Readable(models.Model):\n\tpass\nclass Book(Readable):\n\ttitle = models.CharField(max_length=200)\nThe migration generates with CreateModel for Book, then RemoveField for Readable.title. But running it produces the error.\nReversing the order of the migration operations makes it pass. The auto-detector should be able to use this order.\n",
  "localized_code": "[start of django/db/migrations/autodetector.py]\n1: import functools\n2: import re\n3: from itertools import chain\n4: \n5: from django.conf import settings\n6: from django.db import models\n7: from django.db.migrations import operations\n8: from django.db.migrations.migration import Migration\n9: from django.db.migrations.operations.models import AlterModelOptions\n10: from django.db.migrations.optimizer import MigrationOptimizer\n11: from django.db.migrations.questioner import MigrationQuestioner\n12: from django.db.migrations.utils import (\n13:     COMPILED_REGEX_TYPE, RegexObject, get_migration_name_timestamp,\n14: )\n15: from django.utils.topological_sort import stable_topological_sort\n16: \n17: \n18: class MigrationAutodetector:\n19:     \"\"\"\n20:     Take a pair of ProjectStates and compare them to see what the first would\n21:     need doing to make it match the second (the second usually being the\n22:     project's current state).\n23: \n24:     Note that this naturally operates on entire projects at a time,\n25:     as it's likely that changes interact (for example, you can't\n26:     add a ForeignKey without having a migration to add the table it\n27:     depends on first). A user interface may offer single-app usage\n28:     if it wishes, with the caveat that it may not always be possible.\n29:     \"\"\"\n30: \n31:     def __init__(self, from_state, to_state, questioner=None):\n32:         self.from_state = from_state\n33:         self.to_state = to_state\n34:         self.questioner = questioner or MigrationQuestioner()\n35:         self.existing_apps = {app for app, model in from_state.models}\n36: \n37:     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):\n38:         \"\"\"\n39:         Main entry point to produce a list of applicable changes.\n40:         Take a graph to base names on and an optional set of apps\n41:         to try and restrict to (restriction is not guaranteed)\n42:         \"\"\"\n43:         changes = self._detect_changes(convert_apps, graph)\n44:         changes = self.arrange_for_graph(changes, graph, migration_name)\n45:         if trim_to_apps:\n46:             changes = self._trim_to_apps(changes, trim_to_apps)\n47:         return changes\n48: \n49:     def deep_deconstruct(self, obj):\n50:         \"\"\"\n51:         Recursive deconstruction for a field and its arguments.\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/autodetector.py",
      "suspect_lines": []
    }
  ]
}