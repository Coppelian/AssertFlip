{
  "instance_id": "django__django-16901",
  "problem_statement": "On databases lacking XOR, Q(…) ^ Q(…) ^ Q(…) wrongly interpreted as exactly-one rather than parity\nDescription\n\t\nOn databases that don’t natively support XOR, such as PostgreSQL, Django generates incorrect fallback SQL for Q(…) ^ Q(…) ^ Q(…) with more than 2 arguments. The ​correct interpretation, and the interpretation of databases natively supporting XOR (e.g. ​MySQL), is that a ^ b ^ c is true when an odd number of the arguments are true. But Django’s fallback interpretation is that a ^ b ^ c is true when exactly one argument is true:\n>>> from django.db.models import Q\n>>> from my_app.models import Client\n>>> Client.objects.filter(Q(id=37)).count()\n1\n>>> Client.objects.filter(Q(id=37) ^ Q(id=37)).count()\n0\n>>> Client.objects.filter(Q(id=37) ^ Q(id=37) ^ Q(id=37)).count()\n0\n>>> Client.objects.filter(Q(id=37) ^ Q(id=37) ^ Q(id=37) ^ Q(id=37)).count()\n0\n>>> Client.objects.filter(Q(id=37) ^ Q(id=37) ^ Q(id=37) ^ Q(id=37) ^ Q(id=37)).count()\n0\n(Expected: 1, 0, 1, 0, 1.)\nThis was introduced in #29865.\n",
  "localized_code": "[start of django/db/models/sql/where.py]\n1: \"\"\"\n2: Code to manage the creation and SQL rendering of 'where' constraints.\n3: \"\"\"\n4: import operator\n5: from functools import reduce\n6: \n7: from django.core.exceptions import EmptyResultSet, FullResultSet\n8: from django.db.models.expressions import Case, When\n9: from django.db.models.lookups import Exact\n10: from django.utils import tree\n11: from django.utils.functional import cached_property\n12: \n13: # Connection types\n14: AND = \"AND\"\n15: OR = \"OR\"\n16: XOR = \"XOR\"\n17: \n18: \n19: class WhereNode(tree.Node):\n20:     \"\"\"\n21:     An SQL WHERE clause.\n22: \n23:     The class is tied to the Query class that created it (in order to create\n24:     the correct SQL).\n25: \n26:     A child is usually an expression producing boolean values. Most likely the\n27:     expression is a Lookup instance.\n28: \n29:     However, a child could also be any class with as_sql() and either\n30:     relabeled_clone() method or relabel_aliases() and clone() methods and\n31:     contains_aggregate attribute.\n32:     \"\"\"\n33: \n34:     default = AND\n35:     resolved = False\n36:     conditional = True\n37: \n38:     def split_having_qualify(self, negated=False, must_group_by=False):\n39:         \"\"\"\n40:         Return three possibly None nodes: one for those parts of self that\n41:         should be included in the WHERE clause, one for those parts of self\n42:         that must be included in the HAVING clause, and one for those parts\n43:         that refer to window functions.\n44:         \"\"\"\n45:         if not self.contains_aggregate and not self.contains_over_clause:\n46:             return self, None, None\n47:         in_negated = negated ^ self.negated\n48:         # Whether or not children must be connected in the same filtering\n49:         # clause (WHERE > HAVING > QUALIFY) to maintain logical semantic.\n50:         must_remain_connected = (\n51:             (in_negated and self.connector == AND)\n52:             or (not in_negated and self.connector == OR)\n53:             or self.connector == XOR\n54:         )\n55:         if (\n56:             must_remain_connected\n57:             and self.contains_aggregate\n58:             and not self.contains_over_clause\n59:         ):\n60:             # It's must cheaper to short-circuit and stash everything in the\n61:             # HAVING clause than split children if possible.\n62:             return None, self, None\n63:         where_parts = []\n64:         having_parts = []\n65:         qualify_parts = []\n66:         for c in self.children:\n67:             if hasattr(c, \"split_having_qualify\"):\n68:                 where_part, having_part, qualify_part = c.split_having_qualify(\n69:                     in_negated, must_group_by\n70:                 )\n71:                 if where_part is not None:\n72:                     where_parts.append(where_part)\n73:                 if having_part is not None:\n74:                     having_parts.append(having_part)\n75:                 if qualify_part is not None:\n76:                     qualify_parts.append(qualify_part)\n77:             elif c.contains_over_clause:\n78:                 qualify_parts.append(c)\n79:             elif c.contains_aggregate:\n80:                 having_parts.append(c)\n81:             else:\n82:                 where_parts.append(c)\n83:         if must_remain_connected and qualify_parts:\n84:             # Disjunctive heterogeneous predicates can be pushed down to\n85:             # qualify as long as no conditional aggregation is involved.\n86:             if not where_parts or (where_parts and not must_group_by):\n87:                 return None, None, self\n88:             elif where_parts:\n89:                 # In theory this should only be enforced when dealing with\n90:                 # where_parts containing predicates against multi-valued\n91:                 # relationships that could affect aggregation results but this\n92:                 # is complex to infer properly.\n93:                 raise NotImplementedError(\n94:                     \"Heterogeneous disjunctive predicates against window functions are \"\n95:                     \"not implemented when performing conditional aggregation.\"\n96:                 )\n97:         where_node = (\n98:             self.create(where_parts, self.connector, self.negated)\n99:             if where_parts\n100:             else None\n101:         )\n102:         having_node = (\n103:             self.create(having_parts, self.connector, self.negated)\n104:             if having_parts\n105:             else None\n106:         )\n107:         qualify_node = (\n108:             self.create(qualify_parts, self.connector, self.negated)\n109:             if qualify_parts\n110:             else None\n111:         )\n112:         return where_node, having_node, qualify_node\n113: \n114:     def as_sql(self, compiler, connection):\n115:         \"\"\"\n116:         Return the SQL version of the where clause and the value to be\n117:         substituted in. Return '', [] if this node matches everything,\n118:         None, [] if this node is empty, and raise EmptyResultSet if this\n119:         node can't match anything.\n120:         \"\"\"\n121:         result = []\n122:         result_params = []\n123:         if self.connector == AND:\n124:             full_needed, empty_needed = len(self.children), 1\n125:         else:\n126:             full_needed, empty_needed = 1, len(self.children)\n127: \n128:         if self.connector == XOR and not connection.features.supports_logical_xor:\n129:             # Convert if the database doesn't support XOR:\n130:             #   a XOR b XOR c XOR ...\n131:             # to:\n132:             #   (a OR b OR c OR ...) AND (a + b + c + ...) == 1\n133:             lhs = self.__class__(self.children, OR)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/sql/where.py",
      "suspect_lines": [
        132
      ]
    }
  ]
}