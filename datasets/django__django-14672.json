{
  "instance_id": "django__django-14672",
  "problem_statement": "Missing call `make_hashable` on `through_fields` in `ManyToManyRel`\nDescription\n\t\nIn 3.2 identity property has been added to all ForeignObjectRel to make it possible to compare them. A hash is derived from said identity and it's possible because identity is a tuple. To make limit_choices_to hashable (one of this tuple elements), ​there's a call to make_hashable.\nIt happens that through_fields can be a list. In such case, this make_hashable call is missing in ​ManyToManyRel.\nFor some reason it only fails on checking proxy model. I think proxy models have 29 checks and normal ones 24, hence the issue, but that's just a guess.\nMinimal repro:\nclass Parent(models.Model):\n\tname = models.CharField(max_length=256)\nclass ProxyParent(Parent):\n\tclass Meta:\n\t\tproxy = True\nclass Child(models.Model):\n\tparent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n\tmany_to_many_field = models.ManyToManyField(\n\t\tto=Parent,\n\t\tthrough=\"ManyToManyModel\",\n\t\tthrough_fields=['child', 'parent'],\n\t\trelated_name=\"something\"\n\t)\nclass ManyToManyModel(models.Model):\n\tparent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n\tchild = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n\tsecond_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\nWhich will result in \n File \"manage.py\", line 23, in <module>\n\tmain()\n File \"manage.py\", line 19, in main\n\texecute_from_command_line(sys.argv)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/__init__.py\", line 419, in execute_from_command_line\n\tutility.execute()\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/__init__.py\", line 413, in execute\n\tself.fetch_command(subcommand).run_from_argv(self.argv)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/base.py\", line 354, in run_from_argv\n\tself.execute(*args, **cmd_options)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/base.py\", line 393, in execute\n\tself.check()\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/base.py\", line 419, in check\n\tall_issues = checks.run_checks(\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/checks/registry.py\", line 76, in run_checks\n\tnew_errors = check(app_configs=app_configs, databases=databases)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/checks/model_checks.py\", line 34, in check_all_models\n\terrors.extend(model.check(**kwargs))\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/db/models/base.py\", line 1277, in check\n\t*cls._check_field_name_clashes(),\n File \"/home/tom/PycharmProjects/djangbroken_m2m_projectProject/venv/lib/python3.8/site-packages/django/db/models/base.py\", line 1465, in _check_field_name_clashes\n\tif f not in used_fields:\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/db/models/fields/reverse_related.py\", line 140, in __hash__\n\treturn hash(self.identity)\nTypeError: unhashable type: 'list'\nSolution: Add missing make_hashable call on self.through_fields in ManyToManyRel.\nMissing call `make_hashable` on `through_fields` in `ManyToManyRel`\nDescription\n\t\nIn 3.2 identity property has been added to all ForeignObjectRel to make it possible to compare them. A hash is derived from said identity and it's possible because identity is a tuple. To make limit_choices_to hashable (one of this tuple elements), ​there's a call to make_hashable.\nIt happens that through_fields can be a list. In such case, this make_hashable call is missing in ​ManyToManyRel.\nFor some reason it only fails on checking proxy model. I think proxy models have 29 checks and normal ones 24, hence the issue, but that's just a guess.\nMinimal repro:\nclass Parent(models.Model):\n\tname = models.CharField(max_length=256)\nclass ProxyParent(Parent):\n\tclass Meta:\n\t\tproxy = True\nclass Child(models.Model):\n\tparent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n\tmany_to_many_field = models.ManyToManyField(\n\t\tto=Parent,\n\t\tthrough=\"ManyToManyModel\",\n\t\tthrough_fields=['child', 'parent'],\n\t\trelated_name=\"something\"\n\t)\nclass ManyToManyModel(models.Model):\n\tparent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n\tchild = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n\tsecond_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\nWhich will result in \n File \"manage.py\", line 23, in <module>\n\tmain()\n File \"manage.py\", line 19, in main\n\texecute_from_command_line(sys.argv)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/__init__.py\", line 419, in execute_from_command_line\n\tutility.execute()\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/__init__.py\", line 413, in execute\n\tself.fetch_command(subcommand).run_from_argv(self.argv)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/base.py\", line 354, in run_from_argv\n\tself.execute(*args, **cmd_options)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/base.py\", line 393, in execute\n\tself.check()\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/management/base.py\", line 419, in check\n\tall_issues = checks.run_checks(\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/checks/registry.py\", line 76, in run_checks\n\tnew_errors = check(app_configs=app_configs, databases=databases)\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/core/checks/model_checks.py\", line 34, in check_all_models\n\terrors.extend(model.check(**kwargs))\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/db/models/base.py\", line 1277, in check\n\t*cls._check_field_name_clashes(),\n File \"/home/tom/PycharmProjects/djangbroken_m2m_projectProject/venv/lib/python3.8/site-packages/django/db/models/base.py\", line 1465, in _check_field_name_clashes\n\tif f not in used_fields:\n File \"/home/tom/PycharmProjects/broken_m2m_project/venv/lib/python3.8/site-packages/django/db/models/fields/reverse_related.py\", line 140, in __hash__\n\treturn hash(self.identity)\nTypeError: unhashable type: 'list'\nSolution: Add missing make_hashable call on self.through_fields in ManyToManyRel.\n",
  "localized_code": "[start of django/db/models/fields/reverse_related.py]\n1: \"\"\"\n2: \"Rel objects\" for related fields.\n3: \n4: \"Rel objects\" (for lack of a better name) carry information about the relation\n5: modeled by a related field and provide some utility functions. They're stored\n6: in the ``remote_field`` attribute of the field.\n7: \n8: They also act as reverse fields for the purposes of the Meta API because\n9: they're the closest concept currently available.\n10: \"\"\"\n11: \n12: from django.core import exceptions\n13: from django.utils.functional import cached_property\n14: from django.utils.hashable import make_hashable\n15: \n16: from . import BLANK_CHOICE_DASH\n17: from .mixins import FieldCacheMixin\n18: \n19: \n20: class ForeignObjectRel(FieldCacheMixin):\n21:     \"\"\"\n22:     Used by ForeignObject to store information about the relation.\n23: \n24:     ``_meta.get_fields()`` returns this class to provide access to the field\n25:     flags for the reverse relation.\n26:     \"\"\"\n27: \n28:     # Field flags\n29:     auto_created = True\n30:     concrete = False\n31:     editable = False\n32:     is_relation = True\n33: \n34:     # Reverse relations are always nullable (Django can't enforce that a\n35:     # foreign key on the related model points to this model).\n36:     null = True\n37:     empty_strings_allowed = False\n38: \n39:     def __init__(self, field, to, related_name=None, related_query_name=None,\n40:                  limit_choices_to=None, parent_link=False, on_delete=None):\n41:         self.field = field\n42:         self.model = to\n43:         self.related_name = related_name\n44:         self.related_query_name = related_query_name\n45:         self.limit_choices_to = {} if limit_choices_to is None else limit_choices_to\n46:         self.parent_link = parent_link\n47:         self.on_delete = on_delete\n48: \n49:         self.symmetrical = False\n50:         self.multiple = True\n51: \n52:     # Some of the following cached_properties can't be initialized in\n53:     # __init__ as the field doesn't have its model yet. Calling these methods\n54:     # before field.contribute_to_class() has been called will result in\n55:     # AttributeError\n56:     @cached_property\n57:     def hidden(self):\n58:         return self.is_hidden()\n59: \n60:     @cached_property\n61:     def name(self):\n62:         return self.field.related_query_name()\n63: \n64:     @property\n65:     def remote_field(self):\n66:         return self.field\n67: \n68:     @property\n69:     def target_field(self):\n70:         \"\"\"\n71:         When filtering against this relation, return the field on the remote\n72:         model against which the filtering should happen.\n73:         \"\"\"\n74:         target_fields = self.get_path_info()[-1].target_fields\n75:         if len(target_fields) > 1:\n76:             raise exceptions.FieldError(\"Can't use target_field for multicolumn relations.\")\n77:         return target_fields[0]\n78: \n79:     @cached_property\n80:     def related_model(self):\n81:         if not self.field.model:\n82:             raise AttributeError(\n83:                 \"This property can't be accessed before self.field.contribute_to_class has been called.\")\n84:         return self.field.model\n85: \n86:     @cached_property\n87:     def many_to_many(self):\n88:         return self.field.many_to_many\n89: \n90:     @cached_property\n91:     def many_to_one(self):\n92:         return self.field.one_to_many\n93: \n94:     @cached_property\n95:     def one_to_many(self):\n96:         return self.field.many_to_one\n97: \n98:     @cached_property\n99:     def one_to_one(self):\n100:         return self.field.one_to_one\n101: \n102:     def get_lookup(self, lookup_name):\n103:         return self.field.get_lookup(lookup_name)\n104: \n105:     def get_internal_type(self):\n106:         return self.field.get_internal_type()\n107: \n108:     @property\n109:     def db_type(self):\n110:         return self.field.db_type\n111: \n112:     def __repr__(self):\n113:         return '<%s: %s.%s>' % (\n114:             type(self).__name__,\n115:             self.related_model._meta.app_label,\n116:             self.related_model._meta.model_name,\n117:         )\n118: \n119:     @property\n120:     def identity(self):\n121:         return (\n122:             self.field,\n123:             self.model,\n124:             self.related_name,\n125:             self.related_query_name,\n126:             make_hashable(self.limit_choices_to),\n127:             self.parent_link,\n128:             self.on_delete,\n129:             self.symmetrical,\n130:             self.multiple,\n131:         )\n132: \n133:     def __eq__(self, other):\n134:         if not isinstance(other, self.__class__):\n135:             return NotImplemented\n136:         return self.identity == other.identity\n137: \n138:     def __hash__(self):\n139:         return hash(self.identity)\n140: \n141:     def get_choices(\n142:         self, include_blank=True, blank_choice=BLANK_CHOICE_DASH,\n143:         limit_choices_to=None, ordering=(),\n144:     ):\n145:         \"\"\"\n146:         Return choices with a default blank choices included, for use\n147:         as <select> choices for this field.\n148: \n149:         Analog of django.db.models.fields.Field.get_choices(), provided\n150:         initially for utilization by RelatedFieldListFilter.\n151:         \"\"\"\n152:         limit_choices_to = limit_choices_to or self.limit_choices_to\n153:         qs = self.related_model._default_manager.complex_filter(limit_choices_to)\n154:         if ordering:\n155:             qs = qs.order_by(*ordering)\n156:         return (blank_choice if include_blank else []) + [\n157:             (x.pk, str(x)) for x in qs\n158:         ]\n159: \n160:     def is_hidden(self):\n161:         \"\"\"Should the related object be hidden?\"\"\"\n162:         return bool(self.related_name) and self.related_name[-1] == '+'\n163: \n164:     def get_joining_columns(self):\n165:         return self.field.get_reverse_joining_columns()\n166: \n167:     def get_extra_restriction(self, alias, related_alias):\n168:         return self.field.get_extra_restriction(related_alias, alias)\n169: \n170:     def set_field_name(self):\n171:         \"\"\"\n172:         Set the related field's name, this is not available until later stages\n173:         of app loading, so set_field_name is called from\n174:         set_attributes_from_rel()\n175:         \"\"\"\n176:         # By default foreign object doesn't relate to any remote field (for\n177:         # example custom multicolumn joins currently have no remote field).\n178:         self.field_name = None\n179: \n180:     def get_accessor_name(self, model=None):\n181:         # This method encapsulates the logic that decides what name to give an\n182:         # accessor descriptor that retrieves related many-to-one or\n183:         # many-to-many objects. It uses the lowercased object_name + \"_set\",\n184:         # but this can be overridden with the \"related_name\" option. Due to\n185:         # backwards compatibility ModelForms need to be able to provide an\n186:         # alternate model. See BaseInlineFormSet.get_default_prefix().\n187:         opts = model._meta if model else self.related_model._meta\n188:         model = model or self.related_model\n189:         if self.multiple:\n190:             # If this is a symmetrical m2m relation on self, there is no reverse accessor.\n191:             if self.symmetrical and model == self.model:\n192:                 return None\n193:         if self.related_name:\n194:             return self.related_name\n195:         return opts.model_name + ('_set' if self.multiple else '')\n196: \n197:     def get_path_info(self, filtered_relation=None):\n198:         return self.field.get_reverse_path_info(filtered_relation)\n199: \n200:     def get_cache_name(self):\n201:         \"\"\"\n202:         Return the name of the cache key to use for storing an instance of the\n203:         forward model on the reverse model.\n204:         \"\"\"\n205:         return self.get_accessor_name()\n206: \n207: \n208: class ManyToOneRel(ForeignObjectRel):\nCode replaced for brevity.\n255: \n256: \n257: \n258: class OneToOneRel(ManyToOneRel):\nCode replaced for brevity.\n277: \n278: \n279: \n280: class ManyToManyRel(ForeignObjectRel):\n281:     \"\"\"\n282:     Used by ManyToManyField to store information about the relation.\n283: \n284:     ``_meta.get_fields()`` returns this class to provide access to the field\n285:     flags for the reverse relation.\n286:     \"\"\"\n287: \n288:     def __init__(self, field, to, related_name=None, related_query_name=None,\n289:                  limit_choices_to=None, symmetrical=True, through=None,\n290:                  through_fields=None, db_constraint=True):\n291:         super().__init__(\n292:             field, to,\n293:             related_name=related_name,\n294:             related_query_name=related_query_name,\n295:             limit_choices_to=limit_choices_to,\n296:         )\n297: \n298:         if through and not db_constraint:\n299:             raise ValueError(\"Can't supply a through model and db_constraint=False\")\n300:         self.through = through\n301: \n302:         if through_fields and not through:\n303:             raise ValueError(\"Cannot specify through_fields without a through model\")\n304:         self.through_fields = through_fields\n305: \n306:         self.symmetrical = symmetrical\n307:         self.db_constraint = db_constraint\n308: \n309:     @property\n310:     def identity(self):\n311:         return super().identity + (\n312:             self.through,\n313:             self.through_fields,\n314:             self.db_constraint,\n315:         )\n316: \n317:     def get_related_field(self):\n318:         \"\"\"\n319:         Return the field in the 'to' object to which this relationship is tied.\n320:         Provided for symmetry with ManyToOneRel.\n321:         \"\"\"\n322:         opts = self.through._meta\n323:         if self.through_fields:\n324:             field = opts.get_field(self.through_fields[0])\n325:         else:\n326:             for field in opts.fields:\n327:                 rel = getattr(field, 'remote_field', None)\n328:                 if rel and rel.model == self.model:\n329:                     break\n330:         return field.foreign_related_fields[0]\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/reverse_related.py",
      "suspect_lines": [
        313
      ]
    }
  ]
}