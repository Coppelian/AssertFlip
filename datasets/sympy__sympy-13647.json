{
  "instance_id": "sympy__sympy-13647",
  "problem_statement": "Matrix.col_insert() no longer seems to work correctly.\nExample:\r\n\r\n```\r\nIn [28]: import sympy as sm\r\n\r\nIn [29]: M = sm.eye(6)\r\n\r\nIn [30]: M\r\nOut[30]: \r\n⎡1  0  0  0  0  0⎤\r\n⎢                ⎥\r\n⎢0  1  0  0  0  0⎥\r\n⎢                ⎥\r\n⎢0  0  1  0  0  0⎥\r\n⎢                ⎥\r\n⎢0  0  0  1  0  0⎥\r\n⎢                ⎥\r\n⎢0  0  0  0  1  0⎥\r\n⎢                ⎥\r\n⎣0  0  0  0  0  1⎦\r\n\r\nIn [31]: V = 2 * sm.ones(6, 2)\r\n\r\nIn [32]: V\r\nOut[32]: \r\n⎡2  2⎤\r\n⎢    ⎥\r\n⎢2  2⎥\r\n⎢    ⎥\r\n⎢2  2⎥\r\n⎢    ⎥\r\n⎢2  2⎥\r\n⎢    ⎥\r\n⎢2  2⎥\r\n⎢    ⎥\r\n⎣2  2⎦\r\n\r\nIn [33]: M.col_insert(3, V)\r\nOut[33]: \r\n⎡1  0  0  2  2  1  0  0⎤\r\n⎢                      ⎥\r\n⎢0  1  0  2  2  0  1  0⎥\r\n⎢                      ⎥\r\n⎢0  0  1  2  2  0  0  1⎥\r\n⎢                      ⎥\r\n⎢0  0  0  2  2  0  0  0⎥\r\n⎢                      ⎥\r\n⎢0  0  0  2  2  0  0  0⎥\r\n⎢                      ⎥\r\n⎣0  0  0  2  2  0  0  0⎦\r\nIn [34]: sm.__version__\r\nOut[34]: '1.1.1'\r\n```\r\n\r\nThe 3 x 3 identify matrix to the right of the columns of twos is shifted from the bottom three rows to the top three rows.\r\n\r\n@siefkenj Do you think this has to do with your matrix refactor?\n",
  "localized_code": "[start of sympy/matrices/common.py]\n1: \"\"\"\n2: Basic methods common to all matrices to be used\n3: when creating more advanced matrices (e.g., matrices over rings,\n4: etc.).\n5: \"\"\"\n6: \n7: from __future__ import print_function, division\n8: \n9: import collections\n10: from sympy.core.add import Add\n11: from sympy.core.basic import Basic, Atom\n12: from sympy.core.expr import Expr\n13: from sympy.core.symbol import Symbol\n14: from sympy.core.function import count_ops\n15: from sympy.core.singleton import S\n16: from sympy.core.sympify import sympify\n17: from sympy.core.compatibility import is_sequence, default_sort_key, range, \\\n18:     NotIterable\n19: \n20: from sympy.simplify import simplify as _simplify, signsimp, nsimplify\n21: from sympy.utilities.iterables import flatten\n22: from sympy.functions import Abs\n23: from sympy.core.compatibility import reduce, as_int, string_types\n24: from sympy.assumptions.refine import refine\n25: from sympy.core.decorators import call_highest_priority\n26: \n27: from types import FunctionType\n28: \n29: \n30: class MatrixError(Exception):\n31:     pass\n32: \n33: \n34: class ShapeError(ValueError, MatrixError):\n35:     \"\"\"Wrong matrix shape\"\"\"\n36:     pass\n37: \n38: \n39: class NonSquareMatrixError(ShapeError):\n40:     pass\n41: \n42: \n43: class MatrixRequired(object):\n44:     \"\"\"All subclasses of matrix objects must implement the\n45:     required matrix properties listed here.\"\"\"\n46:     rows = None\n47:     cols = None\n48:     shape = None\n49:     _simplify = None\n50: \n51:     @classmethod\n52:     def _new(cls, *args, **kwargs):\n53:         \"\"\"`_new` must, at minimum, be callable as\n54:         `_new(rows, cols, mat) where mat is a flat list of the\n55:         elements of the matrix.\"\"\"\n56:         raise NotImplementedError(\"Subclasses must implement this.\")\n57: \n58:     def __eq__(self, other):\n59:         raise NotImplementedError(\"Subclasses must impliment this.\")\n60: \n61:     def __getitem__(self, key):\n62:         \"\"\"Implementations of __getitem__ should accept ints, in which\n63:         case the matrix is indexed as a flat list, tuples (i,j) in which\n64:         case the (i,j) entry is returned, slices, or mixed tuples (a,b)\n65:         where a and b are any combintion of slices and integers.\"\"\"\n66:         raise NotImplementedError(\"Subclasses must implement this.\")\n67: \n68:     def __len__(self):\n69:         \"\"\"The total number of entries in the matrix.\"\"\"\n70:         raise NotImplementedError(\"Subclasses must implement this.\")\n71: \n72: \n73: class MatrixShaping(MatrixRequired):\n74:     \"\"\"Provides basic matrix shaping and extracting of submatrices\"\"\"\n75: \n76:     def _eval_col_del(self, col):\n77:         def entry(i, j):\n78:             return self[i, j] if j < col else self[i, j + 1]\n79:         return self._new(self.rows, self.cols - 1, entry)\n80: \n81:     def _eval_col_insert(self, pos, other):\n82:         cols = self.cols\n83: \n84:         def entry(i, j):\n85:             if j < pos:\n86:                 return self[i, j]\n87:             elif pos <= j < pos + other.cols:\n88:                 return other[i, j - pos]\n89:             return self[i, j - pos - other.cols]\n90: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/matrices/common.py",
      "suspect_lines": [
        89
      ]
    }
  ]
}