{
  "instance_id": "django__django-16595",
  "problem_statement": "Migration optimizer does not reduce multiple AlterField\nDescription\n\t\nLet's consider the following operations: \noperations = [\n\tmigrations.AddField(\n\t\tmodel_name=\"book\",\n\t\tname=\"title\",\n\t\tfield=models.CharField(max_length=256, null=True),\n\t),\n\tmigrations.AlterField(\n\t\tmodel_name=\"book\",\n\t\tname=\"title\",\n\t\tfield=models.CharField(max_length=128, null=True),\n\t),\n\tmigrations.AlterField(\n\t\tmodel_name=\"book\",\n\t\tname=\"title\",\n\t\tfield=models.CharField(max_length=128, null=True, help_text=\"help\"),\n\t),\n\tmigrations.AlterField(\n\t\tmodel_name=\"book\",\n\t\tname=\"title\",\n\t\tfield=models.CharField(max_length=128, null=True, help_text=\"help\", default=None),\n\t),\n]\nIf I run the optimizer, I get only the AddField, as we could expect. However, if the AddField model is separated from the AlterField (e.g. because of a non-elidable migration, or inside a non-squashed migration), none of the AlterField are reduced:\noptimizer.optimize(operations[1:], \"books\") \n[<AlterField model_name='book', name='title', field=<django.db.models.fields.CharField>>,\n <AlterField model_name='book', name='title', field=<django.db.models.fields.CharField>>,\n <AlterField model_name='book', name='title', field=<django.db.models.fields.CharField>>]\nIndeed, the AlterField.reduce does not consider the the case where operation is also an AlterField. \nIs this behaviour intended? If so, could it be documented? \nOtherwise, would it make sense to add something like\n\t\tif isinstance(operation, AlterField) and self.is_same_field_operation(\n\t\t\toperation\n\t\t):\n\t\t\treturn [operation]\n",
  "localized_code": "[start of django/db/migrations/operations/fields.py]\n1: from django.db.migrations.utils import field_references\n2: from django.db.models import NOT_PROVIDED\n3: from django.utils.functional import cached_property\n4: \n5: from .base import Operation\n6: \n7: \n8: class FieldOperation(Operation):\n9:     def __init__(self, model_name, name, field=None):\n10:         self.model_name = model_name\n11:         self.name = name\n12:         self.field = field\n13: \n14:     @cached_property\n15:     def model_name_lower(self):\n16:         return self.model_name.lower()\n17: \n18:     @cached_property\n19:     def name_lower(self):\n20:         return self.name.lower()\n21: \n22:     def is_same_model_operation(self, operation):\n23:         return self.model_name_lower == operation.model_name_lower\n24: \n25:     def is_same_field_operation(self, operation):\n26:         return (\n27:             self.is_same_model_operation(operation)\n28:             and self.name_lower == operation.name_lower\n29:         )\n30: \n31:     def references_model(self, name, app_label):\n32:         name_lower = name.lower()\n33:         if name_lower == self.model_name_lower:\n34:             return True\n35:         if self.field:\n36:             return bool(\n37:                 field_references(\n38:                     (app_label, self.model_name_lower),\n39:                     self.field,\n40:                     (app_label, name_lower),\n41:                 )\n42:             )\n43:         return False\n44: \n45:     def references_field(self, model_name, name, app_label):\n46:         model_name_lower = model_name.lower()\n47:         # Check if this operation locally references the field.\n48:         if model_name_lower == self.model_name_lower:\n49:             if name == self.name:\n50:                 return True\n51:             elif (\n52:                 self.field\n53:                 and hasattr(self.field, \"from_fields\")\n54:                 and name in self.field.from_fields\n55:             ):\n56:                 return True\n57:         # Check if this operation remotely references the field.\n58:         if self.field is None:\n59:             return False\n60:         return bool(\n61:             field_references(\n62:                 (app_label, self.model_name_lower),\n63:                 self.field,\n64:                 (app_label, model_name_lower),\n65:                 name,\n66:             )\n67:         )\n68: \n69:     def reduce(self, operation, app_label):\n70:         return super().reduce(operation, app_label) or not operation.references_field(\n71:             self.model_name, self.name, app_label\n72:         )\n73: \n74: \n75: class AddField(FieldOperation):\nCode replaced for brevity.\n151: \n152: \n153: \n154: class RemoveField(FieldOperation):\nCode replaced for brevity.\n195: \n196: \n197: \n198: class AlterField(FieldOperation):\n199:     \"\"\"\n200:     Alter a field's database column (e.g. null, max_length) to the provided\n201:     new field.\n202:     \"\"\"\n203: \n204:     def __init__(self, model_name, name, field, preserve_default=True):\n205:         self.preserve_default = preserve_default\n206:         super().__init__(model_name, name, field)\n207: \n208:     def deconstruct(self):\n209:         kwargs = {\n210:             \"model_name\": self.model_name,\n211:             \"name\": self.name,\n212:             \"field\": self.field,\n213:         }\n214:         if self.preserve_default is not True:\n215:             kwargs[\"preserve_default\"] = self.preserve_default\n216:         return (self.__class__.__name__, [], kwargs)\n217: \n218:     def state_forwards(self, app_label, state):\n219:         state.alter_field(\n220:             app_label,\n221:             self.model_name_lower,\n222:             self.name,\n223:             self.field,\n224:             self.preserve_default,\n225:         )\n226: \n227:     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n228:         to_model = to_state.apps.get_model(app_label, self.model_name)\n229:         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n230:             from_model = from_state.apps.get_model(app_label, self.model_name)\n231:             from_field = from_model._meta.get_field(self.name)\n232:             to_field = to_model._meta.get_field(self.name)\n233:             if not self.preserve_default:\n234:                 to_field.default = self.field.default\n235:             schema_editor.alter_field(from_model, from_field, to_field)\n236:             if not self.preserve_default:\n237:                 to_field.default = NOT_PROVIDED\n238: \n239:     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n240:         self.database_forwards(app_label, schema_editor, from_state, to_state)\n241: \n242:     def describe(self):\n243:         return \"Alter field %s on %s\" % (self.name, self.model_name)\n244: \n245:     @property\n246:     def migration_name_fragment(self):\n247:         return \"alter_%s_%s\" % (self.model_name_lower, self.name_lower)\n248: \n249:     def reduce(self, operation, app_label):\n250:         if isinstance(operation, RemoveField) and self.is_same_field_operation(\n251:             operation\n252:         ):\n253:             return [operation]\n254:         elif (\n255:             isinstance(operation, RenameField)\n256:             and self.is_same_field_operation(operation)\n257:             and self.field.db_column is None\n258:         ):\n259:             return [\n260:                 operation,\n261:                 AlterField(\n262:                     model_name=self.model_name,\n263:                     name=operation.new_name,\n264:                     field=self.field,\n265:                 ),\n266:             ]\n267:         return super().reduce(operation, app_label)\n268: \n269: \n270: class RenameField(FieldOperation):\nCode replaced for brevity.\n357: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/operations/fields.py",
      "suspect_lines": [
        250,
        251,
        252
      ]
    }
  ]
}