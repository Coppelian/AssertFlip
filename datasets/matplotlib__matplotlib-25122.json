{
  "instance_id": "matplotlib__matplotlib-25122",
  "problem_statement": "[Bug]: Windows correction is not correct in `mlab._spectral_helper`\n### Bug summary\r\n\r\nWindows correction is not correct in `mlab._spectral_helper`:\r\nhttps://github.com/matplotlib/matplotlib/blob/3418bada1c1f44da1f73916c5603e3ae79fe58c1/lib/matplotlib/mlab.py#L423-L430\r\n\r\nThe `np.abs` is not needed, and give wrong result for window with negative value, such as `flattop`.\r\nFor reference, the implementation of scipy can be found here :\r\nhttps://github.com/scipy/scipy/blob/d9f75db82fdffef06187c9d8d2f0f5b36c7a791b/scipy/signal/_spectral_py.py#L1854-L1859\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport numpy as np\r\nfrom scipy import signal\r\nwindow = signal.windows.flattop(512)\r\nprint(np.abs(window).sum()**2-window.sum()**2)\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n4372.942556173262\r\n\r\n### Expected outcome\r\n\r\n0\r\n\r\n### Additional information\r\n\r\n_No response_\r\n\r\n### Operating system\r\n\r\n_No response_\r\n\r\n### Matplotlib Version\r\n\r\nlatest\r\n\r\n### Matplotlib Backend\r\n\r\n_No response_\r\n\r\n### Python version\r\n\r\n_No response_\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\nNone\n",
  "localized_code": "[start of lib/matplotlib/mlab.py]\n1: \"\"\"\n2: Numerical Python functions written for compatibility with MATLAB\n3: commands with the same names. Most numerical Python functions can be found in\n4: the `NumPy`_ and `SciPy`_ libraries. What remains here is code for performing\n5: spectral computations and kernel density estimations.\n6: \n7: .. _NumPy: https://numpy.org\n8: .. _SciPy: https://www.scipy.org\n9: \n10: Spectral functions\n11: ------------------\n12: \n13: `cohere`\n14:     Coherence (normalized cross spectral density)\n15: \n16: `csd`\n17:     Cross spectral density using Welch's average periodogram\n18: \n19: `detrend`\n20:     Remove the mean or best fit line from an array\n21: \n22: `psd`\n23:     Power spectral density using Welch's average periodogram\n24: \n25: `specgram`\n26:     Spectrogram (spectrum over segments of time)\n27: \n28: `complex_spectrum`\n29:     Return the complex-valued frequency spectrum of a signal\n30: \n31: `magnitude_spectrum`\n32:     Return the magnitude of the frequency spectrum of a signal\n33: \n34: `angle_spectrum`\n35:     Return the angle (wrapped phase) of the frequency spectrum of a signal\n36: \n37: `phase_spectrum`\n38:     Return the phase (unwrapped angle) of the frequency spectrum of a signal\n39: \n40: `detrend_mean`\n41:     Remove the mean from a line.\n42: \n43: `detrend_linear`\n44:     Remove the best fit line from a line.\n45: \n46: `detrend_none`\n47:     Return the original line.\n48: \n49: `stride_windows`\n50:     Get all windows in an array in a memory-efficient manner\n51: \"\"\"\n52: \n53: import functools\n54: from numbers import Number\n55: \n56: import numpy as np\n57: \n58: from matplotlib import _api, _docstring, cbook\n59: \n60: \n61: def window_hanning(x):\nCode replaced for brevity.\n69: \n70: \n71: \n72: def window_none(x):\nCode replaced for brevity.\n80: \n81: \n82: \n83: def detrend(x, key=None, axis=None):\nCode replaced for brevity.\n129: \n130: \n131: \n132: def detrend_mean(x, axis=None):\nCode replaced for brevity.\n157: \n158: \n159: \n160: def detrend_none(x, axis=None):\nCode replaced for brevity.\n179: \n180: \n181: \n182: def detrend_linear(y):\nCode replaced for brevity.\n213: \n214: \n215: \n216: @_api.deprecated(\"3.6\")\n217: def stride_windows(x, n, noverlap=None, axis=0):\nCode replaced for brevity.\n250: \n251: \n252: \n253:     # np>=1.20 provides sliding_window_view, and we only ever use axis=0.\nCode replaced for brevity.\n288: \n289: \n290: \n291: def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n292:                      window=None, noverlap=None, pad_to=None,\n293:                      sides=None, scale_by_freq=None, mode=None):\n294:     \"\"\"\n295:     Private helper implementing the common parts between the psd, csd,\n296:     spectrogram and complex, magnitude, angle, and phase spectrums.\n297:     \"\"\"\n298:     if y is None:\n299:         # if y is None use x for y\n300:         same_data = True\n301:     else:\n302:         # The checks for if y is x are so that we can use the same function to\n303:         # implement the core of psd(), csd(), and spectrogram() without doing\n304:         # extra calculations.  We return the unaveraged Pxy, freqs, and t.\n305:         same_data = y is x\n306: \n307:     if Fs is None:\n308:         Fs = 2\n309:     if noverlap is None:\n310:         noverlap = 0\n311:     if detrend_func is None:\n312:         detrend_func = detrend_none\n313:     if window is None:\n314:         window = window_hanning\n315: \n316:     # if NFFT is set to None use the whole signal\n317:     if NFFT is None:\n318:         NFFT = 256\n319: \n320:     if mode is None or mode == 'default':\n321:         mode = 'psd'\n322:     _api.check_in_list(\n323:         ['default', 'psd', 'complex', 'magnitude', 'angle', 'phase'],\n324:         mode=mode)\n325: \n326:     if not same_data and mode != 'psd':\n327:         raise ValueError(\"x and y must be equal if mode is not 'psd'\")\n328: \n329:     # Make sure we're dealing with a numpy array. If y and x were the same\n330:     # object to start with, keep them that way\n331:     x = np.asarray(x)\n332:     if not same_data:\n333:         y = np.asarray(y)\n334: \n335:     if sides is None or sides == 'default':\n336:         if np.iscomplexobj(x):\n337:             sides = 'twosided'\n338:         else:\n339:             sides = 'onesided'\n340:     _api.check_in_list(['default', 'onesided', 'twosided'], sides=sides)\n341: \n342:     # zero pad x and y up to NFFT if they are shorter than NFFT\n343:     if len(x) < NFFT:\n344:         n = len(x)\n345:         x = np.resize(x, NFFT)\n346:         x[n:] = 0\n347: \n348:     if not same_data and len(y) < NFFT:\n349:         n = len(y)\n350:         y = np.resize(y, NFFT)\n351:         y[n:] = 0\n352: \n353:     if pad_to is None:\n354:         pad_to = NFFT\n355: \n356:     if mode != 'psd':\n357:         scale_by_freq = False\n358:     elif scale_by_freq is None:\n359:         scale_by_freq = True\n360: \n361:     # For real x, ignore the negative frequencies unless told otherwise\n362:     if sides == 'twosided':\n363:         numFreqs = pad_to\n364:         if pad_to % 2:\n365:             freqcenter = (pad_to - 1)//2 + 1\n366:         else:\n367:             freqcenter = pad_to//2\n368:         scaling_factor = 1.\n369:     elif sides == 'onesided':\n370:         if pad_to % 2:\n371:             numFreqs = (pad_to + 1)//2\n372:         else:\n373:             numFreqs = pad_to//2 + 1\n374:         scaling_factor = 2.\n375: \n376:     if not np.iterable(window):\n377:         window = window(np.ones(NFFT, x.dtype))\n378:     if len(window) != NFFT:\n379:         raise ValueError(\n380:             \"The window length must match the data's first dimension\")\n381: \n382:     result = _stride_windows(x, NFFT, noverlap)\n383:     result = detrend(result, detrend_func, axis=0)\n384:     result = result * window.reshape((-1, 1))\n385:     result = np.fft.fft(result, n=pad_to, axis=0)[:numFreqs, :]\n386:     freqs = np.fft.fftfreq(pad_to, 1/Fs)[:numFreqs]\n387: \n388:     if not same_data:\n389:         # if same_data is False, mode must be 'psd'\n390:         resultY = _stride_windows(y, NFFT, noverlap)\n391:         resultY = detrend(resultY, detrend_func, axis=0)\n392:         resultY = resultY * window.reshape((-1, 1))\n393:         resultY = np.fft.fft(resultY, n=pad_to, axis=0)[:numFreqs, :]\n394:         result = np.conj(result) * resultY\n395:     elif mode == 'psd':\n396:         result = np.conj(result) * result\n397:     elif mode == 'magnitude':\n398:         result = np.abs(result) / np.abs(window).sum()\n399:     elif mode == 'angle' or mode == 'phase':\n400:         # we unwrap the phase later to handle the onesided vs. twosided case\n401:         result = np.angle(result)\n402:     elif mode == 'complex':\n403:         result /= np.abs(window).sum()\n404: \n405:     if mode == 'psd':\n406: \n407:         # Also include scaling factors for one-sided densities and dividing by\n408:         # the sampling frequency, if desired. Scale everything, except the DC\n409:         # component and the NFFT/2 component:\n410: \n411:         # if we have a even number of frequencies, don't scale NFFT/2\n412:         if not NFFT % 2:\n413:             slc = slice(1, -1, None)\n414:         # if we have an odd number, just don't scale DC\n415:         else:\n416:             slc = slice(1, None, None)\n417: \n418:         result[slc] *= scaling_factor\n419: \n420:         # MATLAB divides by the sampling frequency so that density function\n421:         # has units of dB/Hz and can be integrated by the plotted frequency\n422:         # values. Perform the same scaling here.\n423:         if scale_by_freq:\n424:             result /= Fs\n425:             # Scale the spectrum by the norm of the window to compensate for\n426:             # windowing loss; see Bendat & Piersol Sec 11.5.2.\n427:             result /= (np.abs(window)**2).sum()\n428:         else:\n429:             # In this case, preserve power in the segment, not amplitude\n430:             result /= np.abs(window).sum()**2\n431: \n432:     t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs\n433: \n434:     if sides == 'twosided':\n435:         # center the frequency range at zero\n436:         freqs = np.roll(freqs, -freqcenter, axis=0)\n437:         result = np.roll(result, -freqcenter, axis=0)\n438:     elif not pad_to % 2:\n439:         # get the last value correctly, it is negative otherwise\n440:         freqs[-1] *= -1\n441: \n442:     # we unwrap the phase here to handle the onesided vs. twosided case\n443:     if mode == 'phase':\n444:         result = np.unwrap(result, axis=0)\n445: \n446:     return result, freqs, t\n447: \n448: \n449:         mode, x, Fs=None, window=None, pad_to=None, sides=None):\nCode replaced for brevity.\n472: \n473: \n474: \n475: # Split out these keyword docs so that they can be used elsewhere\n476: _docstring.interpd.update(\n477:     Spectral=\"\"\"\\\n478: Fs : float, default: 2\n479:     The sampling frequency (samples per time unit).  It is used to calculate\n480:     the Fourier frequencies, *freqs*, in cycles per time unit.\n481: \n482: window : callable or ndarray, default: `.window_hanning`\n483:     A function or a vector of length *NFFT*.  To create window vectors see\n484:     `.window_hanning`, `.window_none`, `numpy.blackman`, `numpy.hamming`,\n485:     `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  If a\n486:     function is passed as the argument, it must take a data segment as an\n487:     argument and return the windowed version of the segment.\n488: \n489: sides : {'default', 'onesided', 'twosided'}, optional\n490:     Which sides of the spectrum to return. 'default' is one-sided for real\n491:     data and two-sided for complex data. 'onesided' forces the return of a\n492:     one-sided spectrum, while 'twosided' forces two-sided.\"\"\",\n493: \n494:     Single_Spectrum=\"\"\"\\\n495: pad_to : int, optional\n496:     The number of points to which the data segment is padded when performing\n497:     the FFT.  While not increasing the actual resolution of the spectrum (the\n498:     minimum distance between resolvable peaks), this can give more points in\n499:     the plot, allowing for more detail. This corresponds to the *n* parameter\n500:     in the call to `~numpy.fft.fft`.  The default is None, which sets *pad_to*\n501:     equal to the length of the input signal (i.e. no padding).\"\"\",\n502: \n503:     PSD=\"\"\"\\\n504: pad_to : int, optional\n505:     The number of points to which the data segment is padded when performing\n506:     the FFT.  This can be different from *NFFT*, which specifies the number\n507:     of data points used.  While not increasing the actual resolution of the\n508:     spectrum (the minimum distance between resolvable peaks), this can give\n509:     more points in the plot, allowing for more detail. This corresponds to\n510:     the *n* parameter in the call to `~numpy.fft.fft`. The default is None,\n511:     which sets *pad_to* equal to *NFFT*\n512: \n513: NFFT : int, default: 256\n514:     The number of data points used in each block for the FFT.  A power 2 is\n515:     most efficient.  This should *NOT* be used to get zero padding, or the\n516:     scaling of the result will be incorrect; use *pad_to* for this instead.\n517: \n518: detrend : {'none', 'mean', 'linear'} or callable, default: 'none'\n519:     The function applied to each segment before fft-ing, designed to remove\n520:     the mean or linear trend.  Unlike in MATLAB, where the *detrend* parameter\n521:     is a vector, in Matplotlib it is a function.  The :mod:`~matplotlib.mlab`\n522:     module defines `.detrend_none`, `.detrend_mean`, and `.detrend_linear`,\n523:     but you can use a custom function as well.  You can also use a string to\n524:     choose one of the functions: 'none' calls `.detrend_none`. 'mean' calls\n525:     `.detrend_mean`. 'linear' calls `.detrend_linear`.\n526: \n527: scale_by_freq : bool, default: True\n528:     Whether the resulting density values should be scaled by the scaling\n529:     frequency, which gives density in units of 1/Hz.  This allows for\n530:     integration over the returned frequency values.  The default is True for\n531:     MATLAB compatibility.\"\"\")\n532: \n533: \n534: @_docstring.dedent_interpd\n535:         noverlap=None, pad_to=None, sides=None, scale_by_freq=None):\nCode replaced for brevity.\n587: \n588: \n589: \n590: @_docstring.dedent_interpd\n591:         noverlap=None, pad_to=None, sides=None, scale_by_freq=None):\nCode replaced for brevity.\n651: \n652: \n653: \n654: _single_spectrum_docs = \"\"\"\\\n655: Compute the {quantity} of *x*.\n656: Data is padded to a length of *pad_to* and the windowing function *window* is\n657: applied to the signal.\n658: \n659: Parameters\n660: ----------\n661: x : 1-D array or sequence\n662:     Array or sequence containing the data\n663: \n664: {Spectral}\n665: \n666: {Single_Spectrum}\n667: \n668: Returns\n669: -------\n670: spectrum : 1-D array\n671:     The {quantity}.\n672: freqs : 1-D array\n673:     The frequencies corresponding to the elements in *spectrum*.\n674: \n675: See Also\n676: --------\n677: psd\n678:     Returns the power spectral density.\n679: complex_spectrum\n680:     Returns the complex-valued frequency spectrum.\n681: magnitude_spectrum\n682:     Returns the absolute value of the `complex_spectrum`.\n683: angle_spectrum\n684:     Returns the angle of the `complex_spectrum`.\n685: phase_spectrum\n686:     Returns the phase (unwrapped angle) of the `complex_spectrum`.\n687: specgram\n688:     Can return the complex spectrum of segments within the signal.\n689: \"\"\"\n690: \n691: \n692: complex_spectrum = functools.partial(_single_spectrum_helper, \"complex\")\n693: complex_spectrum.__doc__ = _single_spectrum_docs.format(\n694:     quantity=\"complex-valued frequency spectrum\",\n695:     **_docstring.interpd.params)\n696: magnitude_spectrum = functools.partial(_single_spectrum_helper, \"magnitude\")\n697: magnitude_spectrum.__doc__ = _single_spectrum_docs.format(\n698:     quantity=\"magnitude (absolute value) of the frequency spectrum\",\n699:     **_docstring.interpd.params)\n700: angle_spectrum = functools.partial(_single_spectrum_helper, \"angle\")\n701: angle_spectrum.__doc__ = _single_spectrum_docs.format(\n702:     quantity=\"angle of the frequency spectrum (wrapped phase spectrum)\",\n703:     **_docstring.interpd.params)\n704: phase_spectrum = functools.partial(_single_spectrum_helper, \"phase\")\n705: phase_spectrum.__doc__ = _single_spectrum_docs.format(\n706:     quantity=\"phase of the frequency spectrum (unwrapped phase spectrum)\",\n707:     **_docstring.interpd.params)\n708: \n709: \n710: @_docstring.dedent_interpd\n711:              mode=None):\nCode replaced for brevity.\n790: \n791: \n792: \n793: @_docstring.dedent_interpd\n794:            noverlap=0, pad_to=None, sides='default', scale_by_freq=None):\nCode replaced for brevity.\n840: \n841: \n842: \n843: class GaussianKDE:\nCode replaced for brevity.\n987: \n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/mlab.py",
      "suspect_lines": [
        398,
        403,
        427,
        430
      ]
    }
  ]
}