{
  "instance_id": "matplotlib__matplotlib-24870",
  "problem_statement": "[ENH]: Auto-detect bool arrays passed to contour()?\n### Problem\n\nI find myself fairly regularly calling\r\n```python\r\nplt.contour(boolean_2d_array, levels=[.5], ...)\r\n```\r\nto draw the boundary line between True and False regions on a boolean 2d array.  Without `levels=[.5]`, one gets the default 8 levels which go at 0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1.05 resulting in all the contour lines being drawn on top of one another; but clearly(?), for boolean inputs, the only choice that makes sense is to have a single level at 0.5 (or rather, anywhere between 0 and 1).\r\n```python\r\nfrom pylab import *\r\nii, jj = np.ogrid[:100, :100]; im = (ii+jj) % 20 < 10; subplot(121).contour(im); subplot(122).contour(im, levels=[.5])\r\n```\r\n![test](https://user-images.githubusercontent.com/1322974/199115826-8746ebbc-e469-48fa-a7f0-d302750018b5.png)\r\n\n\n### Proposed solution\n\nAutodetect boolean inputs to contour, and default levels to [0.5] in that case.\r\n\r\nI guess the closest similar kind of autodetection in the library is for imshow, which auto-switches between 0-1 float RGBA arrays and 0-255 uint8 RGBA arrays (when given a 3D array as input).\r\n\r\nThoughts?\n",
  "localized_code": "[start of lib/matplotlib/contour.py]\n1: \"\"\"\n2: Classes to support contour plotting and labelling for the Axes class.\n3: \"\"\"\n4: \n5: import functools\n6: from numbers import Integral\n7: \n8: import numpy as np\n9: from numpy import ma\n10: \n11: import matplotlib as mpl\n12: from matplotlib import _api, _docstring\n13: from matplotlib.backend_bases import MouseButton\n14: from matplotlib.text import Text\n15: import matplotlib.path as mpath\n16: import matplotlib.ticker as ticker\n17: import matplotlib.cm as cm\n18: import matplotlib.colors as mcolors\n19: import matplotlib.collections as mcoll\n20: import matplotlib.font_manager as font_manager\n21: import matplotlib.cbook as cbook\n22: import matplotlib.patches as mpatches\n23: import matplotlib.transforms as mtransforms\n24: \n25: \n26: # We can't use a single line collection for contour because a line\n27: # collection can have only a single line style, and we want to be able to have\n28: # dashed negative contours, for example, and solid positive contours.\n29: # We could use a single polygon collection for filled contours, but it\n30: # seems better to keep line and filled contours similar, with one collection\n31: # per level.\n32: \n33: \n34: @_api.deprecated(\"3.7\", alternative=\"Text.set_transform_rotates_text\")\n35: class ClabelText(Text):\n36:     \"\"\"\n37:     Unlike the ordinary text, the get_rotation returns an updated\n38:     angle in the pixel coordinate assuming that the input rotation is\n39:     an angle in data coordinate (or whatever transform set).\n40:     \"\"\"\n41: \n42:     def get_rotation(self):\n43:         new_angle, = self.get_transform().transform_angles(\n44:             [super().get_rotation()], [self.get_position()])\n45:         return new_angle\n46: \n47: \n48: def _contour_labeler_event_handler(cs, inline, inline_spacing, event):\n49:     canvas = cs.axes.figure.canvas\n50:     is_button = event.name == \"button_press_event\"\n51:     is_key = event.name == \"key_press_event\"\n52:     # Quit (even if not in infinite mode; this is consistent with\n53:     # MATLAB and sometimes quite useful, but will require the user to\n54:     # test how many points were actually returned before using data).\n55:     if (is_button and event.button == MouseButton.MIDDLE\n56:             or is_key and event.key in [\"escape\", \"enter\"]):\n57:         canvas.stop_event_loop()\n58:     # Pop last click.\n59:     elif (is_button and event.button == MouseButton.RIGHT\n60:           or is_key and event.key in [\"backspace\", \"delete\"]):\n61:         # Unfortunately, if one is doing inline labels, then there is currently\n62:         # no way to fix the broken contour - once humpty-dumpty is broken, he\n63:         # can't be put back together.  In inline mode, this does nothing.\n64:         if not inline:\n65:             cs.pop_label()\n66:             canvas.draw()\n67:     # Add new click.\n68:     elif (is_button and event.button == MouseButton.LEFT\n69:           # On macOS/gtk, some keys return None.\n70:           or is_key and event.key is not None):\n71:         if event.inaxes == cs.axes:\n72:             cs.add_label_near(event.x, event.y, transform=False,\n73:                               inline=inline, inline_spacing=inline_spacing)\n74:             canvas.draw()\n75: \n76: \n77: class ContourLabeler:\nCode replaced for brevity.\n561: \n562: \n563: \n564: def _is_closed_polygon(X):\nCode replaced for brevity.\n570: \n571: \n572: \n573: def _find_closest_point_on_path(xys, p):\nCode replaced for brevity.\n606: \n607: \n608: \n609: _docstring.interpd.update(contour_set_attributes=r\"\"\"\n610: Attributes\n611: ----------\n612: ax : `~matplotlib.axes.Axes`\n613:     The Axes object in which the contours are drawn.\n614: \n615: collections : `.silent_list` of `.PathCollection`\\s\n616:     The `.Artist`\\s representing the contour. This is a list of\n617:     `.PathCollection`\\s for both line and filled contours.\n618: \n619: levels : array\n620:     The values of the contour levels.\n621: \n622: layers : array\n623:     Same as levels for line contours; half-way between\n624:     levels for filled contours.  See ``ContourSet._process_colors``.\n625: \"\"\")\n626: \n627: \n628: @_docstring.dedent_interpd\n629: class ContourSet(cm.ScalarMappable, ContourLabeler):\n630:     \"\"\"\n631:     Store a set of contour lines or filled regions.\n632: \n633:     User-callable method: `~.Axes.clabel`\n634: \n635:     Parameters\n636:     ----------\n637:     ax : `~.axes.Axes`\n638: \n639:     levels : [level0, level1, ..., leveln]\n640:         A list of floating point numbers indicating the contour levels.\n641: \n642:     allsegs : [level0segs, level1segs, ...]\n643:         List of all the polygon segments for all the *levels*.\n644:         For contour lines ``len(allsegs) == len(levels)``, and for\n645:         filled contour regions ``len(allsegs) = len(levels)-1``. The lists\n646:         should look like ::\n647: \n648:             level0segs = [polygon0, polygon1, ...]\n649:             polygon0 = [[x0, y0], [x1, y1], ...]\n650: \n651:     allkinds : ``None`` or [level0kinds, level1kinds, ...]\n652:         Optional list of all the polygon vertex kinds (code types), as\n653:         described and used in Path. This is used to allow multiply-\n654:         connected paths such as holes within filled polygons.\n655:         If not ``None``, ``len(allkinds) == len(allsegs)``. The lists\n656:         should look like ::\n657: \n658:             level0kinds = [polygon0kinds, ...]\n659:             polygon0kinds = [vertexcode0, vertexcode1, ...]\n660: \n661:         If *allkinds* is not ``None``, usually all polygons for a\n662:         particular contour level are grouped together so that\n663:         ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.\n664: \n665:     **kwargs\n666:         Keyword arguments are as described in the docstring of\n667:         `~.Axes.contour`.\n668: \n669:     %(contour_set_attributes)s\n670:     \"\"\"\n671: \n672:     def __init__(self, ax, *args,\n673:                  levels=None, filled=False, linewidths=None, linestyles=None,\n674:                  hatches=(None,), alpha=None, origin=None, extent=None,\n675:                  cmap=None, colors=None, norm=None, vmin=None, vmax=None,\n676:                  extend='neither', antialiased=None, nchunk=0, locator=None,\n677:                  transform=None, negative_linestyles=None,\n678:                  **kwargs):\n679:         \"\"\"\n680:         Draw contour lines or filled regions, depending on\n681:         whether keyword arg *filled* is ``False`` (default) or ``True``.\n682: \n683:         Call signature::\n684: \n685:             ContourSet(ax, levels, allsegs, [allkinds], **kwargs)\n686: \n687:         Parameters\n688:         ----------\n689:         ax : `~.axes.Axes`\n690:             The `~.axes.Axes` object to draw on.\n691: \n692:         levels : [level0, level1, ..., leveln]\n693:             A list of floating point numbers indicating the contour\n694:             levels.\n695: \n696:         allsegs : [level0segs, level1segs, ...]\n697:             List of all the polygon segments for all the *levels*.\n698:             For contour lines ``len(allsegs) == len(levels)``, and for\n699:             filled contour regions ``len(allsegs) = len(levels)-1``. The lists\n700:             should look like ::\n701: \n702:                 level0segs = [polygon0, polygon1, ...]\n703:                 polygon0 = [[x0, y0], [x1, y1], ...]\n704: \n705:         allkinds : [level0kinds, level1kinds, ...], optional\n706:             Optional list of all the polygon vertex kinds (code types), as\n707:             described and used in Path. This is used to allow multiply-\n708:             connected paths such as holes within filled polygons.\n709:             If not ``None``, ``len(allkinds) == len(allsegs)``. The lists\n710:             should look like ::\n711: \n712:                 level0kinds = [polygon0kinds, ...]\n713:                 polygon0kinds = [vertexcode0, vertexcode1, ...]\n714: \n715:             If *allkinds* is not ``None``, usually all polygons for a\n716:             particular contour level are grouped together so that\n717:             ``level0segs = [polygon0]`` and ``level0kinds = [polygon0kinds]``.\n718: \n719:         **kwargs\n720:             Keyword arguments are as described in the docstring of\n721:             `~.Axes.contour`.\n722:         \"\"\"\n723:         self.axes = ax\n724:         self.levels = levels\n725:         self.filled = filled\n726:         self.linewidths = linewidths\n727:         self.linestyles = linestyles\n728:         self.hatches = hatches\n729:         self.alpha = alpha\n730:         self.origin = origin\n731:         self.extent = extent\n732:         self.colors = colors\n733:         self.extend = extend\n734:         self.antialiased = antialiased\n735:         if self.antialiased is None and self.filled:\n736:             # Eliminate artifacts; we are not stroking the boundaries.\n737:             self.antialiased = False\n738:             # The default for line contours will be taken from the\n739:             # LineCollection default, which uses :rc:`lines.antialiased`.\n740: \n741:         self.nchunk = nchunk\n742:         self.locator = locator\n743:         if (isinstance(norm, mcolors.LogNorm)\n744:                 or isinstance(self.locator, ticker.LogLocator)):\n745:             self.logscale = True\n746:             if norm is None:\n747:                 norm = mcolors.LogNorm()\n748:         else:\n749:             self.logscale = False\n750: \n751:         _api.check_in_list([None, 'lower', 'upper', 'image'], origin=origin)\n752:         if self.extent is not None and len(self.extent) != 4:\n753:             raise ValueError(\n754:                 \"If given, 'extent' must be None or (x0, x1, y0, y1)\")\n755:         if self.colors is not None and cmap is not None:\n756:             raise ValueError('Either colors or cmap must be None')\n757:         if self.origin == 'image':\n758:             self.origin = mpl.rcParams['image.origin']\n759: \n760:         self._transform = transform\n761: \n762:         self.negative_linestyles = negative_linestyles\n763:         # If negative_linestyles was not defined as a keyword argument, define\n764:         # negative_linestyles with rcParams\n765:         if self.negative_linestyles is None:\n766:             self.negative_linestyles = \\\n767:                 mpl.rcParams['contour.negative_linestyle']\n768: \n769:         kwargs = self._process_args(*args, **kwargs)\n770:         self._process_levels()\n771: \n772:         self._extend_min = self.extend in ['min', 'both']\n773:         self._extend_max = self.extend in ['max', 'both']\n774:         if self.colors is not None:\n775:             ncolors = len(self.levels)\n776:             if self.filled:\n777:                 ncolors -= 1\n778:             i0 = 0\n779: \n780:             # Handle the case where colors are given for the extended\n781:             # parts of the contour.\n782: \n783:             use_set_under_over = False\n784:             # if we are extending the lower end, and we've been given enough\n785:             # colors then skip the first color in the resulting cmap. For the\n786:             # extend_max case we don't need to worry about passing more colors\n787:             # than ncolors as ListedColormap will clip.\n788:             total_levels = (ncolors +\n789:                             int(self._extend_min) +\n790:                             int(self._extend_max))\n791:             if (len(self.colors) == total_levels and\n792:                     (self._extend_min or self._extend_max)):\n793:                 use_set_under_over = True\n794:                 if self._extend_min:\n795:                     i0 = 1\n796: \n797:             cmap = mcolors.ListedColormap(self.colors[i0:None], N=ncolors)\n798: \n799:             if use_set_under_over:\n800:                 if self._extend_min:\n801:                     cmap.set_under(self.colors[0])\n802:                 if self._extend_max:\n803:                     cmap.set_over(self.colors[-1])\n804: \n805:         self.collections = cbook.silent_list(None)\n806: \n807:         # label lists must be initialized here\n808:         self.labelTexts = []\n809:         self.labelCValues = []\n810: \n811:         kw = {'cmap': cmap}\n812:         if norm is not None:\n813:             kw['norm'] = norm\n814:         # sets self.cmap, norm if needed;\n815:         cm.ScalarMappable.__init__(self, **kw)\n816:         if vmin is not None:\n817:             self.norm.vmin = vmin\n818:         if vmax is not None:\n819:             self.norm.vmax = vmax\n820:         self._process_colors()\n821: \n822:         if getattr(self, 'allsegs', None) is None:\n823:             self.allsegs, self.allkinds = self._get_allsegs_and_allkinds()\n824:         elif self.allkinds is None:\n825:             # allsegs specified in constructor may or may not have allkinds as\n826:             # well.  Must ensure allkinds can be zipped below.\n827:             self.allkinds = [None] * len(self.allsegs)\n828: \n829:         if self.filled:\n830:             if self.linewidths is not None:\n831:                 _api.warn_external('linewidths is ignored by contourf')\n832:             # Lower and upper contour levels.\n833:             lowers, uppers = self._get_lowers_and_uppers()\n834:             # Default zorder taken from Collection\n835:             self._contour_zorder = kwargs.pop('zorder', 1)\n836: \n837:             self.collections[:] = [\n838:                 mcoll.PathCollection(\n839:                     self._make_paths(segs, kinds),\n840:                     antialiaseds=(self.antialiased,),\n841:                     edgecolors='none',\n842:                     alpha=self.alpha,\n843:                     transform=self.get_transform(),\n844:                     zorder=self._contour_zorder)\n845:                 for level, level_upper, segs, kinds\n846:                 in zip(lowers, uppers, self.allsegs, self.allkinds)]\n847:         else:\n848:             self.tlinewidths = tlinewidths = self._process_linewidths()\n849:             tlinestyles = self._process_linestyles()\n850:             aa = self.antialiased\n851:             if aa is not None:\n852:                 aa = (self.antialiased,)\n853:             # Default zorder taken from LineCollection, which is higher than\n854:             # for filled contours so that lines are displayed on top.\n855:             self._contour_zorder = kwargs.pop('zorder', 2)\n856: \n857:             self.collections[:] = [\n858:                 mcoll.PathCollection(\n859:                     self._make_paths(segs, kinds),\n860:                     facecolors=\"none\",\n861:                     antialiaseds=aa,\n862:                     linewidths=width,\n863:                     linestyles=[lstyle],\n864:                     alpha=self.alpha,\n865:                     transform=self.get_transform(),\n866:                     zorder=self._contour_zorder,\n867:                     label='_nolegend_')\n868:                 for level, width, lstyle, segs, kinds\n869:                 in zip(self.levels, tlinewidths, tlinestyles, self.allsegs,\n870:                        self.allkinds)]\n871: \n872:         for col in self.collections:\n873:             self.axes.add_collection(col, autolim=False)\n874:             col.sticky_edges.x[:] = [self._mins[0], self._maxs[0]]\n875:             col.sticky_edges.y[:] = [self._mins[1], self._maxs[1]]\n876:         self.axes.update_datalim([self._mins, self._maxs])\n877:         self.axes.autoscale_view(tight=True)\n878: \n879:         self.changed()  # set the colors\n880: \n881:         if kwargs:\n882:             _api.warn_external(\n883:                 'The following kwargs were not used by contour: ' +\n884:                 \", \".join(map(repr, kwargs))\n885:             )\n886: \n887:     def get_transform(self):\n888:         \"\"\"Return the `.Transform` instance used by this ContourSet.\"\"\"\n889:         if self._transform is None:\n890:             self._transform = self.axes.transData\n891:         elif (not isinstance(self._transform, mtransforms.Transform)\n892:               and hasattr(self._transform, '_as_mpl_transform')):\n893:             self._transform = self._transform._as_mpl_transform(self.axes)\n894:         return self._transform\n895: \n896:     def __getstate__(self):\n897:         state = self.__dict__.copy()\n898:         # the C object _contour_generator cannot currently be pickled. This\n899:         # isn't a big issue as it is not actually used once the contour has\n900:         # been calculated.\n901:         state['_contour_generator'] = None\n902:         return state\n903: \n904:     def legend_elements(self, variable_name='x', str_format=str):\n905:         \"\"\"\n906:         Return a list of artists and labels suitable for passing through\n907:         to `~.Axes.legend` which represent this ContourSet.\n908: \n909:         The labels have the form \"0 < x <= 1\" stating the data ranges which\n910:         the artists represent.\n911: \n912:         Parameters\n913:         ----------\n914:         variable_name : str\n915:             The string used inside the inequality used on the labels.\n916:         str_format : function: float -> str\n917:             Function used to format the numbers in the labels.\n918: \n919:         Returns\n920:         -------\n921:         artists : list[`.Artist`]\n922:             A list of the artists.\n923:         labels : list[str]\n924:             A list of the labels.\n925:         \"\"\"\n926:         artists = []\n927:         labels = []\n928: \n929:         if self.filled:\n930:             lowers, uppers = self._get_lowers_and_uppers()\n931:             n_levels = len(self.collections)\n932: \n933:             for i, (collection, lower, upper) in enumerate(\n934:                     zip(self.collections, lowers, uppers)):\n935:                 patch = mpatches.Rectangle(\n936:                     (0, 0), 1, 1,\n937:                     facecolor=collection.get_facecolor()[0],\n938:                     hatch=collection.get_hatch(),\n939:                     alpha=collection.get_alpha())\n940:                 artists.append(patch)\n941: \n942:                 lower = str_format(lower)\n943:                 upper = str_format(upper)\n944: \n945:                 if i == 0 and self.extend in ('min', 'both'):\n946:                     labels.append(fr'${variable_name} \\leq {lower}s$')\n947:                 elif i == n_levels - 1 and self.extend in ('max', 'both'):\n948:                     labels.append(fr'${variable_name} > {upper}s$')\n949:                 else:\n950:                     labels.append(fr'${lower} < {variable_name} \\leq {upper}$')\n951:         else:\n952:             for collection, level in zip(self.collections, self.levels):\n953: \n954:                 patch = mcoll.LineCollection(None)\n955:                 patch.update_from(collection)\n956: \n957:                 artists.append(patch)\n958:                 # format the level for insertion into the labels\n959:                 level = str_format(level)\n960:                 labels.append(fr'${variable_name} = {level}$')\n961: \n962:         return artists, labels\n963: \n964:     def _process_args(self, *args, **kwargs):\n965:         \"\"\"\n966:         Process *args* and *kwargs*; override in derived classes.\n967: \n968:         Must set self.levels, self.zmin and self.zmax, and update axes limits.\n969:         \"\"\"\n970:         self.levels = args[0]\n971:         self.allsegs = args[1]\n972:         self.allkinds = args[2] if len(args) > 2 else None\n973:         self.zmax = np.max(self.levels)\n974:         self.zmin = np.min(self.levels)\n975: \n976:         # Check lengths of levels and allsegs.\n977:         if self.filled:\n978:             if len(self.allsegs) != len(self.levels) - 1:\n979:                 raise ValueError('must be one less number of segments as '\n980:                                  'levels')\n981:         else:\n982:             if len(self.allsegs) != len(self.levels):\n983:                 raise ValueError('must be same number of segments as levels')\n984: \n985:         # Check length of allkinds.\n986:         if (self.allkinds is not None and\n987:                 len(self.allkinds) != len(self.allsegs)):\n988:             raise ValueError('allkinds has different length to allsegs')\n989: \n990:         # Determine x, y bounds and update axes data limits.\n991:         flatseglist = [s for seg in self.allsegs for s in seg]\n992:         points = np.concatenate(flatseglist, axis=0)\n993:         self._mins = points.min(axis=0)\n994:         self._maxs = points.max(axis=0)\n995: \n996:         return kwargs\n997: \n998:     def _get_allsegs_and_allkinds(self):\n999:         \"\"\"Compute ``allsegs`` and ``allkinds`` using C extension.\"\"\"\n1000:         allsegs = []\n1001:         allkinds = []\n1002:         if self.filled:\n1003:             lowers, uppers = self._get_lowers_and_uppers()\n1004:             for level, level_upper in zip(lowers, uppers):\n1005:                 vertices, kinds = \\\n1006:                     self._contour_generator.create_filled_contour(\n1007:                         level, level_upper)\n1008:                 allsegs.append(vertices)\n1009:                 allkinds.append(kinds)\n1010:         else:\n1011:             for level in self.levels:\n1012:                 vertices, kinds = self._contour_generator.create_contour(level)\n1013:                 allsegs.append(vertices)\n1014:                 allkinds.append(kinds)\n1015:         return allsegs, allkinds\n1016: \n1017:     def _get_lowers_and_uppers(self):\n1018:         \"\"\"\n1019:         Return ``(lowers, uppers)`` for filled contours.\n1020:         \"\"\"\n1021:         lowers = self._levels[:-1]\n1022:         if self.zmin == lowers[0]:\n1023:             # Include minimum values in lowest interval\n1024:             lowers = lowers.copy()  # so we don't change self._levels\n1025:             if self.logscale:\n1026:                 lowers[0] = 0.99 * self.zmin\n1027:             else:\n1028:                 lowers[0] -= 1\n1029:         uppers = self._levels[1:]\n1030:         return (lowers, uppers)\n1031: \n1032:     def _make_paths(self, segs, kinds):\n1033:         \"\"\"\n1034:         Create and return Path objects for the specified segments and optional\n1035:         kind codes.  *segs* is a list of numpy arrays, each array is either a\n1036:         closed line loop or open line strip of 2D points with a shape of\n1037:         (npoints, 2).  *kinds* is either None or a list (with the same length\n1038:         as *segs*) of numpy arrays, each array is of shape (npoints,) and\n1039:         contains the kind codes for the corresponding line in *segs*.  If\n1040:         *kinds* is None then the Path constructor creates the kind codes\n1041:         assuming that the line is an open strip.\n1042:         \"\"\"\n1043:         if kinds is None:\n1044:             return [mpath.Path(seg) for seg in segs]\n1045:         else:\n1046:             return [mpath.Path(seg, codes=kind) for seg, kind\n1047:                     in zip(segs, kinds)]\n1048: \n1049:     def changed(self):\n1050:         if not hasattr(self, \"cvalues\"):\n1051:             # Just return after calling the super() changed function\n1052:             cm.ScalarMappable.changed(self)\n1053:             return\n1054:         # Force an autoscale immediately because self.to_rgba() calls\n1055:         # autoscale_None() internally with the data passed to it,\n1056:         # so if vmin/vmax are not set yet, this would override them with\n1057:         # content from *cvalues* rather than levels like we want\n1058:         self.norm.autoscale_None(self.levels)\n1059:         tcolors = [(tuple(rgba),)\n1060:                    for rgba in self.to_rgba(self.cvalues, alpha=self.alpha)]\n1061:         self.tcolors = tcolors\n1062:         hatches = self.hatches * len(tcolors)\n1063:         for color, hatch, collection in zip(tcolors, hatches,\n1064:                                             self.collections):\n1065:             if self.filled:\n1066:                 collection.set_facecolor(color)\n1067:                 # update the collection's hatch (may be None)\n1068:                 collection.set_hatch(hatch)\n1069:             else:\n1070:                 collection.set_edgecolor(color)\n1071:         for label, cv in zip(self.labelTexts, self.labelCValues):\n1072:             label.set_alpha(self.alpha)\n1073:             label.set_color(self.labelMappable.to_rgba(cv))\n1074:         # add label colors\n1075:         cm.ScalarMappable.changed(self)\n1076: \n1077:     def _autolev(self, N):\n1078:         \"\"\"\n1079:         Select contour levels to span the data.\n1080: \n1081:         The target number of levels, *N*, is used only when the\n1082:         scale is not log and default locator is used.\n1083: \n1084:         We need two more levels for filled contours than for\n1085:         line contours, because for the latter we need to specify\n1086:         the lower and upper boundary of each range. For example,\n1087:         a single contour boundary, say at z = 0, requires only\n1088:         one contour line, but two filled regions, and therefore\n1089:         three levels to provide boundaries for both regions.\n1090:         \"\"\"\n1091:         if self.locator is None:\n1092:             if self.logscale:\n1093:                 self.locator = ticker.LogLocator()\n1094:             else:\n1095:                 self.locator = ticker.MaxNLocator(N + 1, min_n_ticks=1)\n1096: \n1097:         lev = self.locator.tick_values(self.zmin, self.zmax)\n1098: \n1099:         try:\n1100:             if self.locator._symmetric:\n1101:                 return lev\n1102:         except AttributeError:\n1103:             pass\n1104: \n1105:         # Trim excess levels the locator may have supplied.\n1106:         under = np.nonzero(lev < self.zmin)[0]\n1107:         i0 = under[-1] if len(under) else 0\n1108:         over = np.nonzero(lev > self.zmax)[0]\n1109:         i1 = over[0] + 1 if len(over) else len(lev)\n1110:         if self.extend in ('min', 'both'):\n1111:             i0 += 1\n1112:         if self.extend in ('max', 'both'):\n1113:             i1 -= 1\n1114: \n1115:         if i1 - i0 < 3:\n1116:             i0, i1 = 0, len(lev)\n1117: \n1118:         return lev[i0:i1]\n1119: \n1120:     def _process_contour_level_args(self, args):\n1121:         \"\"\"\n1122:         Determine the contour levels and store in self.levels.\n1123:         \"\"\"\n1124:         if self.levels is None:\n1125:             if len(args) == 0:\n1126:                 levels_arg = 7  # Default, hard-wired.\n1127:             else:\n1128:                 levels_arg = args[0]\n1129:         else:\n1130:             levels_arg = self.levels\n1131:         if isinstance(levels_arg, Integral):\n1132:             self.levels = self._autolev(levels_arg)\n1133:         else:\n1134:             self.levels = np.asarray(levels_arg, np.float64)\n1135: \n1136:         if not self.filled:\n1137:             inside = (self.levels > self.zmin) & (self.levels < self.zmax)\n1138:             levels_in = self.levels[inside]\n1139:             if len(levels_in) == 0:\n1140:                 self.levels = [self.zmin]\n1141:                 _api.warn_external(\n1142:                     \"No contour levels were found within the data range.\")\n1143: \n1144:         if self.filled and len(self.levels) < 2:\n1145:             raise ValueError(\"Filled contours require at least 2 levels.\")\n1146: \n1147:         if len(self.levels) > 1 and np.min(np.diff(self.levels)) <= 0.0:\n1148:             raise ValueError(\"Contour levels must be increasing\")\n1149: \n1150:     def _process_levels(self):\n1151:         \"\"\"\n1152:         Assign values to :attr:`layers` based on :attr:`levels`,\n1153:         adding extended layers as needed if contours are filled.\n1154: \n1155:         For line contours, layers simply coincide with levels;\n1156:         a line is a thin layer.  No extended levels are needed\n1157:         with line contours.\n1158:         \"\"\"\n1159:         # Make a private _levels to include extended regions; we\n1160:         # want to leave the original levels attribute unchanged.\n1161:         # (Colorbar needs this even for line contours.)\n1162:         self._levels = list(self.levels)\n1163: \n1164:         if self.logscale:\n1165:             lower, upper = 1e-250, 1e250\n1166:         else:\n1167:             lower, upper = -1e250, 1e250\n1168: \n1169:         if self.extend in ('both', 'min'):\n1170:             self._levels.insert(0, lower)\n1171:         if self.extend in ('both', 'max'):\n1172:             self._levels.append(upper)\n1173:         self._levels = np.asarray(self._levels)\n1174: \n1175:         if not self.filled:\n1176:             self.layers = self.levels\n1177:             return\n1178: \n1179:         # Layer values are mid-way between levels in screen space.\n1180:         if self.logscale:\n1181:             # Avoid overflow by taking sqrt before multiplying.\n1182:             self.layers = (np.sqrt(self._levels[:-1])\n1183:                            * np.sqrt(self._levels[1:]))\n1184:         else:\n1185:             self.layers = 0.5 * (self._levels[:-1] + self._levels[1:])\n1186: \n1187:     def _process_colors(self):\n1188:         \"\"\"\n1189:         Color argument processing for contouring.\n1190: \n1191:         Note that we base the colormapping on the contour levels\n1192:         and layers, not on the actual range of the Z values.  This\n1193:         means we don't have to worry about bad values in Z, and we\n1194:         always have the full dynamic range available for the selected\n1195:         levels.\n1196: \n1197:         The color is based on the midpoint of the layer, except for\n1198:         extended end layers.  By default, the norm vmin and vmax\n1199:         are the extreme values of the non-extended levels.  Hence,\n1200:         the layer color extremes are not the extreme values of\n1201:         the colormap itself, but approach those values as the number\n1202:         of levels increases.  An advantage of this scheme is that\n1203:         line contours, when added to filled contours, take on\n1204:         colors that are consistent with those of the filled regions;\n1205:         for example, a contour line on the boundary between two\n1206:         regions will have a color intermediate between those\n1207:         of the regions.\n1208: \n1209:         \"\"\"\n1210:         self.monochrome = self.cmap.monochrome\n1211:         if self.colors is not None:\n1212:             # Generate integers for direct indexing.\n1213:             i0, i1 = 0, len(self.levels)\n1214:             if self.filled:\n1215:                 i1 -= 1\n1216:                 # Out of range indices for over and under:\n1217:                 if self.extend in ('both', 'min'):\n1218:                     i0 -= 1\n1219:                 if self.extend in ('both', 'max'):\n1220:                     i1 += 1\n1221:             self.cvalues = list(range(i0, i1))\n1222:             self.set_norm(mcolors.NoNorm())\n1223:         else:\n1224:             self.cvalues = self.layers\n1225:         self.set_array(self.levels)\n1226:         self.autoscale_None()\n1227:         if self.extend in ('both', 'max', 'min'):\n1228:             self.norm.clip = False\n1229: \n1230:         # self.tcolors are set by the \"changed\" method\n1231: \n1232:     def _process_linewidths(self):\n1233:         linewidths = self.linewidths\n1234:         Nlev = len(self.levels)\n1235:         if linewidths is None:\n1236:             default_linewidth = mpl.rcParams['contour.linewidth']\n1237:             if default_linewidth is None:\n1238:                 default_linewidth = mpl.rcParams['lines.linewidth']\n1239:             tlinewidths = [(default_linewidth,)] * Nlev\n1240:         else:\n1241:             if not np.iterable(linewidths):\n1242:                 linewidths = [linewidths] * Nlev\n1243:             else:\n1244:                 linewidths = list(linewidths)\n1245:                 if len(linewidths) < Nlev:\n1246:                     nreps = int(np.ceil(Nlev / len(linewidths)))\n1247:                     linewidths = linewidths * nreps\n1248:                 if len(linewidths) > Nlev:\n1249:                     linewidths = linewidths[:Nlev]\n1250:             tlinewidths = [(w,) for w in linewidths]\n1251:         return tlinewidths\n1252: \n1253:     def _process_linestyles(self):\n1254:         linestyles = self.linestyles\n1255:         Nlev = len(self.levels)\n1256:         if linestyles is None:\n1257:             tlinestyles = ['solid'] * Nlev\n1258:             if self.monochrome:\n1259:                 eps = - (self.zmax - self.zmin) * 1e-15\n1260:                 for i, lev in enumerate(self.levels):\n1261:                     if lev < eps:\n1262:                         tlinestyles[i] = self.negative_linestyles\n1263:         else:\n1264:             if isinstance(linestyles, str):\n1265:                 tlinestyles = [linestyles] * Nlev\n1266:             elif np.iterable(linestyles):\n1267:                 tlinestyles = list(linestyles)\n1268:                 if len(tlinestyles) < Nlev:\n1269:                     nreps = int(np.ceil(Nlev / len(linestyles)))\n1270:                     tlinestyles = tlinestyles * nreps\n1271:                 if len(tlinestyles) > Nlev:\n1272:                     tlinestyles = tlinestyles[:Nlev]\n1273:             else:\n1274:                 raise ValueError(\"Unrecognized type for linestyles kwarg\")\n1275:         return tlinestyles\n1276: \n1277:     def get_alpha(self):\n1278:         \"\"\"Return alpha to be applied to all ContourSet artists.\"\"\"\n1279:         return self.alpha\n1280: \n1281:     def set_alpha(self, alpha):\n1282:         \"\"\"\n1283:         Set the alpha blending value for all ContourSet artists.\n1284:         *alpha* must be between 0 (transparent) and 1 (opaque).\n1285:         \"\"\"\n1286:         self.alpha = alpha\n1287:         self.changed()\n1288: \n1289:     def find_nearest_contour(self, x, y, indices=None, pixel=True):\n1290:         \"\"\"\n1291:         Find the point in the contour plot that is closest to ``(x, y)``.\n1292: \n1293:         This method does not support filled contours.\n1294: \n1295:         Parameters\n1296:         ----------\n1297:         x, y : float\n1298:             The reference point.\n1299:         indices : list of int or None, default: None\n1300:             Indices of contour levels to consider.  If None (the default), all\n1301:             levels are considered.\n1302:         pixel : bool, default: True\n1303:             If *True*, measure distance in pixel (screen) space, which is\n1304:             useful for manual contour labeling; else, measure distance in axes\n1305:             space.\n1306: \n1307:         Returns\n1308:         -------\n1309:         contour : `.Collection`\n1310:             The contour that is closest to ``(x, y)``.\n1311:         segment : int\n1312:             The index of the `.Path` in *contour* that is closest to\n1313:             ``(x, y)``.\n1314:         index : int\n1315:             The index of the path segment in *segment* that is closest to\n1316:             ``(x, y)``.\n1317:         xmin, ymin : float\n1318:             The point in the contour plot that is closest to ``(x, y)``.\n1319:         d2 : float\n1320:             The squared distance from ``(xmin, ymin)`` to ``(x, y)``.\n1321:         \"\"\"\n1322: \n1323:         # This function uses a method that is probably quite\n1324:         # inefficient based on converting each contour segment to\n1325:         # pixel coordinates and then comparing the given point to\n1326:         # those coordinates for each contour.  This will probably be\n1327:         # quite slow for complex contours, but for normal use it works\n1328:         # sufficiently well that the time is not noticeable.\n1329:         # Nonetheless, improvements could probably be made.\n1330: \n1331:         if self.filled:\n1332:             raise ValueError(\"Method does not support filled contours.\")\n1333: \n1334:         if indices is None:\n1335:             indices = range(len(self.collections))\n1336: \n1337:         d2min = np.inf\n1338:         conmin = None\n1339:         segmin = None\n1340:         imin = None\n1341:         xmin = None\n1342:         ymin = None\n1343: \n1344:         point = np.array([x, y])\n1345: \n1346:         for icon in indices:\n1347:             con = self.collections[icon]\n1348:             trans = con.get_transform()\n1349:             paths = con.get_paths()\n1350: \n1351:             for segNum, linepath in enumerate(paths):\n1352:                 lc = linepath.vertices\n1353:                 # transfer all data points to screen coordinates if desired\n1354:                 if pixel:\n1355:                     lc = trans.transform(lc)\n1356: \n1357:                 d2, xc, leg = _find_closest_point_on_path(lc, point)\n1358:                 if d2 < d2min:\n1359:                     d2min = d2\n1360:                     conmin = icon\n1361:                     segmin = segNum\n1362:                     imin = leg[1]\n1363:                     xmin = xc[0]\n1364:                     ymin = xc[1]\n1365: \n1366:         return (conmin, segmin, imin, xmin, ymin, d2min)\n1367: \n1368:     def remove(self):\n1369:         super().remove()\n1370:         for coll in self.collections:\n1371:             coll.remove()\n1372: \n1373: \n1374: @_docstring.dedent_interpd\n1375: class QuadContourSet(ContourSet):\n1376:     \"\"\"\n1377:     Create and store a set of contour lines or filled regions.\n1378: \n1379:     This class is typically not instantiated directly by the user but by\n1380:     `~.Axes.contour` and `~.Axes.contourf`.\n1381: \n1382:     %(contour_set_attributes)s\n1383:     \"\"\"\n1384: \n1385:     def _process_args(self, *args, corner_mask=None, algorithm=None, **kwargs):\n1386:         \"\"\"\n1387:         Process args and kwargs.\n1388:         \"\"\"\n1389:         if isinstance(args[0], QuadContourSet):\n1390:             if self.levels is None:\n1391:                 self.levels = args[0].levels\n1392:             self.zmin = args[0].zmin\n1393:             self.zmax = args[0].zmax\n1394:             self._corner_mask = args[0]._corner_mask\n1395:             contour_generator = args[0]._contour_generator\n1396:             self._mins = args[0]._mins\n1397:             self._maxs = args[0]._maxs\n1398:             self._algorithm = args[0]._algorithm\n1399:         else:\n1400:             import contourpy\n1401: \n1402:             if algorithm is None:\n1403:                 algorithm = mpl.rcParams['contour.algorithm']\n1404:             mpl.rcParams.validate[\"contour.algorithm\"](algorithm)\n1405:             self._algorithm = algorithm\n1406: \n1407:             if corner_mask is None:\n1408:                 if self._algorithm == \"mpl2005\":\n1409:                     # mpl2005 does not support corner_mask=True so if not\n1410:                     # specifically requested then disable it.\n1411:                     corner_mask = False\n1412:                 else:\n1413:                     corner_mask = mpl.rcParams['contour.corner_mask']\n1414:             self._corner_mask = corner_mask\n1415: \n1416:             x, y, z = self._contour_args(args, kwargs)\n1417: \n1418:             contour_generator = contourpy.contour_generator(\n1419:                 x, y, z, name=self._algorithm, corner_mask=self._corner_mask,\n1420:                 line_type=contourpy.LineType.SeparateCode,\n1421:                 fill_type=contourpy.FillType.OuterCode,\n1422:                 chunk_size=self.nchunk)\n1423: \n1424:             t = self.get_transform()\n1425: \n1426:             # if the transform is not trans data, and some part of it\n1427:             # contains transData, transform the xs and ys to data coordinates\n1428:             if (t != self.axes.transData and\n1429:                     any(t.contains_branch_seperately(self.axes.transData))):\n1430:                 trans_to_data = t - self.axes.transData\n1431:                 pts = np.vstack([x.flat, y.flat]).T\n1432:                 transformed_pts = trans_to_data.transform(pts)\n1433:                 x = transformed_pts[..., 0]\n1434:                 y = transformed_pts[..., 1]\n1435: \n1436:             self._mins = [ma.min(x), ma.min(y)]\n1437:             self._maxs = [ma.max(x), ma.max(y)]\n1438: \n1439:         self._contour_generator = contour_generator\n1440: \n1441:         return kwargs\n1442: \n1443:     def _contour_args(self, args, kwargs):\n1444:         if self.filled:\n1445:             fn = 'contourf'\n1446:         else:\n1447:             fn = 'contour'\n1448:         nargs = len(args)\n1449:         if nargs <= 2:\n1450:             z = ma.asarray(args[0], dtype=np.float64)\n1451:             x, y = self._initialize_x_y(z)\n1452:             args = args[1:]\n1453:         elif nargs <= 4:\n1454:             x, y, z = self._check_xyz(args[:3], kwargs)\n1455:             args = args[3:]\n1456:         else:\n1457:             raise _api.nargs_error(fn, takes=\"from 1 to 4\", given=nargs)\n1458:         z = ma.masked_invalid(z, copy=False)\n1459:         self.zmax = float(z.max())\n1460:         self.zmin = float(z.min())\n1461:         if self.logscale and self.zmin <= 0:\n1462:             z = ma.masked_where(z <= 0, z)\n1463:             _api.warn_external('Log scale: values of z <= 0 have been masked')\n1464:             self.zmin = float(z.min())\n1465:         self._process_contour_level_args(args)\n1466:         return (x, y, z)\n1467: \n1468:     def _check_xyz(self, args, kwargs):\n1469:         \"\"\"\n1470:         Check that the shapes of the input arrays match; if x and y are 1D,\n1471:         convert them to 2D using meshgrid.\n1472:         \"\"\"\n1473:         x, y = args[:2]\n1474:         x, y = self.axes._process_unit_info([(\"x\", x), (\"y\", y)], kwargs)\n1475: \n1476:         x = np.asarray(x, dtype=np.float64)\n1477:         y = np.asarray(y, dtype=np.float64)\n1478:         z = ma.asarray(args[2], dtype=np.float64)\n1479: \n1480:         if z.ndim != 2:\n1481:             raise TypeError(f\"Input z must be 2D, not {z.ndim}D\")\n1482:         if z.shape[0] < 2 or z.shape[1] < 2:\n1483:             raise TypeError(f\"Input z must be at least a (2, 2) shaped array, \"\n1484:                             f\"but has shape {z.shape}\")\n1485:         Ny, Nx = z.shape\n1486: \n1487:         if x.ndim != y.ndim:\n1488:             raise TypeError(f\"Number of dimensions of x ({x.ndim}) and y \"\n1489:                             f\"({y.ndim}) do not match\")\n1490:         if x.ndim == 1:\n1491:             nx, = x.shape\n1492:             ny, = y.shape\n1493:             if nx != Nx:\n1494:                 raise TypeError(f\"Length of x ({nx}) must match number of \"\n1495:                                 f\"columns in z ({Nx})\")\n1496:             if ny != Ny:\n1497:                 raise TypeError(f\"Length of y ({ny}) must match number of \"\n1498:                                 f\"rows in z ({Ny})\")\n1499:             x, y = np.meshgrid(x, y)\n1500:         elif x.ndim == 2:\n1501:             if x.shape != z.shape:\n1502:                 raise TypeError(\n1503:                     f\"Shapes of x {x.shape} and z {z.shape} do not match\")\n1504:             if y.shape != z.shape:\n1505:                 raise TypeError(\n1506:                     f\"Shapes of y {y.shape} and z {z.shape} do not match\")\n1507:         else:\n1508:             raise TypeError(f\"Inputs x and y must be 1D or 2D, not {x.ndim}D\")\n1509: \n1510:         return x, y, z\n1511: \n1512:     def _initialize_x_y(self, z):\n1513:         \"\"\"\n1514:         Return X, Y arrays such that contour(Z) will match imshow(Z)\n1515:         if origin is not None.\n1516:         The center of pixel Z[i, j] depends on origin:\n1517:         if origin is None, x = j, y = i;\n1518:         if origin is 'lower', x = j + 0.5, y = i + 0.5;\n1519:         if origin is 'upper', x = j + 0.5, y = Nrows - i - 0.5\n1520:         If extent is not None, x and y will be scaled to match,\n1521:         as in imshow.\n1522:         If origin is None and extent is not None, then extent\n1523:         will give the minimum and maximum values of x and y.\n1524:         \"\"\"\n1525:         if z.ndim != 2:\n1526:             raise TypeError(f\"Input z must be 2D, not {z.ndim}D\")\n1527:         elif z.shape[0] < 2 or z.shape[1] < 2:\n1528:             raise TypeError(f\"Input z must be at least a (2, 2) shaped array, \"\n1529:                             f\"but has shape {z.shape}\")\n1530:         else:\n1531:             Ny, Nx = z.shape\n1532:         if self.origin is None:  # Not for image-matching.\n1533:             if self.extent is None:\n1534:                 return np.meshgrid(np.arange(Nx), np.arange(Ny))\n1535:             else:\n1536:                 x0, x1, y0, y1 = self.extent\n1537:                 x = np.linspace(x0, x1, Nx)\n1538:                 y = np.linspace(y0, y1, Ny)\n1539:                 return np.meshgrid(x, y)\n1540:         # Match image behavior:\n1541:         if self.extent is None:\n1542:             x0, x1, y0, y1 = (0, Nx, 0, Ny)\n1543:         else:\n1544:             x0, x1, y0, y1 = self.extent\n1545:         dx = (x1 - x0) / Nx\n1546:         dy = (y1 - y0) / Ny\n1547:         x = x0 + (np.arange(Nx) + 0.5) * dx\n1548:         y = y0 + (np.arange(Ny) + 0.5) * dy\n1549:         if self.origin == 'upper':\n1550:             y = y[::-1]\n1551:         return np.meshgrid(x, y)\n1552: \n1553: \n1554: _docstring.interpd.update(contour_doc=\"\"\"\n1555: `.contour` and `.contourf` draw contour lines and filled contours,\n1556: respectively.  Except as noted, function signatures and return values\n1557: are the same for both versions.\n1558: \n1559: Parameters\n1560: ----------\n1561: X, Y : array-like, optional\n1562:     The coordinates of the values in *Z*.\n1563: \n1564:     *X* and *Y* must both be 2D with the same shape as *Z* (e.g.\n1565:     created via `numpy.meshgrid`), or they must both be 1-D such\n1566:     that ``len(X) == N`` is the number of columns in *Z* and\n1567:     ``len(Y) == M`` is the number of rows in *Z*.\n1568: \n1569:     *X* and *Y* must both be ordered monotonically.\n1570: \n1571:     If not given, they are assumed to be integer indices, i.e.\n1572:     ``X = range(N)``, ``Y = range(M)``.\n1573: \n1574: Z : (M, N) array-like\n1575:     The height values over which the contour is drawn.  Color-mapping is\n1576:     controlled by *cmap*, *norm*, *vmin*, and *vmax*.\n1577: \n1578: levels : int or array-like, optional\n1579:     Determines the number and positions of the contour lines / regions.\n1580: \n1581:     If an int *n*, use `~matplotlib.ticker.MaxNLocator`, which tries\n1582:     to automatically choose no more than *n+1* \"nice\" contour levels\n1583:     between minimum and maximum numeric values of *Z*.\n1584: \n1585:     If array-like, draw contour lines at the specified levels.\n1586:     The values must be in increasing order.\n1587: \n1588: Returns\n1589: -------\n1590: `~.contour.QuadContourSet`\n1591: \n1592: Other Parameters\n1593: ----------------\n1594: corner_mask : bool, default: :rc:`contour.corner_mask`\n1595:     Enable/disable corner masking, which only has an effect if *Z* is\n1596:     a masked array.  If ``False``, any quad touching a masked point is\n1597:     masked out.  If ``True``, only the triangular corners of quads\n1598:     nearest those points are always masked out, other triangular\n1599:     corners comprising three unmasked points are contoured as usual.\n1600: \n1601: colors : color string or sequence of colors, optional\n1602:     The colors of the levels, i.e. the lines for `.contour` and the\n1603:     areas for `.contourf`.\n1604: \n1605:     The sequence is cycled for the levels in ascending order. If the\n1606:     sequence is shorter than the number of levels, it's repeated.\n1607: \n1608:     As a shortcut, single color strings may be used in place of\n1609:     one-element lists, i.e. ``'red'`` instead of ``['red']`` to color\n1610:     all levels with the same color. This shortcut does only work for\n1611:     color strings, not for other ways of specifying colors.\n1612: \n1613:     By default (value *None*), the colormap specified by *cmap*\n1614:     will be used.\n1615: \n1616: alpha : float, default: 1\n1617:     The alpha blending value, between 0 (transparent) and 1 (opaque).\n1618: \n1619: %(cmap_doc)s\n1620: \n1621:     This parameter is ignored if *colors* is set.\n1622: \n1623: %(norm_doc)s\n1624: \n1625:     This parameter is ignored if *colors* is set.\n1626: \n1627: %(vmin_vmax_doc)s\n1628: \n1629:     If *vmin* or *vmax* are not given, the default color scaling is based on\n1630:     *levels*.\n1631: \n1632:     This parameter is ignored if *colors* is set.\n1633: \n1634: origin : {*None*, 'upper', 'lower', 'image'}, default: None\n1635:     Determines the orientation and exact position of *Z* by specifying\n1636:     the position of ``Z[0, 0]``.  This is only relevant, if *X*, *Y*\n1637:     are not given.\n1638: \n1639:     - *None*: ``Z[0, 0]`` is at X=0, Y=0 in the lower left corner.\n1640:     - 'lower': ``Z[0, 0]`` is at X=0.5, Y=0.5 in the lower left corner.\n1641:     - 'upper': ``Z[0, 0]`` is at X=N+0.5, Y=0.5 in the upper left\n1642:       corner.\n1643:     - 'image': Use the value from :rc:`image.origin`.\n1644: \n1645: extent : (x0, x1, y0, y1), optional\n1646:     If *origin* is not *None*, then *extent* is interpreted as in\n1647:     `.imshow`: it gives the outer pixel boundaries. In this case, the\n1648:     position of Z[0, 0] is the center of the pixel, not a corner. If\n1649:     *origin* is *None*, then (*x0*, *y0*) is the position of Z[0, 0],\n1650:     and (*x1*, *y1*) is the position of Z[-1, -1].\n1651: \n1652:     This argument is ignored if *X* and *Y* are specified in the call\n1653:     to contour.\n1654: \n1655: locator : ticker.Locator subclass, optional\n1656:     The locator is used to determine the contour levels if they\n1657:     are not given explicitly via *levels*.\n1658:     Defaults to `~.ticker.MaxNLocator`.\n1659: \n1660: extend : {'neither', 'both', 'min', 'max'}, default: 'neither'\n1661:     Determines the ``contourf``-coloring of values that are outside the\n1662:     *levels* range.\n1663: \n1664:     If 'neither', values outside the *levels* range are not colored.\n1665:     If 'min', 'max' or 'both', color the values below, above or below\n1666:     and above the *levels* range.\n1667: \n1668:     Values below ``min(levels)`` and above ``max(levels)`` are mapped\n1669:     to the under/over values of the `.Colormap`. Note that most\n1670:     colormaps do not have dedicated colors for these by default, so\n1671:     that the over and under values are the edge values of the colormap.\n1672:     You may want to set these values explicitly using\n1673:     `.Colormap.set_under` and `.Colormap.set_over`.\n1674: \n1675:     .. note::\n1676: \n1677:         An existing `.QuadContourSet` does not get notified if\n1678:         properties of its colormap are changed. Therefore, an explicit\n1679:         call `.QuadContourSet.changed()` is needed after modifying the\n1680:         colormap. The explicit call can be left out, if a colorbar is\n1681:         assigned to the `.QuadContourSet` because it internally calls\n1682:         `.QuadContourSet.changed()`.\n1683: \n1684:     Example::\n1685: \n1686:         x = np.arange(1, 10)\n1687:         y = x.reshape(-1, 1)\n1688:         h = x * y\n1689: \n1690:         cs = plt.contourf(h, levels=[10, 30, 50],\n1691:             colors=['#808080', '#A0A0A0', '#C0C0C0'], extend='both')\n1692:         cs.cmap.set_over('red')\n1693:         cs.cmap.set_under('blue')\n1694:         cs.changed()\n1695: \n1696: xunits, yunits : registered units, optional\n1697:     Override axis units by specifying an instance of a\n1698:     :class:`matplotlib.units.ConversionInterface`.\n1699: \n1700: antialiased : bool, optional\n1701:     Enable antialiasing, overriding the defaults.  For\n1702:     filled contours, the default is *True*.  For line contours,\n1703:     it is taken from :rc:`lines.antialiased`.\n1704: \n1705: nchunk : int >= 0, optional\n1706:     If 0, no subdivision of the domain.  Specify a positive integer to\n1707:     divide the domain into subdomains of *nchunk* by *nchunk* quads.\n1708:     Chunking reduces the maximum length of polygons generated by the\n1709:     contouring algorithm which reduces the rendering workload passed\n1710:     on to the backend and also requires slightly less RAM.  It can\n1711:     however introduce rendering artifacts at chunk boundaries depending\n1712:     on the backend, the *antialiased* flag and value of *alpha*.\n1713: \n1714: linewidths : float or array-like, default: :rc:`contour.linewidth`\n1715:     *Only applies to* `.contour`.\n1716: \n1717:     The line width of the contour lines.\n1718: \n1719:     If a number, all levels will be plotted with this linewidth.\n1720: \n1721:     If a sequence, the levels in ascending order will be plotted with\n1722:     the linewidths in the order specified.\n1723: \n1724:     If None, this falls back to :rc:`lines.linewidth`.\n1725: \n1726: linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, optional\n1727:     *Only applies to* `.contour`.\n1728: \n1729:     If *linestyles* is *None*, the default is 'solid' unless the lines are\n1730:     monochrome. In that case, negative contours will instead take their\n1731:     linestyle from the *negative_linestyles* argument.\n1732: \n1733:     *linestyles* can also be an iterable of the above strings specifying a set\n1734:     of linestyles to be used. If this iterable is shorter than the number of\n1735:     contour levels it will be repeated as necessary.\n1736: \n1737: negative_linestyles : {*None*, 'solid', 'dashed', 'dashdot', 'dotted'}, \\\n1738:                        optional\n1739:     *Only applies to* `.contour`.\n1740: \n1741:     If *linestyles* is *None* and the lines are monochrome, this argument\n1742:     specifies the line style for negative contours.\n1743: \n1744:     If *negative_linestyles* is *None*, the default is taken from\n1745:     :rc:`contour.negative_linestyles`.\n1746: \n1747:     *negative_linestyles* can also be an iterable of the above strings\n1748:     specifying a set of linestyles to be used. If this iterable is shorter than\n1749:     the number of contour levels it will be repeated as necessary.\n1750: \n1751: hatches : list[str], optional\n1752:     *Only applies to* `.contourf`.\n1753: \n1754:     A list of cross hatch patterns to use on the filled areas.\n1755:     If None, no hatching will be added to the contour.\n1756:     Hatching is supported in the PostScript, PDF, SVG and Agg\n1757:     backends only.\n1758: \n1759: algorithm : {'mpl2005', 'mpl2014', 'serial', 'threaded'}, optional\n1760:     Which contouring algorithm to use to calculate the contour lines and\n1761:     polygons. The algorithms are implemented in\n1762:     `ContourPy <https://github.com/contourpy/contourpy>`_, consult the\n1763:     `ContourPy documentation <https://contourpy.readthedocs.io>`_ for\n1764:     further information.\n1765: \n1766:     The default is taken from :rc:`contour.algorithm`.\n1767: \n1768: data : indexable object, optional\n1769:     DATA_PARAMETER_PLACEHOLDER\n1770: \n1771: Notes\n1772: -----\n1773: 1. `.contourf` differs from the MATLAB version in that it does not draw\n1774:    the polygon edges. To draw edges, add line contours with calls to\n1775:    `.contour`.\n1776: \n1777: 2. `.contourf` fills intervals that are closed at the top; that is, for\n1778:    boundaries *z1* and *z2*, the filled region is::\n1779: \n1780:       z1 < Z <= z2\n1781: \n1782:    except for the lowest interval, which is closed on both sides (i.e.\n1783:    it includes the lowest value).\n1784: \n1785: 3. `.contour` and `.contourf` use a `marching squares\n1786:    <https://en.wikipedia.org/wiki/Marching_squares>`_ algorithm to\n1787:    compute contour locations.  More information can be found in\n1788:    `ContourPy documentation <https://contourpy.readthedocs.io>`_.\n1789: \"\"\" % _docstring.interpd.params)\n\n[start of lib/matplotlib/tri/_tricontour.py]\n1: import numpy as np\n2: \n3: from matplotlib import _docstring\n4: from matplotlib.contour import ContourSet\n5: from matplotlib.tri._triangulation import Triangulation\n6: \n7: \n8: @_docstring.dedent_interpd\n9: class TriContourSet(ContourSet):\n10:     \"\"\"\n11:     Create and store a set of contour lines or filled regions for\n12:     a triangular grid.\n13: \n14:     This class is typically not instantiated directly by the user but by\n15:     `~.Axes.tricontour` and `~.Axes.tricontourf`.\n16: \n17:     %(contour_set_attributes)s\n18:     \"\"\"\n19:     def __init__(self, ax, *args, **kwargs):\n20:         \"\"\"\n21:         Draw triangular grid contour lines or filled regions,\n22:         depending on whether keyword arg *filled* is False\n23:         (default) or True.\n24: \n25:         The first argument of the initializer must be an `~.axes.Axes`\n26:         object.  The remaining arguments and keyword arguments\n27:         are described in the docstring of `~.Axes.tricontour`.\n28:         \"\"\"\n29:         super().__init__(ax, *args, **kwargs)\n30: \n31:     def _process_args(self, *args, **kwargs):\n32:         \"\"\"\n33:         Process args and kwargs.\n34:         \"\"\"\n35:         if isinstance(args[0], TriContourSet):\n36:             C = args[0]._contour_generator\n37:             if self.levels is None:\n38:                 self.levels = args[0].levels\n39:             self.zmin = args[0].zmin\n40:             self.zmax = args[0].zmax\n41:             self._mins = args[0]._mins\n42:             self._maxs = args[0]._maxs\n43:         else:\n44:             from matplotlib import _tri\n45:             tri, z = self._contour_args(args, kwargs)\n46:             C = _tri.TriContourGenerator(tri.get_cpp_triangulation(), z)\n47:             self._mins = [tri.x.min(), tri.y.min()]\n48:             self._maxs = [tri.x.max(), tri.y.max()]\n49: \n50:         self._contour_generator = C\n51:         return kwargs\n52: \n53:     def _contour_args(self, args, kwargs):\n54:         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(*args,\n55:                                                                    **kwargs)\n56:         z = np.ma.asarray(args[0])\n57:         if z.shape != tri.x.shape:\n58:             raise ValueError('z array must have same length as triangulation x'\n59:                              ' and y arrays')\n60: \n61:         # z values must be finite, only need to check points that are included\n62:         # in the triangulation.\n63:         z_check = z[np.unique(tri.get_masked_triangles())]\n64:         if np.ma.is_masked(z_check):\n65:             raise ValueError('z must not contain masked points within the '\n66:                              'triangulation')\n67:         if not np.isfinite(z_check).all():\n68:             raise ValueError('z array must not contain non-finite values '\n69:                              'within the triangulation')\n70: \n71:         z = np.ma.masked_invalid(z, copy=False)\n72:         self.zmax = float(z_check.max())\n73:         self.zmin = float(z_check.min())\n74:         if self.logscale and self.zmin <= 0:\n75:             func = 'contourf' if self.filled else 'contour'\n76:             raise ValueError(f'Cannot {func} log of negative values.')\n77:         self._process_contour_level_args(args[1:])\n78:         return (tri, z)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/contour.py",
      "suspect_lines": [
        1120,
        1125,
        1126,
        1127,
        1450,
        1452,
        1454,
        1455,
        1465,
        1468,
        1473,
        1478
      ]
    },
    {
      "filename": "/lib/matplotlib/tri/_tricontour.py",
      "suspect_lines": [
        56,
        77
      ]
    }
  ]
}