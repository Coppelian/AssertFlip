{
  "instance_id": "sympy__sympy-15809",
  "problem_statement": "Zero-argument Min() and Max()\nRight now `Min()` and `Max()` with no arguments raise `ValueError: The Max/Min functions must have arguments.`. It might be mathematically more convenient to have them return `oo` and `-oo`, respectively. See https://en.wikipedia.org/wiki/Empty_set#Extended_real_numbers for why these are valid answers mathematically. \n",
  "localized_code": "[start of sympy/functions/elementary/miscellaneous.py]\n1: from __future__ import print_function, division\n2: \n3: from sympy.core import S, sympify\n4: from sympy.core.add import Add\n5: from sympy.core.containers import Tuple\n6: from sympy.core.operations import LatticeOp, ShortCircuit\n7: from sympy.core.function import (Application, Lambda,\n8:     ArgumentIndexError)\n9: from sympy.core.expr import Expr\n10: from sympy.core.mod import Mod\n11: from sympy.core.mul import Mul\n12: from sympy.core.numbers import Rational\n13: from sympy.core.power import Pow\n14: from sympy.core.relational import Eq, Relational\n15: from sympy.core.singleton import Singleton\n16: from sympy.core.symbol import Dummy\n17: from sympy.core.rules import Transform\n18: from sympy.core.compatibility import as_int, with_metaclass, range\n19: from sympy.core.logic import fuzzy_and, fuzzy_or, _torf\n20: from sympy.functions.elementary.integers import floor\n21: from sympy.logic.boolalg import And, Or\n22: \n23: def _minmax_as_Piecewise(op, *args):\n24:     # helper for Min/Max rewrite as Piecewise\n25:     from sympy.functions.elementary.piecewise import Piecewise\n26:     ec = []\n27:     for i, a in enumerate(args):\n28:         c = []\n29:         for j in range(i + 1, len(args)):\n30:             c.append(Relational(a, args[j], op))\n31:         ec.append((a, And(*c)))\n32:     return Piecewise(*ec)\n33: \n34: \n35: class IdentityFunction(with_metaclass(Singleton, Lambda)):\n36:     \"\"\"\n37:     The identity function\n38: \n39:     Examples\n40:     ========\n41: \n42:     >>> from sympy import Id, Symbol\n43:     >>> x = Symbol('x')\n44:     >>> Id(x)\n45:     x\n46: \n47:     \"\"\"\n48: \n49:     def __new__(cls):\n50:         from sympy.sets.sets import FiniteSet\n51:         x = Dummy('x')\n52:         #construct \"by hand\" to avoid infinite loop\n53:         obj = Expr.__new__(cls, Tuple(x), x)\n54:         obj.nargs = FiniteSet(1)\n55:         return obj\n56: \n57: Id = S.IdentityFunction\n58: \n59: ###############################################################################\n60: ############################# ROOT and SQUARE ROOT FUNCTION ###################\n61: ###############################################################################\n62: \n63: \n64: def sqrt(arg, evaluate=None):\nCode replaced for brevity.\n132: \n133: \n134: \n135: def cbrt(arg, evaluate=None):\nCode replaced for brevity.\n185: \n186: \n187: \n188: def root(arg, n, k=0, evaluate=None):\nCode replaced for brevity.\n277: \n278: \n279: \n280: def real_root(arg, n=None, evaluate=None):\nCode replaced for brevity.\n333: \n334: \n335: ###############################################################################\n336: ############################# MINIMUM and MAXIMUM #############################\n337: ###############################################################################\n338: \n339: \n340: class MinMaxBase(Expr, LatticeOp):\n341:     def __new__(cls, *args, **assumptions):\n342:         if not args:\n343:             raise ValueError(\"The Max/Min functions must have arguments.\")\n344: \n345:         args = (sympify(arg) for arg in args)\n346: \n347:         # first standard filter, for cls.zero and cls.identity\n348:         # also reshape Max(a, Max(b, c)) to Max(a, b, c)\n349:         try:\n350:             args = frozenset(cls._new_args_filter(args))\n351:         except ShortCircuit:\n352:             return cls.zero\n353: \n354:         if assumptions.pop('evaluate', True):\n355:             # remove redundant args that are easily identified\n356:             args = cls._collapse_arguments(args, **assumptions)\n357: \n358:         # find local zeros\n359:         args = cls._find_localzeros(args, **assumptions)\n360: \n361:         if not args:\n362:             return cls.identity\n363: \n364:         if len(args) == 1:\n365:             return list(args).pop()\n366: \n367:         # base creation\n368:         _args = frozenset(args)\n369:         obj = Expr.__new__(cls, _args, **assumptions)\n370:         obj._argset = _args\n371:         return obj\n372: \n373:     @classmethod\n374:     def _collapse_arguments(cls, args, **assumptions):\n375:         \"\"\"Remove redundant args.\n376: \n377:         Examples\n378:         ========\n379: \n380:         >>> from sympy import Min, Max\n381:         >>> from sympy.abc import a, b, c, d, e\n382: \n383:         Any arg in parent that appears in any\n384:         parent-like function in any of the flat args\n385:         of parent can be removed from that sub-arg:\n386: \n387:         >>> Min(a, Max(b, Min(a, c, d)))\n388:         Min(a, Max(b, Min(c, d)))\n389: \n390:         If the arg of parent appears in an opposite-than parent\n391:         function in any of the flat args of parent that function\n392:         can be replaced with the arg:\n393: \n394:         >>> Min(a, Max(b, Min(c, d, Max(a, e))))\n395:         Min(a, Max(b, Min(a, c, d)))\n396: \n397:         \"\"\"\n398:         from sympy.utilities.iterables import ordered\n399:         from sympy.utilities.iterables import sift\n400:         from sympy.simplify.simplify import walk\n401: \n402:         if not args:\n403:             return args\n404:         args = list(ordered(args))\n405:         if cls == Min:\n406:             other = Max\n407:         else:\n408:             other = Min\n409: \n410:         # find global comparable max of Max and min of Min if a new\n411:         # value is being introduced in these args at position 0 of\n412:         # the ordered args\n413:         if args[0].is_number:\n414:             sifted = mins, maxs = [], []\n415:             for i in args:\n416:                 for v in walk(i, Min, Max):\n417:                     if v.args[0].is_comparable:\n418:                         sifted[isinstance(v, Max)].append(v)\n419:             small = Min.identity\n420:             for i in mins:\n421:                 v = i.args[0]\n422:                 if v.is_number and (v < small) == True:\n423:                     small = v\n424:             big = Max.identity\n425:             for i in maxs:\n426:                 v = i.args[0]\n427:                 if v.is_number and (v > big) == True:\n428:                     big = v\n429:             # at the point when this function is called from __new__,\n430:             # there may be more than one numeric arg present since\n431:             # local zeros have not been handled yet, so look through\n432:             # more than the first arg\n433:             if cls == Min:\n434:                 for i in range(len(args)):\n435:                     if not args[i].is_number:\n436:                         break\n437:                     if (args[i] < small) == True:\n438:                         small = args[i]\n439:             elif cls == Max:\n440:                 for i in range(len(args)):\n441:                     if not args[i].is_number:\n442:                         break\n443:                     if (args[i] > big) == True:\n444:                         big = args[i]\n445:             T = None\n446:             if cls == Min:\n447:                 if small != Min.identity:\n448:                     other = Max\n449:                     T = small\n450:             elif big != Max.identity:\n451:                 other = Min\n452:                 T = big\n453:             if T is not None:\n454:                 # remove numerical redundancy\n455:                 for i in range(len(args)):\n456:                     a = args[i]\n457:                     if isinstance(a, other):\n458:                         a0 = a.args[0]\n459:                         if ((a0 > T) if other == Max else (a0 < T)) == True:\n460:                             args[i] = cls.identity\n461: \n462:         # remove redundant symbolic args\n463:         def do(ai, a):\n464:             if not isinstance(ai, (Min, Max)):\n465:                 return ai\n466:             cond = a in ai.args\n467:             if not cond:\n468:                 return ai.func(*[do(i, a) for i in ai.args],\n469:                     evaluate=False)\n470:             if isinstance(ai, cls):\n471:                 return ai.func(*[do(i, a) for i in ai.args if i != a],\n472:                     evaluate=False)\n473:             return a\n474:         for i, a in enumerate(args):\n475:             args[i + 1:] = [do(ai, a) for ai in args[i + 1:]]\n476: \n477:         # factor out common elements as for\n478:         # Min(Max(x, y), Max(x, z)) -> Max(x, Min(y, z))\n479:         # and vice versa when swapping Min/Max -- do this only for the\n480:         # easy case where all functions contain something in common;\n481:         # trying to find some optimal subset of args to modify takes\n482:         # too long\n483:         if len(args) > 1:\n484:             common = None\n485:             remove = []\n486:             sets = []\n487:             for i in range(len(args)):\n488:                 a = args[i]\n489:                 if not isinstance(a, other):\n490:                     continue\n491:                 s = set(a.args)\n492:                 common = s if common is None else (common & s)\n493:                 if not common:\n494:                     break\n495:                 sets.append(s)\n496:                 remove.append(i)\n497:             if common:\n498:                 sets = filter(None, [s - common for s in sets])\n499:                 sets = [other(*s, evaluate=False) for s in sets]\n500:                 for i in reversed(remove):\n501:                     args.pop(i)\n502:                 oargs = [cls(*sets)] if sets else []\n503:                 oargs.extend(common)\n504:                 args.append(other(*oargs, evaluate=False))\n505: \n506:         return args\n507: \n508:     @classmethod\n509:     def _new_args_filter(cls, arg_sequence):\n510:         \"\"\"\n511:         Generator filtering args.\n512: \n513:         first standard filter, for cls.zero and cls.identity.\n514:         Also reshape Max(a, Max(b, c)) to Max(a, b, c),\n515:         and check arguments for comparability\n516:         \"\"\"\n517:         for arg in arg_sequence:\n518: \n519:             # pre-filter, checking comparability of arguments\n520:             if not isinstance(arg, Expr) or arg.is_real is False or (\n521:                     arg.is_number and\n522:                     not arg.is_comparable):\n523:                 raise ValueError(\"The argument '%s' is not comparable.\" % arg)\n524: \n525:             if arg == cls.zero:\n526:                 raise ShortCircuit(arg)\n527:             elif arg == cls.identity:\n528:                 continue\n529:             elif arg.func == cls:\n530:                 for x in arg.args:\n531:                     yield x\n532:             else:\n533:                 yield arg\n534: \n535:     @classmethod\n536:     def _find_localzeros(cls, values, **options):\n537:         \"\"\"\n538:         Sequentially allocate values to localzeros.\n539: \n540:         When a value is identified as being more extreme than another member it\n541:         replaces that member; if this is never true, then the value is simply\n542:         appended to the localzeros.\n543:         \"\"\"\n544:         localzeros = set()\n545:         for v in values:\n546:             is_newzero = True\n547:             localzeros_ = list(localzeros)\n548:             for z in localzeros_:\n549:                 if id(v) == id(z):\n550:                     is_newzero = False\n551:                 else:\n552:                     con = cls._is_connected(v, z)\n553:                     if con:\n554:                         is_newzero = False\n555:                         if con is True or con == cls:\n556:                             localzeros.remove(z)\n557:                             localzeros.update([v])\n558:             if is_newzero:\n559:                 localzeros.update([v])\n560:         return localzeros\n561: \n562:     @classmethod\n563:     def _is_connected(cls, x, y):\n564:         \"\"\"\n565:         Check if x and y are connected somehow.\n566:         \"\"\"\n567:         from sympy.core.exprtools import factor_terms\n568:         def hit(v, t, f):\n569:             if not v.is_Relational:\n570:                 return t if v else f\n571:         for i in range(2):\n572:             if x == y:\n573:                 return True\n574:             r = hit(x >= y, Max, Min)\n575:             if r is not None:\n576:                 return r\n577:             r = hit(y <= x, Max, Min)\n578:             if r is not None:\n579:                 return r\n580:             r = hit(x <= y, Min, Max)\n581:             if r is not None:\n582:                 return r\n583:             r = hit(y >= x, Min, Max)\n584:             if r is not None:\n585:                 return r\n586:             # simplification can be expensive, so be conservative\n587:             # in what is attempted\n588:             x = factor_terms(x - y)\n589:             y = S.Zero\n590: \n591:         return False\n592: \n593:     def _eval_derivative(self, s):\n594:         # f(x).diff(s) -> x.diff(s) * f.fdiff(1)(s)\n595:         i = 0\n596:         l = []\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/functions/elementary/miscellaneous.py",
      "suspect_lines": [
        342,
        343
      ]
    }
  ]
}