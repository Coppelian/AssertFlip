{
  "instance_id": "sphinx-doc__sphinx-9258",
  "problem_statement": "[RFE] Support union types specification using | (vertical bar/pipe)\nPlease add a support for specifying multiple types acceptable for a parameter/attribute/variable.\nUse case:\nImagine that there is a function that accepts both `bytes` and `str`. The docstring would look like:\n\n``` restructuredtext\ndef foo(text):\n    \"\"\"Bar\n\n    :param text: a text\n    :type text: bytes | str\n\n    \"\"\"\n```\n\nSuch a syntax is already supported by e.g. [PyCharm](https://www.jetbrains.com/pycharm/help/type-hinting-in-pycharm.html).\n\n",
  "localized_code": "[start of sphinx/domains/python.py]\n1: \"\"\"\n2:     sphinx.domains.python\n3:     ~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     The Python domain.\n6: \n7:     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import builtins\n12: import inspect\n13: import re\n14: import sys\n15: import typing\n16: import warnings\n17: from inspect import Parameter\n18: from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Optional, Tuple, Type, cast\n19: \n20: from docutils import nodes\n21: from docutils.nodes import Element, Node\n22: from docutils.parsers.rst import directives\n23: \n24: from sphinx import addnodes\n25: from sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition\n26: from sphinx.application import Sphinx\n27: from sphinx.builders import Builder\n28: from sphinx.deprecation import RemovedInSphinx50Warning\n29: from sphinx.directives import ObjectDescription\n30: from sphinx.domains import Domain, Index, IndexEntry, ObjType\n31: from sphinx.environment import BuildEnvironment\n32: from sphinx.locale import _, __\n33: from sphinx.pycode.ast import ast\n34: from sphinx.pycode.ast import parse as ast_parse\n35: from sphinx.roles import XRefRole\n36: from sphinx.util import logging\n37: from sphinx.util.docfields import Field, GroupedField, TypedField\n38: from sphinx.util.docutils import SphinxDirective\n39: from sphinx.util.inspect import signature_from_str\n40: from sphinx.util.nodes import find_pending_xref_condition, make_id, make_refnode\n41: from sphinx.util.typing import OptionSpec, TextlikeNode\n42: \n43: logger = logging.getLogger(__name__)\n44: \n45: \n46: # REs for Python signatures\n47: py_sig_re = re.compile(\n48:     r'''^ ([\\w.]*\\.)?            # class name(s)\n49:           (\\w+)  \\s*             # thing name\n50:           (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n51:            (?:\\s* -> \\s* (.*))?  #           return annotation\n52:           )? $                   # and nothing more\n53:           ''', re.VERBOSE)\n54: \n55: \n56: pairindextypes = {\n57:     'module':    _('module'),\n58:     'keyword':   _('keyword'),\n59:     'operator':  _('operator'),\n60:     'object':    _('object'),\n61:     'exception': _('exception'),\n62:     'statement': _('statement'),\n63:     'builtin':   _('built-in function'),\n64: }\n65: \n66: \n67: class ObjectEntry(NamedTuple):\nCode replaced for brevity.\n71: \n72: \n73: \n74: class ModuleEntry(NamedTuple):\nCode replaced for brevity.\n79: \n80: \n81: \n82: def type_to_xref(text: str, env: BuildEnvironment = None) -> addnodes.pending_xref:\nCode replaced for brevity.\n106: \n107: \n108: \n109: def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Node]:\nCode replaced for brevity.\n181: \n182: \n183: \n184: def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\nCode replaced for brevity.\n231: \n232: \n233: \n234: def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\nCode replaced for brevity.\n279: \n280: \n281: \n282: # This override allows our inline type specifiers to behave like :class: link\n283: # when it comes to handling \".\" and \"~\" prefixes.\n284: class PyXrefMixin:\n285:     def make_xref(self, rolename: str, domain: str, target: str,\n286:                   innernode: Type[TextlikeNode] = nodes.emphasis,\n287:                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n288:         result = super().make_xref(rolename, domain, target,  # type: ignore\n289:                                    innernode, contnode, env)\n290:         result['refspecific'] = True\n291:         result['py:module'] = env.ref_context.get('py:module')\n292:         result['py:class'] = env.ref_context.get('py:class')\n293:         if target.startswith(('.', '~')):\n294:             prefix, result['reftarget'] = target[0], target[1:]\n295:             if prefix == '.':\n296:                 text = target[1:]\n297:             elif prefix == '~':\n298:                 text = target.split('.')[-1]\n299:             for node in result.traverse(nodes.Text):\n300:                 node.parent[node.parent.index(node)] = nodes.Text(text)\n301:                 break\n302:         return result\n303: \n304:     def make_xrefs(self, rolename: str, domain: str, target: str,\n305:                    innernode: Type[TextlikeNode] = nodes.emphasis,\n306:                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n307:         delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\.\\.\\.)'\n308:         delims_re = re.compile(delims)\n309:         sub_targets = re.split(delims, target)\n310: \n311:         split_contnode = bool(contnode and contnode.astext() == target)\n312: \n313:         results = []\n314:         for sub_target in filter(None, sub_targets):\n315:             if split_contnode:\n316:                 contnode = nodes.Text(sub_target)\n317: \n318:             if delims_re.match(sub_target):\n319:                 results.append(contnode or innernode(sub_target, sub_target))\n320:             else:\n321:                 results.append(self.make_xref(rolename, domain, sub_target,\n322:                                               innernode, contnode, env))\n323: \n324:         return results\n325: \n326: \n327: class PyField(PyXrefMixin, Field):\nCode replaced for brevity.\n335: \n336: \n337: \n338: class PyGroupedField(PyXrefMixin, GroupedField):\n339:     pass\n340: \n341: \n342: class PyTypedField(PyXrefMixin, TypedField):\nCode replaced for brevity.\n350: \n351: \n352: \n353: class PyObject(ObjectDescription[Tuple[str, str]]):\nCode replaced for brevity.\n572: \n573: \n574: \n575: class PyFunction(PyObject):\nCode replaced for brevity.\n609: \n610: \n611: \n612: class PyDecoratorFunction(PyFunction):\nCode replaced for brevity.\n626: \n627: \n628: \n629: class PyVariable(PyObject):\nCode replaced for brevity.\n657: \n658: \n659: \n660: class PyClasslike(PyObject):\nCode replaced for brevity.\n686: \n687: \n688: \n689: class PyMethod(PyObject):\nCode replaced for brevity.\n747: \n748: \n749: \n750: class PyClassMethod(PyMethod):\nCode replaced for brevity.\n759: \n760: \n761: \n762: class PyStaticMethod(PyMethod):\nCode replaced for brevity.\n771: \n772: \n773: \n774: class PyDecoratorMethod(PyMethod):\nCode replaced for brevity.\n787: \n788: \n789: \n790: class PyAttribute(PyObject):\nCode replaced for brevity.\n825: \n826: \n827: \n828: class PyProperty(PyObject):\nCode replaced for brevity.\n865: \n866: \n867: \n868: class PyDecoratorMixin:\nCode replaced for brevity.\n888: \n889: \n890: \n891: class PyModule(SphinxDirective):\nCode replaced for brevity.\n951: \n952: \n953: \n954: class PyCurrentModule(SphinxDirective):\nCode replaced for brevity.\n972: \n973: \n974: \n975: class PyXRefRole(XRefRole):\nCode replaced for brevity.\n995: \n996: \n997: \n998: def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\nCode replaced for brevity.\n1010: \n1011: \n1012: \n1013: class PythonModuleIndex(Index):\nCode replaced for brevity.\n1082: \n1083: \n1084: \n1085: class PythonDomain(Domain):\nCode replaced for brevity.\n1354: \n1355: \n1356: \n1357:                      node: pending_xref, contnode: Element) -> Element:\nCode replaced for brevity.\n1383: \n1384: \n1385: \n1386: def setup(app: Sphinx) -> Dict[str, Any]:\nCode replaced for brevity.\n1399: \n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/domains/python.py",
      "suspect_lines": [
        307
      ]
    }
  ]
}