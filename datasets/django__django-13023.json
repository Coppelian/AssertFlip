{
  "instance_id": "django__django-13023",
  "problem_statement": "DecimalField.to_python() raises TypeError on dict values.\nDescription\n\t\nA call to DecimalField.to_python() with a dictionary as the value parameter produces TypeError instead of ValidationError. This is a problem, for example, when you try to save a model object, and a decimal field got set to a dictionary by mistake. The TypeError exception that comes back makes it hard to track the problem to the field if the object has a lot of fields.\nI am proposing a patch to fix it:\n​https://github.com/django/django/pull/13023\n",
  "localized_code": "[start of django/db/models/fields/__init__.py]\n1: import collections.abc\n2: import copy\n3: import datetime\n4: import decimal\n5: import operator\n6: import uuid\n7: import warnings\n8: from base64 import b64decode, b64encode\n9: from functools import partialmethod, total_ordering\n10: \n11: from django import forms\n12: from django.apps import apps\n13: from django.conf import settings\n14: from django.core import checks, exceptions, validators\n15: from django.db import connection, connections, router\n16: from django.db.models.constants import LOOKUP_SEP\n17: from django.db.models.query_utils import DeferredAttribute, RegisterLookupMixin\n18: from django.utils import timezone\n19: from django.utils.datastructures import DictWrapper\n20: from django.utils.dateparse import (\n21:     parse_date, parse_datetime, parse_duration, parse_time,\n22: )\n23: from django.utils.duration import duration_microseconds, duration_string\n24: from django.utils.functional import Promise, cached_property\n25: from django.utils.ipv6 import clean_ipv6_address\n26: from django.utils.itercompat import is_iterable\n27: from django.utils.text import capfirst\n28: from django.utils.translation import gettext_lazy as _\n29: \n30: __all__ = [\n31:     'AutoField', 'BLANK_CHOICE_DASH', 'BigAutoField', 'BigIntegerField',\n32:     'BinaryField', 'BooleanField', 'CharField', 'CommaSeparatedIntegerField',\n33:     'DateField', 'DateTimeField', 'DecimalField', 'DurationField',\n34:     'EmailField', 'Empty', 'Field', 'FilePathField', 'FloatField',\n35:     'GenericIPAddressField', 'IPAddressField', 'IntegerField', 'NOT_PROVIDED',\n36:     'NullBooleanField', 'PositiveBigIntegerField', 'PositiveIntegerField',\n37:     'PositiveSmallIntegerField', 'SlugField', 'SmallAutoField',\n38:     'SmallIntegerField', 'TextField', 'TimeField', 'URLField', 'UUIDField',\n39: ]\n40: \n41: \n42: class Empty:\n43:     pass\n44: \n45: \n46: class NOT_PROVIDED:\n47:     pass\n48: \n49: \n50: # The values to use for \"blank\" in SelectFields. Will be appended to the start\n51: # of most \"choices\" lists.\n52: BLANK_CHOICE_DASH = [(\"\", \"---------\")]\n53: \n54: \n55: def _load_field(app_label, model_name, field_name):\nCode replaced for brevity.\n56: \n57: \n58: \n59: # A guide to Field parameters:\n60: #\n61: #   * name:      The name of the field specified in the model.\n62: #   * attname:   The attribute to use on the model object. This is the same as\n63: #                \"name\", except in the case of ForeignKeys, where \"_id\" is\n64: #                appended.\n65: #   * db_column: The db_column specified in the model (or None).\n66: #   * column:    The database column for this field. This is the same as\n67: #                \"attname\", except if db_column is specified.\n68: #\n69: # Code that introspects values, or does other dynamic things, should use\n70: # attname. For example, this gets the primary key value of object \"obj\":\n71: #\n72: #     getattr(obj, opts.pk.attname)\n73: \n74: def _empty(of_cls):\n75:     new = Empty()\n76:     new.__class__ = of_cls\n77:     return new\n78: \n79: \n80: def return_None():\n81:     return None\n82: \n83: \n84: @total_ordering\n85: class Field(RegisterLookupMixin):\nCode replaced for brevity.\n933: \n934: \n935: \n936: class BooleanField(Field):\nCode replaced for brevity.\n979: \n980: \n981: \n982:     descript\nCode replaced for brevity.\n1042: \n1043: \n1044: \n1045:     default_\nCode replaced for brevity.\n1058: \n1059: \n1060: \n1061:     def chec\nCode replaced for brevity.\n1090: \n1091: \n1092: \n1093:     empty_st\nCode replaced for brevity.\n1233: \n1234: \n1235: \n1236:     empty_strings_al\nCode replaced for brevity.\n1389: \n1390: \n1391: \n1392: class DecimalField(Field):\n1393:     empty_strings_allowed = False\n1394:     default_error_messages = {\n1395:         'invalid': _('“%(value)s” value must be a decimal number.'),\n1396:     }\n1397:     description = _(\"Decimal number\")\n1398: \n1399:     def __init__(self, verbose_name=None, name=None, max_digits=None,\n1400:                  decimal_places=None, **kwargs):\n1401:         self.max_digits, self.decimal_places = max_digits, decimal_places\n1402:         super().__init__(verbose_name, name, **kwargs)\n1403: \n1404:     def check(self, **kwargs):\n1405:         errors = super().check(**kwargs)\n1406: \n1407:         digits_errors = [\n1408:             *self._check_decimal_places(),\n1409:             *self._check_max_digits(),\n1410:         ]\n1411:         if not digits_errors:\n1412:             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n1413:         else:\n1414:             errors.extend(digits_errors)\n1415:         return errors\n1416: \n1417:     def _check_decimal_places(self):\n1418:         try:\n1419:             decimal_places = int(self.decimal_places)\n1420:             if decimal_places < 0:\n1421:                 raise ValueError()\n1422:         except TypeError:\n1423:             return [\n1424:                 checks.Error(\n1425:                     \"DecimalFields must define a 'decimal_places' attribute.\",\n1426:                     obj=self,\n1427:                     id='fields.E130',\n1428:                 )\n1429:             ]\n1430:         except ValueError:\n1431:             return [\n1432:                 checks.Error(\n1433:                     \"'decimal_places' must be a non-negative integer.\",\n1434:                     obj=self,\n1435:                     id='fields.E131',\n1436:                 )\n1437:             ]\n1438:         else:\n1439:             return []\n1440: \n1441:     def _check_max_digits(self):\n1442:         try:\n1443:             max_digits = int(self.max_digits)\n1444:             if max_digits <= 0:\n1445:                 raise ValueError()\n1446:         except TypeError:\n1447:             return [\n1448:                 checks.Error(\n1449:                     \"DecimalFields must define a 'max_digits' attribute.\",\n1450:                     obj=self,\n1451:                     id='fields.E132',\n1452:                 )\n1453:             ]\n1454:         except ValueError:\n1455:             return [\n1456:                 checks.Error(\n1457:                     \"'max_digits' must be a positive integer.\",\n1458:                     obj=self,\n1459:                     id='fields.E133',\n1460:                 )\n1461:             ]\n1462:         else:\n1463:             return []\n1464: \n1465:     def _check_decimal_places_and_max_digits(self, **kwargs):\n1466:         if int(self.decimal_places) > int(self.max_digits):\n1467:             return [\n1468:                 checks.Error(\n1469:                     \"'max_digits' must be greater or equal to 'decimal_places'.\",\n1470:                     obj=self,\n1471:                     id='fields.E134',\n1472:                 )\n1473:             ]\n1474:         return []\n1475: \n1476:     @cached_property\n1477:     def validators(self):\n1478:         return super().validators + [\n1479:             validators.DecimalValidator(self.max_digits, self.decimal_places)\n1480:         ]\n1481: \n1482:     @cached_property\n1483:     def context(self):\n1484:         return decimal.Context(prec=self.max_digits)\n1485: \n1486:     def deconstruct(self):\n1487:         name, path, args, kwargs = super().deconstruct()\n1488:         if self.max_digits is not None:\n1489:             kwargs['max_digits'] = self.max_digits\n1490:         if self.decimal_places is not None:\n1491:             kwargs['decimal_places'] = self.decimal_places\n1492:         return name, path, args, kwargs\n1493: \n1494:     def get_internal_type(self):\n1495:         return \"DecimalField\"\n1496: \n1497:     def to_python(self, value):\n1498:         if value is None:\n1499:             return value\n1500:         if isinstance(value, float):\n1501:             return self.context.create_decimal_from_float(value)\n1502:         try:\n1503:             return decimal.Decimal(value)\n1504:         except decimal.InvalidOperation:\n1505:             raise exceptions.ValidationError(\n1506:                 self.error_messages['invalid'],\n1507:                 code='invalid',\n1508:                 params={'value': value},\n1509:             )\n1510: \n1511:     def get_db_prep_save(self, value, connection):\n1512:         return connection.ops.adapt_decimalfield_value(self.to_python(value), self.max_digits, self.decimal_places)\n1513: \n1514:     def get_prep_value(self, value):\n1515:         value = super().get_prep_value(value)\n1516:         return self.to_python(value)\n1517: \n1518:     def formfield(self, **kwargs):\n1519:         return super().formfield(**{\n1520:             'max_digits': self.max_digits,\n1521:             'decimal_places': self.decimal_places,\n1522:             'form_class': forms.DecimalField,\n1523:             **kwargs,\n1524:         })\n1525: \n1526: \n1527:     Store timedelta objects.\nCode replaced for brevity.\n1584: \n1585: \n1586: \n1587: ault_validators = [validators.val\nCode replaced for brevity.\n1608: \n1609: \n1610: \n1611:     de\nCode replaced for brevity.\n1672: \n1673: \n1674: \n1675:     de\nCode replaced for brevity.\n1712: \n1713: \n1714: \n1715:     defaul\nCode replaced for brevity.\n1799: \n1800: \n1801: \n1802: cription = _(\"Big (8 byte) integer\")\nCode replaced for brevity.\n1814: \n1815: \n1816: \n1817:     descriptio\nCode replaced for brevity.\n1845: \n1846: \n1847: \n1848:     descriptio\nCode replaced for brevity.\n1925: \n1926: \n1927: \n1928:         'invalid'\nCode replaced for brevity.\n1955: \n1956: \n1957: \n1958:         \"\"\"\nCode replaced for brevity.\n1972: \n1973: \n1974: \n1975:     def get\nCode replaced for brevity.\n1985: \n1986: \n1987: \n1988:     def get_int\nCode replaced for brevity.\n1998: \n1999: \n2000: \n2001:     def g\nCode replaced for brevity.\n2011: \n2012: \n2013: \n2014: [validators.validate_slug]\nCode replaced for brevity.\n2044: \n2045: \n2046: \n2047:     def get_intern\nCode replaced for brevity.\n2051: \n2052: \n2053: \n2054: def get_internal_type(s\nCode replaced for brevity.\n2077: \n2078: \n2079: \n2080:     default_error_mess\nCode replaced for brevity.\n2209: \n2210: \n2211: \n2212:     descrip\nCode replaced for brevity.\n2232: \n2233: \n2234: \n2235:     empty_values = [None,\nCode replaced for brevity.\n2296: \n2297: \n2298: \n2299: 'invalid': _('“%(value)s”\nCode replaced for brevity.\n2349: \n2350: \n2351: \n2352: self, *args, **kwargs):\nCode replaced for brevity.\n2401: \n2402: \n2403: \n2404: kward inheritance compatibility\nCode replaced for brevity.\n2429: \n2430: \n2431: \n2432:     def\nCode replaced for brevity.\n2438: \n2439: \n2440: \n2441:         return 'BigAutoField'\nCode replaced for brevity.\n2447: \n2448: \n2449: \n2450:         return 'SmallAutoField'\nCode replaced for brevity.\n2456: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/__init__.py",
      "suspect_lines": [
        1504
      ]
    }
  ]
}