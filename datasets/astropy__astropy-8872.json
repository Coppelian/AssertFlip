{
  "instance_id": "astropy__astropy-8872",
  "problem_statement": "float16 quantities get upgraded to float64 automatically\nWhen trying to create a `Quantity` from a `np.float16` (not something I actually intended to do, I was experimenting while investigating other issue) it gets upgraded automatically to `np.float64`, which is something that does not happen with other float types:\r\n\r\n```\r\nIn [73]: np.float16(1)\r\nOut[73]: 1.0\r\n\r\nIn [74]: (np.float16(1) * u.km)\r\nOut[74]: <Quantity 1. km>\r\n\r\nIn [75]: (np.float16(1) * u.km).dtype\r\nOut[75]: dtype('float64')\r\n```\r\n\r\nHowever:\r\n\r\n```\r\nIn [76]: (np.float32(1) * u.km).dtype\r\nOut[76]: dtype('float32')\r\n\r\nIn [77]: (np.float64(1) * u.km).dtype\r\nOut[77]: dtype('float64')\r\n\r\nIn [78]: (np.float128(1) * u.km).dtype\r\nOut[78]: dtype('float128')\r\n\r\nIn [79]: (np.float(1) * u.km).dtype\r\nOut[79]: dtype('float64')\r\n\r\nIn [80]: (np.float_(1) * u.km).dtype\r\nOut[80]: dtype('float64')\r\n```\r\n\r\nSomewhat related: #6389\n",
  "localized_code": "[start of astropy/units/quantity.py]\n1: # -*- coding: utf-8 -*-\n2: # Licensed under a 3-clause BSD style license - see LICENSE.rst\n3: \"\"\"\n4: This module defines the `Quantity` object, which represents a number with some\n5: associated units. `Quantity` objects support operations like ordinary numbers,\n6: but will deal with unit conversions internally.\n7: \"\"\"\n8: \n9: \n10: # Standard library\n11: import re\n12: import numbers\n13: from fractions import Fraction\n14: import warnings\n15: \n16: import numpy as np\n17: \n18: # AstroPy\n19: from .core import (Unit, dimensionless_unscaled, get_current_unit_registry,\n20:                    UnitBase, UnitsError, UnitConversionError, UnitTypeError)\n21: from .utils import is_effectively_unity\n22: from .format.latex import Latex\n23: from astropy.utils.compat import NUMPY_LT_1_14, NUMPY_LT_1_16, NUMPY_LT_1_17\n24: from astropy.utils.compat.misc import override__dir__\n25: from astropy.utils.exceptions import AstropyDeprecationWarning, AstropyWarning\n26: from astropy.utils.misc import isiterable, InheritDocstrings\n27: from astropy.utils.data_info import ParentDtypeInfo\n28: from astropy import config as _config\n29: from .quantity_helper import (converters_and_unit, can_have_arbitrary_unit,\n30:                               check_output)\n31: \n32: __all__ = [\"Quantity\", \"SpecificTypeQuantity\",\n33:            \"QuantityInfoBase\", \"QuantityInfo\", \"allclose\", \"isclose\"]\n34: \n35: \n36: # We don't want to run doctests in the docstrings we inherit from Numpy\n37: __doctest_skip__ = ['Quantity.*']\n38: \n39: _UNIT_NOT_INITIALISED = \"(Unit not initialised)\"\n40: _UFUNCS_FILTER_WARNINGS = {np.arcsin, np.arccos, np.arccosh, np.arctanh}\n41: \n42: \n43: class Conf(_config.ConfigNamespace):\n44:     \"\"\"\n45:     Configuration parameters for Quantity\n46:     \"\"\"\n47:     latex_array_threshold = _config.ConfigItem(100,\n48:         'The maximum size an array Quantity can be before its LaTeX '\n49:         'representation for IPython gets \"summarized\" (meaning only the first '\n50:         'and last few elements are shown with \"...\" between). Setting this to a '\n51:         'negative number means that the value will instead be whatever numpy '\n52:         'gets from get_printoptions.')\n53: \n54: \n55: conf = Conf()\n56: \n57: \n58: class QuantityIterator:\nCode replaced for brevity.\n108: \n109: \n110: \n111:     # should not be considered a typical Quantity subclass by Table.\nCode replaced for brevity.\n134: \n135: \n136: \n137: class QuantityInfo(QuantityInfoBase):\nCode replaced for brevity.\n193: \n194: \n195: \n196: class Quantity(np.ndarray, metaclass=InheritDocstrings):\n197:     \"\"\"A `~astropy.units.Quantity` represents a number with some associated unit.\n198: \n199:     See also: http://docs.astropy.org/en/stable/units/quantity.html\n200: \n201:     Parameters\n202:     ----------\n203:     value : number, `~numpy.ndarray`, `Quantity` object (sequence), str\n204:         The numerical value of this quantity in the units given by unit.  If a\n205:         `Quantity` or sequence of them (or any other valid object with a\n206:         ``unit`` attribute), creates a new `Quantity` object, converting to\n207:         `unit` units as needed.  If a string, it is converted to a number or\n208:         `Quantity`, depending on whether a unit is present.\n209: \n210:     unit : `~astropy.units.UnitBase` instance, str\n211:         An object that represents the unit associated with the input value.\n212:         Must be an `~astropy.units.UnitBase` object or a string parseable by\n213:         the :mod:`~astropy.units` package.\n214: \n215:     dtype : ~numpy.dtype, optional\n216:         The dtype of the resulting Numpy array or scalar that will\n217:         hold the value.  If not provided, it is determined from the input,\n218:         except that any input that cannot represent float (integer and bool)\n219:         is converted to float.\n220: \n221:     copy : bool, optional\n222:         If `True` (default), then the value is copied.  Otherwise, a copy will\n223:         only be made if ``__array__`` returns a copy, if value is a nested\n224:         sequence, or if a copy is needed to satisfy an explicitly given\n225:         ``dtype``.  (The `False` option is intended mostly for internal use,\n226:         to speed up initialization where a copy is known to have been made.\n227:         Use with care.)\n228: \n229:     order : {'C', 'F', 'A'}, optional\n230:         Specify the order of the array.  As in `~numpy.array`.  This parameter\n231:         is ignored if the input is a `Quantity` and ``copy=False``.\n232: \n233:     subok : bool, optional\n234:         If `False` (default), the returned array will be forced to be a\n235:         `Quantity`.  Otherwise, `Quantity` subclasses will be passed through,\n236:         or a subclass appropriate for the unit will be used (such as\n237:         `~astropy.units.Dex` for ``u.dex(u.AA)``).\n238: \n239:     ndmin : int, optional\n240:         Specifies the minimum number of dimensions that the resulting array\n241:         should have.  Ones will be pre-pended to the shape as needed to meet\n242:         this requirement.  This parameter is ignored if the input is a\n243:         `Quantity` and ``copy=False``.\n244: \n245:     Raises\n246:     ------\n247:     TypeError\n248:         If the value provided is not a Python numeric type.\n249:     TypeError\n250:         If the unit provided is not either a :class:`~astropy.units.Unit`\n251:         object or a parseable string unit.\n252: \n253:     Notes\n254:     -----\n255:     Quantities can also be created by multiplying a number or array with a\n256:     :class:`~astropy.units.Unit`. See http://docs.astropy.org/en/latest/units/\n257: \n258:     \"\"\"\n259:     # Need to set a class-level default for _equivalencies, or\n260:     # Constants can not initialize properly\n261:     _equivalencies = []\n262: \n263:     # Default unit for initialization; can be overridden by subclasses,\n264:     # possibly to `None` to indicate there is no default unit.\n265:     _default_unit = dimensionless_unscaled\n266: \n267:     # Ensures views have an undefined unit.\n268:     _unit = None\n269: \n270:     __array_priority__ = 10000\n271: \n272:     def __new__(cls, value, unit=None, dtype=None, copy=True, order=None,\n273:                 subok=False, ndmin=0):\n274: \n275:         if unit is not None:\n276:             # convert unit first, to avoid multiple string->unit conversions\n277:             unit = Unit(unit)\n278:             # if we allow subclasses, allow a class from the unit.\n279:             if subok:\n280:                 qcls = getattr(unit, '_quantity_class', cls)\n281:                 if issubclass(qcls, cls):\n282:                     cls = qcls\n283: \n284:         # optimize speed for Quantity with no dtype given, copy=False\n285:         if isinstance(value, Quantity):\n286:             if unit is not None and unit is not value.unit:\n287:                 value = value.to(unit)\n288:                 # the above already makes a copy (with float dtype)\n289:                 copy = False\n290: \n291:             if type(value) is not cls and not (subok and\n292:                                                isinstance(value, cls)):\n293:                 value = value.view(cls)\n294: \n295:             if dtype is None:\n296:                 if not copy:\n297:                     return value\n298: \n299:                 if not (np.can_cast(np.float32, value.dtype) or\n300:                         value.dtype.fields):\n301:                     dtype = float\n302: \n303:             return np.array(value, dtype=dtype, copy=copy, order=order,\n304:                             subok=True, ndmin=ndmin)\n305: \n306:         # Maybe str, or list/tuple of Quantity? If so, this may set value_unit.\n307:         # To ensure array remains fast, we short-circuit it.\n308:         value_unit = None\n309:         if not isinstance(value, np.ndarray):\n310:             if isinstance(value, str):\n311:                 # The first part of the regex string matches any integer/float;\n312:                 # the second parts adds possible trailing .+-, which will break\n313:                 # the float function below and ensure things like 1.2.3deg\n314:                 # will not work.\n315:                 pattern = (r'\\s*[+-]?'\n316:                            r'((\\d+\\.?\\d*)|(\\.\\d+)|([nN][aA][nN])|'\n317:                            r'([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))'\n318:                            r'([eE][+-]?\\d+)?'\n319:                            r'[.+-]?')\n320: \n321:                 v = re.match(pattern, value)\n322:                 unit_string = None\n323:                 try:\n324:                     value = float(v.group())\n325: \n326:                 except Exception:\n327:                     raise TypeError('Cannot parse \"{0}\" as a {1}. It does not '\n328:                                     'start with a number.'\n329:                                     .format(value, cls.__name__))\n330: \n331:                 unit_string = v.string[v.end():].strip()\n332:                 if unit_string:\n333:                     value_unit = Unit(unit_string)\n334:                     if unit is None:\n335:                         unit = value_unit  # signal no conversion needed below.\n336: \n337:             elif (isiterable(value) and len(value) > 0 and\n338:                   all(isinstance(v, Quantity) for v in value)):\n339:                 # Convert all quantities to the same unit.\n340:                 if unit is None:\n341:                     unit = value[0].unit\n342:                 value = [q.to_value(unit) for q in value]\n343:                 value_unit = unit  # signal below that conversion has been done\n344: \n345:         if value_unit is None:\n346:             # If the value has a `unit` attribute and if not None\n347:             # (for Columns with uninitialized unit), treat it like a quantity.\n348:             value_unit = getattr(value, 'unit', None)\n349:             if value_unit is None:\n350:                 # Default to dimensionless for no (initialized) unit attribute.\n351:                 if unit is None:\n352:                     unit = cls._default_unit\n353:                 value_unit = unit  # signal below that no conversion is needed\n354:             else:\n355:                 try:\n356:                     value_unit = Unit(value_unit)\n357:                 except Exception as exc:\n358:                     raise TypeError(\"The unit attribute {0!r} of the input could \"\n359:                                     \"not be parsed as an astropy Unit, raising \"\n360:                                     \"the following exception:\\n{1}\"\n361:                                     .format(value.unit, exc))\n362: \n363:                 if unit is None:\n364:                     unit = value_unit\n365:                 elif unit is not value_unit:\n366:                     copy = False  # copy will be made in conversion at end\n367: \n368:         value = np.array(value, dtype=dtype, copy=copy, order=order,\n369:                          subok=False, ndmin=ndmin)\n370: \n371:         # check that array contains numbers or long int objects\n372:         if (value.dtype.kind in 'OSU' and\n373:             not (value.dtype.kind == 'O' and\n374:                  isinstance(value.item(() if value.ndim == 0 else 0),\n375:                             numbers.Number))):\n376:             raise TypeError(\"The value must be a valid Python or \"\n377:                             \"Numpy numeric type.\")\n378: \n379:         # by default, cast any integer, boolean, etc., to float\n380:         if dtype is None and (not (np.can_cast(np.float32, value.dtype)\n381:                                    or value.dtype.fields)\n382:                               or value.dtype.kind == 'O'):\n383:             value = value.astype(float)\n384: \n385:         value = value.view(cls)\n386:         value._set_unit(value_unit)\n387:         if unit is value_unit:\n388:             return value\n389:         else:\n390:             # here we had non-Quantity input that had a \"unit\" attribute\n391:             # with a unit different from the desired one.  So, convert.\n392:             return value.to(unit)\n393: \n394:     def __array_finalize__(self, obj):\n395:         # If we're a new object or viewing an ndarray, nothing has to be done.\n396:         if obj is None or obj.__class__ is np.ndarray:\n397:             return\n398: \n399:         # If our unit is not set and obj has a valid one, use it.\n400:         if self._unit is None:\n401:             unit = getattr(obj, '_unit', None)\n402:             if unit is not None:\n403:                 self._set_unit(unit)\n404: \n405:         # Copy info if the original had `info` defined.  Because of the way the\n406:         # DataInfo works, `'info' in obj.__dict__` is False until the\n407:         # `info` attribute is accessed or set.\n408:         if 'info' in obj.__dict__:\n409:             self.info = obj.info\n410: \n411:     def __array_wrap__(self, obj, context=None):\n412: \n413:         if context is None:\n414:             # Methods like .squeeze() created a new `ndarray` and then call\n415:             # __array_wrap__ to turn the array into self's subclass.\n416:             return self._new_view(obj)\n417: \n418:         raise NotImplementedError('__array_wrap__ should not be used '\n419:                                   'with a context any more, since we require '\n420:                                   'numpy >=1.13.  Please raise an issue on '\n421:                                   'https://github.com/astropy/astropy')\n422: \n423:     def __array_ufunc__(self, function, method, *inputs, **kwargs):\n424:         \"\"\"Wrap numpy ufuncs, taking care of units.\n425: \n426:         Parameters\n427:         ----------\n428:         function : callable\n429:             ufunc to wrap.\n430:         method : str\n431:             Ufunc method: ``__call__``, ``at``, ``reduce``, etc.\n432:         inputs : tuple\n433:             Input arrays.\n434:         kwargs : keyword arguments\n435:             As passed on, with ``out`` containing possible quantity output.\n436: \n437:         Returns\n438:         -------\n439:         result : `~astropy.units.Quantity`\n440:             Results of the ufunc, with the unit set properly.\n441:         \"\"\"\n442:         # Determine required conversion functions -- to bring the unit of the\n443:         # input to that expected (e.g., radian for np.sin), or to get\n444:         # consistent units between two inputs (e.g., in np.add) --\n445:         # and the unit of the result (or tuple of units for nout > 1).\n446:         converters, unit = converters_and_unit(function, method, *inputs)\n447: \n448:         out = kwargs.get('out', None)\n449:         # Avoid loop back by turning any Quantity output into array views.\n450:         if out is not None:\n451:             # If pre-allocated output is used, check it is suitable.\n452:             # This also returns array view, to ensure we don't loop back.\n453:             if function.nout == 1:\n454:                 out = out[0]\n455:             out_array = check_output(out, unit, inputs, function=function)\n456:             # Ensure output argument remains a tuple.\n457:             kwargs['out'] = (out_array,) if function.nout == 1 else out_array\n458: \n459:         # Same for inputs, but here also convert if necessary.\n460:         arrays = []\n461:         for input_, converter in zip(inputs, converters):\n462:             input_ = getattr(input_, 'value', input_)\n463:             arrays.append(converter(input_) if converter else input_)\n464: \n465:         # Call our superclass's __array_ufunc__\n466:         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n467:         # If unit is None, a plain array is expected (e.g., comparisons), which\n468:         # means we're done.\n469:         # We're also done if the result was None (for method 'at') or\n470:         # NotImplemented, which can happen if other inputs/outputs override\n471:         # __array_ufunc__; hopefully, they can then deal with us.\n472:         if unit is None or result is None or result is NotImplemented:\n473:             return result\n474: \n475:         return self._result_as_quantity(result, unit, out)\n476: \n477:     def _result_as_quantity(self, result, unit, out):\n478:         \"\"\"Turn result into a quantity with the given unit.\n479: \n480:         If no output is given, it will take a view of the array as a quantity,\n481:         and set the unit.  If output is given, those should be quantity views\n482:         of the result arrays, and the function will just set the unit.\n483: \n484:         Parameters\n485:         ----------\n486:         result : `~numpy.ndarray` or tuple of `~numpy.ndarray`\n487:             Array(s) which need to be turned into quantity.\n488:         unit : `~astropy.units.Unit`\n489:             Unit for the quantities to be returned (or `None` if the result\n490:             should not be a quantity).  Should be tuple if result is a tuple.\n491:         out : `~astropy.units.Quantity` or None\n492:             Possible output quantity. Should be `None` or a tuple if result\n493:             is a tuple.\n494: \n495:         Returns\n496:         -------\n497:         out : `~astropy.units.Quantity`\n498:            With units set.\n499:         \"\"\"\n500:         if isinstance(result, tuple):\n501:             if out is None:\n502:                 out = (None,) * len(result)\n503:             return tuple(self._result_as_quantity(result_, unit_, out_)\n504:                          for (result_, unit_, out_) in\n505:                          zip(result, unit, out))\n506: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/astropy/units/quantity.py",
      "suspect_lines": [
        218,
        219,
        299,
        300,
        380,
        381,
        382
      ]
    }
  ]
}