{
  "instance_id": "django__django-11790",
  "problem_statement": "AuthenticationForm's username field doesn't set maxlength HTML attribute.\nDescription\n\t\nAuthenticationForm's username field doesn't render with maxlength HTML attribute anymore.\nRegression introduced in #27515 and 5ceaf14686ce626404afb6a5fbd3d8286410bf13.\n​https://groups.google.com/forum/?utm_source=digest&utm_medium=email#!topic/django-developers/qnfSqro0DlA\n​https://forum.djangoproject.com/t/possible-authenticationform-max-length-regression-in-django-2-1/241\n",
  "localized_code": "[start of django/contrib/auth/forms.py]\n1: import unicodedata\n2: \n3: from django import forms\n4: from django.contrib.auth import (\n5:     authenticate, get_user_model, password_validation,\n6: )\n7: from django.contrib.auth.hashers import (\n8:     UNUSABLE_PASSWORD_PREFIX, identify_hasher,\n9: )\n10: from django.contrib.auth.models import User\n11: from django.contrib.auth.tokens import default_token_generator\n12: from django.contrib.sites.shortcuts import get_current_site\n13: from django.core.mail import EmailMultiAlternatives\n14: from django.template import loader\n15: from django.utils.encoding import force_bytes\n16: from django.utils.http import urlsafe_base64_encode\n17: from django.utils.text import capfirst\n18: from django.utils.translation import gettext, gettext_lazy as _\n19: \n20: UserModel = get_user_model()\n21: \n22: \n23: class ReadOnlyPasswordHashWidget(forms.Widget):\n24:     template_name = 'auth/widgets/read_only_password_hash.html'\n25:     read_only = True\n26: \n27:     def get_context(self, name, value, attrs):\n28:         context = super().get_context(name, value, attrs)\n29:         summary = []\n30:         if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n31:             summary.append({'label': gettext(\"No password set.\")})\n32:         else:\n33:             try:\n34:                 hasher = identify_hasher(value)\n35:             except ValueError:\n36:                 summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n37:             else:\n38:                 for key, value_ in hasher.safe_summary(value).items():\n39:                     summary.append({'label': gettext(key), 'value': value_})\n40:         context['summary'] = summary\n41:         return context\n42: \n43: \n44: class ReadOnlyPasswordHashField(forms.Field):\n45:     widget = ReadOnlyPasswordHashWidget\n46: \n47:     def __init__(self, *args, **kwargs):\n48:         kwargs.setdefault(\"required\", False)\n49:         super().__init__(*args, **kwargs)\n50: \n51:     def bound_data(self, data, initial):\n52:         # Always return initial because the widget doesn't\n53:         # render an input field.\n54:         return initial\n55: \n56:     def has_changed(self, initial, data):\n57:         return False\n58: \n59: \n60: class UsernameField(forms.CharField):\nCode replaced for brevity.\n69: \n70: \n71: \n72: class UserCreationForm(forms.ModelForm):\nCode replaced for brevity.\n129: \n130: \n131: \n132:     pa\nCode replaced for brevity.\n160: \n161: \n162: \n163: class AuthenticationForm(forms.Form):\n164:     \"\"\"\n165:     Base class for authenticating users. Extend this to get a form that accepts\n166:     username/password logins.\n167:     \"\"\"\n168:     username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))\n169:     password = forms.CharField(\n170:         label=_(\"Password\"),\n171:         strip=False,\n172:         widget=forms.PasswordInput(attrs={'autocomplete': 'current-password'}),\n173:     )\n174: \n175:     error_messages = {\n176:         'invalid_login': _(\n177:             \"Please enter a correct %(username)s and password. Note that both \"\n178:             \"fields may be case-sensitive.\"\n179:         ),\n180:         'inactive': _(\"This account is inactive.\"),\n181:     }\n182: \n183:     def __init__(self, request=None, *args, **kwargs):\n184:         \"\"\"\n185:         The 'request' parameter is set for custom auth use by subclasses.\n186:         The form data comes in via the standard 'data' kwarg.\n187:         \"\"\"\n188:         self.request = request\n189:         self.user_cache = None\n190:         super().__init__(*args, **kwargs)\n191: \n192:         # Set the max length and label for the \"username\" field.\n193:         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n194:         self.fields['username'].max_length = self.username_field.max_length or 254\n195:         if self.fields['username'].label is None:\n196:             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n197: \n198:     def clean(self):\n199:         username = self.cleaned_data.get('username')\n200:         password = self.cleaned_data.get('password')\n201: \n202:         if username is not None and password:\n203:             self.user_cache = authenticate(self.request, username=username, password=password)\n204:             if self.user_cache is None:\n205:                 raise self.get_invalid_login_error()\n206:             else:\n207:                 self.confirm_login_allowed(self.user_cache)\n208: \n209:         return self.cleaned_data\n210: \n211:     def confirm_login_allowed(self, user):\n212:         \"\"\"\n213:         Controls whether the given User may log in. This is a policy setting,\n214:         independent of end-user authentication. This default behavior is to\n215:         allow login by active users, and reject login by inactive users.\n216: \n217:         If the given user cannot log in, this method should raise a\n218:         ``forms.ValidationError``.\n219: \n220:         If the given user may log in, this method should return None.\n221:         \"\"\"\n222:         if not user.is_active:\n223:             raise forms.ValidationError(\n224:                 self.error_messages['inactive'],\n225:                 code='inactive',\n226:             )\n227: \n228:     def get_user(self):\n229:         return self.user_cache\n230: \n231:     def get_invalid_login_error(self):\n232:         return forms.ValidationError(\n233:             self.error_messages['invalid_login'],\n234:             code='invalid_login',\n235:             params={'username': self.username_field.verbose_name},\n236:         )\n237: \n238: \n239:     emai\nCode replaced for brevity.\n307: \n308: \n309: \n310:     \"\"\"\nCode replaced for brevity.\n351: \n352: \n353: \n354:     \"\"\"\nCode replaced for brevity.\n381: \n382: \n383: \n384:     \"\"\"\nCode replaced for brevity.\n435: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/auth/forms.py",
      "suspect_lines": [
        194
      ]
    }
  ]
}