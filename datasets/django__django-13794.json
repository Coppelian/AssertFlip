{
  "instance_id": "django__django-13794",
  "problem_statement": "add filter is unable to concatenate strings with lazy string\nDescription\n\t\nIf you try to concatenate a string with a lazy string with the add template filter, the result is always the empty string because the add filter generates an exception (TypeError: can only concatenate str (not \"__proxy__\") to str).\n",
  "localized_code": "[start of django/utils/functional.py]\n1: import copy\n2: import itertools\n3: import operator\n4: from functools import total_ordering, wraps\n5: \n6: \n7: class cached_property:\n8:     \"\"\"\n9:     Decorator that converts a method with a single self argument into a\n10:     property cached on the instance.\n11: \n12:     A cached property can be made out of an existing method:\n13:     (e.g. ``url = cached_property(get_absolute_url)``).\n14:     The optional ``name`` argument is obsolete as of Python 3.6 and will be\n15:     deprecated in Django 4.0 (#30127).\n16:     \"\"\"\n17:     name = None\n18: \n19:     @staticmethod\n20:     def func(instance):\n21:         raise TypeError(\n22:             'Cannot use cached_property instance without calling '\n23:             '__set_name__() on it.'\n24:         )\n25: \n26:     def __init__(self, func, name=None):\n27:         self.real_func = func\n28:         self.__doc__ = getattr(func, '__doc__')\n29: \n30:     def __set_name__(self, owner, name):\n31:         if self.name is None:\n32:             self.name = name\n33:             self.func = self.real_func\n34:         elif name != self.name:\n35:             raise TypeError(\n36:                 \"Cannot assign the same cached_property to two different names \"\n37:                 \"(%r and %r).\" % (self.name, name)\n38:             )\n39: \n40:     def __get__(self, instance, cls=None):\n41:         \"\"\"\n42:         Call the function and put the return value in instance.__dict__ so that\n43:         subsequent attribute access on the instance returns the cached value\n44:         instead of calling cached_property.__get__().\n45:         \"\"\"\n46:         if instance is None:\n47:             return self\n48:         res = instance.__dict__[self.name] = self.func(instance)\n49:         return res\n50: \n51: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/functional.py",
      "suspect_lines": []
    }
  ]
}