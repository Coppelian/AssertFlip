{
  "instance_id": "sphinx-doc__sphinx-8593",
  "problem_statement": "autodoc: `:meta public:` does not effect to variables\n**Describe the bug**\r\nautodoc: `:meta public:` does not effect to variables.\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# example.py\r\n_foo = None  #: :meta public:\r\n```\r\n```\r\n# index.rst\r\n.. automodule:: example\r\n   :members:\r\n```\r\n\r\nI expect `_foo` is shown on the built document, but not shown.\r\n\r\n**Expected behavior**\r\n`_foo` should be shown on the built document.\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.1\r\n- Sphinx version: HEAD of 3.x\r\n- Sphinx extensions: sphinx.ext.autodoc\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\r\n\n",
  "localized_code": "[start of sphinx/ext/autodoc/__init__.py]\n1: \"\"\"\n2:     sphinx.ext.autodoc\n3:     ~~~~~~~~~~~~~~~~~~\n4: \n5:     Automatically insert docstrings for functions, classes or whole modules into\n6:     the doctree, thus avoiding duplication between docstrings and documentation\n7:     for those who like elaborate docstrings.\n8: \n9:     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10:     :license: BSD, see LICENSE for details.\n11: \"\"\"\n12: \n13: import re\n14: import warnings\n15: from inspect import Parameter, Signature\n16: from types import ModuleType\n17: from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,\n18:                     TypeVar, Union)\n19: \n20: from docutils.statemachine import StringList\n21: \n22: import sphinx\n23: from sphinx.application import Sphinx\n24: from sphinx.config import ENUM, Config\n25: from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,\n26:                                 RemovedInSphinx60Warning)\n27: from sphinx.environment import BuildEnvironment\n28: from sphinx.ext.autodoc.importer import (ClassAttribute, get_class_members, get_module_members,\n29:                                          get_object_members, import_module, import_object)\n30: from sphinx.ext.autodoc.mock import mock\n31: from sphinx.locale import _, __\n32: from sphinx.pycode import ModuleAnalyzer, PycodeError\n33: from sphinx.util import inspect, logging\n34: from sphinx.util.docstrings import extract_metadata, prepare_docstring\n35: from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n36:                                  stringify_signature)\n37: from sphinx.util.typing import get_type_hints, restify\n38: from sphinx.util.typing import stringify as stringify_typehint\n39: \n40: if False:\n41:     # For type annotation\n42:     from typing import Type  # NOQA # for python3.5.1\n43: \n44:     from sphinx.ext.autodoc.directive import DocumenterBridge\n45: \n46: \n47: logger = logging.getLogger(__name__)\n48: \n49: \n50: # This type isn't exposed directly in any modules, but can be found\n51: # here in most Python versions\n52: MethodDescriptorType = type(type.__subclasses__)\n53: \n54: \n55: #: extended signature RE: with explicit module name separated by ::\n56: py_ext_sig_re = re.compile(\n57:     r'''^ ([\\w.]+::)?            # explicit module name\n58:           ([\\w.]+\\.)?            # module and/or class name(s)\n59:           (\\w+)  \\s*             # thing name\n60:           (?: \\((.*)\\)           # optional: arguments\n61:            (?:\\s* -> \\s* (.*))?  #           return annotation\n62:           )? $                   # and nothing more\n63:           ''', re.VERBOSE)\n64: special_member_re = re.compile(r'^__\\S+__$')\n65: \n66: \n67: def identity(x: Any) -> Any:\n68:     return x\n69: \n70: \n71: class _All:\nCode replaced for brevity.\n75: \n76: \n77: \n78: class _Empty:\nCode replaced for brevity.\n82: \n83: \n84: \n85: ALL = _All()\n86: EMPTY = _Empty()\n87: UNINITIALIZED_ATTR = object()\n88: INSTANCEATTR = object()\n89: SLOTSATTR = object()\n90: \n91: \n92: def members_option(arg: Any) -> Union[object, List[str]]:\nCode replaced for brevity.\n99: \n100: \n101: \n102: def members_set_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n108: \n109: \n110: \n111: def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n115: \n116: \n117: \n118: def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\nCode replaced for brevity.\n123: \n124: \n125: \n126: def member_order_option(arg: Any) -> Optional[str]:\nCode replaced for brevity.\n133: \n134: \n135: \n136: SUPPRESS = object()\n137: \n138: \n139: def annotation_option(arg: Any) -> Any:\nCode replaced for brevity.\n144: \n145: \n146: \n147: def bool_option(arg: Any) -> bool:\nCode replaced for brevity.\n151: \n152: \n153: \n154: def merge_special_members_option(options: Dict) -> None:\nCode replaced for brevity.\n166: \n167: \n168: \n169: def merge_members_option(options: Dict) -> None:\nCode replaced for brevity.\n180: \n181: \n182: \n183: # Some useful event listener factories for autodoc-process-docstring.\n184: \n185: def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\nCode replaced for brevity.\n210: \n211: \n212: \n213:             exclude: bool = False) -> Callable:\nCode replaced for brevity.\n246: \n247: \n248: \n249: # This class is used only in ``sphinx.ext.autodoc.directive``,\n250: # But we define this class here to keep compatibility (see #4538)\n251: class Options(dict):\nCode replaced for brevity.\n257: \n258: \n259: \n260: class ObjectMember(tuple):\nCode replaced for brevity.\n283: \n284: \n285: \n286: ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n287: \n288: \n289: class Documenter:\nCode replaced for brevity.\n968: \n969: \n970: \n971: class ModuleDocumenter(Documenter):\n972:     \"\"\"\n973:     Specialized Documenter subclass for modules.\n974:     \"\"\"\n975:     objtype = 'module'\n976:     content_indent = ''\n977:     titles_allowed = True\n978: \n979:     option_spec = {\n980:         'members': members_option, 'undoc-members': bool_option,\n981:         'noindex': bool_option, 'inherited-members': inherited_members_option,\n982:         'show-inheritance': bool_option, 'synopsis': identity,\n983:         'platform': identity, 'deprecated': bool_option,\n984:         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n985:         'private-members': members_option, 'special-members': members_option,\n986:         'imported-members': bool_option, 'ignore-module-all': bool_option\n987:     }  # type: Dict[str, Callable]\n988: \n989:     def __init__(self, *args: Any) -> None:\n990:         super().__init__(*args)\n991:         merge_members_option(self.options)\n992:         self.__all__ = None  # type: Optional[Sequence[str]]\n993: \n994:     @classmethod\n995:     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n996:                             ) -> bool:\n997:         # don't document submodules automatically\n998:         return False\n999: \n1000:     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1001:                      ) -> Tuple[str, List[str]]:\n1002:         if modname is not None:\n1003:             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n1004:                            type='autodoc')\n1005:         return (path or '') + base, []\n1006: \n1007:     def parse_name(self) -> bool:\n1008:         ret = super().parse_name()\n1009:         if self.args or self.retann:\n1010:             logger.warning(__('signature arguments or return annotation '\n1011:                               'given for automodule %s') % self.fullname,\n1012:                            type='autodoc')\n1013:         return ret\n1014: \n1015:     def import_object(self, raiseerror: bool = False) -> bool:\n1016:         ret = super().import_object(raiseerror)\n1017: \n1018:         try:\n1019:             if not self.options.ignore_module_all:\n1020:                 self.__all__ = inspect.getall(self.object)\n1021:         except AttributeError as exc:\n1022:             # __all__ raises an error.\n1023:             logger.warning(__('%s.__all__ raises an error. Ignored: %r'),\n1024:                            (self.fullname, exc), type='autodoc')\n1025:         except ValueError as exc:\n1026:             # invalid __all__ found.\n1027:             logger.warning(__('__all__ should be a list of strings, not %r '\n1028:                               '(in module %s) -- ignoring __all__') %\n1029:                            (exc.args[0], self.fullname), type='autodoc')\n1030: \n1031:         return ret\n1032: \n1033:     def add_directive_header(self, sig: str) -> None:\n1034:         Documenter.add_directive_header(self, sig)\n1035: \n1036:         sourcename = self.get_sourcename()\n1037: \n1038:         # add some module-specific options\n1039:         if self.options.synopsis:\n1040:             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n1041:         if self.options.platform:\n1042:             self.add_line('   :platform: ' + self.options.platform, sourcename)\n1043:         if self.options.deprecated:\n1044:             self.add_line('   :deprecated:', sourcename)\n1045: \n1046:     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1047:         if want_all:\n1048:             members = get_module_members(self.object)\n1049:             if not self.__all__:\n1050:                 # for implicit module members, check __module__ to avoid\n1051:                 # documenting imported objects\n1052:                 return True, members\n1053:             else:\n1054:                 ret = []\n1055:                 for name, value in members:\n1056:                     if name in self.__all__:\n1057:                         ret.append(ObjectMember(name, value))\n1058:                     else:\n1059:                         ret.append(ObjectMember(name, value, skipped=True))\n1060: \n1061:                 return False, ret\n1062:         else:\n1063:             memberlist = self.options.members or []\n1064:             ret = []\n1065:             for name in memberlist:\n1066:                 try:\n1067:                     value = safe_getattr(self.object, name)\n1068:                     ret.append(ObjectMember(name, value))\n1069:                 except AttributeError:\n1070:                     logger.warning(__('missing attribute mentioned in :members: option: '\n1071:                                       'module %s, attribute %s') %\n1072:                                    (safe_getattr(self.object, '__name__', '???'), name),\n1073:                                    type='autodoc')\n1074:             return False, ret\n1075: \n1076:     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1077:                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1078:         if order == 'bysource' and self.__all__:\n1079:             # Sort alphabetically first (for members not listed on the __all__)\n1080:             documenters.sort(key=lambda e: e[0].name)\n1081: \n1082:             # Sort by __all__\n1083:             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1084:                 name = entry[0].name.split('::')[1]\n1085:                 if name in self.__all__:\n1086:                     return self.__all__.index(name)\n1087:                 else:\n1088:                     return len(self.__all__)\n1089:             documenters.sort(key=keyfunc)\n1090: \n1091:             return documenters\n1092:         else:\n1093:             return super().sort_members(documenters, order)\n1094: \n1095: \n1096: class ModuleLevelDocumenter(Documenter):\nCode replaced for brevity.\n1114: \n1115: \n1116: \n1117: class ClassLevelDocumenter(Documenter):\nCode replaced for brevity.\n1147: \n1148: \n1149: \n1150: class DocstringSignatureMixin:\nCode replaced for brevity.\n1242: \n1243: \n1244: \n1245: class DocstringStripSignatureMixin(DocstringSignatureMixin):\nCode replaced for brevity.\n1260: \n1261: \n1262: \n1263: class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n1363: \n1364: \n1365: \n1366: class DecoratorDocumenter(FunctionDocumenter):\nCode replaced for brevity.\n1380: \n1381: \n1382: \n1383: # Types which have confusing metaclass signatures it would be best not to show.\n1384: # These are listed by name, rather than storing the objects themselves, to avoid\n1385: # needing to import the modules.\n1386: _METACLASS_CALL_BLACKLIST = [\n1387:     'enum.EnumMeta.__call__',\n1388: ]\n1389: \n1390: \n1391: # Types whose __new__ signature is a pass-thru.\n1392: _CLASS_NEW_BLACKLIST = [\n1393:     'typing.Generic.__new__',\n1394: ]\n1395: \n1396: \n1397: class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n1693: \n1694: \n1695: \n1696: class ExceptionDocumenter(ClassDocumenter):\nCode replaced for brevity.\n1709: \n1710: \n1711: \n1712:     # define types of instance variables\nCode replaced for brevity.\n1731: \n1732: \n1733: \n1734: class GenericAliasMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1750: \n1751: \n1752: \n1753: class NewTypeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1769: \n1770: \n1771: \n1772: class TypeVarMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1809: \n1810: \n1811: \n1812: class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n1850: \n1851: \n1852: \n1853:                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\nCode replaced for brevity.\n1928: \n1929: \n1930: \n1931: class NewTypeDataDocumenter(DataDocumenter):\nCode replaced for brevity.\n1946: \n1947: \n1948: \n1949: class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n2094: \n2095: \n2096: \n2097: class NonDataDescriptorMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2116: \n2117: \n2118: \n2119: class SlotsMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2163: \n2164: \n2165: \n2166: class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2216: \n2217: \n2218: \n2219: class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\nCode replaced for brevity.\n2265: \n2266: \n2267: \n2268:                           DocstringStripSignatureMixin, ClassLevelDocumenter):\nCode replaced for brevity.\n2428: \n2429: \n2430: \n2431: class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\nCode replaced for brevity.\n2459: \n2460: \n2461: \n2462: class NewTypeAttributeDocumenter(AttributeDocumenter):\nCode replaced for brevity.\n2477: \n2478: \n2479: \n2480: def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\nCode replaced for brevity.\n2483: \n2484: \n2485: \n2486: def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\nCode replaced for brevity.\n2492: \n2493: \n2494: \n2495: def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\nCode replaced for brevity.\n2500: \n2501: \n2502: \n2503: # for compatibility\n2504: from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2505: from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2506: from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2507: from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2508: from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2509: from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2510: from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2511: \n2512: \n2513: def setup(app: Sphinx) -> Dict[str, Any]:\nCode replaced for brevity.\n2547: \n\n[start of sphinx/ext/autodoc/importer.py]\n1: \"\"\"\n2:     sphinx.ext.autodoc.importer\n3:     ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4: \n5:     Importer utilities for autodoc\n6: \n7:     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8:     :license: BSD, see LICENSE for details.\n9: \"\"\"\n10: \n11: import importlib\n12: import traceback\n13: import warnings\n14: from typing import Any, Callable, Dict, List, Mapping, NamedTuple, Optional, Tuple\n15: \n16: from sphinx.deprecation import RemovedInSphinx40Warning, deprecated_alias\n17: from sphinx.pycode import ModuleAnalyzer, PycodeError\n18: from sphinx.util import logging\n19: from sphinx.util.inspect import (getannotations, getmro, getslots, isclass, isenumclass,\n20:                                  safe_getattr)\n21: \n22: if False:\n23:     # For type annotation\n24:     from typing import Type  # NOQA\n25: \n26: logger = logging.getLogger(__name__)\n27: \n28: \n29: def mangle(subject: Any, name: str) -> str:\n30:     \"\"\"mangle the given name.\"\"\"\n31:     try:\n32:         if isclass(subject) and name.startswith('__') and not name.endswith('__'):\n33:             return \"_%s%s\" % (subject.__name__, name)\n34:     except AttributeError:\n35:         pass\n36: \n37:     return name\n38: \n39: \n40: def unmangle(subject: Any, name: str) -> Optional[str]:\n41:     \"\"\"unmangle the given name.\"\"\"\n42:     try:\n43:         if isclass(subject) and not name.endswith('__'):\n44:             prefix = \"_%s__\" % subject.__name__\n45:             if name.startswith(prefix):\n46:                 return name.replace(prefix, \"__\", 1)\n47:             else:\n48:                 for cls in subject.__mro__:\n49:                     prefix = \"_%s__\" % cls.__name__\n50:                     if name.startswith(prefix):\n51:                         # mangled attribute defined in parent class\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sphinx/ext/autodoc/__init__.py",
      "suspect_lines": [
        28,
        29,
        1048,
        1052,
        1054,
        1055,
        1056,
        1057,
        1058,
        1059,
        1061,
        1066,
        1067,
        1068,
        1069
      ]
    },
    {
      "filename": "/sphinx/ext/autodoc/importer.py",
      "suspect_lines": [
        16
      ]
    }
  ]
}