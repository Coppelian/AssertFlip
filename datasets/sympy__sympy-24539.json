{
  "instance_id": "sympy__sympy-24539",
  "problem_statement": "`PolyElement.as_expr()` not accepting symbols\nThe method `PolyElement.as_expr()`\r\n\r\nhttps://github.com/sympy/sympy/blob/193e3825645d93c73e31cdceb6d742cc6919624d/sympy/polys/rings.py#L618-L624\r\n\r\nis supposed to let you set the symbols you want to use, but, as it stands, either you pass the wrong number of symbols, and get an error message, or you pass the right number of symbols, and it ignores them, using `self.ring.symbols` instead:\r\n\r\n```python\r\n>>> from sympy import ring, ZZ, symbols\r\n>>> R, x, y, z = ring(\"x,y,z\", ZZ)\r\n>>> f = 3*x**2*y - x*y*z + 7*z**3 + 1\r\n>>> U, V, W = symbols(\"u,v,w\")\r\n>>> f.as_expr(U, V, W)\r\n3*x**2*y - x*y*z + 7*z**3 + 1\r\n```\n",
  "localized_code": "[start of sympy/polys/rings.py]\n1: \"\"\"Sparse polynomial rings. \"\"\"\n2: \n3: from __future__ import annotations\n4: from typing import Any\n5: \n6: from operator import add, mul, lt, le, gt, ge\n7: from functools import reduce\n8: from types import GeneratorType\n9: \n10: from sympy.core.expr import Expr\n11: from sympy.core.numbers import igcd, oo\n12: from sympy.core.symbol import Symbol, symbols as _symbols\n13: from sympy.core.sympify import CantSympify, sympify\n14: from sympy.ntheory.multinomial import multinomial_coefficients\n15: from sympy.polys.compatibility import IPolys\n16: from sympy.polys.constructor import construct_domain\n17: from sympy.polys.densebasic import dmp_to_dict, dmp_from_dict\n18: from sympy.polys.domains.domainelement import DomainElement\n19: from sympy.polys.domains.polynomialring import PolynomialRing\n20: from sympy.polys.heuristicgcd import heugcd\n21: from sympy.polys.monomials import MonomialOps\n22: from sympy.polys.orderings import lex\n23: from sympy.polys.polyerrors import (\n24:     CoercionFailed, GeneratorsError,\n25:     ExactQuotientFailed, MultivariatePolynomialError)\n26: from sympy.polys.polyoptions import (Domain as DomainOpt,\n27:                                      Order as OrderOpt, build_options)\n28: from sympy.polys.polyutils import (expr_from_dict, _dict_reorder,\n29:                                    _parallel_dict_from_expr)\n30: from sympy.printing.defaults import DefaultPrinting\n31: from sympy.utilities import public\n32: from sympy.utilities.iterables import is_sequence\n33: from sympy.utilities.magic import pollute\n34: \n35: @public\n36: def ring(symbols, domain, order=lex):\n37:     \"\"\"Construct a polynomial ring returning ``(ring, x_1, ..., x_n)``.\n38: \n39:     Parameters\n40:     ==========\n41: \n42:     symbols : str\n43:         Symbol/Expr or sequence of str, Symbol/Expr (non-empty)\n44:     domain : :class:`~.Domain` or coercible\n45:     order : :class:`~.MonomialOrder` or coercible, optional, defaults to ``lex``\n46: \n47:     Examples\n48:     ========\n49: \n50:     >>> from sympy.polys.rings import ring\n51:     >>> from sympy.polys.domains import ZZ\n52:     >>> from sympy.polys.orderings import lex\n53: \n54:     >>> R, x, y, z = ring(\"x,y,z\", ZZ, lex)\n55:     >>> R\n56:     Polynomial ring in x, y, z over ZZ with lex order\n57:     >>> x + y + z\n58:     x + y + z\n59:     >>> type(_)\n60:     <class 'sympy.polys.rings.PolyElement'>\n61: \n62:     \"\"\"\n63:     _ring = PolyRing(symbols, domain, order)\n64:     return (_ring,) + _ring.gens\n65: \n66: @public\n67: def xring(symbols, domain, order=lex):\nCode replaced for brevity.\n95: \n96: \n97: @public\n98: def vring(symbols, domain, order=lex):\nCode replaced for brevity.\n126: \n127: \n128: @public\n129: def sring(exprs, *symbols, **options):\nCode replaced for brevity.\n179: \n180: \n181: def _parse_symbols(symbols):\nCode replaced for brevity.\n192: \n193: \n194: _ring_cache: dict[Any, Any] = {}\n195: \n196: class PolyRing(DefaultPrinting, IPolys):\nCode replaced for brevity.\n553: \n554: \n555: \n556: class PolyElement(DomainElement, DefaultPrinting, CantSympify, dict):\n557:     \"\"\"Element of multivariate distributed polynomial ring. \"\"\"\n558: \n559:     def new(self, init):\n560:         return self.__class__(init)\n561: \n562:     def parent(self):\n563:         return self.ring.to_domain()\n564: \n565:     def __getnewargs__(self):\n566:         return (self.ring, list(self.iterterms()))\n567: \n568:     _hash = None\n569: \n570:     def __hash__(self):\n571:         # XXX: This computes a hash of a dictionary, but currently we don't\n572:         # protect dictionary from being changed so any use site modifications\n573:         # will make hashing go wrong. Use this feature with caution until we\n574:         # figure out how to make a safe API without compromising speed of this\n575:         # low-level class.\n576:         _hash = self._hash\n577:         if _hash is None:\n578:             self._hash = _hash = hash((self.ring, frozenset(self.items())))\n579:         return _hash\n580: \n581:     def copy(self):\n582:         \"\"\"Return a copy of polynomial self.\n583: \n584:         Polynomials are mutable; if one is interested in preserving\n585:         a polynomial, and one plans to use inplace operations, one\n586:         can copy the polynomial. This method makes a shallow copy.\n587: \n588:         Examples\n589:         ========\n590: \n591:         >>> from sympy.polys.domains import ZZ\n592:         >>> from sympy.polys.rings import ring\n593: \n594:         >>> R, x, y = ring('x, y', ZZ)\n595:         >>> p = (x + y)**2\n596:         >>> p1 = p.copy()\n597:         >>> p2 = p\n598:         >>> p[R.zero_monom] = 3\n599:         >>> p\n600:         x**2 + 2*x*y + y**2 + 3\n601:         >>> p1\n602:         x**2 + 2*x*y + y**2\n603:         >>> p2\n604:         x**2 + 2*x*y + y**2 + 3\n605: \n606:         \"\"\"\n607:         return self.new(self)\n608: \n609:     def set_ring(self, new_ring):\n610:         if self.ring == new_ring:\n611:             return self\n612:         elif self.ring.symbols != new_ring.symbols:\n613:             terms = list(zip(*_dict_reorder(self, self.ring.symbols, new_ring.symbols)))\n614:             return new_ring.from_terms(terms, self.ring.domain)\n615:         else:\n616:             return new_ring.from_dict(self, self.ring.domain)\n617: \n618:     def as_expr(self, *symbols):\n619:         if symbols and len(symbols) != self.ring.ngens:\n620:             raise ValueError(\"not enough symbols, expected %s got %s\" % (self.ring.ngens, len(symbols)))\n621:         else:\n622:             symbols = self.ring.symbols\n623: \n624:         return expr_from_dict(self.as_expr_dict(), *symbols)\n625: \n626:     def as_expr_dict(self):\n627:         to_sympy = self.ring.domain.to_sympy\n628:         return {monom: to_sympy(coeff) for monom, coeff in self.iterterms()}\n629: \n630:     def clear_denoms(self):\n631:         domain = self.ring.domain\n632: \n633:         if not domain.is_Field or not domain.has_assoc_Ring:\n634:             return domain.one, self\n635: \n636:         ground_ring = domain.get_ring()\n637:         common = ground_ring.one\n638:         lcm = ground_ring.lcm\n639:         denom = domain.denom\n640: \n641:         for coeff in self.values():\n642:             common = lcm(common, denom(coeff))\n643: \n644:         poly = self.new([ (k, v*common) for k, v in self.items() ])\n645:         return common, poly\n646: \n647:     def strip_zero(self):\n648:         \"\"\"Eliminate monomials with zero coefficient. \"\"\"\n649:         for k, v in list(self.items()):\n650:             if not v:\n651:                 del self[k]\n652: \n653:     def __eq__(p1, p2):\n654:         \"\"\"Equality test for polynomials.\n655: \n656:         Examples\n657:         ========\n658: \n659:         >>> from sympy.polys.domains import ZZ\n660:         >>> from sympy.polys.rings import ring\n661: \n662:         >>> _, x, y = ring('x, y', ZZ)\n663:         >>> p1 = (x + y)**2 + (x - y)**2\n664:         >>> p1 == 4*x*y\n665:         False\n666:         >>> p1 == 2*(x**2 + y**2)\n667:         True\n668: \n669:         \"\"\"\n670:         if not p2:\n671:             return not p1\n672:         elif isinstance(p2, PolyElement) and p2.ring == p1.ring:\n673:             return dict.__eq__(p1, p2)\n674:         elif len(p1) > 1:\n675:             return False\n676:         else:\n677:             return p1.get(p1.ring.zero_monom) == p2\n678: \n679:     def __ne__(p1, p2):\n680:         return not p1 == p2\n681: \n682:     def almosteq(p1, p2, tolerance=None):\n683:         \"\"\"Approximate equality test for polynomials. \"\"\"\n684:         ring = p1.ring\n685: \n686:         if isinstance(p2, ring.dtype):\n687:             if set(p1.keys()) != set(p2.keys()):\n688:                 return False\n689: \n690:             almosteq = ring.domain.almosteq\n691: \n692:             for k in p1.keys():\n693:                 if not almosteq(p1[k], p2[k], tolerance):\n694:                     return False\n695:             return True\n696:         elif len(p1) > 1:\n697:             return False\n698:         else:\n699:             try:\n700:                 p2 = ring.domain.convert(p2)\n701:             except CoercionFailed:\n702:                 return False\n703:             else:\n704:                 return ring.domain.almosteq(p1.const(), p2, tolerance)\n705: \n706:     def sort_key(self):\n707:         return (len(self), self.terms())\n708: \n709:     def _cmp(p1, p2, op):\n710:         if isinstance(p2, p1.ring.dtype):\n711:             return op(p1.sort_key(), p2.sort_key())\n712:         else:\n713:             return NotImplemented\n714: \n715:     def __lt__(p1, p2):\n716:         return p1._cmp(p2, lt)\n717:     def __le__(p1, p2):\n718:         return p1._cmp(p2, le)\n719:     def __gt__(p1, p2):\n720:         return p1._cmp(p2, gt)\n721:     def __ge__(p1, p2):\n722:         return p1._cmp(p2, ge)\n723: \n724:     def _drop(self, gen):\n725:         ring = self.ring\n726:         i = ring.index(gen)\n727: \n728:         if ring.ngens == 1:\n729:             return i, ring.domain\n730:         else:\n731:             symbols = list(ring.symbols)\n732:             del symbols[i]\n733:             return i, ring.clone(symbols=symbols)\n734: \n735:     def drop(self, gen):\n736:         i, ring = self._drop(gen)\n737: \n738:         if self.ring.ngens == 1:\n739:             if self.is_ground:\n740:                 return self.coeff(1)\n741:             else:\n742:                 raise ValueError(\"Cannot drop %s\" % gen)\n743:         else:\n744:             poly = ring.zero\n745: \n746:             for k, v in self.items():\n747:                 if k[i] == 0:\n748:                     K = list(k)\n749:                     del K[i]\n750:                     poly[tuple(K)] = v\n751:                 else:\n752:                     raise ValueError(\"Cannot drop %s\" % gen)\n753: \n754:             return poly\n755: \n756:     def _drop_to_ground(self, gen):\n757:         ring = self.ring\n758:         i = ring.index(gen)\n759: \n760:         symbols = list(ring.symbols)\n761:         del symbols[i]\n762:         return i, ring.clone(symbols=symbols, domain=ring[i])\n763: \n764:     def drop_to_ground(self, gen):\n765:         if self.ring.ngens == 1:\n766:             raise ValueError(\"Cannot drop only generator to ground\")\n767: \n768:         i, ring = self._drop_to_ground(gen)\n769:         poly = ring.zero\n770:         gen = ring.domain.gens[0]\n771: \n772:         for monom, coeff in self.iterterms():\n773:             mon = monom[:i] + monom[i+1:]\n774:             if mon not in poly:\n775:                 poly[mon] = (gen**monom[i]).mul_ground(coeff)\n776:             else:\n777:                 poly[mon] += (gen**monom[i]).mul_ground(coeff)\n778: \n779:         return poly\n780: \n781:     def to_dense(self):\n782:         return dmp_from_dict(self, self.ring.ngens-1, self.ring.domain)\n783: \n784:     def to_dict(self):\n785:         return dict(self)\n786: \n787:     def str(self, printer, precedence, exp_pattern, mul_symbol):\n788:         if not self:\n789:             return printer._print(self.ring.domain.zero)\n790:         prec_mul = precedence[\"Mul\"]\n791:         prec_atom = precedence[\"Atom\"]\n792:         ring = self.ring\n793:         symbols = ring.symbols\n794:         ngens = ring.ngens\n795:         zm = ring.zero_monom\n796:         sexpvs = []\n797:         for expv, coeff in self.terms():\n798:             negative = ring.domain.is_negative(coeff)\n799:             sign = \" - \" if negative else \" + \"\n800:             sexpvs.append(sign)\n801:             if expv == zm:\n802:                 scoeff = printer._print(coeff)\n803:                 if negative and scoeff.startswith(\"-\"):\n804:                     scoeff = scoeff[1:]\n805:             else:\n806:                 if negative:\n807:                     coeff = -coeff\n808:                 if coeff != self.ring.domain.one:\n809:                     scoeff = printer.parenthesize(coeff, prec_mul, strict=True)\n810:                 else:\n811:                     scoeff = ''\n812:             sexpv = []\n813:             for i in range(ngens):\n814:                 exp = expv[i]\n815:                 if not exp:\n816:                     continue\n817:                 symbol = printer.parenthesize(symbols[i], prec_atom, strict=True)\n818:                 if exp != 1:\n819:                     if exp != int(exp) or exp < 0:\n820:                         sexp = printer.parenthesize(exp, prec_atom, strict=False)\n821:                     else:\n822:                         sexp = exp\n823:                     sexpv.append(exp_pattern % (symbol, sexp))\n824:                 else:\n825:                     sexpv.append('%s' % symbol)\n826:             if scoeff:\n827:                 sexpv = [scoeff] + sexpv\n828:             sexpvs.append(mul_symbol.join(sexpv))\n829:         if sexpvs[0] in [\" + \", \" - \"]:\n830:             head = sexpvs.pop(0)\n831:             if head == \" - \":\n832:                 sexpvs.insert(0, \"-\")\n833:         return \"\".join(sexpvs)\n834: \n835:     @property\n836:     def is_generator(self):\n837:         return self in self.ring._gens_set\n838: \n839:     @property\n840:     def is_ground(self):\n841:         return not self or (len(self) == 1 and self.ring.zero_monom in self)\n842: \n843:     @property\n844:     def is_monomial(self):\n845:         return not self or (len(self) == 1 and self.LC == 1)\n846: \n847:     @property\n848:     def is_term(self):\n849:         return len(self) <= 1\n850: \n851:     @property\n852:     def is_negative(self):\n853:         return self.ring.domain.is_negative(self.LC)\n854: \n855:     @property\n856:     def is_positive(self):\n857:         return self.ring.domain.is_positive(self.LC)\n858: \n859:     @property\n860:     def is_nonnegative(self):\n861:         return self.ring.domain.is_nonnegative(self.LC)\n862: \n863:     @property\n864:     def is_nonpositive(self):\n865:         return self.ring.domain.is_nonpositive(self.LC)\n866: \n867:     @property\n868:     def is_zero(f):\n869:         return not f\n870: \n871:     @property\n872:     def is_one(f):\n873:         return f == f.ring.one\n874: \n875:     @property\n876:     def is_monic(f):\n877:         return f.ring.domain.is_one(f.LC)\n878: \n879:     @property\n880:     def is_primitive(f):\n881:         return f.ring.domain.is_one(f.content())\n882: \n883:     @property\n884:     def is_linear(f):\n885:         return all(sum(monom) <= 1 for monom in f.itermonoms())\n886: \n887:     @property\n888:     def is_quadratic(f):\n889:         return all(sum(monom) <= 2 for monom in f.itermonoms())\n890: \n891:     @property\n892:     def is_squarefree(f):\n893:         if not f.ring.ngens:\n894:             return True\n895:         return f.ring.dmp_sqf_p(f)\n896: \n897:     @property\n898:     def is_irreducible(f):\n899:         if not f.ring.ngens:\n900:             return True\n901:         return f.ring.dmp_irreducible_p(f)\n902: \n903:     @property\n904:     def is_cyclotomic(f):\n905:         if f.ring.is_univariate:\n906:             return f.ring.dup_cyclotomic_p(f)\n907:         else:\n908:             raise MultivariatePolynomialError(\"cyclotomic polynomial\")\n909: \n910:     def __neg__(self):\n911:         return self.new([ (monom, -coeff) for monom, coeff in self.iterterms() ])\n912: \n913:     def __pos__(self):\n914:         return self\n915: \n916:     def __add__(p1, p2):\n917:         \"\"\"Add two polynomials.\n918: \n919:         Examples\n920:         ========\n921: \n922:         >>> from sympy.polys.domains import ZZ\n923:         >>> from sympy.polys.rings import ring\n924: \n925:         >>> _, x, y = ring('x, y', ZZ)\n926:         >>> (x + y)**2 + (x - y)**2\n927:         2*x**2 + 2*y**2\n928: \n929:         \"\"\"\n930:         if not p2:\n931:             return p1.copy()\n932:         ring = p1.ring\n933:         if isinstance(p2, ring.dtype):\n934:             p = p1.copy()\n935:             get = p.get\n936:             zero = ring.domain.zero\n937:             for k, v in p2.items():\n938:                 v = get(k, zero) + v\n939:                 if v:\n940:                     p[k] = v\n941:                 else:\n942:                     del p[k]\n943:             return p\n944:         elif isinstance(p2, PolyElement):\n945:             if isinstance(ring.domain, PolynomialRing) and ring.domain.ring == p2.ring:\n946:                 pass\n947:             elif isinstance(p2.ring.domain, PolynomialRing) and p2.ring.domain.ring == ring:\n948:                 return p2.__radd__(p1)\n949:             else:\n950:                 return NotImplemented\n951: \n952:         try:\n953:             cp2 = ring.domain_new(p2)\n954:         except CoercionFailed:\n955:             return NotImplemented\n956:         else:\n957:             p = p1.copy()\n958:             if not cp2:\n959:                 return p\n960:             zm = ring.zero_monom\n961:             if zm not in p1.keys():\n962:                 p[zm] = cp2\n963:             else:\n964:                 if p2 == -p[zm]:\n965:                     del p[zm]\n966:                 else:\n967:                     p[zm] += cp2\n968:             return p\n969: \n970:     def __radd__(p1, n):\n971:         p = p1.copy()\n972:         if not n:\n973:             return p\n974:         ring = p1.ring\n975:         try:\n976:             n = ring.domain_new(n)\n977:         except CoercionFailed:\n978:             return NotImplemented\n979:         else:\n980:             zm = ring.zero_monom\n981:             if zm not in p1.keys():\n982:                 p[zm] = n\n983:             else:\n984:                 if n == -p[zm]:\n985:                     del p[zm]\n986:                 else:\n987:                     p[zm] += n\n988:             return p\n989: \n990:     def __sub__(p1, p2):\n991:         \"\"\"Subtract polynomial p2 from p1.\n992: \n993:         Examples\n994:         ========\n995: \n996:         >>> from sympy.polys.domains import ZZ\n997:         >>> from sympy.polys.rings import ring\n998: \n999:         >>> _, x, y = ring('x, y', ZZ)\n1000:         >>> p1 = x + y**2\n1001:         >>> p2 = x*y + y**2\n1002:         >>> p1 - p2\n1003:         -x*y + x\n1004: \n1005:         \"\"\"\n1006:         if not p2:\n1007:             return p1.copy()\n1008:         ring = p1.ring\n1009:         if isinstance(p2, ring.dtype):\n1010:             p = p1.copy()\n1011:             get = p.get\n1012:             zero = ring.domain.zero\n1013:             for k, v in p2.items():\n1014:                 v = get(k, zero) - v\n1015:                 if v:\n1016:                     p[k] = v\n1017:                 else:\n1018:                     del p[k]\n1019:             return p\n1020:         elif isinstance(p2, PolyElement):\n1021:             if isinstance(ring.domain, PolynomialRing) and ring.domain.ring == p2.ring:\n1022:                 pass\n1023:             elif isinstance(p2.ring.domain, PolynomialRing) and p2.ring.domain.ring == ring:\n1024:                 return p2.__rsub__(p1)\n1025:             else:\n1026:                 return NotImplemented\n1027: \n1028:         try:\n1029:             p2 = ring.domain_new(p2)\n1030:         except CoercionFailed:\n1031:             return NotImplemented\n1032:         else:\n1033:             p = p1.copy()\n1034:             zm = ring.zero_monom\n1035:             if zm not in p1.keys():\n1036:                 p[zm] = -p2\n1037:             else:\n1038:                 if p2 == p[zm]:\n1039:                     del p[zm]\n1040:                 else:\n1041:                     p[zm] -= p2\n1042:             return p\n1043: \n1044:     def __rsub__(p1, n):\n1045:         \"\"\"n - p1 with n convertible to the coefficient domain.\n1046: \n1047:         Examples\n1048:         ========\n1049: \n1050:         >>> from sympy.polys.domains import ZZ\n1051:         >>> from sympy.polys.rings import ring\n1052: \n1053:         >>> _, x, y = ring('x, y', ZZ)\n1054:         >>> p = x + y\n1055:         >>> 4 - p\n1056:         -x - y + 4\n1057: \n1058:         \"\"\"\n1059:         ring = p1.ring\n1060:         try:\n1061:             n = ring.domain_new(n)\n1062:         except CoercionFailed:\n1063:             return NotImplemented\n1064:         else:\n1065:             p = ring.zero\n1066:             for expv in p1:\n1067:                 p[expv] = -p1[expv]\n1068:             p += n\n1069:             return p\n1070: \n1071:     def __mul__(p1, p2):\n1072:         \"\"\"Multiply two polynomials.\n1073: \n1074:         Examples\n1075:         ========\n1076: \n1077:         >>> from sympy.polys.domains import QQ\n1078:         >>> from sympy.polys.rings import ring\n1079: \n1080:         >>> _, x, y = ring('x, y', QQ)\n1081:         >>> p1 = x + y\n1082:         >>> p2 = x - y\n1083:         >>> p1*p2\n1084:         x**2 - y**2\n1085: \n1086:         \"\"\"\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/polys/rings.py",
      "suspect_lines": [
        619,
        620,
        621
      ]
    }
  ]
}