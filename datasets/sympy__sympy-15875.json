{
  "instance_id": "sympy__sympy-15875",
  "problem_statement": "is_zero is incorrect on complex integer\n`is_zero` should return `None` if it cannot decide, but should never give the wrong answer. However:\r\n\r\n```\r\n>>> e = -2*I + (1 + I)**2\r\n>>> e.is_zero\r\nFalse\r\n>>> simplify(e).is_zero\r\nTrue\r\n```\r\n\r\nThis is causing errors in determining the rank of a matrix. See issue #15872 \nFixing is_zero for complex numbers while Add\nReferences to other Issues or PRs\r\n#15873 \r\n\r\nOther comments:\r\n\r\n<!-- BEGIN RELEASE NOTES -->\r\n\r\n- core\r\n  - Fix `is_zero` becoming `False` on some expressions with `Add`.\r\n\r\n<!-- END RELEASE NOTES -->\r\n\n",
  "localized_code": "[start of sympy/core/add.py]\n1: from __future__ import print_function, division\n2: \n3: from collections import defaultdict\n4: from functools import cmp_to_key\n5: \n6: from .basic import Basic\n7: from .compatibility import reduce, is_sequence, range\n8: from .logic import _fuzzy_group, fuzzy_or, fuzzy_not\n9: from .singleton import S\n10: from .operations import AssocOp\n11: from .cache import cacheit\n12: from .numbers import ilcm, igcd\n13: from .expr import Expr\n14: \n15: # Key for sorting commutative args in canonical order\n16: _args_sortkey = cmp_to_key(Basic.compare)\n17: \n18: \n19: def _addsort(args):\n20:     # in-place sorting of args\n21:     args.sort(key=_args_sortkey)\n22: \n23: \n24: def _unevaluated_Add(*args):\n25:     \"\"\"Return a well-formed unevaluated Add: Numbers are collected and\n26:     put in slot 0 and args are sorted. Use this when args have changed\n27:     but you still want to return an unevaluated Add.\n28: \n29:     Examples\n30:     ========\n31: \n32:     >>> from sympy.core.add import _unevaluated_Add as uAdd\n33:     >>> from sympy import S, Add\n34:     >>> from sympy.abc import x, y\n35:     >>> a = uAdd(*[S(1.0), x, S(2)])\n36:     >>> a.args[0]\n37:     3.00000000000000\n38:     >>> a.args[1]\n39:     x\n40: \n41:     Beyond the Number being in slot 0, there is no other assurance of\n42:     order for the arguments since they are hash sorted. So, for testing\n43:     purposes, output produced by this in some other function can only\n44:     be tested against the output of this function or as one of several\n45:     options:\n46: \n47:     >>> opts = (Add(x, y, evaluated=False), Add(y, x, evaluated=False))\n48:     >>> a = uAdd(x, y)\n49:     >>> assert a in opts and a == uAdd(x, y)\n50:     >>> uAdd(x + 1, x + 2)\n51:     x + x + 3\n52:     \"\"\"\n53:     args = list(args)\n54:     newargs = []\n55:     co = S.Zero\n56:     while args:\n57:         a = args.pop()\n58:         if a.is_Add:\n59:             # this will keep nesting from building up\n60:             # so that x + (x + 1) -> x + x + 1 (3 args)\n61:             args.extend(a.args)\n62:         elif a.is_Number:\n63:             co += a\n64:         else:\n65:             newargs.append(a)\n66:     _addsort(newargs)\n67:     if co:\n68:         newargs.insert(0, co)\n69:     return Add._from_args(newargs)\n70: \n71: \n72: class Add(Expr, AssocOp):\n73: \n74:     __slots__ = []\n75: \n76:     is_Add = True\n77: \n78:     @classmethod\n79:     def flatten(cls, seq):\n80:         \"\"\"\n81:         Takes the sequence \"seq\" of nested Adds and returns a flatten list.\n82: \n83:         Returns: (commutative_part, noncommutative_part, order_symbols)\n84: \n85:         Applies associativity, all terms are commutable with respect to\n86:         addition.\n87: \n88:         NB: the removal of 0 is already handled by AssocOp.__new__\n89: \n90:         See also\n91:         ========\n92: \n93:         sympy.core.mul.Mul.flatten\n94: \n95:         \"\"\"\n96:         from sympy.calculus.util import AccumBounds\n97:         from sympy.matrices.expressions import MatrixExpr\n98:         from sympy.tensor.tensor import TensExpr\n99:         rv = None\n100:         if len(seq) == 2:\n101:             a, b = seq\n102:             if b.is_Rational:\n103:                 a, b = b, a\n104:             if a.is_Rational:\n105:                 if b.is_Mul:\n106:                     rv = [a, b], [], None\n107:             if rv:\n108:                 if all(s.is_commutative for s in rv[0]):\n109:                     return rv\n110:                 return [], rv[0], None\n111: \n112:         terms = {}      # term -> coeff\n113:                         # e.g. x**2 -> 5   for ... + 5*x**2 + ...\n114: \n115:         coeff = S.Zero  # coefficient (Number or zoo) to always be in slot 0\n116:                         # e.g. 3 + ...\n117:         order_factors = []\n118: \n119:         for o in seq:\n120: \n121:             # O(x)\n122:             if o.is_Order:\n123:                 for o1 in order_factors:\n124:                     if o1.contains(o):\n125:                         o = None\n126:                         break\n127:                 if o is None:\n128:                     continue\n129:                 order_factors = [o] + [\n130:                     o1 for o1 in order_factors if not o.contains(o1)]\n131:                 continue\n132: \n133:             # 3 or NaN\n134:             elif o.is_Number:\n135:                 if (o is S.NaN or coeff is S.ComplexInfinity and\n136:                         o.is_finite is False):\n137:                     # we know for sure the result will be nan\n138:                     return [S.NaN], [], None\n139:                 if coeff.is_Number:\n140:                     coeff += o\n141:                     if coeff is S.NaN:\n142:                         # we know for sure the result will be nan\n143:                         return [S.NaN], [], None\n144:                 continue\n145: \n146:             elif isinstance(o, AccumBounds):\n147:                 coeff = o.__add__(coeff)\n148:                 continue\n149: \n150:             elif isinstance(o, MatrixExpr):\n151:                 # can't add 0 to Matrix so make sure coeff is not 0\n152:                 coeff = o.__add__(coeff) if coeff else o\n153:                 continue\n154: \n155:             elif isinstance(o, TensExpr):\n156:                 coeff = o.__add__(coeff) if coeff else o\n157:                 continue\n158: \n159:             elif o is S.ComplexInfinity:\n160:                 if coeff.is_finite is False:\n161:                     # we know for sure the result will be nan\n162:                     return [S.NaN], [], None\n163:                 coeff = S.ComplexInfinity\n164:                 continue\n165: \n166:             # Add([...])\n167:             elif o.is_Add:\n168:                 # NB: here we assume Add is always commutative\n169:                 seq.extend(o.args)  # TODO zerocopy?\n170:                 continue\n171: \n172:             # Mul([...])\n173:             elif o.is_Mul:\n174:                 c, s = o.as_coeff_Mul()\n175: \n176:             # check for unevaluated Pow, e.g. 2**3 or 2**(-1/2)\n177:             elif o.is_Pow:\n178:                 b, e = o.as_base_exp()\n179:                 if b.is_Number and (e.is_Integer or\n180:                                    (e.is_Rational and e.is_negative)):\n181:                     seq.append(b**e)\n182:                     continue\n183:                 c, s = S.One, o\n184: \n185:             else:\n186:                 # everything else\n187:                 c = S.One\n188:                 s = o\n189: \n190:             # now we have:\n191:             # o = c*s, where\n192:             #\n193:             # c is a Number\n194:             # s is an expression with number factor extracted\n195:             # let's collect terms with the same s, so e.g.\n196:             # 2*x**2 + 3*x**2  ->  5*x**2\n197:             if s in terms:\n198:                 terms[s] += c\n199:                 if terms[s] is S.NaN:\n200:                     # we know for sure the result will be nan\n201:                     return [S.NaN], [], None\n202:             else:\n203:                 terms[s] = c\n204: \n205:         # now let's construct new args:\n206:         # [2*x**2, x**3, 7*x**4, pi, ...]\n207:         newseq = []\n208:         noncommutative = False\n209:         for s, c in terms.items():\n210:             # 0*s\n211:             if c is S.Zero:\n212:                 continue\n213:             # 1*s\n214:             elif c is S.One:\n215:                 newseq.append(s)\n216:             # c*s\n217:             else:\n218:                 if s.is_Mul:\n219:                     # Mul, already keeps its arguments in perfect order.\n220:                     # so we can simply put c in slot0 and go the fast way.\n221:                     cs = s._new_rawargs(*((c,) + s.args))\n222:                     newseq.append(cs)\n223:                 elif s.is_Add:\n224:                     # we just re-create the unevaluated Mul\n225:                     newseq.append(Mul(c, s, evaluate=False))\n226:                 else:\n227:                     # alternatively we have to call all Mul's machinery (slow)\n228:                     newseq.append(Mul(c, s))\n229: \n230:             noncommutative = noncommutative or not s.is_commutative\n231: \n232:         # oo, -oo\n233:         if coeff is S.Infinity:\n234:             newseq = [f for f in newseq if not\n235:                       (f.is_nonnegative or f.is_real and f.is_finite)]\n236: \n237:         elif coeff is S.NegativeInfinity:\n238:             newseq = [f for f in newseq if not\n239:                       (f.is_nonpositive or f.is_real and f.is_finite)]\n240: \n241:         if coeff is S.ComplexInfinity:\n242:             # zoo might be\n243:             #   infinite_real + finite_im\n244:             #   finite_real + infinite_im\n245:             #   infinite_real + infinite_im\n246:             # addition of a finite real or imaginary number won't be able to\n247:             # change the zoo nature; adding an infinite qualtity would result\n248:             # in a NaN condition if it had sign opposite of the infinite\n249:             # portion of zoo, e.g., infinite_real - infinite_real.\n250:             newseq = [c for c in newseq if not (c.is_finite and\n251:                                                 c.is_real is not None)]\n252: \n253:         # process O(x)\n254:         if order_factors:\n255:             newseq2 = []\n256:             for t in newseq:\n257:                 for o in order_factors:\n258:                     # x + O(x) -> O(x)\n259:                     if o.contains(t):\n260:                         t = None\n261:                         break\n262:                 # x + O(x**2) -> x + O(x**2)\n263:                 if t is not None:\n264:                     newseq2.append(t)\n265:             newseq = newseq2 + order_factors\n266:             # 1 + O(1) -> O(1)\n267:             for o in order_factors:\n268:                 if o.contains(coeff):\n269:                     coeff = S.Zero\n270:                     break\n271: \n272:         # order args canonically\n273:         _addsort(newseq)\n274: \n275:         # current code expects coeff to be first\n276:         if coeff is not S.Zero:\n277:             newseq.insert(0, coeff)\n278: \n279:         # we are done\n280:         if noncommutative:\n281:             return [], newseq, None\n282:         else:\n283:             return newseq, [], None\n284: \n285:     @classmethod\n286:     def class_key(cls):\n287:         \"\"\"Nice order of classes\"\"\"\n288:         return 3, 1, cls.__name__\n289: \n290:     def as_coefficients_dict(a):\n291:         \"\"\"Return a dictionary mapping terms to their Rational coefficient.\n292:         Since the dictionary is a defaultdict, inquiries about terms which\n293:         were not present will return a coefficient of 0. If an expression is\n294:         not an Add it is considered to have a single term.\n295: \n296:         Examples\n297:         ========\n298: \n299:         >>> from sympy.abc import a, x\n300:         >>> (3*x + a*x + 4).as_coefficients_dict()\n301:         {1: 4, x: 3, a*x: 1}\n302:         >>> _[a]\n303:         0\n304:         >>> (3*a*x).as_coefficients_dict()\n305:         {a*x: 3}\n306:         \"\"\"\n307: \n308:         d = defaultdict(list)\n309:         for ai in a.args:\n310:             c, m = ai.as_coeff_Mul()\n311:             d[m].append(c)\n312:         for k, v in d.items():\n313:             if len(v) == 1:\n314:                 d[k] = v[0]\n315:             else:\n316:                 d[k] = Add(*v)\n317:         di = defaultdict(int)\n318:         di.update(d)\n319:         return di\n320: \n321:     @cacheit\n322:     def as_coeff_add(self, *deps):\n323:         \"\"\"\n324:         Returns a tuple (coeff, args) where self is treated as an Add and coeff\n325:         is the Number term and args is a tuple of all other terms.\n326: \n327:         Examples\n328:         ========\n329: \n330:         >>> from sympy.abc import x\n331:         >>> (7 + 3*x).as_coeff_add()\n332:         (7, (3*x,))\n333:         >>> (7*x).as_coeff_add()\n334:         (0, (7*x,))\n335:         \"\"\"\n336:         if deps:\n337:             l1 = []\n338:             l2 = []\n339:             for f in self.args:\n340:                 if f.has(*deps):\n341:                     l2.append(f)\n342:                 else:\n343:                     l1.append(f)\n344:             return self._new_rawargs(*l1), tuple(l2)\n345:         coeff, notrat = self.args[0].as_coeff_add()\n346:         if coeff is not S.Zero:\n347:             return coeff, notrat + self.args[1:]\n348:         return S.Zero, self.args\n349: \n350:     def as_coeff_Add(self, rational=False):\n351:         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n352:         coeff, args = self.args[0], self.args[1:]\n353: \n354:         if coeff.is_Number and not rational or coeff.is_Rational:\n355:             return coeff, self._new_rawargs(*args)\n356:         return S.Zero, self\n357: \n358:     # Note, we intentionally do not implement Add.as_coeff_mul().  Rather, we\n359:     # let Expr.as_coeff_mul() just always return (S.One, self) for an Add.  See\n360:     # issue 5524.\n361: \n362:     def _eval_power(self, e):\n363:         if e.is_Rational and self.is_number:\n364:             from sympy.core.evalf import pure_complex\n365:             from sympy.core.mul import _unevaluated_Mul\n366:             from sympy.core.exprtools import factor_terms\n367:             from sympy.core.function import expand_multinomial\n368:             from sympy.functions.elementary.complexes import sign\n369:             from sympy.functions.elementary.miscellaneous import sqrt\n370:             ri = pure_complex(self)\n371:             if ri:\n372:                 r, i = ri\n373:                 if e.q == 2:\n374:                     D = sqrt(r**2 + i**2)\n375:                     if D.is_Rational:\n376:                         # (r, i, D) is a Pythagorean triple\n377:                         root = sqrt(factor_terms((D - r)/2))**e.p\n378:                         return root*expand_multinomial((\n379:                             # principle value\n380:                             (D + r)/abs(i) + sign(i)*S.ImaginaryUnit)**e.p)\n381:                 elif e == -1:\n382:                     return _unevaluated_Mul(\n383:                         r - i*S.ImaginaryUnit,\n384:                         1/(r**2 + i**2))\n385: \n386:     @cacheit\n387:     def _eval_derivative(self, s):\n388:         return self.func(*[a.diff(s) for a in self.args])\n389: \n390:     def _eval_nseries(self, x, n, logx):\n391:         terms = [t.nseries(x, n=n, logx=logx) for t in self.args]\n392:         return self.func(*terms)\n393: \n394:     def _matches_simple(self, expr, repl_dict):\n395:         # handle (w+3).matches('x+5') -> {w: x+2}\n396:         coeff, terms = self.as_coeff_add()\n397:         if len(terms) == 1:\n398:             return terms[0].matches(expr - coeff, repl_dict)\n399:         return\n400: \n401:     def matches(self, expr, repl_dict={}, old=False):\n402:         return AssocOp._matches_commutative(self, expr, repl_dict, old)\n403: \n404:     @staticmethod\n405:     def _combine_inverse(lhs, rhs):\n406:         \"\"\"\n407:         Returns lhs - rhs, but treats oo like a symbol so oo - oo\n408:         returns 0, instead of a nan.\n409:         \"\"\"\n410:         from sympy.core.function import expand_mul\n411:         from sympy.core.symbol import Dummy\n412:         inf = (S.Infinity, S.NegativeInfinity)\n413:         if lhs.has(*inf) or rhs.has(*inf):\n414:             oo = Dummy('oo')\n415:             reps = {\n416:                 S.Infinity: oo,\n417:                 S.NegativeInfinity: -oo}\n418:             ireps = dict([(v, k) for k, v in reps.items()])\n419:             eq = expand_mul(lhs.xreplace(reps) - rhs.xreplace(reps))\n420:             if eq.has(oo):\n421:                 eq = eq.replace(\n422:                     lambda x: x.is_Pow and x.base == oo,\n423:                     lambda x: x.base)\n424:             return eq.xreplace(ireps)\n425:         else:\n426:             return expand_mul(lhs - rhs)\n427: \n428:     @cacheit\n429:     def as_two_terms(self):\n430:         \"\"\"Return head and tail of self.\n431: \n432:         This is the most efficient way to get the head and tail of an\n433:         expression.\n434: \n435:         - if you want only the head, use self.args[0];\n436:         - if you want to process the arguments of the tail then use\n437:           self.as_coef_add() which gives the head and a tuple containing\n438:           the arguments of the tail when treated as an Add.\n439:         - if you want the coefficient when self is treated as a Mul\n440:           then use self.as_coeff_mul()[0]\n441: \n442:         >>> from sympy.abc import x, y\n443:         >>> (3*x - 2*y + 5).as_two_terms()\n444:         (5, 3*x - 2*y)\n445:         \"\"\"\n446:         return self.args[0], self._new_rawargs(*self.args[1:])\n447: \n448:     def as_numer_denom(self):\n449: \n450:         # clear rational denominator\n451:         content, expr = self.primitive()\n452:         ncon, dcon = content.as_numer_denom()\n453: \n454:         # collect numerators and denominators of the terms\n455:         nd = defaultdict(list)\n456:         for f in expr.args:\n457:             ni, di = f.as_numer_denom()\n458:             nd[di].append(ni)\n459: \n460:         # check for quick exit\n461:         if len(nd) == 1:\n462:             d, n = nd.popitem()\n463:             return self.func(\n464:                 *[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d)\n465: \n466:         # sum up the terms having a common denominator\n467:         for d, n in nd.items():\n468:             if len(n) == 1:\n469:                 nd[d] = n[0]\n470:             else:\n471:                 nd[d] = self.func(*n)\n472: \n473:         # assemble single numerator and denominator\n474:         denoms, numers = [list(i) for i in zip(*iter(nd.items()))]\n475:         n, d = self.func(*[Mul(*(denoms[:i] + [numers[i]] + denoms[i + 1:]))\n476:                    for i in range(len(numers))]), Mul(*denoms)\n477: \n478:         return _keep_coeff(ncon, n), _keep_coeff(dcon, d)\n479: \n480:     def _eval_is_polynomial(self, syms):\n481:         return all(term._eval_is_polynomial(syms) for term in self.args)\n482: \n483:     def _eval_is_rational_function(self, syms):\n484:         return all(term._eval_is_rational_function(syms) for term in self.args)\n485: \n486:     def _eval_is_algebraic_expr(self, syms):\n487:         return all(term._eval_is_algebraic_expr(syms) for term in self.args)\n488: \n489:     # assumption methods\n490:     _eval_is_real = lambda self: _fuzzy_group(\n491:         (a.is_real for a in self.args), quick_exit=True)\n492:     _eval_is_complex = lambda self: _fuzzy_group(\n493:         (a.is_complex for a in self.args), quick_exit=True)\n494:     _eval_is_antihermitian = lambda self: _fuzzy_group(\n495:         (a.is_antihermitian for a in self.args), quick_exit=True)\n496:     _eval_is_finite = lambda self: _fuzzy_group(\n497:         (a.is_finite for a in self.args), quick_exit=True)\n498:     _eval_is_hermitian = lambda self: _fuzzy_group(\n499:         (a.is_hermitian for a in self.args), quick_exit=True)\n500:     _eval_is_integer = lambda self: _fuzzy_group(\n501:         (a.is_integer for a in self.args), quick_exit=True)\n502:     _eval_is_rational = lambda self: _fuzzy_group(\n503:         (a.is_rational for a in self.args), quick_exit=True)\n504:     _eval_is_algebraic = lambda self: _fuzzy_group(\n505:         (a.is_algebraic for a in self.args), quick_exit=True)\n506:     _eval_is_commutative = lambda self: _fuzzy_group(\n507:         a.is_commutative for a in self.args)\n508: \n509:     def _eval_is_imaginary(self):\n510:         nz = []\n511:         im_I = []\n512:         for a in self.args:\n513:             if a.is_real:\n514:                 if a.is_zero:\n515:                     pass\n516:                 elif a.is_zero is False:\n517:                     nz.append(a)\n518:                 else:\n519:                     return\n520:             elif a.is_imaginary:\n521:                 im_I.append(a*S.ImaginaryUnit)\n522:             elif (S.ImaginaryUnit*a).is_real:\n523:                 im_I.append(a*S.ImaginaryUnit)\n524:             else:\n525:                 return\n526:         b = self.func(*nz)\n527:         if b.is_zero:\n528:             return fuzzy_not(self.func(*im_I).is_zero)\n529:         elif b.is_zero is False:\n530:             return False\n531: \n532:     def _eval_is_zero(self):\n533:         if self.is_commutative is False:\n534:             # issue 10528: there is no way to know if a nc symbol\n535:             # is zero or not\n536:             return\n537:         nz = []\n538:         z = 0\n539:         im_or_z = False\n540:         im = False\n541:         for a in self.args:\n542:             if a.is_real:\n543:                 if a.is_zero:\n544:                     z += 1\n545:                 elif a.is_zero is False:\n546:                     nz.append(a)\n547:                 else:\n548:                     return\n549:             elif a.is_imaginary:\n550:                 im = True\n551:             elif (S.ImaginaryUnit*a).is_real:\n552:                 im_or_z = True\n553:             else:\n554:                 return\n555:         if z == len(self.args):\n556:             return True\n557:         if len(nz) == len(self.args):\n558:             return None\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/add.py",
      "suspect_lines": [
        557
      ]
    }
  ]
}