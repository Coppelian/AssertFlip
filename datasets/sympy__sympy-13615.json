{
  "instance_id": "sympy__sympy-13615",
  "problem_statement": "Complement doesn't work when input is a mixture of Symbols and numbers\n```\r\n>>> a=FiniteSet(x,y,2)\r\n>>> b=Interval(-10,10)\r\n>>> Complement(a,b)\r\n{x, y}\r\n```\r\n`{x, y} \\ [-10,10]` is expected as output.\n",
  "localized_code": "[start of sympy/sets/sets.py]\n1: from __future__ import print_function, division\n2: \n3: from itertools import product\n4: \n5: from sympy.core.sympify import (_sympify, sympify, converter,\n6:     SympifyError)\n7: from sympy.core.basic import Basic\n8: from sympy.core.expr import Expr\n9: from sympy.core.singleton import Singleton, S\n10: from sympy.core.evalf import EvalfMixin\n11: from sympy.core.numbers import Float\n12: from sympy.core.compatibility import (iterable, with_metaclass,\n13:     ordered, range, PY3)\n14: from sympy.core.evaluate import global_evaluate\n15: from sympy.core.function import FunctionClass\n16: from sympy.core.mul import Mul\n17: from sympy.core.relational import Eq, Ne\n18: from sympy.core.symbol import Symbol, Dummy, _uniquely_named_symbol\n19: from sympy.sets.contains import Contains\n20: from sympy.utilities.iterables import sift\n21: from sympy.utilities.misc import func_name, filldedent\n22: \n23: from mpmath import mpi, mpf\n24: from sympy.logic.boolalg import And, Or, Not, true, false\n25: from sympy.utilities import subsets\n26: \n27: \n28: class Set(Basic):\n29:     \"\"\"\n30:     The base class for any kind of set.\n31: \n32:     This is not meant to be used directly as a container of items. It does not\n33:     behave like the builtin ``set``; see :class:`FiniteSet` for that.\n34: \n35:     Real intervals are represented by the :class:`Interval` class and unions of\n36:     sets by the :class:`Union` class. The empty set is represented by the\n37:     :class:`EmptySet` class and available as a singleton as ``S.EmptySet``.\n38:     \"\"\"\n39:     is_number = False\n40:     is_iterable = False\n41:     is_interval = False\n42: \n43:     is_FiniteSet = False\n44:     is_Interval = False\n45:     is_ProductSet = False\n46:     is_Union = False\n47:     is_Intersection = None\n48:     is_EmptySet = None\n49:     is_UniversalSet = None\n50:     is_Complement = None\n51:     is_ComplexRegion = False\n52: \n53:     @staticmethod\n54:     def _infimum_key(expr):\n55:         \"\"\"\n56:         Return infimum (if possible) else S.Infinity.\n57:         \"\"\"\n58:         try:\n59:             infimum = expr.inf\n60:             assert infimum.is_comparable\n61:         except (NotImplementedError,\n62:                 AttributeError, AssertionError, ValueError):\n63:             infimum = S.Infinity\n64:         return infimum\n65: \n66:     def union(self, other):\n67:         \"\"\"\n68:         Returns the union of 'self' and 'other'.\n69: \n70:         Examples\n71:         ========\n72: \n73:         As a shortcut it is possible to use the '+' operator:\n74: \n75:         >>> from sympy import Interval, FiniteSet\n76:         >>> Interval(0, 1).union(Interval(2, 3))\n77:         Union(Interval(0, 1), Interval(2, 3))\n78:         >>> Interval(0, 1) + Interval(2, 3)\n79:         Union(Interval(0, 1), Interval(2, 3))\n80:         >>> Interval(1, 2, True, True) + FiniteSet(2, 3)\n81:         Union(Interval.Lopen(1, 2), {3})\n82: \n83:         Similarly it is possible to use the '-' operator for set differences:\n84: \n85:         >>> Interval(0, 2) - Interval(0, 1)\n86:         Interval.Lopen(1, 2)\n87:         >>> Interval(1, 3) - FiniteSet(2)\n88:         Union(Interval.Ropen(1, 2), Interval.Lopen(2, 3))\n89: \n90:         \"\"\"\n91:         return Union(self, other)\n92: \n93:     def intersect(self, other):\n94:         \"\"\"\n95:         Returns the intersection of 'self' and 'other'.\n96: \n97:         >>> from sympy import Interval\n98: \n99:         >>> Interval(1, 3).intersect(Interval(1, 2))\n100:         Interval(1, 2)\n101: \n102:         >>> from sympy import imageset, Lambda, symbols, S\n103:         >>> n, m = symbols('n m')\n104:         >>> a = imageset(Lambda(n, 2*n), S.Integers)\n105:         >>> a.intersect(imageset(Lambda(m, 2*m + 1), S.Integers))\n106:         EmptySet()\n107: \n108:         \"\"\"\n109:         return Intersection(self, other)\n110: \n111:     def intersection(self, other):\n112:         \"\"\"\n113:         Alias for :meth:`intersect()`\n114:         \"\"\"\n115:         return self.intersect(other)\n116: \n117:     def _intersect(self, other):\n118:         \"\"\"\n119:         This function should only be used internally\n120: \n121:         self._intersect(other) returns a new, intersected set if self knows how\n122:         to intersect itself with other, otherwise it returns ``None``\n123: \n124:         When making a new set class you can be assured that other will not\n125:         be a :class:`Union`, :class:`FiniteSet`, or :class:`EmptySet`\n126: \n127:         Used within the :class:`Intersection` class\n128:         \"\"\"\n129:         return None\n130: \n131:     def is_disjoint(self, other):\n132:         \"\"\"\n133:         Returns True if 'self' and 'other' are disjoint\n134: \n135:         Examples\n136:         ========\n137: \n138:         >>> from sympy import Interval\n139:         >>> Interval(0, 2).is_disjoint(Interval(1, 2))\n140:         False\n141:         >>> Interval(0, 2).is_disjoint(Interval(3, 4))\n142:         True\n143: \n144:         References\n145:         ==========\n146: \n147:         .. [1] http://en.wikipedia.org/wiki/Disjoint_sets\n148:         \"\"\"\n149:         return self.intersect(other) == S.EmptySet\n150: \n151:     def isdisjoint(self, other):\n152:         \"\"\"\n153:         Alias for :meth:`is_disjoint()`\n154:         \"\"\"\n155:         return self.is_disjoint(other)\n156: \n157:     def _union(self, other):\n158:         \"\"\"\n159:         This function should only be used internally\n160: \n161:         self._union(other) returns a new, joined set if self knows how\n162:         to join itself with other, otherwise it returns ``None``.\n163:         It may also return a python set of SymPy Sets if they are somehow\n164:         simpler. If it does this it must be idempotent i.e. the sets returned\n165:         must return ``None`` with _union'ed with each other\n166: \n167:         Used within the :class:`Union` class\n168:         \"\"\"\n169:         return None\n170: \n171:     def complement(self, universe):\n172:         r\"\"\"\n173:         The complement of 'self' w.r.t the given universe.\n174: \n175:         Examples\n176:         ========\n177: \n178:         >>> from sympy import Interval, S\n179:         >>> Interval(0, 1).complement(S.Reals)\n180:         Union(Interval.open(-oo, 0), Interval.open(1, oo))\n181: \n182:         >>> Interval(0, 1).complement(S.UniversalSet)\n183:         UniversalSet() \\ Interval(0, 1)\n184: \n185:         \"\"\"\n186:         return Complement(universe, self)\n187: \n188:     def _complement(self, other):\n189:         # this behaves as other - self\n190:         if isinstance(other, ProductSet):\n191:             # For each set consider it or it's complement\n192:             # We need at least one of the sets to be complemented\n193:             # Consider all 2^n combinations.\n194:             # We can conveniently represent these options easily using a\n195:             # ProductSet\n196: \n197:             # XXX: this doesn't work if the dimensions of the sets isn't same.\n198:             # A - B is essentially same as A if B has a different\n199:             # dimensionality than A\n200:             switch_sets = ProductSet(FiniteSet(o, o - s) for s, o in\n201:                                      zip(self.sets, other.sets))\n202:             product_sets = (ProductSet(*set) for set in switch_sets)\n203:             # Union of all combinations but this one\n204:             return Union(p for p in product_sets if p != other)\n205: \n206:         elif isinstance(other, Interval):\n207:             if isinstance(self, Interval) or isinstance(self, FiniteSet):\n208:                 return Intersection(other, self.complement(S.Reals))\n209: \n210:         elif isinstance(other, Union):\n211:             return Union(o - self for o in other.args)\n212: \n213:         elif isinstance(other, Complement):\n214:             return Complement(other.args[0], Union(other.args[1], self), evaluate=False)\n215: \n216:         elif isinstance(other, EmptySet):\n217:             return S.EmptySet\n218: \n219:         elif isinstance(other, FiniteSet):\n220:             return FiniteSet(*[el for el in other if self.contains(el) != True])\n221: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/sets/sets.py",
      "suspect_lines": [
        220
      ]
    }
  ]
}