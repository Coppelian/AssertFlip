{
  "instance_id": "django__django-15467",
  "problem_statement": "ModelAdmin with defined radio_fields override empty_label\nDescription\n\t\nModelAdmin drops my \"empty_label\" and set \"default_empty_label\". For example:\nclass MyModelAdmin(ModelAdmin):\n\tradio_fields = 'myfield',\n\tdef formfield_for_foreignkey(self, db_field, *args, **kwargs):\n\t\tif db_field.name == 'myfield':\n\t\t\tkwargs['empty_label'] = \"I WANT TO SET MY OWN EMPTY LABEL\"\n\t\treturn super().formfield_for_foreignkey(db_field, *args, **kwargs)\nYou get never the \"I WANT TO SET MY OWN EMPTY LABEL\"\nHow to fix it:\nIn django\\contrib\\admin\\options.py, row 234:\nkwargs['empty_label'] = _('None') if db_field.blank else None\nShould be changed on:\nkwargs['empty_label'] = (kwargs.get('empty_label') or _('None')) if db_field.blank else None\n",
  "localized_code": "[start of django/contrib/admin/options.py]\n1: import copy\n2: import json\n3: import re\n4: from functools import partial, update_wrapper\n5: from urllib.parse import quote as urlquote\n6: \n7: from django import forms\n8: from django.conf import settings\n9: from django.contrib import messages\n10: from django.contrib.admin import helpers, widgets\n11: from django.contrib.admin.checks import (\n12:     BaseModelAdminChecks,\n13:     InlineModelAdminChecks,\n14:     ModelAdminChecks,\n15: )\n16: from django.contrib.admin.decorators import display\n17: from django.contrib.admin.exceptions import DisallowedModelAdminToField\n18: from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n19: from django.contrib.admin.utils import (\n20:     NestedObjects,\n21:     construct_change_message,\n22:     flatten_fieldsets,\n23:     get_deleted_objects,\n24:     lookup_spawns_duplicates,\n25:     model_format_dict,\n26:     model_ngettext,\n27:     quote,\n28:     unquote,\n29: )\n30: from django.contrib.admin.widgets import AutocompleteSelect, AutocompleteSelectMultiple\n31: from django.contrib.auth import get_permission_codename\n32: from django.core.exceptions import (\n33:     FieldDoesNotExist,\n34:     FieldError,\n35:     PermissionDenied,\n36:     ValidationError,\n37: )\n38: from django.core.paginator import Paginator\n39: from django.db import models, router, transaction\n40: from django.db.models.constants import LOOKUP_SEP\n41: from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n42: from django.forms.models import (\n43:     BaseInlineFormSet,\n44:     inlineformset_factory,\n45:     modelform_defines_fields,\n46:     modelform_factory,\n47:     modelformset_factory,\n48: )\n49: from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n50: from django.http import HttpResponseRedirect\n51: from django.http.response import HttpResponseBase\n52: from django.template.response import SimpleTemplateResponse, TemplateResponse\n53: from django.urls import reverse\n54: from django.utils.decorators import method_decorator\n55: from django.utils.html import format_html\n56: from django.utils.http import urlencode\n57: from django.utils.safestring import mark_safe\n58: from django.utils.text import (\n59:     capfirst,\n60:     format_lazy,\n61:     get_text_list,\n62:     smart_split,\n63:     unescape_string_literal,\n64: )\n65: from django.utils.translation import gettext as _\n66: from django.utils.translation import ngettext\n67: from django.views.decorators.csrf import csrf_protect\n68: from django.views.generic import RedirectView\n69: \n70: IS_POPUP_VAR = \"_popup\"\n71: TO_FIELD_VAR = \"_to_field\"\n72: \n73: \n74: HORIZONTAL, VERTICAL = 1, 2\n75: \n76: \n77:     # it cannot import models from other applications at the module level.\nCode replaced for brevity.\n82: \n83: \n84: \n85: def get_ul_class(radio_style):\nCode replaced for brevity.\n86: \n87: \n88: \n89: class IncorrectLookupParameters(Exception):\n90:     pass\n91: \n92: \n93: # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n94: # by adding to ModelAdmin.formfield_overrides.\n95: \n96: FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n97:     models.DateTimeField: {\n98:         \"form_class\": forms.SplitDateTimeField,\n99:         \"widget\": widgets.AdminSplitDateTime,\n100:     },\n101:     models.DateField: {\"widget\": widgets.AdminDateWidget},\n102:     models.TimeField: {\"widget\": widgets.AdminTimeWidget},\n103:     models.TextField: {\"widget\": widgets.AdminTextareaWidget},\n104:     models.URLField: {\"widget\": widgets.AdminURLFieldWidget},\n105:     models.IntegerField: {\"widget\": widgets.AdminIntegerFieldWidget},\n106:     models.BigIntegerField: {\"widget\": widgets.AdminBigIntegerFieldWidget},\n107:     models.CharField: {\"widget\": widgets.AdminTextInputWidget},\n108:     models.ImageField: {\"widget\": widgets.AdminFileWidget},\n109:     models.FileField: {\"widget\": widgets.AdminFileWidget},\n110:     models.EmailField: {\"widget\": widgets.AdminEmailInputWidget},\n111:     models.UUIDField: {\"widget\": widgets.AdminUUIDInputWidget},\n112: }\n113: \n114: csrf_protect_m = method_decorator(csrf_protect)\n115: \n116: \n117: class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n118:     \"\"\"Functionality common to both ModelAdmin and InlineAdmin.\"\"\"\n119: \n120:     autocomplete_fields = ()\n121:     raw_id_fields = ()\n122:     fields = None\n123:     exclude = None\n124:     fieldsets = None\n125:     form = forms.ModelForm\n126:     filter_vertical = ()\n127:     filter_horizontal = ()\n128:     radio_fields = {}\n129:     prepopulated_fields = {}\n130:     formfield_overrides = {}\n131:     readonly_fields = ()\n132:     ordering = None\n133:     sortable_by = None\n134:     view_on_site = True\n135:     show_full_result_count = True\n136:     checks_class = BaseModelAdminChecks\n137: \n138:     def check(self, **kwargs):\n139:         return self.checks_class().check(self, **kwargs)\n140: \n141:     def __init__(self):\n142:         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides\n143:         # rather than simply overwriting.\n144:         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)\n145:         for k, v in self.formfield_overrides.items():\n146:             overrides.setdefault(k, {}).update(v)\n147:         self.formfield_overrides = overrides\n148: \n149:     def formfield_for_dbfield(self, db_field, request, **kwargs):\n150:         \"\"\"\n151:         Hook for specifying the form Field instance for a given database Field\n152:         instance.\n153: \n154:         If kwargs are given, they're passed to the form Field's constructor.\n155:         \"\"\"\n156:         # If the field specifies choices, we don't need to look for special\n157:         # admin widgets - we just need to use a select widget of some kind.\n158:         if db_field.choices:\n159:             return self.formfield_for_choice_field(db_field, request, **kwargs)\n160: \n161:         # ForeignKey or ManyToManyFields\n162:         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):\n163:             # Combine the field kwargs with any options for formfield_overrides.\n164:             # Make sure the passed in **kwargs override anything in\n165:             # formfield_overrides because **kwargs is more specific, and should\n166:             # always win.\n167:             if db_field.__class__ in self.formfield_overrides:\n168:                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}\n169: \n170:             # Get the correct formfield.\n171:             if isinstance(db_field, models.ForeignKey):\n172:                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)\n173:             elif isinstance(db_field, models.ManyToManyField):\n174:                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)\n175: \n176:             # For non-raw_id fields, wrap the widget with a wrapper that adds\n177:             # extra HTML -- the \"add other\" interface -- to the end of the\n178:             # rendered output. formfield can be None if it came from a\n179:             # OneToOneField with parent_link=True or a M2M intermediary.\n180:             if formfield and db_field.name not in self.raw_id_fields:\n181:                 related_modeladmin = self.admin_site._registry.get(\n182:                     db_field.remote_field.model\n183:                 )\n184:                 wrapper_kwargs = {}\n185:                 if related_modeladmin:\n186:                     wrapper_kwargs.update(\n187:                         can_add_related=related_modeladmin.has_add_permission(request),\n188:                         can_change_related=related_modeladmin.has_change_permission(\n189:                             request\n190:                         ),\n191:                         can_delete_related=related_modeladmin.has_delete_permission(\n192:                             request\n193:                         ),\n194:                         can_view_related=related_modeladmin.has_view_permission(\n195:                             request\n196:                         ),\n197:                     )\n198:                 formfield.widget = widgets.RelatedFieldWidgetWrapper(\n199:                     formfield.widget,\n200:                     db_field.remote_field,\n201:                     self.admin_site,\n202:                     **wrapper_kwargs,\n203:                 )\n204: \n205:             return formfield\n206: \n207:         # If we've got overrides for the formfield defined, use 'em. **kwargs\n208:         # passed to formfield_for_dbfield override the defaults.\n209:         for klass in db_field.__class__.mro():\n210:             if klass in self.formfield_overrides:\n211:                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}\n212:                 return db_field.formfield(**kwargs)\n213: \n214:         # For any other type of field, just call its formfield() method.\n215:         return db_field.formfield(**kwargs)\n216: \n217:     def formfield_for_choice_field(self, db_field, request, **kwargs):\n218:         \"\"\"\n219:         Get a form Field for a database Field that has declared choices.\n220:         \"\"\"\n221:         # If the field is named as a radio_field, use a RadioSelect\n222:         if db_field.name in self.radio_fields:\n223:             # Avoid stomping on custom widget/choices arguments.\n224:             if \"widget\" not in kwargs:\n225:                 kwargs[\"widget\"] = widgets.AdminRadioSelect(\n226:                     attrs={\n227:                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n228:                     }\n229:                 )\n230:             if \"choices\" not in kwargs:\n231:                 kwargs[\"choices\"] = db_field.get_choices(\n232:                     include_blank=db_field.blank, blank_choice=[(\"\", _(\"None\"))]\n233:                 )\n234:         return db_field.formfield(**kwargs)\n235: \n236:     def get_field_queryset(self, db, db_field, request):\n237:         \"\"\"\n238:         If the ModelAdmin specifies ordering, the queryset should respect that\n239:         ordering.  Otherwise don't specify the queryset, let the field decide\n240:         (return None in that case).\n241:         \"\"\"\n242:         related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n243:         if related_admin is not None:\n244:             ordering = related_admin.get_ordering(request)\n245:             if ordering is not None and ordering != ():\n246:                 return db_field.remote_field.model._default_manager.using(db).order_by(\n247:                     *ordering\n248:                 )\n249:         return None\n250: \n251:     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n252:         \"\"\"\n253:         Get a form Field for a ForeignKey.\n254:         \"\"\"\n255:         db = kwargs.get(\"using\")\n256: \n257:         if \"widget\" not in kwargs:\n258:             if db_field.name in self.get_autocomplete_fields(request):\n259:                 kwargs[\"widget\"] = AutocompleteSelect(\n260:                     db_field, self.admin_site, using=db\n261:                 )\n262:             elif db_field.name in self.raw_id_fields:\n263:                 kwargs[\"widget\"] = widgets.ForeignKeyRawIdWidget(\n264:                     db_field.remote_field, self.admin_site, using=db\n265:                 )\n266:             elif db_field.name in self.radio_fields:\n267:                 kwargs[\"widget\"] = widgets.AdminRadioSelect(\n268:                     attrs={\n269:                         \"class\": get_ul_class(self.radio_fields[db_field.name]),\n270:                     }\n271:                 )\n272:                 kwargs[\"empty_label\"] = _(\"None\") if db_field.blank else None\n273: \n274:         if \"queryset\" not in kwargs:\n275:             queryset = self.get_field_queryset(db, db_field, request)\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/contrib/admin/options.py",
      "suspect_lines": [
        272
      ]
    }
  ]
}