{
  "instance_id": "django__django-12406",
  "problem_statement": "ModelForm RadioSelect widget for foreign keys should not present a blank option if blank=False on the model\nDescription\n\t\nUnlike the select widget, where a blank option is idiomatic even for required fields, radioselect has an inherent unfilled state that makes the \"-------\" option look suspiciously like a valid choice.\nclass TestRun(models.Model):\n\tdata_file = models.ForeignKey(BatchData, on_delete=models.SET_NULL, null=True, blank=False)\nclass TestRunForm(ModelForm):\n\tclass Meta:\n\t\tmodel = TestRun\n\t\tfields = ['data_file']\n\t\twidgets = {'data_file': RadioSelect()}\nrenders {{test_run_form.data_file}} as\n<ul id=\"id_data_file\">\n <li><label for=\"id_data_file_0\">\n\t<input checked=\"checked\" id=\"id_data_file_0\" name=\"data_file\" type=\"radio\" value=\"\"> ---------\n </label></li>\n <li><label for=\"id_data_file_1\">\n\t<input id=\"id_data_file_1\" name=\"data_file\" type=\"radio\" value=\"1\"> First Data File\n </label></li>\n</ul>\nInstead, there should be no checked option for RadioSelect's <input> tags when rendering a new form from a model if blank is not a valid selection.\n",
  "localized_code": "[start of django/db/models/fields/related.py]\n1: import functools\n2: import inspect\n3: from functools import partial\n4: \n5: from django import forms\n6: from django.apps import apps\n7: from django.conf import SettingsReference\n8: from django.core import checks, exceptions\n9: from django.db import connection, router\n10: from django.db.backends import utils\n11: from django.db.models import Q\n12: from django.db.models.constants import LOOKUP_SEP\n13: from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14: from django.db.models.query_utils import PathInfo\n15: from django.db.models.utils import make_model_tuple\n16: from django.utils.functional import cached_property\n17: from django.utils.translation import gettext_lazy as _\n18: \n19: from . import Field\n20: from .mixins import FieldCacheMixin\n21: from .related_descriptors import (\n22:     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,\n23:     ForwardOneToOneDescriptor, ManyToManyDescriptor,\n24:     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,\n25: )\n26: from .related_lookups import (\n27:     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,\n28:     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,\n29: )\n30: from .reverse_related import (\n31:     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,\n32: )\n33: \n34: RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n35: \n36: \n37: def resolve_relation(scope_model, relation):\n38:     \"\"\"\n39:     Transform relation into a model or fully-qualified model string of the form\n40:     \"app_label.ModelName\", relative to scope_model.\n41: \n42:     The relation argument can be:\n43:       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n44:         the model argument will be returned.\n45:       * A bare model name without an app_label, in which case scope_model's\n46:         app_label will be prepended.\n47:       * An \"app_label.ModelName\" string.\n48:       * A model class, which will be returned unchanged.\n49:     \"\"\"\n50:     # Check for recursive relations\n51:     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n... Code Truncated ...\n\n[start of django/forms/models.py]\n1: \"\"\"\n2: Helper functions for creating Form classes from Django models\n3: and database field objects.\n4: \"\"\"\n5: \n6: from itertools import chain\n7: \n8: from django.core.exceptions import (\n9:     NON_FIELD_ERRORS, FieldError, ImproperlyConfigured, ValidationError,\n10: )\n11: from django.forms.fields import ChoiceField, Field\n12: from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n13: from django.forms.formsets import BaseFormSet, formset_factory\n14: from django.forms.utils import ErrorList\n15: from django.forms.widgets import (\n16:     HiddenInput, MultipleHiddenInput, SelectMultiple,\n17: )\n18: from django.utils.text import capfirst, get_text_list\n19: from django.utils.translation import gettext, gettext_lazy as _\n20: \n21: __all__ = (\n22:     'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',\n23:     'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS',\n24:     'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',\n25:     'inlineformset_factory', 'modelform_factory',\n26: )\n27: \n28: ALL_FIELDS = '__all__'\n29: \n30: \n31: def construct_instance(form, instance, fields=None, exclude=None):\n32:     \"\"\"\n33:     Construct and return a model instance from the bound ``form``'s\n34:     ``cleaned_data``, but do not save the returned instance to the database.\n35:     \"\"\"\n36:     from django.db import models\n37:     opts = instance._meta\n38: \n39:     cleaned_data = form.cleaned_data\n40:     file_field_list = []\n41:     for f in opts.fields:\n42:         if not f.editable or isinstance(f, models.AutoField) \\\n43:                 or f.name not in cleaned_data:\n44:             continue\n45:         if fields is not None and f.name not in fields:\n46:             continue\n47:         if exclude and f.name in exclude:\n48:             continue\n49:         # Leave defaults for fields that aren't in POST data, except for\n50:         # checkbox inputs because they don't appear in POST data if not checked.\n51:         if (\n52:             f.has_default() and\n53:             form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)) and\n54:             cleaned_data.get(f.name) in form[f.name].field.empty_values\n55:         ):\n56:             continue\n57:         # Defer saving file-type fields until after the other fields, so a\n58:         # callable upload_to can use the values from other fields.\n59:         if isinstance(f, models.FileField):\n60:             file_field_list.append(f)\n61:         else:\n62:             f.save_form_data(instance, cleaned_data[f.name])\n63: \n64:     for f in file_field_list:\n65:         f.save_form_data(instance, cleaned_data[f.name])\n66: \n67:     return instance\n68: \n69: \n70: # ModelForms #################################################################\n71: \n72: def model_to_dict(instance, fields=None, exclude=None):\nCode replaced for brevity.\n94: \n95: \n96: \n97: def apply_limit_choices_to_to_formfield(formfield):\nCode replaced for brevity.\n102: \n103: \n104: \n105:                      field_classes=None, *, apply_limit_choices_to=True):\nCode replaced for brevity.\n191: \n192: \n193: \n194: class ModelFormOptions:\nCode replaced for brevity.\n204: \n205: \n206: \n207: class ModelFormMetaclass(DeclarativeFieldsMetaclass):\nCode replaced for brevity.\n276: \n277: \n278: \n279: class BaseModelForm(BaseForm):\nCode replaced for brevity.\n467: \n468: \n469: \n470: class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n471:     pass\n472: \n473: \n474:                       field_classes=None):\nCode replaced for brevity.\n554: \n555: \n556: \n557: # ModelFormSets ##############################################################\n558: \n559: class BaseModelFormSet(BaseFormSet):\nCode replaced for brevity.\n856: \n857: \n858: \n859:                          min_num=None, validate_min=False, field_classes=None):\nCode replaced for brevity.\n883: \n884: \n885: \n886: # InlineFormSets #############################################################\n887: \n888: class BaseInlineFormSet(BaseModelFormSet):\nCode replaced for brevity.\n985: \n986: \n987: \n988: def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\nCode replaced for brevity.\n1041: \n1042: \n1043: \n1044:                           min_num=None, validate_min=False, field_classes=None):\nCode replaced for brevity.\n1083: \n1084: \n1085: \n1086: # Fields #####################################################################\n1087: \n1088: class InlineForeignKeyField(Field):\nCode replaced for brevity.\n1126: \n1127: \n1128: \n1129: class ModelChoiceIteratorValue:\nCode replaced for brevity.\n1140: \n1141: \n1142: \n1143: class ModelChoiceIterator:\nCode replaced for brevity.\n1171: \n1172: \n1173: \n1174: class ModelChoiceField(ChoiceField):\n1175:     \"\"\"A ChoiceField whose choices are a model QuerySet.\"\"\"\n1176:     # This class is a subclass of ChoiceField for purity, but it doesn't\n1177:     # actually use any of ChoiceField's implementation.\n1178:     default_error_messages = {\n1179:         'invalid_choice': _('Select a valid choice. That choice is not one of'\n1180:                             ' the available choices.'),\n1181:     }\n1182:     iterator = ModelChoiceIterator\n1183: \n1184:     def __init__(self, queryset, *, empty_label=\"---------\",\n1185:                  required=True, widget=None, label=None, initial=None,\n1186:                  help_text='', to_field_name=None, limit_choices_to=None,\n1187:                  **kwargs):\n1188:         if required and (initial is not None):\n1189:             self.empty_label = None\n1190:         else:\n1191:             self.empty_label = empty_label\n1192: \n1193:         # Call Field instead of ChoiceField __init__() because we don't need\n1194:         # ChoiceField.__init__().\n1195:         Field.__init__(\n1196:             self, required=required, widget=widget, label=label,\n1197:             initial=initial, help_text=help_text, **kwargs\n1198:         )\n1199:         self.queryset = queryset\n1200:         self.limit_choices_to = limit_choices_to   # limit the queryset later.\n1201:         self.to_field_name = to_field_name\n1202: \n1203:     def get_limit_choices_to(self):\n1204:         \"\"\"\n1205:         Return ``limit_choices_to`` for this form field.\n1206: \n1207:         If it is a callable, invoke it and return the result.\n1208:         \"\"\"\n1209:         if callable(self.limit_choices_to):\n1210:             return self.limit_choices_to()\n1211:         return self.limit_choices_to\n1212: \n1213:     def __deepcopy__(self, memo):\n1214:         result = super(ChoiceField, self).__deepcopy__(memo)\n1215:         # Need to force a new ModelChoiceIterator to be created, bug #11183\n1216:         if self.queryset is not None:\n1217:             result.queryset = self.queryset.all()\n1218:         return result\n1219: \n1220:     def _get_queryset(self):\n1221:         return self._queryset\n1222: \n1223:     def _set_queryset(self, queryset):\n1224:         self._queryset = None if queryset is None else queryset.all()\n1225:         self.widget.choices = self.choices\n1226: \n1227:     queryset = property(_get_queryset, _set_queryset)\n1228: \n1229:     # this method will be used to create object labels by the QuerySetIterator.\n1230:     # Override it to customize the label.\n1231:     def label_from_instance(self, obj):\n1232:         \"\"\"\n1233:         Convert objects into strings and generate the labels for the choices\n1234:         presented by this object. Subclasses can override this method to\n1235:         customize the display of the choices.\n1236:         \"\"\"\n1237:         return str(obj)\n1238: \n1239:     def _get_choices(self):\n1240:         # If self._choices is set, then somebody must have manually set\n1241:         # the property self.choices. In this case, just return self._choices.\n1242:         if hasattr(self, '_choices'):\n1243:             return self._choices\n1244: \n1245:         # Otherwise, execute the QuerySet in self.queryset to determine the\n1246:         # choices dynamically. Return a fresh ModelChoiceIterator that has not been\n1247:         # consumed. Note that we're instantiating a new ModelChoiceIterator *each*\n1248:         # time _get_choices() is called (and, thus, each time self.choices is\n1249:         # accessed) so that we can ensure the QuerySet has not been consumed. This\n1250:         # construct might look complicated but it allows for lazy evaluation of\n1251:         # the queryset.\n1252:         return self.iterator(self)\n1253: \n1254:     choices = property(_get_choices, ChoiceField._set_choices)\n1255: \n1256:     def prepare_value(self, value):\n1257:         if hasattr(value, '_meta'):\n1258:             if self.to_field_name:\n1259:                 return value.serializable_value(self.to_field_name)\n1260:             else:\n1261:                 return value.pk\n1262:         return super().prepare_value(value)\n1263: \n1264:     def to_python(self, value):\n1265:         if value in self.empty_values:\n1266:             return None\n1267:         try:\n1268:             key = self.to_field_name or 'pk'\n1269:             if isinstance(value, self.queryset.model):\n1270:                 value = getattr(value, key)\n1271:             value = self.queryset.get(**{key: value})\n1272:         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\n1273:             raise ValidationError(self.error_messages['invalid_choice'], code='invalid_choice')\n1274:         return value\n1275: \n1276:     def validate(self, value):\n1277:         return Field.validate(self, value)\n1278: \n1279:     def has_changed(self, initial, data):\n1280:         if self.disabled:\n1281:             return False\n1282:         initial_value = initial if initial is not None else ''\n1283:         data_value = data if data is not None else ''\n1284:         return str(self.prepare_value(initial_value)) != str(data_value)\n1285: \n1286: \n1287: class ModelMultipleChoiceField(ModelChoiceField):\nCode replaced for brevity.\n1376: \n1377: \n1378: \n1379:     retu\nCode replaced for brevity.\n1383: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/models/fields/related.py",
      "suspect_lines": []
    },
    {
      "filename": "/django/forms/models.py",
      "suspect_lines": [
        16,
        1187,
        1188,
        1189,
        1190,
        1191,
        1192
      ]
    }
  ]
}