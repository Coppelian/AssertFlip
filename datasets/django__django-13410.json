{
  "instance_id": "django__django-13410",
  "problem_statement": "Bug in posix implementation of django/core/files/locks.py\nDescription\n\t\nThe posix version of locks (the version which supports import fcntl) has a bug. The code attempts to return True to indicate success or failure acquiring a lock, but instead it always returns False. The reason is that cpython fcntl module returns None if successful, and raises an OSError to indicate failure (see â€‹https://docs.python.org/3/library/fcntl.html#fcntl.flock).\nAnyone interested in using the non-blocking (i.e. locks.LOCKS_NB) requires a valid return value to know if they have successfully acquired the lock.\nI believe the correct implementation should be the following:\ndiff --git a/django/core/files/locks.py b/django/core/files/locks.py\nindex c46b00b905..4938347ea7 100644\n--- a/django/core/files/locks.py\n+++ b/django/core/files/locks.py\n@@ -107,9 +107,15 @@ else:\n\t\t\t return True\n\t else:\n\t\t def lock(f, flags):\n-\t\t\tret = fcntl.flock(_fd(f), flags)\n-\t\t\treturn ret == 0\n+\t\t\ttry:\n+\t\t\t\tfcntl.flock(_fd(f), flags)\n+\t\t\t\treturn True\n+\t\t\texcept OSError:\n+\t\t\t\treturn False\n\t\t def unlock(f):\n-\t\t\tret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n-\t\t\treturn ret == 0\n+\t\t\ttry:\n+\t\t\t\tfcntl.flock(_fd(f), fcntl.LOCK_UN)\n+\t\t\t\treturn True\n+\t\t\texcept OSError:\n+\t\t\t\treturn False\n",
  "localized_code": "[start of django/core/files/locks.py]\n1: \"\"\"\n2: Portable file locking utilities.\n3: \n4: Based partially on an example by Jonathan Feignberg in the Python\n5: Cookbook [1] (licensed under the Python Software License) and a ctypes port by\n6: Anatoly Techtonik for Roundup [2] (license [3]).\n7: \n8: [1] http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65203\n9: [2] https://sourceforge.net/p/roundup/code/ci/default/tree/roundup/backends/portalocker.py\n10: [3] https://sourceforge.net/p/roundup/code/ci/default/tree/COPYING.txt\n11: \n12: Example Usage::\n13: \n14:     >>> from django.core.files import locks\n15:     >>> with open('./file', 'wb') as f:\n16:     ...     locks.lock(f, locks.LOCK_EX)\n17:     ...     f.write('Django')\n18: \"\"\"\n19: import os\n20: \n21: __all__ = ('LOCK_EX', 'LOCK_SH', 'LOCK_NB', 'lock', 'unlock')\n22: \n23: \n24: def _fd(f):\n25:     \"\"\"Get a filedescriptor from something which could be a file or an fd.\"\"\"\n26:     return f.fileno() if hasattr(f, 'fileno') else f\n27: \n28: \n29: if os.name == 'nt':\n30:     import msvcrt\n31:     from ctypes import (\n32:         POINTER, Structure, Union, byref, c_int64, c_ulong, c_void_p, sizeof,\n33:         windll,\n34:     )\n35:     from ctypes.wintypes import BOOL, DWORD, HANDLE\n36: \n37:     LOCK_SH = 0  # the default\n38:     LOCK_NB = 0x1  # LOCKFILE_FAIL_IMMEDIATELY\n39:     LOCK_EX = 0x2  # LOCKFILE_EXCLUSIVE_LOCK\n40: \n41:     # --- Adapted from the pyserial project ---\n42:     # detect size of ULONG_PTR\n43:     if sizeof(c_ulong) != sizeof(c_void_p):\n44:         ULONG_PTR = c_int64\n45:     else:\n46:         ULONG_PTR = c_ulong\n47:     PVOID = c_void_p\n48: \n49:     # --- Union inside Structure by stackoverflow:3480240 ---\n50:     class _OFFSET(Structure):\n51:         _fields_ = [\n52:             ('Offset', DWORD),\n53:             ('OffsetHigh', DWORD)]\n54: \n55:     class _OFFSET_UNION(Union):\nCode replaced for brevity.\n59: \n60: \n61:     class OVERLAPPED(Structure):\nCode replaced for brevity.\n67: \n68: \n69:     LPOVERLAPPED = POINTER(OVERLAPPED)\n70: \n71:     # --- Define function prototypes for extra safety ---\n72:     LockFileEx = windll.kernel32.LockFileEx\n73:     LockFileEx.restype = BOOL\n74:     LockFileEx.argtypes = [HANDLE, DWORD, DWORD, DWORD, DWORD, LPOVERLAPPED]\n75:     UnlockFileEx = windll.kernel32.UnlockFileEx\n76:     UnlockFileEx.restype = BOOL\n77:     UnlockFileEx.argtypes = [HANDLE, DWORD, DWORD, DWORD, LPOVERLAPPED]\n78: \n79:     def lock(f, flags):\nCode replaced for brevity.\n83: \n84: \n85:     def unlock(f):\nCode replaced for brevity.\n89: else:\n90: else:\n91:     try:\n92:         import fcntl\n93:         LOCK_SH = fcntl.LOCK_SH  # shared lock\n94:         LOCK_NB = fcntl.LOCK_NB  # non-blocking\n95:         LOCK_EX = fcntl.LOCK_EX\n96:     except (ImportError, AttributeError):\n97:         # File locking is not supported.\n98:         LOCK_EX = LOCK_SH = LOCK_NB = 0\n99: \n100:         # Dummy functions that don't do anything.\n101:             # File is not locked\nCode replaced for brevity.\n103: \n104: \n105:         def unlock(f):\n106:             # File is unlocked\n107:             return True\n108:     else:\n109:         def lock(f, flags):\n110:             ret = fcntl.flock(_fd(f), flags)\n111:             return ret == 0\n112: \n113:         def unlock(f):\n114:             ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n115:             return ret == 0\n\n",
  "line_level_localization": [
    {
      "filename": "/django/core/files/locks.py",
      "suspect_lines": [
        110,
        111,
        114,
        115
      ]
    }
  ]
}