{
  "instance_id": "django__django-15916",
  "problem_statement": "Allow ModelForm meta to specify formfield_callback.\nDescription\n\t \n\t\t(last modified by Klaas-Jan Gorter)\n\t \nThe function django.forms.modelform_factory returns a form class based on the class it recieves as form argument. As an additional argument it accepts a formfield_callback function. When no callback is provided the class uses no callback instead of the formfield_callback of the base form provided.\nExample:\nfrom django import forms\nform django.db import models\nclass MyModel(forms.Model):\n\tactive = models.BooleanField()\n\tname = models.CharField(max_length=64, blank=True, null=True)\n\t\ndef all_required(field, **kwargs):\n\tformfield = field.formfield(**kwargs)\n\tformfield.required = True\n\treturn formfield\nclass MyForm(forms.ModelForm):\n\tformfield_callback = all_required\n\tclass Meta:\n\t\tmodel = MyModel\n\t\tformfield_callback = all_required\n\t\tfields = ['active', 'name']\nFactoryForm = forms.modelform_factory(MyModel, form=MyForm)\nThe expected behavior would be that the FactoryForm uses the formfield_callback specified in the Meta attribute of MyForm and that therefore the fields would be required in both the FactoryForm and MyForm. However, under the current behavior of modelform_factory the formfield_callback is overwritten (with the default argument None) before the new class is constructed and in FactoryForm the fields are not required.\nI believe this is a bug, because this behavior has been observed before in Ticket #18573 in Django 1.3. The test that was proposed there was incorrect, because under the expected behavior the callback should have been called four times not two times as was asserted. (I believe this test has been removed from version 2, because I find no equivalent test in tests/model_formsets_regress.)\n",
  "localized_code": "[start of django/forms/models.py]\n1: \"\"\"\n2: Helper functions for creating Form classes from Django models\n3: and database field objects.\n4: \"\"\"\n5: from itertools import chain\n6: \n7: from django.core.exceptions import (\n8:     NON_FIELD_ERRORS,\n9:     FieldError,\n10:     ImproperlyConfigured,\n11:     ValidationError,\n12: )\n13: from django.forms.fields import ChoiceField, Field\n14: from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass\n15: from django.forms.formsets import BaseFormSet, formset_factory\n16: from django.forms.utils import ErrorList\n17: from django.forms.widgets import (\n18:     HiddenInput,\n19:     MultipleHiddenInput,\n20:     RadioSelect,\n21:     SelectMultiple,\n22: )\n23: from django.utils.text import capfirst, get_text_list\n24: from django.utils.translation import gettext\n25: from django.utils.translation import gettext_lazy as _\n26: \n27: __all__ = (\n28:     \"ModelForm\",\n29:     \"BaseModelForm\",\n30:     \"model_to_dict\",\n31:     \"fields_for_model\",\n32:     \"ModelChoiceField\",\n33:     \"ModelMultipleChoiceField\",\n34:     \"ALL_FIELDS\",\n35:     \"BaseModelFormSet\",\n36:     \"modelformset_factory\",\n37:     \"BaseInlineFormSet\",\n38:     \"inlineformset_factory\",\n39:     \"modelform_factory\",\n40: )\n41: \n42: ALL_FIELDS = \"__all__\"\n43: \n44: \n45: def construct_instance(form, instance, fields=None, exclude=None):\n46:     \"\"\"\n47:     Construct and return a model instance from the bound ``form``'s\n48:     ``cleaned_data``, but do not save the returned instance to the database.\n49:     \"\"\"\n50:     from django.db import models\n51: \n52:     opts = instance._meta\n53: \n54:     cleaned_data = form.cleaned_data\n55:     file_field_list = []\n56:     for f in opts.fields:\n57:         if (\n58:             not f.editable\n59:             or isinstance(f, models.AutoField)\n60:             or f.name not in cleaned_data\n61:         ):\n62:             continue\n63:         if fields is not None and f.name not in fields:\n64:             continue\n65:         if exclude and f.name in exclude:\n66:             continue\n67:         # Leave defaults for fields that aren't in POST data, except for\n68:         # checkbox inputs because they don't appear in POST data if not checked.\n69:         if (\n70:             f.has_default()\n71:             and form[f.name].field.widget.value_omitted_from_data(\n72:                 form.data, form.files, form.add_prefix(f.name)\n73:             )\n74:             and cleaned_data.get(f.name) in form[f.name].field.empty_values\n75:         ):\n76:             continue\n77:         # Defer saving file-type fields until after the other fields, so a\n78:         # callable upload_to can use the values from other fields.\n79:         if isinstance(f, models.FileField):\n80:             file_field_list.append(f)\n81:         else:\n82:             f.save_form_data(instance, cleaned_data[f.name])\n83: \n84:     for f in file_field_list:\n85:         f.save_form_data(instance, cleaned_data[f.name])\n86: \n87:     return instance\n88: \n89: \n90: # ModelForms #################################################################\n91: \n92: \n93: def model_to_dict(instance, fields=None, exclude=None):\nCode replaced for brevity.\n115: \n116: \n117: \n118: def apply_limit_choices_to_to_formfield(formfield):\nCode replaced for brevity.\n132: \n133: \n134: \n135: ):\nCode replaced for brevity.\n242: \n243: \n244: \n245: class ModelFormOptions:\nCode replaced for brevity.\n255: \n256: \n257: \n258: class ModelFormMetaclass(DeclarativeFieldsMetaclass):\n259:     def __new__(mcs, name, bases, attrs):\n260:         base_formfield_callback = None\n261:         for b in bases:\n262:             if hasattr(b, \"Meta\") and hasattr(b.Meta, \"formfield_callback\"):\n263:                 base_formfield_callback = b.Meta.formfield_callback\n264:                 break\n265: \n266:         formfield_callback = attrs.pop(\"formfield_callback\", base_formfield_callback)\n267: \n268:         new_class = super().__new__(mcs, name, bases, attrs)\n269: \n270:         if bases == (BaseModelForm,):\n271:             return new_class\n272: \n273:         opts = new_class._meta = ModelFormOptions(getattr(new_class, \"Meta\", None))\n274: \n275:         # We check if a string was passed to `fields` or `exclude`,\n276:         # which is likely to be a mistake where the user typed ('foo') instead\n277:         # of ('foo',)\n278:         for opt in [\"fields\", \"exclude\", \"localized_fields\"]:\n279:             value = getattr(opts, opt)\n280:             if isinstance(value, str) and value != ALL_FIELDS:\n281:                 msg = (\n282:                     \"%(model)s.Meta.%(opt)s cannot be a string. \"\n283:                     \"Did you mean to type: ('%(value)s',)?\"\n284:                     % {\n285:                         \"model\": new_class.__name__,\n286:                         \"opt\": opt,\n287:                         \"value\": value,\n288:                     }\n289:                 )\n290:                 raise TypeError(msg)\n291: \n292:         if opts.model:\n293:             # If a model is defined, extract form fields from it.\n294:             if opts.fields is None and opts.exclude is None:\n295:                 raise ImproperlyConfigured(\n296:                     \"Creating a ModelForm without either the 'fields' attribute \"\n297:                     \"or the 'exclude' attribute is prohibited; form %s \"\n298:                     \"needs updating.\" % name\n299:                 )\n300: \n301:             if opts.fields == ALL_FIELDS:\n302:                 # Sentinel for fields_for_model to indicate \"get the list of\n303:                 # fields from the model\"\n304:                 opts.fields = None\n305: \n306:             fields = fields_for_model(\n307:                 opts.model,\n308:                 opts.fields,\n309:                 opts.exclude,\n310:                 opts.widgets,\n311:                 formfield_callback,\n312:                 opts.localized_fields,\n313:                 opts.labels,\n314:                 opts.help_texts,\n315:                 opts.error_messages,\n316:                 opts.field_classes,\n317:                 # limit_choices_to will be applied during ModelForm.__init__().\n318:                 apply_limit_choices_to=False,\n319:             )\n320: \n321:             # make sure opts.fields doesn't specify an invalid field\n322:             none_model_fields = {k for k, v in fields.items() if not v}\n323:             missing_fields = none_model_fields.difference(new_class.declared_fields)\n324:             if missing_fields:\n325:                 message = \"Unknown field(s) (%s) specified for %s\"\n326:                 message = message % (\", \".join(missing_fields), opts.model.__name__)\n327:                 raise FieldError(message)\n328:             # Override default model fields with any custom declared ones\n329:             # (plus, include all the other declared fields).\n330:             fields.update(new_class.declared_fields)\n331:         else:\n332:             fields = new_class.declared_fields\n333: \n334:         new_class.base_fields = fields\n335: \n336:         return new_class\n337: \n338: \n339: class BaseModelForm(BaseForm):\nCode replaced for brevity.\n556: \n557: \n558: \n559: class ModelForm(BaseModelForm, metaclass=ModelFormMetaclass):\n560:     pass\n561: \n562: \n563: def modelform_factory(\n564:     model,\n565:     form=ModelForm,\n566:     fields=None,\n567:     exclude=None,\n568:     formfield_callback=None,\n569:     widgets=None,\n570:     localized_fields=None,\n571:     labels=None,\n572:     help_texts=None,\n573:     error_messages=None,\n574:     field_classes=None,\n575: ):\n576:     \"\"\"\n577:     Return a ModelForm containing form fields for the given model. You can\n578:     optionally pass a `form` argument to use as a starting point for\n579:     constructing the ModelForm.\n580: \n581:     ``fields`` is an optional list of field names. If provided, include only\n582:     the named fields in the returned fields. If omitted or '__all__', use all\n583:     fields.\n584: \n585:     ``exclude`` is an optional list of field names. If provided, exclude the\n586:     named fields from the returned fields, even if they are listed in the\n587:     ``fields`` argument.\n588: \n589:     ``widgets`` is a dictionary of model field names mapped to a widget.\n590: \n591:     ``localized_fields`` is a list of names of fields which should be localized.\n592: \n593:     ``formfield_callback`` is a callable that takes a model field and returns\n594:     a form field.\n595: \n596:     ``labels`` is a dictionary of model field names mapped to a label.\n597: \n598:     ``help_texts`` is a dictionary of model field names mapped to a help text.\n599: \n600:     ``error_messages`` is a dictionary of model field names mapped to a\n601:     dictionary of error messages.\n602: \n603:     ``field_classes`` is a dictionary of model field names mapped to a form\n604:     field class.\n605:     \"\"\"\n606:     # Create the inner Meta class. FIXME: ideally, we should be able to\n607:     # construct a ModelForm without creating and passing in a temporary\n608:     # inner class.\n609: \n610:     # Build up a list of attributes that the Meta object will have.\n611:     attrs = {\"model\": model}\n612:     if fields is not None:\n613:         attrs[\"fields\"] = fields\n614:     if exclude is not None:\n615:         attrs[\"exclude\"] = exclude\n616:     if widgets is not None:\n617:         attrs[\"widgets\"] = widgets\n618:     if localized_fields is not None:\n619:         attrs[\"localized_fields\"] = localized_fields\n620:     if labels is not None:\n621:         attrs[\"labels\"] = labels\n622:     if help_texts is not None:\n623:         attrs[\"help_texts\"] = help_texts\n624:     if error_messages is not None:\n625:         attrs[\"error_messages\"] = error_messages\n626:     if field_classes is not None:\n627:         attrs[\"field_classes\"] = field_classes\n628: \n629:     # If parent form class already has an inner Meta, the Meta we're\n630:     # creating needs to inherit from the parent's inner meta.\n631:     bases = (form.Meta,) if hasattr(form, \"Meta\") else ()\n632:     Meta = type(\"Meta\", bases, attrs)\n633:     if formfield_callback:\n634:         Meta.formfield_callback = staticmethod(formfield_callback)\n635:     # Give this new form class a reasonable name.\n636:     class_name = model.__name__ + \"Form\"\n637: \n638:     # Class attributes for the new form class.\n639:     form_class_attrs = {\"Meta\": Meta, \"formfield_callback\": formfield_callback}\n640: \n641:     if getattr(Meta, \"fields\", None) is None and getattr(Meta, \"exclude\", None) is None:\n642:         raise ImproperlyConfigured(\n643:             \"Calling modelform_factory without defining 'fields' or \"\n644:             \"'exclude' explicitly is prohibited.\"\n645:         )\n646: \n647:     # Instantiate type(form) in order to use the same metaclass as form.\n648:     return type(form)(class_name, (form,), form_class_attrs)\n649: \n650: \n651: # ModelFormSets ##############################################################\n652: \n653: \n654: class BaseModelFormSet(BaseFormSet):\nCode replaced for brevity.\n1003: \n1004: \n1005: \n1006: ):\nCode replaced for brevity.\n1071: \n1072: \n1073: \n1074: # InlineFormSets #############################################################\n1075: \n1076: \n1077: class BaseInlineFormSet(BaseModelFormSet):\nCode replaced for brevity.\n1185: \n1186: \n1187: \n1188: def _get_foreign_key(parent_model, model, fk_name=None, can_fail=False):\nCode replaced for brevity.\n1264: \n1265: \n1266: \n1267: ):\nCode replaced for brevity.\n1330: \n1331: \n1332: \n1333: # Fields #####################################################################\n1334: \n1335: \n1336: class InlineForeignKeyField(Field):\nCode replaced for brevity.\n1377: \n1378: \n1379: \n1380: class ModelChoiceIteratorValue:\nCode replaced for brevity.\n1394: \n1395: \n1396: \n1397: class ModelChoiceIterator:\nCode replaced for brevity.\n1425: \n1426: \n1427: \n1428: class ModelChoiceField(ChoiceField):\nCode replaced for brevity.\n1561: \n1562: \n1563: \n1564: class ModelMultipleChoiceField(ModelChoiceField):\nCode replaced for brevity.\n1660: \n1661: \n1662: \n1663:     retu\nCode replaced for brevity.\n1666: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/forms/models.py",
      "suspect_lines": [
        260,
        261,
        262,
        263,
        264,
        265,
        266,
        267,
        311,
        639
      ]
    }
  ]
}