{
  "instance_id": "django__django-14765",
  "problem_statement": "ProjectState.__init__() can assume its real_apps argument is a set\nDescription\n\t\n​PR #14760 made all calls to ProjectState.__init__() pass real_apps as a set. In ​ProjectState.__init__() now, then, instead of checking that real_apps is a set and converting it to a set if not, it can just assert that it's a set when non-None. (Presumably the construction of new ProjectState objects is part of Django's internal API.) I had made this comment on the PR, but it wasn't important enough to hold up the PR because another PR was depending on it getting merged.\n",
  "localized_code": "[start of django/db/migrations/state.py]\n1: import copy\n2: from collections import defaultdict\n3: from contextlib import contextmanager\n4: from functools import partial\n5: \n6: from django.apps import AppConfig\n7: from django.apps.registry import Apps, apps as global_apps\n8: from django.conf import settings\n9: from django.core.exceptions import FieldDoesNotExist\n10: from django.db import models\n11: from django.db.migrations.utils import field_is_referenced, get_references\n12: from django.db.models import NOT_PROVIDED\n13: from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n14: from django.db.models.options import DEFAULT_NAMES, normalize_together\n15: from django.db.models.utils import make_model_tuple\n16: from django.utils.functional import cached_property\n17: from django.utils.module_loading import import_string\n18: from django.utils.version import get_docs_version\n19: \n20: from .exceptions import InvalidBasesError\n21: from .utils import resolve_relation\n22: \n23: \n24: def _get_app_label_and_model_name(model, app_label=''):\n25:     if isinstance(model, str):\n26:         split = model.split('.', 1)\n27:         return tuple(split) if len(split) == 2 else (app_label, split[0])\n28:     else:\n29:         return model._meta.app_label, model._meta.model_name\n30: \n31: \n32: def _get_related_models(m):\n33:     \"\"\"Return all models that have a direct relationship to the given model.\"\"\"\n34:     related_models = [\n35:         subclass for subclass in m.__subclasses__()\n36:         if issubclass(subclass, models.Model)\n37:     ]\n38:     related_fields_models = set()\n39:     for f in m._meta.get_fields(include_parents=True, include_hidden=True):\n40:         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):\n41:             related_fields_models.add(f.model)\n42:             related_models.append(f.related_model)\n43:     # Reverse accessors of foreign keys to proxy models are attached to their\n44:     # concrete proxied model.\n45:     opts = m._meta\n46:     if opts.proxy and m in related_fields_models:\n47:         related_models.append(opts.concrete_model)\n48:     return related_models\n49: \n50: \n51: def get_related_models_tuples(model):\nCode replaced for brevity.\n59: \n60: \n61: \n62: def get_related_models_recursive(model):\nCode replaced for brevity.\n81: \n82: \n83: \n84: class ProjectState:\n85:     \"\"\"\n86:     Represent the entire project's overall state. This is the item that is\n87:     passed around - do it here rather than at the app level so that cross-app\n88:     FKs/etc. resolve properly.\n89:     \"\"\"\n90: \n91:     def __init__(self, models=None, real_apps=None):\n92:         self.models = models or {}\n93:         # Apps to include from main registry, usually unmigrated ones\n94:         if real_apps:\n95:             self.real_apps = real_apps if isinstance(real_apps, set) else set(real_apps)\n96:         else:\n97:             self.real_apps = set()\n98:         self.is_delayed = False\n99:         # {remote_model_key: {model_key: [(field_name, field)]}}\n100:         self.relations = None\n101: \n102:     def add_model(self, model_state):\n103:         app_label, model_name = model_state.app_label, model_state.name_lower\n104:         self.models[(app_label, model_name)] = model_state\n105:         if 'apps' in self.__dict__:  # hasattr would cache the property\n106:             self.reload_model(app_label, model_name)\n107: \n108:     def remove_model(self, app_label, model_name):\n109:         del self.models[app_label, model_name]\n110:         if 'apps' in self.__dict__:  # hasattr would cache the property\n111:             self.apps.unregister_model(app_label, model_name)\n112:             # Need to do this explicitly since unregister_model() doesn't clear\n113:             # the cache automatically (#24513)\n114:             self.apps.clear_cache()\n115: \n116:     def rename_model(self, app_label, old_name, new_name):\n117:         # Add a new model.\n118:         old_name_lower = old_name.lower()\n119:         new_name_lower = new_name.lower()\n120:         renamed_model = self.models[app_label, old_name_lower].clone()\n121:         renamed_model.name = new_name\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/django/db/migrations/state.py",
      "suspect_lines": [
        94,
        95,
        97
      ]
    }
  ]
}