{
  "instance_id": "sympy__sympy-20438",
  "problem_statement": "`is_subset` gives wrong results\n@sylee957 Current status on `master`,\r\n```python\r\n>>> a = FiniteSet(1, 2)\r\n>>> b = ProductSet(a, a)\r\n>>> c = FiniteSet((1, 1), (1, 2), (2, 1), (2, 2))\r\n>>> b.intersection(c) == c.intersection(b)\r\nTrue\r\n>>> b.is_subset(c)\r\n>>> c.is_subset(b)\r\nTrue\r\n>>> Eq(b, c).simplify()\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.6/code.py\", line 91, in runcode\r\n    exec(code, self.locals)\r\n  File \"<console>\", line 1, in <module>\r\n  File \"/home/czgdp1807ssd/sympy_project/sympy/sympy/core/basic.py\", line 1655, in simplify\r\n    return simplify(self, **kwargs)\r\n  File \"/home/czgdp1807ssd/sympy_project/sympy/sympy/simplify/simplify.py\", line 559, in simplify\r\n    return _eval_simplify(**kwargs)\r\n  File \"/home/czgdp1807ssd/sympy_project/sympy/sympy/core/relational.py\", line 646, in _eval_simplify\r\n    e = super(Equality, self)._eval_simplify(**kwargs)\r\n  File \"/home/czgdp1807ssd/sympy_project/sympy/sympy/core/relational.py\", line 308, in _eval_simplify\r\n    elif dif.equals(0):  # XXX this is expensive\r\nAttributeError: 'Complement' object has no attribute 'equals'\r\n>>> b.rewrite(FiniteSet)\r\n      2\r\n{1, 2} \r\n>>> \r\n```\r\n\r\n_Originally posted by @czgdp1807 in https://github.com/sympy/sympy/pull/16764#issuecomment-592606532_\n",
  "localized_code": "[start of sympy/core/relational.py]\n1: from typing import Dict, Union, Type\n2: \n3: from sympy.utilities.exceptions import SymPyDeprecationWarning\n4: from .basic import S, Atom\n5: from .compatibility import ordered\n6: from .basic import Basic\n7: from .evalf import EvalfMixin\n8: from .function import AppliedUndef\n9: from .sympify import _sympify, SympifyError\n10: from .parameters import global_parameters\n11: from sympy.core.logic import fuzzy_bool, fuzzy_xor, fuzzy_and, fuzzy_not\n12: from sympy.logic.boolalg import Boolean, BooleanAtom\n13: \n14: __all__ = (\n15:     'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge',\n16:     'Relational', 'Equality', 'Unequality', 'StrictLessThan', 'LessThan',\n17:     'StrictGreaterThan', 'GreaterThan',\n18: )\n19: \n20: from .expr import Expr\n21: from sympy.multipledispatch import dispatch\n22: from .containers import Tuple\n23: from .symbol import Symbol\n24: \n25: \n26: def _nontrivBool(side):\n27:     return isinstance(side, Boolean) and \\\n28:            not isinstance(side, Atom)\n29: \n30: \n31: # Note, see issue 4986.  Ideally, we wouldn't want to subclass both Boolean\n32: # and Expr.\n33: # from .. import Expr\n34: \n35: \n36: def _canonical(cond):\n37:     # return a condition in which all relationals are canonical\n38:     reps = {r: r.canonical for r in cond.atoms(Relational)}\n39:     return cond.xreplace(reps)\n40:     # XXX: AttributeError was being caught here but it wasn't triggered by any of\n41:     # the tests so I've removed it...\n42: \n43: \n44: class Relational(Boolean, EvalfMixin):\n45:     \"\"\"Base class for all relation types.\n46: \n47:     Explanation\n48:     ===========\n49: \n50:     Subclasses of Relational should generally be instantiated directly, but\n51:     Relational can be instantiated with a valid ``rop`` value to dispatch to\n... Code Truncated ...\n\n[start of sympy/sets/handlers/comparison.py]\n1: from sympy.core.relational import Eq, is_eq\n2: from sympy.core.basic import Basic\n3: from sympy.core.logic import fuzzy_and, fuzzy_bool\n4: from sympy.logic.boolalg import And\n5: from sympy.multipledispatch import dispatch\n6: from sympy.sets.sets import tfn, ProductSet, Interval, FiniteSet, Set\n7: \n8: \n9: @dispatch(Interval, FiniteSet) # type:ignore\n10: def _eval_is_eq(lhs, rhs): # noqa: F811\n11:     return False\n12: \n13: \n14: @dispatch(FiniteSet, Interval) # type:ignore\n15: def _eval_is_eq(lhs, rhs): # noqa: F811\n16:     return False\n17: \n18: \n19: @dispatch(Interval, Interval) # type:ignore\n20: def _eval_is_eq(lhs, rhs): # noqa: F811\n21:     return And(Eq(lhs.left, rhs.left),\n22:                Eq(lhs.right, rhs.right),\n23:                lhs.left_open == rhs.left_open,\n24:                lhs.right_open == rhs.right_open)\n25: \n26: \n27: @dispatch(FiniteSet, Interval) # type:ignore\n28: def _eval_is_eq(lhs, rhs): # noqa: F811\n29:     return False\n30: \n31: \n32: @dispatch(FiniteSet, FiniteSet) # type:ignore\n33: def _eval_is_eq(lhs, rhs): # noqa: F811\n34:     def all_in_both():\n35:         s_set = set(lhs.args)\n36:         o_set = set(rhs.args)\n37:         yield fuzzy_and(lhs._contains(e) for e in o_set - s_set)\n38:         yield fuzzy_and(rhs._contains(e) for e in s_set - o_set)\n39: \n40:     return tfn[fuzzy_and(all_in_both())]\n41: \n42: \n43: @dispatch(ProductSet, ProductSet) # type:ignore\n44: def _eval_is_eq(lhs, rhs): # noqa: F811\n45:     if len(lhs.sets) != len(rhs.sets):\n46:         return False\n47: \n48:     eqs = (is_eq(x, y) for x, y in zip(lhs.sets, rhs.sets))\n49:     return tfn[fuzzy_and(map(fuzzy_bool, eqs))]\n50: \n51: \n52: @dispatch(Set, Basic) # type:ignore\n53: def _eval_is_eq(lhs, rhs): # noqa: F811\n54:     return False\n55: \n56: \n57: @dispatch(Set, Set) # type:ignore\n58: def _eval_is_eq(lhs, rhs): # noqa: F811\n59:     return None\n\n[start of sympy/sets/handlers/issubset.py]\n1: from sympy import S, Symbol\n2: from sympy.core.logic import fuzzy_and, fuzzy_bool, fuzzy_not, fuzzy_or\n3: from sympy.core.relational import Eq\n4: from sympy.sets.sets import FiniteSet, Interval, Set, Union\n5: from sympy.sets.fancysets import Complexes, Reals, Range, Rationals\n6: from sympy.multipledispatch import dispatch\n7: \n8: \n9: _inf_sets = [S.Naturals, S.Naturals0, S.Integers, S.Rationals, S.Reals, S.Complexes]\n10: \n11: @dispatch(Set, Set)  # type: ignore # noqa:F811\n12: def is_subset_sets(a, b): # noqa:F811\n13:     return None\n14: \n15: @dispatch(Interval, Interval)  # type: ignore # noqa:F811\n16: def is_subset_sets(a, b): # noqa:F811\n17:     # This is correct but can be made more comprehensive...\n18:     if fuzzy_bool(a.start < b.start):\n19:         return False\n20:     if fuzzy_bool(a.end > b.end):\n21:         return False\n22:     if (b.left_open and not a.left_open and fuzzy_bool(Eq(a.start, b.start))):\n23:         return False\n24:     if (b.right_open and not a.right_open and fuzzy_bool(Eq(a.end, b.end))):\n25:         return False\n26: \n27: @dispatch(Interval, FiniteSet)  # type: ignore # noqa:F811\n28: def is_subset_sets(a_interval, b_fs): # noqa:F811\n29:     # An Interval can only be a subset of a finite set if it is finite\n30:     # which can only happen if it has zero measure.\n31:     if fuzzy_not(a_interval.measure.is_zero):\n32:         return False\n33: \n34: @dispatch(Interval, Union)  # type: ignore # noqa:F811\n35: def is_subset_sets(a_interval, b_u): # noqa:F811\n36:     if all(isinstance(s, (Interval, FiniteSet)) for s in b_u.args):\n37:         intervals = [s for s in b_u.args if isinstance(s, Interval)]\n38:         if all(fuzzy_bool(a_interval.start < s.start) for s in intervals):\n39:             return False\n40:         if all(fuzzy_bool(a_interval.end > s.end) for s in intervals):\n41:             return False\n42:         if a_interval.measure.is_nonzero:\n43:             no_overlap = lambda s1, s2: fuzzy_or([\n44:                     fuzzy_bool(s1.end <= s2.start),\n45:                     fuzzy_bool(s1.start >= s2.end),\n46:                     ])\n47:             if all(no_overlap(s, a_interval) for s in intervals):\n48:                 return False\n49: \n50: @dispatch(Range, Range)  # type: ignore # noqa:F811\n51: def is_subset_sets(a, b): # noqa:F811\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/relational.py",
      "suspect_lines": []
    },
    {
      "filename": "/sympy/sets/handlers/comparison.py",
      "suspect_lines": [
        26,
        27,
        28,
        29,
        30,
        31,
        59
      ]
    },
    {
      "filename": "/sympy/sets/handlers/issubset.py",
      "suspect_lines": [
        4
      ]
    }
  ]
}