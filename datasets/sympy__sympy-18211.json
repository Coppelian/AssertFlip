{
  "instance_id": "sympy__sympy-18211",
  "problem_statement": "`solveset` raises `NotImplementedError` instead of returning `ConditionSet`\nThe problem is\r\n```julia\r\nIn [10]: Eq(n*cos(n) - 3*sin(n), 0).as_set()                                                                                                                  \r\n---------------------------------------------------------------------------\r\nNotImplementedError\r\n```\r\nHere `solveset` raises `NotImplementedError` but probably a `ConditionSet` should be returned by `solveset` instead. The obvious result of `as_set()` here is\r\n```julia\r\nIn [11]: ConditionSet(n, Eq(n*cos(n) - 3*sin(n), 0), Reals)                                                                                                   \r\nOut[11]: {n | n ∊ ℝ ∧ n⋅cos(n) - 3⋅sin(n) = 0}\r\n```\r\n\r\n_Originally posted by @oscarbenjamin in https://github.com/sympy/sympy/pull/17771_\n",
  "localized_code": "[start of sympy/core/relational.py]\n1: from __future__ import print_function, division\n2: \n3: from sympy.utilities.exceptions import SymPyDeprecationWarning\n4: from .add import _unevaluated_Add, Add\n5: from .basic import S\n6: from .compatibility import ordered\n7: from .basic import Basic\n8: from .expr import Expr\n9: from .evalf import EvalfMixin\n10: from .sympify import _sympify\n11: from .parameters import global_parameters\n12: \n13: from sympy.logic.boolalg import Boolean, BooleanAtom\n14: \n15: __all__ = (\n16:     'Rel', 'Eq', 'Ne', 'Lt', 'Le', 'Gt', 'Ge',\n17:     'Relational', 'Equality', 'Unequality', 'StrictLessThan', 'LessThan',\n18:     'StrictGreaterThan', 'GreaterThan',\n19: )\n20: \n21: \n22: \n23: # Note, see issue 4986.  Ideally, we wouldn't want to subclass both Boolean\n24: # and Expr.\n25: \n26: def _canonical(cond):\n27:     # return a condition in which all relationals are canonical\n28:     reps = {r: r.canonical for r in cond.atoms(Relational)}\n29:     return cond.xreplace(reps)\n30:     # XXX: AttributeError was being caught here but it wasn't triggered by any of\n31:     # the tests so I've removed it...\n32: \n33: \n34: class Relational(Boolean, EvalfMixin):\n35:     \"\"\"Base class for all relation types.\n36: \n37:     Subclasses of Relational should generally be instantiated directly, but\n38:     Relational can be instantiated with a valid ``rop`` value to dispatch to\n39:     the appropriate subclass.\n40: \n41:     Parameters\n42:     ==========\n43:     rop : str or None\n44:         Indicates what subclass to instantiate.  Valid values can be found\n45:         in the keys of Relational.ValidRelationalOperator.\n46: \n47:     Examples\n48:     ========\n49: \n50:     >>> from sympy import Rel\n51:     >>> from sympy.abc import x, y\n52:     >>> Rel(y, x + x**2, '==')\n53:     Eq(y, x**2 + x)\n54: \n55:     \"\"\"\n56:     __slots__ = []\n57: \n58:     is_Relational = True\n59: \n60:     # ValidRelationOperator - Defined below, because the necessary classes\n61:     #   have not yet been defined\n62: \n63:     def __new__(cls, lhs, rhs, rop=None, **assumptions):\n64:         # If called by a subclass, do nothing special and pass on to Basic.\n65:         if cls is not Relational:\n66:             return Basic.__new__(cls, lhs, rhs, **assumptions)\n67: \n68:         # XXX: Why do this? There should be a separate function to make a\n69:         # particular subclass of Relational from a string.\n70:         #\n71:         # If called directly with an operator, look up the subclass\n72:         # corresponding to that operator and delegate to it\n73:         cls = cls.ValidRelationOperator.get(rop, None)\n74:         if cls is None:\n75:             raise ValueError(\"Invalid relational operator symbol: %r\" % rop)\n76: \n77:         # XXX: Why should the below be removed when Py2 is not supported?\n78:         #\n79:         # /// drop when Py2 is no longer supported\n80:         if not issubclass(cls, (Eq, Ne)):\n81:             # validate that Booleans are not being used in a relational\n82:             # other than Eq/Ne;\n83:             # Note: Symbol is a subclass of Boolean but is considered\n84:             # acceptable here.\n85:             from sympy.core.symbol import Symbol\n86:             from sympy.logic.boolalg import Boolean\n87:             def unacceptable(side):\n88:                 return isinstance(side, Boolean) and not isinstance(side, Symbol)\n89: \n90:             if unacceptable(lhs) or unacceptable(rhs):\n91:                 from sympy.utilities.misc import filldedent\n92:                 raise TypeError(filldedent('''\n93:                     A Boolean argument can only be used in\n94:                     Eq and Ne; all other relationals expect\n95:                     real expressions.\n96:                 '''))\n97:         # \\\\\\\n98: \n99:         return cls(lhs, rhs, **assumptions)\n100: \n101:     @property\n102:     def lhs(self):\n103:         \"\"\"The left-hand side of the relation.\"\"\"\n104:         return self._args[0]\n105: \n106:     @property\n107:     def rhs(self):\n108:         \"\"\"The right-hand side of the relation.\"\"\"\n109:         return self._args[1]\n110: \n111:     @property\n112:     def reversed(self):\n113:         \"\"\"Return the relationship with sides reversed.\n114: \n115:         Examples\n116:         ========\n117: \n118:         >>> from sympy import Eq\n119:         >>> from sympy.abc import x\n120:         >>> Eq(x, 1)\n121:         Eq(x, 1)\n122:         >>> _.reversed\n123:         Eq(1, x)\n124:         >>> x < 1\n125:         x < 1\n126:         >>> _.reversed\n127:         1 > x\n128:         \"\"\"\n129:         ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}\n130:         a, b = self.args\n131:         return Relational.__new__(ops.get(self.func, self.func), b, a)\n132: \n133:     @property\n134:     def reversedsign(self):\n135:         \"\"\"Return the relationship with signs reversed.\n136: \n137:         Examples\n138:         ========\n139: \n140:         >>> from sympy import Eq\n141:         >>> from sympy.abc import x\n142:         >>> Eq(x, 1)\n143:         Eq(x, 1)\n144:         >>> _.reversedsign\n145:         Eq(-x, -1)\n146:         >>> x < 1\n147:         x < 1\n148:         >>> _.reversedsign\n149:         -x > -1\n150:         \"\"\"\n151:         a, b = self.args\n152:         if not (isinstance(a, BooleanAtom) or isinstance(b, BooleanAtom)):\n153:             ops = {Eq: Eq, Gt: Lt, Ge: Le, Lt: Gt, Le: Ge, Ne: Ne}\n154:             return Relational.__new__(ops.get(self.func, self.func), -a, -b)\n155:         else:\n156:             return self\n157: \n158:     @property\n159:     def negated(self):\n160:         \"\"\"Return the negated relationship.\n161: \n162:         Examples\n163:         ========\n164: \n165:         >>> from sympy import Eq\n166:         >>> from sympy.abc import x\n167:         >>> Eq(x, 1)\n168:         Eq(x, 1)\n169:         >>> _.negated\n170:         Ne(x, 1)\n171:         >>> x < 1\n172:         x < 1\n173:         >>> _.negated\n174:         x >= 1\n175: \n176:         Notes\n177:         =====\n178: \n179:         This works more or less identical to ``~``/``Not``. The difference is\n180:         that ``negated`` returns the relationship even if ``evaluate=False``.\n181:         Hence, this is useful in code when checking for e.g. negated relations\n182:         to existing ones as it will not be affected by the `evaluate` flag.\n183: \n184:         \"\"\"\n185:         ops = {Eq: Ne, Ge: Lt, Gt: Le, Le: Gt, Lt: Ge, Ne: Eq}\n186:         # If there ever will be new Relational subclasses, the following line\n187:         # will work until it is properly sorted out\n188:         # return ops.get(self.func, lambda a, b, evaluate=False: ~(self.func(a,\n189:         #      b, evaluate=evaluate)))(*self.args, evaluate=False)\n190:         return Relational.__new__(ops.get(self.func), *self.args)\n191: \n192:     def _eval_evalf(self, prec):\n193:         return self.func(*[s._evalf(prec) for s in self.args])\n194: \n195:     @property\n196:     def canonical(self):\n197:         \"\"\"Return a canonical form of the relational by putting a\n198:         Number on the rhs else ordering the args. The relation is also changed\n199:         so that the left-hand side expression does not start with a ``-``.\n200:         No other simplification is attempted.\n201: \n202:         Examples\n203:         ========\n204: \n205:         >>> from sympy.abc import x, y\n206:         >>> x < 2\n207:         x < 2\n208:         >>> _.reversed.canonical\n209:         x < 2\n210:         >>> (-y < x).canonical\n211:         x > -y\n212:         >>> (-y > x).canonical\n213:         x < -y\n214:         \"\"\"\n215:         args = self.args\n216:         r = self\n217:         if r.rhs.is_number:\n218:             if r.rhs.is_Number and r.lhs.is_Number and r.lhs > r.rhs:\n219:                 r = r.reversed\n220:         elif r.lhs.is_number:\n221:             r = r.reversed\n222:         elif tuple(ordered(args)) != args:\n223:             r = r.reversed\n224: \n225:         LHS_CEMS = getattr(r.lhs, 'could_extract_minus_sign', None)\n226:         RHS_CEMS = getattr(r.rhs, 'could_extract_minus_sign', None)\n227: \n228:         if isinstance(r.lhs, BooleanAtom) or isinstance(r.rhs, BooleanAtom):\n229:             return r\n230: \n231:         # Check if first value has negative sign\n232:         if LHS_CEMS and LHS_CEMS():\n233:             return r.reversedsign\n234:         elif not r.rhs.is_number and RHS_CEMS and RHS_CEMS():\n235:             # Right hand side has a minus, but not lhs.\n236:             # How does the expression with reversed signs behave?\n237:             # This is so that expressions of the type\n238:             # Eq(x, -y) and Eq(-x, y)\n239:             # have the same canonical representation\n240:             expr1, _ = ordered([r.lhs, -r.rhs])\n241:             if expr1 != r.lhs:\n242:                 return r.reversed.reversedsign\n243: \n244:         return r\n245: \n246:     def equals(self, other, failing_expression=False):\n247:         \"\"\"Return True if the sides of the relationship are mathematically\n248:         identical and the type of relationship is the same.\n249:         If failing_expression is True, return the expression whose truth value\n250:         was unknown.\"\"\"\n251:         if isinstance(other, Relational):\n252:             if self == other or self.reversed == other:\n253:                 return True\n254:             a, b = self, other\n255:             if a.func in (Eq, Ne) or b.func in (Eq, Ne):\n256:                 if a.func != b.func:\n257:                     return False\n258:                 left, right = [i.equals(j,\n259:                                         failing_expression=failing_expression)\n260:                                for i, j in zip(a.args, b.args)]\n261:                 if left is True:\n262:                     return right\n263:                 if right is True:\n264:                     return left\n265:                 lr, rl = [i.equals(j, failing_expression=failing_expression)\n266:                           for i, j in zip(a.args, b.reversed.args)]\n267:                 if lr is True:\n268:                     return rl\n269:                 if rl is True:\n270:                     return lr\n271:                 e = (left, right, lr, rl)\n272:                 if all(i is False for i in e):\n273:                     return False\n274:                 for i in e:\n275:                     if i not in (True, False):\n276:                         return i\n277:             else:\n278:                 if b.func != a.func:\n279:                     b = b.reversed\n280:                 if a.func != b.func:\n281:                     return False\n282:                 left = a.lhs.equals(b.lhs,\n283:                                     failing_expression=failing_expression)\n284:                 if left is False:\n285:                     return False\n286:                 right = a.rhs.equals(b.rhs,\n287:                                      failing_expression=failing_expression)\n288:                 if right is False:\n289:                     return False\n290:                 if left is True:\n291:                     return right\n292:                 return left\n293: \n294:     def _eval_simplify(self, **kwargs):\n295:         r = self\n296:         r = r.func(*[i.simplify(**kwargs) for i in r.args])\n297:         if r.is_Relational:\n298:             dif = r.lhs - r.rhs\n299:             # replace dif with a valid Number that will\n300:             # allow a definitive comparison with 0\n301:             v = None\n302:             if dif.is_comparable:\n303:                 v = dif.n(2)\n304:             elif dif.equals(0):  # XXX this is expensive\n305:                 v = S.Zero\n306:             if v is not None:\n307:                 r = r.func._eval_relation(v, S.Zero)\n308:             r = r.canonical\n309:             # If there is only one symbol in the expression,\n310:             # try to write it on a simplified form\n311:             free = list(filter(lambda x: x.is_real is not False, r.free_symbols))\n312:             if len(free) == 1:\n313:                 try:\n314:                     from sympy.solvers.solveset import linear_coeffs\n315:                     x = free.pop()\n316:                     dif = r.lhs - r.rhs\n317:                     m, b = linear_coeffs(dif, x)\n318:                     if m.is_zero is False:\n319:                         if m.is_negative:\n320:                             # Dividing with a negative number, so change order of arguments\n321:                             # canonical will put the symbol back on the lhs later\n322:                             r = r.func(-b/m, x)\n323:                         else:\n324:                             r = r.func(x, -b/m)\n325:                     else:\n326:                         r = r.func(b, S.zero)\n327:                 except ValueError:\n328:                     # maybe not a linear function, try polynomial\n329:                     from sympy.polys import Poly, poly, PolynomialError, gcd\n330:                     try:\n331:                         p = poly(dif, x)\n332:                         c = p.all_coeffs()\n333:                         constant = c[-1]\n334:                         c[-1] = 0\n335:                         scale = gcd(c)\n336:                         c = [ctmp/scale for ctmp in c]\n337:                         r = r.func(Poly.from_list(c, x).as_expr(), -constant/scale)\n338:                     except PolynomialError:\n339:                         pass\n340:             elif len(free) >= 2:\n341:                 try:\n342:                     from sympy.solvers.solveset import linear_coeffs\n343:                     from sympy.polys import gcd\n344:                     free = list(ordered(free))\n345:                     dif = r.lhs - r.rhs\n346:                     m = linear_coeffs(dif, *free)\n347:                     constant = m[-1]\n348:                     del m[-1]\n349:                     scale = gcd(m)\n350:                     m = [mtmp/scale for mtmp in m]\n351:                     nzm = list(filter(lambda f: f[0] != 0, list(zip(m, free))))\n352:                     if scale.is_zero is False:\n353:                         if constant != 0:\n354:                             # lhs: expression, rhs: constant\n355:                             newexpr = Add(*[i*j for i, j in nzm])\n356:                             r = r.func(newexpr, -constant/scale)\n357:                         else:\n358:                             # keep first term on lhs\n359:                             lhsterm = nzm[0][0]*nzm[0][1]\n360:                             del nzm[0]\n361:                             newexpr = Add(*[i*j for i, j in nzm])\n362:                             r = r.func(lhsterm, -newexpr)\n363: \n364:                     else:\n365:                         r = r.func(constant, S.zero)\n366:                 except ValueError:\n367:                     pass\n368:         # Did we get a simplified result?\n369:         r = r.canonical\n370:         measure = kwargs['measure']\n371:         if measure(r) < kwargs['ratio']*measure(self):\n372:             return r\n373:         else:\n374:             return self\n375: \n376:     def _eval_trigsimp(self, **opts):\n377:         from sympy.simplify import trigsimp\n378:         return self.func(trigsimp(self.lhs, **opts), trigsimp(self.rhs, **opts))\n379: \n380:     def expand(self, **kwargs):\n381:         args = (arg.expand(**kwargs) for arg in self.args)\n382:         return self.func(*args)\n383: \n384:     def __nonzero__(self):\n385:         raise TypeError(\"cannot determine truth value of Relational\")\n386: \n387:     __bool__ = __nonzero__\n388: \n389:     def _eval_as_set(self):\n390:         # self is univariate and periodicity(self, x) in (0, None)\n391:         from sympy.solvers.inequalities import solve_univariate_inequality\n392:         syms = self.free_symbols\n393:         assert len(syms) == 1\n394:         x = syms.pop()\n395:         return solve_univariate_inequality(self, x, relational=False)\n396: \n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/sympy/core/relational.py",
      "suspect_lines": [
        395
      ]
    }
  ]
}