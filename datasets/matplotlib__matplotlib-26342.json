{
  "instance_id": "matplotlib__matplotlib-26342",
  "problem_statement": "[ENH]: ContourSet.set_paths\n### Problem\n\nTo get contour labelling working with its special transforms, Cartopy has a [workaround](https://github.com/SciTools/cartopy/blob/2ed668c17b4e52421f15c5be3761719c75c5311a/lib/cartopy/mpl/contour.py#L89-L108) where it replaces all the paths on the `ContourSet` with transformed versions.  This currently looks like\r\n\r\n```python\r\npaths = cs.get_paths()\r\npaths[:] = transformed_paths\r\n``` \r\n\r\nwhich doesnâ€™t smell very good.\n\n### Proposed solution\n\nThe above would smell better as \r\n\r\n```python\r\ncs.set_paths(transformed_paths)\r\n``` \n",
  "localized_code": "[start of lib/matplotlib/collections.py]\n1: \"\"\"\n2: Classes for the efficient drawing of large collections of objects that\n3: share most properties, e.g., a large number of line segments or\n4: polygons.\n5: \n6: The classes are not meant to be as flexible as their single element\n7: counterparts (e.g., you may not be able to select all line styles) but\n8: they are meant to be fast for common use cases (e.g., a large set of solid\n9: line segments).\n10: \"\"\"\n11: \n12: import itertools\n13: import math\n14: from numbers import Number, Real\n15: import warnings\n16: \n17: import numpy as np\n18: \n19: import matplotlib as mpl\n20: from . import (_api, _path, artist, cbook, cm, colors as mcolors, _docstring,\n21:                hatch as mhatch, lines as mlines, path as mpath, transforms)\n22: from ._enums import JoinStyle, CapStyle\n23: \n24: \n25: # \"color\" is excluded; it is a compound setter, and its docstring differs\n26: # in LineCollection.\n27: @_api.define_aliases({\n28:     \"antialiased\": [\"antialiaseds\", \"aa\"],\n29:     \"edgecolor\": [\"edgecolors\", \"ec\"],\n30:     \"facecolor\": [\"facecolors\", \"fc\"],\n31:     \"linestyle\": [\"linestyles\", \"dashes\", \"ls\"],\n32:     \"linewidth\": [\"linewidths\", \"lw\"],\n33:     \"offset_transform\": [\"transOffset\"],\n34: })\n35: class Collection(artist.Artist, cm.ScalarMappable):\n36:     r\"\"\"\n37:     Base class for Collections. Must be subclassed to be usable.\n38: \n39:     A Collection represents a sequence of `.Patch`\\es that can be drawn\n40:     more efficiently together than individually. For example, when a single\n41:     path is being drawn repeatedly at different offsets, the renderer can\n42:     typically execute a ``draw_marker()`` call much more efficiently than a\n43:     series of repeated calls to ``draw_path()`` with the offsets put in\n44:     one-by-one.\n45: \n46:     Most properties of a collection can be configured per-element. Therefore,\n47:     Collections have \"plural\" versions of many of the properties of a `.Patch`\n48:     (e.g. `.Collection.get_paths` instead of `.Patch.get_path`). Exceptions are\n49:     the *zorder*, *hatch*, *pickradius*, *capstyle* and *joinstyle* properties,\n50:     which can only be set globally for the whole collection.\n51: \n52:     Besides these exceptions, all properties can be specified as single values\n53:     (applying to all elements) or sequences of values. The property of the\n54:     ``i``\\th element of the collection is::\n55: \n56:       prop[i % len(prop)]\n57: \n58:     Each Collection can optionally be used as its own `.ScalarMappable` by\n59:     passing the *norm* and *cmap* parameters to its constructor. If the\n60:     Collection's `.ScalarMappable` matrix ``_A`` has been set (via a call\n61:     to `.Collection.set_array`), then at draw time this internal scalar\n62:     mappable will be used to set the ``facecolors`` and ``edgecolors``,\n63:     ignoring those that were manually passed in.\n64:     \"\"\"\n65:     #: Either a list of 3x3 arrays or an Nx3x3 array (representing N\n66:     #: transforms), suitable for the `all_transforms` argument to\n67:     #: `~matplotlib.backend_bases.RendererBase.draw_path_collection`;\n68:     #: each 3x3 array is used to initialize an\n69:     #: `~matplotlib.transforms.Affine2D` object.\n70:     #: Each kind of collection defines this based on its arguments.\n71:     _transforms = np.empty((0, 3, 3))\n72: \n73:     # Whether to draw an edge by default.  Set on a\n74:     # subclass-by-subclass basis.\n75:     _edge_default = False\n76: \n77:     @_docstring.interpd\n78:     def __init__(self, *,\n79:                  edgecolors=None,\n80:                  facecolors=None,\n81:                  linewidths=None,\n82:                  linestyles='solid',\n83:                  capstyle=None,\n84:                  joinstyle=None,\n85:                  antialiaseds=None,\n86:                  offsets=None,\n87:                  offset_transform=None,\n88:                  norm=None,  # optional for ScalarMappable\n89:                  cmap=None,  # ditto\n90:                  pickradius=5.0,\n91:                  hatch=None,\n92:                  urls=None,\n93:                  zorder=1,\n94:                  **kwargs\n95:                  ):\n96:         \"\"\"\n97:         Parameters\n98:         ----------\n99:         edgecolors : color or list of colors, default: :rc:`patch.edgecolor`\n100:             Edge color for each patch making up the collection. The special\n101:             value 'face' can be passed to make the edgecolor match the\n102:             facecolor.\n103:         facecolors : color or list of colors, default: :rc:`patch.facecolor`\n104:             Face color for each patch making up the collection.\n105:         linewidths : float or list of floats, default: :rc:`patch.linewidth`\n106:             Line width for each patch making up the collection.\n107:         linestyles : str or tuple or list thereof, default: 'solid'\n108:             Valid strings are ['solid', 'dashed', 'dashdot', 'dotted', '-',\n109:             '--', '-.', ':']. Dash tuples should be of the form::\n110: \n111:                 (offset, onoffseq),\n112: \n113:             where *onoffseq* is an even length tuple of on and off ink lengths\n114:             in points. For examples, see\n115:             :doc:`/gallery/lines_bars_and_markers/linestyles`.\n116:         capstyle : `.CapStyle`-like, default: :rc:`patch.capstyle`\n117:             Style to use for capping lines for all paths in the collection.\n118:             Allowed values are %(CapStyle)s.\n119:         joinstyle : `.JoinStyle`-like, default: :rc:`patch.joinstyle`\n120:             Style to use for joining lines for all paths in the collection.\n121:             Allowed values are %(JoinStyle)s.\n122:         antialiaseds : bool or list of bool, default: :rc:`patch.antialiased`\n123:             Whether each patch in the collection should be drawn with\n124:             antialiasing.\n125:         offsets : (float, float) or list thereof, default: (0, 0)\n126:             A vector by which to translate each patch after rendering (default\n127:             is no translation). The translation is performed in screen (pixel)\n128:             coordinates (i.e. after the Artist's transform is applied).\n129:         offset_transform : `~.Transform`, default: `.IdentityTransform`\n130:             A single transform which will be applied to each *offsets* vector\n131:             before it is used.\n132:         cmap, norm\n133:             Data normalization and colormapping parameters. See\n134:             `.ScalarMappable` for a detailed description.\n135:         hatch : str, optional\n136:             Hatching pattern to use in filled paths, if any. Valid strings are\n137:             ['/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See\n138:             :doc:`/gallery/shapes_and_collections/hatch_style_reference` for\n139:             the meaning of each hatch type.\n140:         pickradius : float, default: 5.0\n141:             If ``pickradius <= 0``, then `.Collection.contains` will return\n142:             ``True`` whenever the test point is inside of one of the polygons\n143:             formed by the control points of a Path in the Collection. On the\n144:             other hand, if it is greater than 0, then we instead check if the\n145:             test point is contained in a stroke of width ``2*pickradius``\n146:             following any of the Paths in the Collection.\n147:         urls : list of str, default: None\n148:             A URL for each patch to link to once drawn. Currently only works\n149:             for the SVG backend. See :doc:`/gallery/misc/hyperlinks_sgskip` for\n150:             examples.\n151:         zorder : float, default: 1\n152:             The drawing order, shared by all Patches in the Collection. See\n153:             :doc:`/gallery/misc/zorder_demo` for all defaults and examples.\n154:         \"\"\"\n155:         artist.Artist.__init__(self)\n156:         cm.ScalarMappable.__init__(self, norm, cmap)\n157:         # list of un-scaled dash patterns\n158:         # this is needed scaling the dash pattern by linewidth\n159:         self._us_linestyles = [(0, None)]\n160:         # list of dash patterns\n161:         self._linestyles = [(0, None)]\n162:         # list of unbroadcast/scaled linewidths\n163:         self._us_lw = [0]\n164:         self._linewidths = [0]\n165: \n166:         self._gapcolor = None  # Currently only used by LineCollection.\n167: \n168:         # Flags set by _set_mappable_flags: are colors from mapping an array?\n169:         self._face_is_mapped = None\n170:         self._edge_is_mapped = None\n171:         self._mapped_colors = None  # calculated in update_scalarmappable\n172:         self._hatch_color = mcolors.to_rgba(mpl.rcParams['hatch.color'])\n173:         self.set_facecolor(facecolors)\n174:         self.set_edgecolor(edgecolors)\n175:         self.set_linewidth(linewidths)\n176:         self.set_linestyle(linestyles)\n177:         self.set_antialiased(antialiaseds)\n178:         self.set_pickradius(pickradius)\n179:         self.set_urls(urls)\n180:         self.set_hatch(hatch)\n181:         self.set_zorder(zorder)\n182: \n183:         if capstyle:\n184:             self.set_capstyle(capstyle)\n185:         else:\n186:             self._capstyle = None\n187: \n188:         if joinstyle:\n189:             self.set_joinstyle(joinstyle)\n190:         else:\n191:             self._joinstyle = None\n192: \n193:         if offsets is not None:\n194:             offsets = np.asanyarray(offsets, float)\n195:             # Broadcast (2,) -> (1, 2) but nothing else.\n196:             if offsets.shape == (2,):\n197:                 offsets = offsets[None, :]\n198: \n199:         self._offsets = offsets\n200:         self._offset_transform = offset_transform\n201: \n202:         self._path_effects = None\n203:         self._internal_update(kwargs)\n204:         self._paths = None\n205: \n206:     def get_paths(self):\n207:         return self._paths\n208: \n209:     def set_paths(self, paths):\n210:         raise NotImplementedError\n211: \n212:     def get_transforms(self):\n213:         return self._transforms\n214: \n215:     def get_offset_transform(self):\n216:         \"\"\"Return the `.Transform` instance used by this artist offset.\"\"\"\n217:         if self._offset_transform is None:\n218:             self._offset_transform = transforms.IdentityTransform()\n219:         elif (not isinstance(self._offset_transform, transforms.Transform)\n220:               and hasattr(self._offset_transform, '_as_mpl_transform')):\n221:             self._offset_transform = \\\n222:                 self._offset_transform._as_mpl_transform(self.axes)\n223:         return self._offset_transform\n224: \n225:     def set_offset_transform(self, offset_transform):\n226:         \"\"\"\n227:         Set the artist offset transform.\n228: \n229:         Parameters\n230:         ----------\n231:         offset_transform : `.Transform`\n232:         \"\"\"\n233:         self._offset_transform = offset_transform\n234: \n235:     def get_datalim(self, transData):\n236:         # Calculate the data limits and return them as a `.Bbox`.\n237:         #\n238:         # This operation depends on the transforms for the data in the\n239:         # collection and whether the collection has offsets:\n240:         #\n241:         # 1. offsets = None, transform child of transData: use the paths for\n242:         # the automatic limits (i.e. for LineCollection in streamline).\n243:         # 2. offsets != None: offset_transform is child of transData:\n244:         #\n245:         #    a. transform is child of transData: use the path + offset for\n246:         #       limits (i.e for bar).\n247:         #    b. transform is not a child of transData: just use the offsets\n248:         #       for the limits (i.e. for scatter)\n249:         #\n250:         # 3. otherwise return a null Bbox.\n251: \n252:         transform = self.get_transform()\n253:         offset_trf = self.get_offset_transform()\n254:         if not (isinstance(offset_trf, transforms.IdentityTransform)\n255:                 or offset_trf.contains_branch(transData)):\n256:             # if the offsets are in some coords other than data,\n257:             # then don't use them for autoscaling.\n258:             return transforms.Bbox.null()\n259: \n260:         paths = self.get_paths()\n261:         if not len(paths):\n262:             # No paths to transform\n263:             return transforms.Bbox.null()\n264: \n265:         if not transform.is_affine:\n266:             paths = [transform.transform_path_non_affine(p) for p in paths]\n267:             # Don't convert transform to transform.get_affine() here because\n268:             # we may have transform.contains_branch(transData) but not\n269:             # transforms.get_affine().contains_branch(transData).  But later,\n270:             # be careful to only apply the affine part that remains.\n271: \n272:         offsets = self.get_offsets()\n273: \n274:         if any(transform.contains_branch_seperately(transData)):\n275:             # collections that are just in data units (like quiver)\n276:             # can properly have the axes limits set by their shape +\n277:             # offset.  LineCollections that have no offsets can\n278:             # also use this algorithm (like streamplot).\n279:             if isinstance(offsets, np.ma.MaskedArray):\n280:                 offsets = offsets.filled(np.nan)\n281:                 # get_path_collection_extents handles nan but not masked arrays\n282:             return mpath.get_path_collection_extents(\n283:                 transform.get_affine() - transData, paths,\n284:                 self.get_transforms(),\n285:                 offset_trf.transform_non_affine(offsets),\n286:                 offset_trf.get_affine().frozen())\n287: \n288:         # NOTE: None is the default case where no offsets were passed in\n289:         if self._offsets is not None:\n290:             # this is for collections that have their paths (shapes)\n291:             # in physical, axes-relative, or figure-relative units\n292:             # (i.e. like scatter). We can't uniquely set limits based on\n293:             # those shapes, so we just set the limits based on their\n294:             # location.\n295:             offsets = (offset_trf - transData).transform(offsets)\n296:             # note A-B means A B^{-1}\n297:             offsets = np.ma.masked_invalid(offsets)\n298:             if not offsets.mask.all():\n299:                 bbox = transforms.Bbox.null()\n300:                 bbox.update_from_data_xy(offsets)\n301:                 return bbox\n302:         return transforms.Bbox.null()\n303: \n304:     def get_window_extent(self, renderer=None):\n305:         # TODO: check to ensure that this does not fail for\n306:         # cases other than scatter plot legend\n307:         return self.get_datalim(transforms.IdentityTransform())\n308: \n309:     def _prepare_points(self):\n310:         # Helper for drawing and hit testing.\n311: \n312:         transform = self.get_transform()\n313:         offset_trf = self.get_offset_transform()\n314:         offsets = self.get_offsets()\n315:         paths = self.get_paths()\n316: \n317:         if self.have_units():\n318:             paths = []\n319:             for path in self.get_paths():\n320:                 vertices = path.vertices\n321:                 xs, ys = vertices[:, 0], vertices[:, 1]\n322:                 xs = self.convert_xunits(xs)\n323:                 ys = self.convert_yunits(ys)\n324:                 paths.append(mpath.Path(np.column_stack([xs, ys]), path.codes))\n325:             xs = self.convert_xunits(offsets[:, 0])\n326:             ys = self.convert_yunits(offsets[:, 1])\n327:             offsets = np.ma.column_stack([xs, ys])\n328: \n329:         if not transform.is_affine:\n330:             paths = [transform.transform_path_non_affine(path)\n331:                      for path in paths]\n332:             transform = transform.get_affine()\n333:         if not offset_trf.is_affine:\n334:             offsets = offset_trf.transform_non_affine(offsets)\n335:             # This might have changed an ndarray into a masked array.\n336:             offset_trf = offset_trf.get_affine()\n337: \n338:         if isinstance(offsets, np.ma.MaskedArray):\n339:             offsets = offsets.filled(np.nan)\n340:             # Changing from a masked array to nan-filled ndarray\n341:             # is probably most efficient at this point.\n342: \n343:         return transform, offset_trf, offsets, paths\n344: \n345:     @artist.allow_rasterization\n346:     def draw(self, renderer):\n347:         if not self.get_visible():\n348:             return\n349:         renderer.open_group(self.__class__.__name__, self.get_gid())\n350: \n351:         self.update_scalarmappable()\n352: \n353:         transform, offset_trf, offsets, paths = self._prepare_points()\n354: \n355:         gc = renderer.new_gc()\n356:         self._set_gc_clip(gc)\n357:         gc.set_snap(self.get_snap())\n358: \n359:         if self._hatch:\n360:             gc.set_hatch(self._hatch)\n361:             gc.set_hatch_color(self._hatch_color)\n362: \n363:         if self.get_sketch_params() is not None:\n364:             gc.set_sketch_params(*self.get_sketch_params())\n365: \n366:         if self.get_path_effects():\n367:             from matplotlib.patheffects import PathEffectRenderer\n368:             renderer = PathEffectRenderer(self.get_path_effects(), renderer)\n369: \n370:         # If the collection is made up of a single shape/color/stroke,\n371:         # it can be rendered once and blitted multiple times, using\n372:         # `draw_markers` rather than `draw_path_collection`.  This is\n373:         # *much* faster for Agg, and results in smaller file sizes in\n374:         # PDF/SVG/PS.\n375: \n376:         trans = self.get_transforms()\n377:         facecolors = self.get_facecolor()\n378:         edgecolors = self.get_edgecolor()\n379:         do_single_path_optimization = False\n380:         if (len(paths) == 1 and len(trans) <= 1 and\n381:                 len(facecolors) == 1 and len(edgecolors) == 1 and\n382:                 len(self._linewidths) == 1 and\n383:                 all(ls[1] is None for ls in self._linestyles) and\n384:                 len(self._antialiaseds) == 1 and len(self._urls) == 1 and\n385:                 self.get_hatch() is None):\n386:             if len(trans):\n387:                 combined_transform = transforms.Affine2D(trans[0]) + transform\n388:             else:\n389:                 combined_transform = transform\n390:             extents = paths[0].get_extents(combined_transform)\n391:             if (extents.width < self.figure.bbox.width\n392:                     and extents.height < self.figure.bbox.height):\n393:                 do_single_path_optimization = True\n394: \n395:         if self._joinstyle:\n396:             gc.set_joinstyle(self._joinstyle)\n397: \n398:         if self._capstyle:\n399:             gc.set_capstyle(self._capstyle)\n400: \n401:         if do_single_path_optimization:\n402:             gc.set_foreground(tuple(edgecolors[0]))\n403:             gc.set_linewidth(self._linewidths[0])\n404:             gc.set_dashes(*self._linestyles[0])\n405:             gc.set_antialiased(self._antialiaseds[0])\n406:             gc.set_url(self._urls[0])\n407:             renderer.draw_markers(\n408:                 gc, paths[0], combined_transform.frozen(),\n409:                 mpath.Path(offsets), offset_trf, tuple(facecolors[0]))\n410:         else:\n411:             if self._gapcolor is not None:\n412:                 # First draw paths within the gaps.\n413:                 ipaths, ilinestyles = self._get_inverse_paths_linestyles()\n414:                 renderer.draw_path_collection(\n415:                     gc, transform.frozen(), ipaths,\n416:                     self.get_transforms(), offsets, offset_trf,\n417:                     [mcolors.to_rgba(\"none\")], self._gapcolor,\n418:                     self._linewidths, ilinestyles,\n419:                     self._antialiaseds, self._urls,\n420:                     \"screen\")\n421: \n422:             renderer.draw_path_collection(\n423:                 gc, transform.frozen(), paths,\n424:                 self.get_transforms(), offsets, offset_trf,\n425:                 self.get_facecolor(), self.get_edgecolor(),\n426:                 self._linewidths, self._linestyles,\n427:                 self._antialiaseds, self._urls,\n428:                 \"screen\")  # offset_position, kept for backcompat.\n429: \n430:         gc.restore()\n431:         renderer.close_group(self.__class__.__name__)\n432:         self.stale = False\n433: \n434:     def set_pickradius(self, pickradius):\n435:         \"\"\"\n436:         Set the pick radius used for containment tests.\n437: \n438:         Parameters\n439:         ----------\n440:         pickradius : float\n441:             Pick radius, in points.\n442:         \"\"\"\n443:         if not isinstance(pickradius, Real):\n444:             raise ValueError(\n445:                 f\"pickradius must be a real-valued number, not {pickradius!r}\")\n446:         self._pickradius = pickradius\n447: \n448:     def get_pickradius(self):\n449:         return self._pickradius\n450: \n451:     def contains(self, mouseevent):\n452:         \"\"\"\n453:         Test whether the mouse event occurred in the collection.\n454: \n455:         Returns ``bool, dict(ind=itemlist)``, where every item in itemlist\n456:         contains the event.\n457:         \"\"\"\n458:         if self._different_canvas(mouseevent) or not self.get_visible():\n459:             return False, {}\n460:         pickradius = (\n461:             float(self._picker)\n462:             if isinstance(self._picker, Number) and\n463:                self._picker is not True  # the bool, not just nonzero or 1\n464:             else self._pickradius)\n465:         if self.axes:\n466:             self.axes._unstale_viewLim()\n467:         transform, offset_trf, offsets, paths = self._prepare_points()\n468:         # Tests if the point is contained on one of the polygons formed\n469:         # by the control points of each of the paths. A point is considered\n470:         # \"on\" a path if it would lie within a stroke of width 2*pickradius\n471:         # following the path. If pickradius <= 0, then we instead simply check\n472:         # if the point is *inside* of the path instead.\n473:         ind = _path.point_in_path_collection(\n474:             mouseevent.x, mouseevent.y, pickradius,\n475:             transform.frozen(), paths, self.get_transforms(),\n476:             offsets, offset_trf, pickradius <= 0)\n477:         return len(ind) > 0, dict(ind=ind)\n478: \n479:     def set_urls(self, urls):\n480:         \"\"\"\n481:         Parameters\n482:         ----------\n483:         urls : list of str or None\n484: \n485:         Notes\n486:         -----\n487:         URLs are currently only implemented by the SVG backend. They are\n488:         ignored by all other backends.\n489:         \"\"\"\n490:         self._urls = urls if urls is not None else [None]\n491:         self.stale = True\n492: \n493:     def get_urls(self):\n494:         \"\"\"\n495:         Return a list of URLs, one for each element of the collection.\n496: \n497:         The list contains *None* for elements without a URL. See\n498:         :doc:`/gallery/misc/hyperlinks_sgskip` for an example.\n499:         \"\"\"\n500:         return self._urls\n501: \n502:     def set_hatch(self, hatch):\n503:         r\"\"\"\n504:         Set the hatching pattern\n505: \n506:         *hatch* can be one of::\n507: \n508:           /   - diagonal hatching\n509:           \\   - back diagonal\n510:           |   - vertical\n511:           -   - horizontal\n512:           +   - crossed\n513:           x   - crossed diagonal\n514:           o   - small circle\n515:           O   - large circle\n516:           .   - dots\n517:           *   - stars\n518: \n519:         Letters can be combined, in which case all the specified\n520:         hatchings are done.  If same letter repeats, it increases the\n521:         density of hatching of that pattern.\n522: \n523:         Hatching is supported in the PostScript, PDF, SVG and Agg\n524:         backends only.\n525: \n526:         Unlike other properties such as linewidth and colors, hatching\n527:         can only be specified for the collection as a whole, not separately\n528:         for each member.\n529: \n530:         Parameters\n531:         ----------\n532:         hatch : {'/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'}\n533:         \"\"\"\n534:         # Use validate_hatch(list) after deprecation.\n535:         mhatch._validate_hatch_pattern(hatch)\n536:         self._hatch = hatch\n537:         self.stale = True\n538: \n539:     def get_hatch(self):\n540:         \"\"\"Return the current hatching pattern.\"\"\"\n541:         return self._hatch\n542: \n543:     def set_offsets(self, offsets):\n544:         \"\"\"\n545:         Set the offsets for the collection.\n546: \n547:         Parameters\n548:         ----------\n549:         offsets : (N, 2) or (2,) array-like\n550:         \"\"\"\n551:         offsets = np.asanyarray(offsets)\n552:         if offsets.shape == (2,):  # Broadcast (2,) -> (1, 2) but nothing else.\n553:             offsets = offsets[None, :]\n554:         cstack = (np.ma.column_stack if isinstance(offsets, np.ma.MaskedArray)\n555:                   else np.column_stack)\n556:         self._offsets = cstack(\n557:             (np.asanyarray(self.convert_xunits(offsets[:, 0]), float),\n558:              np.asanyarray(self.convert_yunits(offsets[:, 1]), float)))\n559:         self.stale = True\n560: \n561:     def get_offsets(self):\n562:         \"\"\"Return the offsets for the collection.\"\"\"\n563:         # Default to zeros in the no-offset (None) case\n564:         return np.zeros((1, 2)) if self._offsets is None else self._offsets\n565: \n566:     def _get_default_linewidth(self):\n567:         # This may be overridden in a subclass.\n568:         return mpl.rcParams['patch.linewidth']  # validated as float\n569: \n570:     def set_linewidth(self, lw):\n571:         \"\"\"\n572:         Set the linewidth(s) for the collection.  *lw* can be a scalar\n573:         or a sequence; if it is a sequence the patches will cycle\n574:         through the sequence\n575: \n576:         Parameters\n577:         ----------\n578:         lw : float or list of floats\n579:         \"\"\"\n580:         if lw is None:\n581:             lw = self._get_default_linewidth()\n582:         # get the un-scaled/broadcast lw\n583:         self._us_lw = np.atleast_1d(lw)\n584: \n585:         # scale all of the dash patterns.\n586:         self._linewidths, self._linestyles = self._bcast_lwls(\n587:             self._us_lw, self._us_linestyles)\n588:         self.stale = True\n589: \n590:     def set_linestyle(self, ls):\n591:         \"\"\"\n592:         Set the linestyle(s) for the collection.\n593: \n594:         ===========================   =================\n595:         linestyle                     description\n596:         ===========================   =================\n597:         ``'-'`` or ``'solid'``        solid line\n598:         ``'--'`` or  ``'dashed'``     dashed line\n599:         ``'-.'`` or  ``'dashdot'``    dash-dotted line\n600:         ``':'`` or ``'dotted'``       dotted line\n601:         ===========================   =================\n602: \n603:         Alternatively a dash tuple of the following form can be provided::\n604: \n605:             (offset, onoffseq),\n606: \n607:         where ``onoffseq`` is an even length tuple of on and off ink in points.\n608: \n609:         Parameters\n610:         ----------\n611:         ls : str or tuple or list thereof\n612:             Valid values for individual linestyles include {'-', '--', '-.',\n613:             ':', '', (offset, on-off-seq)}. See `.Line2D.set_linestyle` for a\n614:             complete description.\n615:         \"\"\"\n616:         try:\n617:             dashes = [mlines._get_dash_pattern(ls)]\n618:         except ValueError:\n619:             try:\n620:                 dashes = [mlines._get_dash_pattern(x) for x in ls]\n621:             except ValueError as err:\n622:                 emsg = f'Do not know how to convert {ls!r} to dashes'\n623:                 raise ValueError(emsg) from err\n624: \n625:         # get the list of raw 'unscaled' dash patterns\n626:         self._us_linestyles = dashes\n627: \n628:         # broadcast and scale the lw and dash patterns\n629:         self._linewidths, self._linestyles = self._bcast_lwls(\n630:             self._us_lw, self._us_linestyles)\n631: \n632:     @_docstring.interpd\n633:     def set_capstyle(self, cs):\n634:         \"\"\"\n635:         Set the `.CapStyle` for the collection (for all its elements).\n636: \n637:         Parameters\n638:         ----------\n639:         cs : `.CapStyle` or %(CapStyle)s\n640:         \"\"\"\n641:         self._capstyle = CapStyle(cs)\n642: \n643:     def get_capstyle(self):\n644:         return self._capstyle.name\n645: \n646:     @_docstring.interpd\n647:     def set_joinstyle(self, js):\n648:         \"\"\"\n649:         Set the `.JoinStyle` for the collection (for all its elements).\n650: \n651:         Parameters\n652:         ----------\n653:         js : `.JoinStyle` or %(JoinStyle)s\n654:         \"\"\"\n655:         self._joinstyle = JoinStyle(js)\n656: \n657:     def get_joinstyle(self):\n658:         return self._joinstyle.name\n659: \n660:     @staticmethod\n661:     def _bcast_lwls(linewidths, dashes):\n662:         \"\"\"\n663:         Internal helper function to broadcast + scale ls/lw\n664: \n665:         In the collection drawing code, the linewidth and linestyle are cycled\n666:         through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are\n667:         going to scale the dash pattern at set time (not draw time) we need to\n668:         do the broadcasting now and expand both lists to be the same length.\n669: \n670:         Parameters\n671:         ----------\n672:         linewidths : list\n673:             line widths of collection\n674:         dashes : list\n675:             dash specification (offset, (dash pattern tuple))\n676: \n677:         Returns\n678:         -------\n679:         linewidths, dashes : list\n680:             Will be the same length, dashes are scaled by paired linewidth\n681:         \"\"\"\n682:         if mpl.rcParams['_internal.classic_mode']:\n683:             return linewidths, dashes\n684:         # make sure they are the same length so we can zip them\n685:         if len(dashes) != len(linewidths):\n686:             l_dashes = len(dashes)\n687:             l_lw = len(linewidths)\n688:             gcd = math.gcd(l_dashes, l_lw)\n689:             dashes = list(dashes) * (l_lw // gcd)\n690:             linewidths = list(linewidths) * (l_dashes // gcd)\n691: \n692:         # scale the dash patterns\n693:         dashes = [mlines._scale_dashes(o, d, lw)\n694:                   for (o, d), lw in zip(dashes, linewidths)]\n695: \n696:         return linewidths, dashes\n697: \n698:     def set_antialiased(self, aa):\n699:         \"\"\"\n700:         Set the antialiasing state for rendering.\n701: \n702:         Parameters\n703:         ----------\n704:         aa : bool or list of bools\n705:         \"\"\"\n706:         if aa is None:\n707:             aa = self._get_default_antialiased()\n708:         self._antialiaseds = np.atleast_1d(np.asarray(aa, bool))\n709:         self.stale = True\n710: \n711:     def _get_default_antialiased(self):\n712:         # This may be overridden in a subclass.\n713:         return mpl.rcParams['patch.antialiased']\n714: \n715:     def set_color(self, c):\n716:         \"\"\"\n717:         Set both the edgecolor and the facecolor.\n718: \n719:         Parameters\n720:         ----------\n721:         c : color or list of RGBA tuples\n722: \n723:         See Also\n724:         --------\n725:         Collection.set_facecolor, Collection.set_edgecolor\n726:             For setting the edge or face color individually.\n727:         \"\"\"\n728:         self.set_facecolor(c)\n729:         self.set_edgecolor(c)\n730: \n731:     def _get_default_facecolor(self):\n732:         # This may be overridden in a subclass.\n733:         return mpl.rcParams['patch.facecolor']\n734: \n735:     def _set_facecolor(self, c):\n736:         if c is None:\n737:             c = self._get_default_facecolor()\n738: \n739:         self._facecolors = mcolors.to_rgba_array(c, self._alpha)\n740:         self.stale = True\n741: \n742:     def set_facecolor(self, c):\n743:         \"\"\"\n744:         Set the facecolor(s) of the collection. *c* can be a color (all patches\n745:         have same color), or a sequence of colors; if it is a sequence the\n746:         patches will cycle through the sequence.\n747: \n748:         If *c* is 'none', the patch will not be filled.\n749: \n750:         Parameters\n751:         ----------\n752:         c : color or list of colors\n753:         \"\"\"\n754:         if isinstance(c, str) and c.lower() in (\"none\", \"face\"):\n755:             c = c.lower()\n756:         self._original_facecolor = c\n757:         self._set_facecolor(c)\n758: \n759:     def get_facecolor(self):\n760:         return self._facecolors\n761: \n762:     def get_edgecolor(self):\n763:         if cbook._str_equal(self._edgecolors, 'face'):\n764:             return self.get_facecolor()\n765:         else:\n766:             return self._edgecolors\n767: \n768:     def _get_default_edgecolor(self):\n769:         # This may be overridden in a subclass.\n770:         return mpl.rcParams['patch.edgecolor']\n771: \n772:     def _set_edgecolor(self, c):\n773:         set_hatch_color = True\n774:         if c is None:\n775:             if (mpl.rcParams['patch.force_edgecolor']\n776:                     or self._edge_default\n777:                     or cbook._str_equal(self._original_facecolor, 'none')):\n778:                 c = self._get_default_edgecolor()\n779:             else:\n780:                 c = 'none'\n781:                 set_hatch_color = False\n782:         if cbook._str_lower_equal(c, 'face'):\n783:             self._edgecolors = 'face'\n784:             self.stale = True\n785:             return\n786:         self._edgecolors = mcolors.to_rgba_array(c, self._alpha)\n787:         if set_hatch_color and len(self._edgecolors):\n788:             self._hatch_color = tuple(self._edgecolors[0])\n789:         self.stale = True\n790: \n791:     def set_edgecolor(self, c):\n792:         \"\"\"\n793:         Set the edgecolor(s) of the collection.\n794: \n795:         Parameters\n796:         ----------\n797:         c : color or list of colors or 'face'\n798:             The collection edgecolor(s).  If a sequence, the patches cycle\n799:             through it.  If 'face', match the facecolor.\n800:         \"\"\"\n801:         # We pass through a default value for use in LineCollection.\n802:         # This allows us to maintain None as the default indicator in\n803:         # _original_edgecolor.\n804:         if isinstance(c, str) and c.lower() in (\"none\", \"face\"):\n805:             c = c.lower()\n806:         self._original_edgecolor = c\n807:         self._set_edgecolor(c)\n808: \n809:     def set_alpha(self, alpha):\n810:         \"\"\"\n811:         Set the transparency of the collection.\n812: \n813:         Parameters\n814:         ----------\n815:         alpha : float or array of float or None\n816:             If not None, *alpha* values must be between 0 and 1, inclusive.\n817:             If an array is provided, its length must match the number of\n818:             elements in the collection.  Masked values and nans are not\n819:             supported.\n820:         \"\"\"\n821:         artist.Artist._set_alpha_for_array(self, alpha)\n822:         self._set_facecolor(self._original_facecolor)\n823:         self._set_edgecolor(self._original_edgecolor)\n824: \n825:     set_alpha.__doc__ = artist.Artist._set_alpha_for_array.__doc__\n826: \n827:     def get_linewidth(self):\n828:         return self._linewidths\n829: \n830:     def get_linestyle(self):\n831:         return self._linestyles\n832: \n833:     def _set_mappable_flags(self):\n834:         \"\"\"\n835:         Determine whether edges and/or faces are color-mapped.\n836: \n837:         This is a helper for update_scalarmappable.\n838:         It sets Boolean flags '_edge_is_mapped' and '_face_is_mapped'.\n839: \n840:         Returns\n841:         -------\n842:         mapping_change : bool\n843:             True if either flag is True, or if a flag has changed.\n844:         \"\"\"\n845:         # The flags are initialized to None to ensure this returns True\n846:         # the first time it is called.\n847:         edge0 = self._edge_is_mapped\n848:         face0 = self._face_is_mapped\n849:         # After returning, the flags must be Booleans, not None.\n850:         self._edge_is_mapped = False\n851:         self._face_is_mapped = False\n852:         if self._A is not None:\n853:             if not cbook._str_equal(self._original_facecolor, 'none'):\n854:                 self._face_is_mapped = True\n855:                 if cbook._str_equal(self._original_edgecolor, 'face'):\n856:                     self._edge_is_mapped = True\n857:             else:\n858:                 if self._original_edgecolor is None:\n859:                     self._edge_is_mapped = True\n860: \n861:         mapped = self._face_is_mapped or self._edge_is_mapped\n862:         changed = (edge0 is None or face0 is None\n863:                    or self._edge_is_mapped != edge0\n864:                    or self._face_is_mapped != face0)\n865:         return mapped or changed\n866: \n867:     def update_scalarmappable(self):\n868:         \"\"\"\n869:         Update colors from the scalar mappable array, if any.\n870: \n871:         Assign colors to edges and faces based on the array and/or\n872:         colors that were directly set, as appropriate.\n873:         \"\"\"\n874:         if not self._set_mappable_flags():\n875:             return\n876:         # Allow possibility to call 'self.set_array(None)'.\n877:         if self._A is not None:\n878:             # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)\n879:             if self._A.ndim > 1 and not isinstance(self, _MeshData):\n880:                 raise ValueError('Collections can only map rank 1 arrays')\n881:             if np.iterable(self._alpha):\n882:                 if self._alpha.size != self._A.size:\n883:                     raise ValueError(\n884:                         f'Data array shape, {self._A.shape} '\n885:                         'is incompatible with alpha array shape, '\n886:                         f'{self._alpha.shape}. '\n887:                         'This can occur with the deprecated '\n888:                         'behavior of the \"flat\" shading option, '\n889:                         'in which a row and/or column of the data '\n890:                         'array is dropped.')\n891:                 # pcolormesh, scatter, maybe others flatten their _A\n892:                 self._alpha = self._alpha.reshape(self._A.shape)\n893:             self._mapped_colors = self.to_rgba(self._A, self._alpha)\n894: \n895:         if self._face_is_mapped:\n896:             self._facecolors = self._mapped_colors\n897:         else:\n898:             self._set_facecolor(self._original_facecolor)\n899:         if self._edge_is_mapped:\n900:             self._edgecolors = self._mapped_colors\n901:         else:\n902:             self._set_edgecolor(self._original_edgecolor)\n903:         self.stale = True\n904: \n905:     def get_fill(self):\n906:         \"\"\"Return whether face is colored.\"\"\"\n907:         return not cbook._str_lower_equal(self._original_facecolor, \"none\")\n908: \n909:     def update_from(self, other):\n910:         \"\"\"Copy properties from other to self.\"\"\"\n911: \n912:         artist.Artist.update_from(self, other)\n913:         self._antialiaseds = other._antialiaseds\n914:         self._mapped_colors = other._mapped_colors\n915:         self._edge_is_mapped = other._edge_is_mapped\n916:         self._original_edgecolor = other._original_edgecolor\n917:         self._edgecolors = other._edgecolors\n918:         self._face_is_mapped = other._face_is_mapped\n919:         self._original_facecolor = other._original_facecolor\n920:         self._facecolors = other._facecolors\n921:         self._linewidths = other._linewidths\n922:         self._linestyles = other._linestyles\n923:         self._us_linestyles = other._us_linestyles\n924:         self._pickradius = other._pickradius\n925:         self._hatch = other._hatch\n926: \n927:         # update_from for scalarmappable\n928:         self._A = other._A\n929:         self.norm = other.norm\n930:         self.cmap = other.cmap\n931:         self.stale = True\n932: \n933: \n934: class _CollectionWithSizes(Collection):\nCode replaced for brevity.\n978: \n979: \n980: \n981: class PathCollection(_CollectionWithSizes):\n982:     r\"\"\"\n983:     A collection of `~.path.Path`\\s, as created by e.g. `~.Axes.scatter`.\n984:     \"\"\"\n985: \n986:     def __init__(self, paths, sizes=None, **kwargs):\n987:         \"\"\"\n988:         Parameters\n989:         ----------\n990:         paths : list of `.path.Path`\n991:             The paths that will make up the `.Collection`.\n992:         sizes : array-like\n993:             The factor by which to scale each drawn `~.path.Path`. One unit\n994:             squared in the Path's data space is scaled to be ``sizes**2``\n995:             points when rendered.\n996:         **kwargs\n997:             Forwarded to `.Collection`.\n998:         \"\"\"\n999: \n1000:         super().__init__(**kwargs)\n1001:         self.set_paths(paths)\n1002:         self.set_sizes(sizes)\n1003:         self.stale = True\n1004: \n1005:     def set_paths(self, paths):\n1006:         self._paths = paths\n1007:         self.stale = True\n1008: \n1009:     def get_paths(self):\n1010:         return self._paths\n1011: \n1012:     def legend_elements(self, prop=\"colors\", num=\"auto\",\n1013:                         fmt=None, func=lambda x: x, **kwargs):\n1014:         \"\"\"\n1015:         Create legend handles and labels for a PathCollection.\n1016: \n1017:         Each legend handle is a `.Line2D` representing the Path that was drawn,\n1018:         and each label is a string what each Path represents.\n1019: \n1020:         This is useful for obtaining a legend for a `~.Axes.scatter` plot;\n1021:         e.g.::\n1022: \n1023:             scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3])\n1024:             plt.legend(*scatter.legend_elements())\n1025: \n1026:         creates three legend elements, one for each color with the numerical\n1027:         values passed to *c* as the labels.\n1028: \n1029:         Also see the :ref:`automatedlegendcreation` example.\n1030: \n1031:         Parameters\n1032:         ----------\n1033:         prop : {\"colors\", \"sizes\"}, default: \"colors\"\n1034:             If \"colors\", the legend handles will show the different colors of\n1035:             the collection. If \"sizes\", the legend will show the different\n1036:             sizes. To set both, use *kwargs* to directly edit the `.Line2D`\n1037:             properties.\n1038:         num : int, None, \"auto\" (default), array-like, or `~.ticker.Locator`\n1039:             Target number of elements to create.\n1040:             If None, use all unique elements of the mappable array. If an\n1041:             integer, target to use *num* elements in the normed range.\n1042:             If *\"auto\"*, try to determine which option better suits the nature\n1043:             of the data.\n1044:             The number of created elements may slightly deviate from *num* due\n1045:             to a `~.ticker.Locator` being used to find useful locations.\n1046:             If a list or array, use exactly those elements for the legend.\n1047:             Finally, a `~.ticker.Locator` can be provided.\n1048:         fmt : str, `~matplotlib.ticker.Formatter`, or None (default)\n1049:             The format or formatter to use for the labels. If a string must be\n1050:             a valid input for a `.StrMethodFormatter`. If None (the default),\n... Code Truncated ...\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/collections.py",
      "suspect_lines": [
        210,
        1004,
        1005,
        1006,
        1007
      ]
    }
  ]
}