{
  "instance_id": "matplotlib__matplotlib-21568",
  "problem_statement": "[Bug]: Datetime axis with usetex is unclear\n### Bug summary\n\nThe spacing for a datetime axis when using `usetex=True` is unclear in matplotlib version 3.4 when comparing it to 3.3.\n\n### Code for reproduction\n\n```python\nimport matplotlib\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\nnp.random.seed(1)\r\nmatplotlib.rcParams[\"text.usetex\"] = True\r\n\r\ndates = pd.date_range(\"2020-01-01 00:00:00\", end=\"2020-01-01 00:10:00\", periods=100)\r\ndata = np.random.rand(100)\r\n\r\nfig, ax = plt.subplots(constrained_layout=True)\r\nax.plot(dates, data)\r\nplt.savefig(matplotlib.__version__ + \".png\")\n```\n\n\n### Actual outcome\n\nExample of how it look in 3.3.4:\r\n![3 3 4](https://user-images.githubusercontent.com/19758978/139711077-e4fd7727-1e8b-4225-b399-ddad2307f754.png)\r\n\r\nExample of how it look in 3.4.3:\r\n![3 4 3](https://user-images.githubusercontent.com/19758978/139711070-2859fd7a-70b2-449e-a3b0-d48e50184077.png)\n\n### Expected outcome\n\nThe ideal case would be to have the spacing from version 3.3 in a tex format.\n\n### Operating system\n\nWindows\n\n### Matplotlib Version\n\n3.4.3\n\n### Matplotlib Backend\n\n_No response_\n\n### Python version\n\n_No response_\n\n### Jupyter version\n\n_No response_\n\n### Other libraries\n\n_No response_\n\n### Installation\n\nconda\n\n### Conda channel\n\nconda-forge\n",
  "localized_code": "[start of lib/matplotlib/dates.py]\n1: \"\"\"\n2: Matplotlib provides sophisticated date plotting capabilities, standing on the\n3: shoulders of python :mod:`datetime` and the add-on module :mod:`dateutil`.\n4: \n5: By default, Matplotlib uses the units machinery described in\n6: `~matplotlib.units` to convert `datetime.datetime`, and `numpy.datetime64`\n7: objects when plotted on an x- or y-axis. The user does not\n8: need to do anything for dates to be formatted, but dates often have strict\n9: formatting needs, so this module provides many axis locators and formatters.\n10: A basic example using `numpy.datetime64` is::\n11: \n12:     import numpy as np\n13: \n14:     times = np.arange(np.datetime64('2001-01-02'),\n15:                       np.datetime64('2002-02-03'), np.timedelta64(75, 'm'))\n16:     y = np.random.randn(len(times))\n17: \n18:     fig, ax = plt.subplots()\n19:     ax.plot(times, y)\n20: \n21: .. seealso::\n22: \n23:     - :doc:`/gallery/text_labels_and_annotations/date`\n24:     - :doc:`/gallery/ticks/date_concise_formatter`\n25:     - :doc:`/gallery/ticks/date_demo_convert`\n26: \n27: .. _date-format:\n28: \n29: Matplotlib date format\n30: ----------------------\n31: \n32: Matplotlib represents dates using floating point numbers specifying the number\n33: of days since a default epoch of 1970-01-01 UTC; for example,\n34: 1970-01-01, 06:00 is the floating point number 0.25. The formatters and\n35: locators require the use of `datetime.datetime` objects, so only dates between\n36: year 0001 and 9999 can be represented.  Microsecond precision\n37: is achievable for (approximately) 70 years on either side of the epoch, and\n38: 20 microseconds for the rest of the allowable range of dates (year 0001 to\n39: 9999). The epoch can be changed at import time via `.dates.set_epoch` or\n40: :rc:`dates.epoch` to other dates if necessary; see\n41: :doc:`/gallery/ticks/date_precision_and_epochs` for a discussion.\n42: \n43: .. note::\n44: \n45:    Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern\n46:    microsecond precision and also made the default axis limit of 0 an invalid\n47:    datetime.  In 3.3 the epoch was changed as above.  To convert old\n48:    ordinal floats to the new epoch, users can do::\n49: \n50:      new_ordinal = old_ordinal + mdates.date2num(np.datetime64('0000-12-31'))\n51: \n52: \n53: There are a number of helper functions to convert between :mod:`datetime`\n54: objects and Matplotlib dates:\n55: \n56: .. currentmodule:: matplotlib.dates\n57: \n58: .. autosummary::\n59:    :nosignatures:\n60: \n61:    datestr2num\n62:    date2num\n63:    num2date\n64:    num2timedelta\n65:    drange\n66:    set_epoch\n67:    get_epoch\n68: \n69: .. note::\n70: \n71:    Like Python's `datetime.datetime`, Matplotlib uses the Gregorian calendar\n72:    for all conversions between dates and floating point numbers. This practice\n73:    is not universal, and calendar differences can cause confusing\n74:    differences between what Python and Matplotlib give as the number of days\n75:    since 0001-01-01 and what other software and databases yield.  For\n76:    example, the US Naval Observatory uses a calendar that switches\n77:    from Julian to Gregorian in October, 1582.  Hence, using their\n78:    calculator, the number of days between 0001-01-01 and 2006-04-01 is\n79:    732403, whereas using the Gregorian calendar via the datetime\n80:    module we find::\n81: \n82:      In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()\n83:      Out[1]: 732401\n84: \n85: All the Matplotlib date converters, tickers and formatters are timezone aware.\n86: If no explicit timezone is provided, :rc:`timezone` is assumed.  If you want to\n87: use a custom time zone, pass a `datetime.tzinfo` instance with the tz keyword\n88: argument to `num2date`, `.Axis.axis_date`, and any custom date tickers or\n89: locators you create.\n90: \n91: A wide range of specific and general purpose date tick locators and\n92: formatters are provided in this module.  See\n93: :mod:`matplotlib.ticker` for general information on tick locators\n94: and formatters.  These are described below.\n95: \n96: The dateutil_ module provides additional code to handle date ticking, making it\n97: easy to place ticks on any kinds of dates.  See examples below.\n98: \n99: .. _dateutil: https://dateutil.readthedocs.io\n100: \n101: Date tickers\n102: ------------\n103: \n104: Most of the date tickers can locate single or multiple values.  For example::\n105: \n106:     # import constants for the days of the week\n107:     from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU\n108: \n109:     # tick on mondays every week\n110:     loc = WeekdayLocator(byweekday=MO, tz=tz)\n111: \n112:     # tick on mondays and saturdays\n113:     loc = WeekdayLocator(byweekday=(MO, SA))\n114: \n115: In addition, most of the constructors take an interval argument::\n116: \n117:     # tick on mondays every second week\n118:     loc = WeekdayLocator(byweekday=MO, interval=2)\n119: \n120: The rrule locator allows completely general date ticking::\n121: \n122:     # tick every 5th easter\n123:     rule = rrulewrapper(YEARLY, byeaster=1, interval=5)\n124:     loc = RRuleLocator(rule)\n125: \n126: The available date tickers are:\n127: \n128: * `MicrosecondLocator`: Locate microseconds.\n129: \n130: * `SecondLocator`: Locate seconds.\n131: \n132: * `MinuteLocator`: Locate minutes.\n133: \n134: * `HourLocator`: Locate hours.\n135: \n136: * `DayLocator`: Locate specified days of the month.\n137: \n138: * `WeekdayLocator`: Locate days of the week, e.g., MO, TU.\n139: \n140: * `MonthLocator`: Locate months, e.g., 7 for July.\n141: \n142: * `YearLocator`: Locate years that are multiples of base.\n143: \n144: * `RRuleLocator`: Locate using a `matplotlib.dates.rrulewrapper`.\n145:   `.rrulewrapper` is a simple wrapper around dateutil_'s `dateutil.rrule` which\n146:   allow almost arbitrary date tick specifications.  See :doc:`rrule example\n147:   </gallery/ticks/date_demo_rrule>`.\n148: \n149: * `AutoDateLocator`: On autoscale, this class picks the best `DateLocator`\n150:   (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If\n151:   called with ``interval_multiples=True`` it will make ticks line up with\n152:   sensible multiples of the tick intervals.  E.g. if the interval is 4 hours,\n153:   it will pick hours 0, 4, 8, etc as ticks.  This behaviour is not guaranteed\n154:   by default.\n155: \n156: Date formatters\n157: ---------------\n158: \n159: The available date formatters are:\n160: \n161: * `AutoDateFormatter`: attempts to figure out the best format to use.  This is\n162:   most useful when used with the `AutoDateLocator`.\n163: \n164: * `ConciseDateFormatter`: also attempts to figure out the best format to use,\n165:   and to make the format as compact as possible while still having complete\n166:   date information.  This is most useful when used with the `AutoDateLocator`.\n167: \n168: * `DateFormatter`: use `~datetime.datetime.strftime` format strings.\n169: \"\"\"\n170: \n171: import datetime\n172: import functools\n173: import logging\n174: import math\n175: import re\n176: \n177: from dateutil.rrule import (rrule, MO, TU, WE, TH, FR, SA, SU, YEARLY,\n178:                             MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,\n179:                             SECONDLY)\n180: from dateutil.relativedelta import relativedelta\n181: import dateutil.parser\n182: import dateutil.tz\n183: import numpy as np\n184: \n185: import matplotlib as mpl\n186: from matplotlib import _api, cbook, ticker, units\n187: \n188: __all__ = ('datestr2num', 'date2num', 'num2date', 'num2timedelta', 'drange',\n189:            'epoch2num', 'num2epoch', 'set_epoch', 'get_epoch', 'DateFormatter',\n190:            'ConciseDateFormatter', 'AutoDateFormatter',\n191:            'DateLocator', 'RRuleLocator', 'AutoDateLocator', 'YearLocator',\n192:            'MonthLocator', 'WeekdayLocator',\n193:            'DayLocator', 'HourLocator', 'MinuteLocator',\n194:            'SecondLocator', 'MicrosecondLocator',\n195:            'rrule', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU',\n196:            'YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY',\n197:            'HOURLY', 'MINUTELY', 'SECONDLY', 'MICROSECONDLY', 'relativedelta',\n198:            'DateConverter', 'ConciseDateConverter')\n199: \n200: \n201: _log = logging.getLogger(__name__)\n202: UTC = datetime.timezone.utc\n203: \n204: \n205: def _get_rc_timezone():\nCode replaced for brevity.\n210: \n211: \n212: \n213: \"\"\"\n214: Time-related constants.\n215: \"\"\"\n216: EPOCH_OFFSET = float(datetime.datetime(1970, 1, 1).toordinal())\n217: # EPOCH_OFFSET is not used by matplotlib\n218: JULIAN_OFFSET = 1721424.5  # Julian date at 0000-12-31\n219: # note that the Julian day epoch is achievable w/\n220: # np.datetime64('-4713-11-24T12:00:00'); datetime64 is proleptic\n221: # Gregorian and BC has a one-year offset.  So\n222: # np.datetime64('0000-12-31') - np.datetime64('-4713-11-24T12:00') = 1721424.5\n223: # Ref: https://en.wikipedia.org/wiki/Julian_day\n224: MICROSECONDLY = SECONDLY + 1\n225: HOURS_PER_DAY = 24.\n226: MIN_PER_HOUR = 60.\n227: SEC_PER_MIN = 60.\n228: MONTHS_PER_YEAR = 12.\n229: \n230: DAYS_PER_WEEK = 7.\n231: DAYS_PER_MONTH = 30.\n232: DAYS_PER_YEAR = 365.0\n233: \n234: MINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY\n235: \n236: SEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR\n237: SEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY\n238: SEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK\n239: \n240: MUSECONDS_PER_DAY = 1e6 * SEC_PER_DAY\n241: \n242: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY = (\n243:     MO, TU, WE, TH, FR, SA, SU)\n244: WEEKDAYS = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)\n245: \n246: # default epoch: passed to np.datetime64...\n247: _epoch = None\n248: \n249: \n250: def _reset_epoch_test_example():\nCode replaced for brevity.\n257: \n258: \n259: \n260: def set_epoch(epoch):\nCode replaced for brevity.\n286: \n287: \n288: \n289: def get_epoch():\nCode replaced for brevity.\n302: \n303: \n304: \n305: def _dt64_to_ordinalf(d):\nCode replaced for brevity.\n330: \n331: \n332: \n333: def _from_ordinalf(x, tz=None):\nCode replaced for brevity.\n370: \n371: \n372: \n373: # a version of _from_ordinalf that can operate on numpy arrays\n374: _from_ordinalf_np_vectorized = np.vectorize(_from_ordinalf, otypes=\"O\")\n375: \n376: \n377: # a version of dateutil.parser.parse that can operate on numpy arrays\n378: _dateutil_parser_parse_np_vectorized = np.vectorize(dateutil.parser.parse)\n379: \n380: \n381: def datestr2num(d, default=None):\nCode replaced for brevity.\n402: \n403: \n404: \n405: def date2num(d):\nCode replaced for brevity.\n451: \n452: \n453: \n454: def julian2num(j):\nCode replaced for brevity.\n474: \n475: \n476: \n477: def num2julian(n):\nCode replaced for brevity.\n496: \n497: \n498: \n499: def num2date(x, tz=None):\nCode replaced for brevity.\n528: \n529: \n530: \n531: _ordinalf_to_timedelta_np_vectorized = np.vectorize(\n532:     lambda x: datetime.timedelta(days=x), otypes=\"O\")\n533: \n534: \n535: def num2timedelta(x):\nCode replaced for brevity.\n551: \n552: \n553: \n554: def drange(dstart, dend, delta):\nCode replaced for brevity.\n591: \n592: \n593: \n594: def _wrap_in_tex(text):\n595:     p = r'([a-zA-Z]+)'\n596:     ret_text = re.sub(p, r'}$\\1$\\\\mathdefault{', text)\n597: \n598:     # Braces ensure dashes are not spaced like binary operators.\n599:     ret_text = '$\\\\mathdefault{'+ret_text.replace('-', '{-}')+'}$'\n600:     ret_text = ret_text.replace('$\\\\mathdefault{}$', '')\n601:     return ret_text\n602: \n603: \n604: ## date tickers and formatters ###\n605: \n606: \n607: class DateFormatter(ticker.Formatter):\nCode replaced for brevity.\n637: \n638: \n639: \n640: class ConciseDateFormatter(ticker.Formatter):\nCode replaced for brevity.\n854: \n855: \n856: \n857: class AutoDateFormatter(ticker.Formatter):\nCode replaced for brevity.\n974: \n975: \n976: \n977: class rrulewrapper:\nCode replaced for brevity.\n1079: \n1080: \n1081: \n1082: class DateLocator(ticker.Locator):\nCode replaced for brevity.\n1151: \n1152: \n1153: \n1154:     # use the dateutil rrule instance\nCode replaced for brevity.\n1227: \n1228: \n1229: \n1230: class AutoDateLocator(DateLocator):\nCode replaced for brevity.\n1460: \n1461: \n1462: \n1463: class YearLocator(RRuleLocator):\nCode replaced for brevity.\n1501: \n1502: \n1503: \n1504: class MonthLocator(RRuleLocator):\nCode replaced for brevity.\n1526: \n1527: \n1528: \n1529: class WeekdayLocator(RRuleLocator):\nCode replaced for brevity.\n1554: \n1555: \n1556: \n1557: class DayLocator(RRuleLocator):\nCode replaced for brevity.\n1580: \n1581: \n1582: \n1583: class HourLocator(RRuleLocator):\nCode replaced for brevity.\n1600: \n1601: \n1602: \n1603: class MinuteLocator(RRuleLocator):\nCode replaced for brevity.\n1620: \n1621: \n1622: \n1623: class SecondLocator(RRuleLocator):\nCode replaced for brevity.\n1640: \n1641: \n1642: \n1643: class MicrosecondLocator(DateLocator):\nCode replaced for brevity.\n1717: \n1718: \n1719: \n1720: @_api.deprecated(\"3.5\",\n1721:                  alternative=\"mdates.date2num(datetime.utcfromtimestamp(e))\")\n1722: def epoch2num(e):\nCode replaced for brevity.\n1740: \n1741: \n1742: \n1743: @_api.deprecated(\"3.5\", alternative=\"mdates.num2date(e).timestamp()\")\n1744: def num2epoch(d):\nCode replaced for brevity.\n1761: \n1762: \n1763: \n1764: def date_ticker_factory(span, tz=None, numticks=5):\nCode replaced for brevity.\n1803: \n1804: \n1805: \n1806: class DateConverter(units.ConversionInterface):\nCode replaced for brevity.\n1863: \n1864: \n1865: \n1866:     # docstring inherited\nCode replaced for brevity.\n1890: \n1891: \n1892: \n1893: class _SwitchableDateConverter:\nCode replaced for brevity.\n1915: \n1916: \n1917: \n1918: units.registry[np.datetime64] = \\\n1919:     units.registry[datetime.date] = \\\n1920:     units.registry[datetime.datetime] = \\\n1921:     _SwitchableDateConverter()\n\n",
  "line_level_localization": [
    {
      "filename": "/lib/matplotlib/dates.py",
      "suspect_lines": [
        598,
        599
      ]
    }
  ]
}