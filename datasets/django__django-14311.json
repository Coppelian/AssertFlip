{
  "instance_id": "django__django-14311",
  "problem_statement": "Allow autoreloading of `python -m custom_module runserver`\nDescription\n\t \n\t\t(last modified by Mariusz Felisiak)\n\t \nThe original fix [1] only attempted to deal with -m foo.bar where bar is a package and __main__.py exists under foo/bar.\nWhen a dotted name for a module (for example, foo.bar.baz where baz.py resides under foo/bar) is specified like -m foo.bar.baz, the resulting arguments end up being -m foo.bar, which is uncalled for.\n[1] â€‹https://github.com/django/django/commit/ec6d2531c59466924b645f314ac33f54470d7ac3 \nFixed detection when started non-django modules with \"python -m\" in autoreloader.\n",
  "localized_code": "[start of django/utils/autoreload.py]\n1: import functools\n2: import itertools\n3: import logging\n4: import os\n5: import signal\n6: import subprocess\n7: import sys\n8: import threading\n9: import time\n10: import traceback\n11: import weakref\n12: from collections import defaultdict\n13: from pathlib import Path\n14: from types import ModuleType\n15: from zipimport import zipimporter\n16: \n17: import django\n18: from django.apps import apps\n19: from django.core.signals import request_finished\n20: from django.dispatch import Signal\n21: from django.utils.functional import cached_property\n22: from django.utils.version import get_version_tuple\n23: \n24: autoreload_started = Signal()\n25: file_changed = Signal()\n26: \n27: DJANGO_AUTORELOAD_ENV = 'RUN_MAIN'\n28: \n29: logger = logging.getLogger('django.utils.autoreload')\n30: \n31: # If an error is raised while importing a file, it's not placed in sys.modules.\n32: # This means that any future modifications aren't caught. Keep a list of these\n33: # file paths to allow watching them in the future.\n34: _error_files = []\n35: _exception = None\n36: \n37: try:\n38:     import termios\n39: except ImportError:\n40:     termios = None\n41: \n42: \n43: try:\n44:     import pywatchman\n45: except ImportError:\n46:     pywatchman = None\n47: \n48: \n49: def is_django_module(module):\n50:     \"\"\"Return True if the given module is nested under Django.\"\"\"\n51:     return module.__name__.startswith('django.')\n52: \n53: \n54: def is_django_path(path):\nCode replaced for brevity.\n56: \n57: \n58: \n59: def check_errors(fn):\nCode replaced for brevity.\n81: \n82: \n83: \n84: def raise_last_exception():\nCode replaced for brevity.\n87: \n88: \n89: \n90: def ensure_echo_on():\nCode replaced for brevity.\n106: \n107: \n108: \n109:     # aren't loaded on the fly.\nCode replaced for brevity.\n116: \n117: \n118: \n119: @functools.lru_cache(maxsize=1)\n120: def iter_modules_and_files(modules, extra_files):\nCode replaced for brevity.\n162: \n163: \n164: \n165: @functools.lru_cache(maxsize=1)\n166: def common_roots(paths):\nCode replaced for brevity.\n193: \n194: \n195: \n196: def sys_path_directories():\nCode replaced for brevity.\n210: \n211: \n212: \n213: def get_child_arguments():\n214:     \"\"\"\n215:     Return the executable. This contains a workaround for Windows if the\n216:     executable is reported to not have the .exe extension which can cause bugs\n217:     on reloading.\n218:     \"\"\"\n219:     import __main__\n220:     py_script = Path(sys.argv[0])\n221: \n222:     args = [sys.executable] + ['-W%s' % o for o in sys.warnoptions]\n223:     # __spec__ is set when the server was started with the `-m` option,\n224:     # see https://docs.python.org/3/reference/import.html#main-spec\n225:     # __spec__ may not exist, e.g. when running in a Conda env.\n226:     if getattr(__main__, '__spec__', None) is not None and __main__.__spec__.parent:\n227:         args += ['-m', __main__.__spec__.parent]\n228:         args += sys.argv[1:]\n229:     elif not py_script.exists():\n230:         # sys.argv[0] may not exist for several reasons on Windows.\n231:         # It may exist with a .exe extension or have a -script.py suffix.\n232:         exe_entrypoint = py_script.with_suffix('.exe')\n233:         if exe_entrypoint.exists():\n234:             # Should be executed directly, ignoring sys.executable.\n235:             return [exe_entrypoint, *sys.argv[1:]]\n236:         script_entrypoint = py_script.with_name('%s-script.py' % py_script.name)\n237:         if script_entrypoint.exists():\n238:             # Should be executed as usual.\n239:             return [*args, script_entrypoint, *sys.argv[1:]]\n240:         raise RuntimeError('Script %s does not exist.' % py_script)\n241:     else:\n242:         args += sys.argv\n243:     return args\n244: \n245: \n246: def trigger_reload(filename):\nCode replaced for brevity.\n248: \n249: \n250: \n251: def restart_with_reloader():\nCode replaced for brevity.\n257: \n258: \n259: \n260: class BaseReloader:\nCode replaced for brevity.\n362: \n363: \n364: \n365: class StatReloader(BaseReloader):\nCode replaced for brevity.\n400: \n401: \n402: \n403: class WatchmanUnavailable(RuntimeError):\n404:     pass\n405: \n406: \n407: class WatchmanReloader(BaseReloader):\nCode replaced for brevity.\n597: \n598: \n599: \n600: def get_reloader():\nCode replaced for brevity.\n606: \n607: \n608: \n609: def start_django(reloader, main_func, *args, **kwargs):\nCode replaced for brevity.\n625: \n626: \n627: \n628: def run_with_reloader(main_func, *args, **kwargs):\nCode replaced for brevity.\n639: \n\n",
  "line_level_localization": [
    {
      "filename": "/django/utils/autoreload.py",
      "suspect_lines": [
        226,
        227
      ]
    }
  ]
}